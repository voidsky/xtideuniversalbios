     1                                  ; Project name	:	XTIDE Universal BIOS
     2                                  ; Authors		:	Tomi Tilli
     3                                  ;				:	aitotat@gmail.com
     4                                  ;				:
     5                                  ;				:	Greg Lindhorst
     6                                  ;				:	gregli@hotmail.com
     7                                  ;				;
     8                                  ;				:	Krister Nordvall
     9                                  ;				:	krille_n_@hotmail.com
    10                                  ;				:
    11                                  ; Description	:	Main file for BIOS. This is the only file that needs
    12                                  ;					to be compiled since other files are included to this
    13                                  ;					file (so no linker needed, Nasm does it all).
    14                                  
    15                                  ;
    16                                  ; XTIDE Universal BIOS and Associated Tools
    17                                  ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
    18                                  ;
    19                                  ; This program is free software; you can redistribute it and/or modify
    20                                  ; it under the terms of the GNU General Public License as published by
    21                                  ; the Free Software Foundation; either version 2 of the License, or
    22                                  ; (at your option) any later version.
    23                                  ;
    24                                  ; This program is distributed in the hope that it will be useful,
    25                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    26                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    27                                  ; GNU General Public License for more details.
    28                                  ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    29                                  ;
    30                                  
    31                                  	ORG 0							; Code start offset 0000h
    32                                  
    33                                  	; We must define included libraries before including "AssemblyLibrary.inc".
    34                                  %define	EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS	; Exclude unused library functions
    35                                  %ifdef MODULE_BOOT_MENU
    36                                  	%define MENUEVENT_INLINE_OFFSETS    	; Only one menu required, save space and inline offsets
    37                                  	%define INCLUDE_MENU_LIBRARY
    38                                  	%define MENU_NO_ESC					    ; User cannot 'esc' out of the menu
    39                                  %else	; If no boot menu included
    40                                  	%define	INCLUDE_DISPLAY_LIBRARY
    41                                  	%define INCLUDE_KEYBOARD_LIBRARY
    42                                  	%define INCLUDE_TIME_LIBRARY
    43                                  %endif
    44                                  
    45                                  
    46                                  	; Included .inc files
    47                                  	%include "AssemblyLibrary.inc"	; Assembly Library. Must be included first!
    48                              <1> ; Project name	:	Assembly Library
    49                              <1> ; Description	:	Common defines for all library functions.
    50                              <1> %ifndef ASSEMBLY_LIBRARY_INC
    51                              <1> %define ASSEMBLY_LIBRARY_INC
    52                              <1> 
    53                              <1> ; Include .inc files
    54                              <1> %include "Emulate.inc"			; Must be included first!
    55                              <2> ; Project name	:	Emulation library
    56                              <2> ; Description	:	Macros for emulating later x86 instructions with older
    57                              <2> ;					processors.
    58                              <2> ;					Macros are used so optimized builds can be done
    59                              <2> ;					easily for different processors.
    60                              <2> ;
    61                              <2> ;					This file must be first to be included to
    62                              <2> ;					any source file.
    63                              <2> %ifndef EMULATE_INC
    64                              <2> %define EMULATE_INC
    65                              <2> 
    66                              <2> ; Defines for processor support (should be set in makefile).
    67                              <2> ; Unsupported instructions will be emulated using macros.
    68                              <2> ; If AT class PC is used (instead of XT), define USE_AT
    69                              <2> 
    70                              <2> ;%define USE_186				; Define to use 18x/V20/V30 instructions
    71                              <2> ;%define USE_286				; Define to use 286 instructions
    72                              <2> ;%define USE_386				; Define to use 386 instructions
    73                              <2> ;%define USE_AT					; Define for AT class machine
    74                              <2> 
    75                              <2> %ifdef USE_386
    76                              <2> 	%define USE_286				; Define to use 286 instructions
    77                              <2> %endif
    78                              <2> %ifdef USE_286
    79                              <2> 	%define USE_186				; Define to use 18x/V20/V30 instructions
    80                              <2> 	%define USE_UNDOC_INTEL		; Not supported by NEC V20/V30
    81                              <2> %endif
    82                              <2> 
    83                              <2> %ifdef USE_386
    84                              <2> 	CPU 386						; Allow instructions up to 386
    85                              <2> %elifdef USE_286
    86                              <2> 	CPU 286						; Allow instructions up to 286
    87                              <2> %elifdef USE_186
    88                              <2> 	CPU 186						; Allow instructions up to 188/186/V20/V30
    89                              <2> %else
    90                              <2> 	CPU 8086					; Allow 8088/8086 instructions only
    91                              <2> %endif
    92                              <2> 
    93                              <2> BITS 16							; Set 16 bit code generation
    94                              <2> 
    95                              <2> ; Alignments for jump targets.
    96                              <2> ; Following values are optimal for different processor types:
    97                              <2> ; 286 and 386SX			WORD (16-bit, 2 bytes)
    98                              <2> ; 386DX and 486			DWORD (32-bit, 4 bytes)
    99                              <2> ; Pentium and later		QWORD (64-bit, 8 bytes)
   100                              <2> %ifdef USE_AT
   101                              <2> 	%ifdef USE_386
   102                              <2> 		JUMP_ALIGN		EQU		4
   103                              <2> 		WORD_ALIGN		EQU		2
   104                              <2> 	%else ; USE_286
   105                              <2> 		JUMP_ALIGN		EQU		2
   106                              <2> 		WORD_ALIGN		EQU		2
   107                              <2> 	%endif
   108                              <2> %else ; XT
   109                              <2> 	JUMP_ALIGN		EQU		1
   110                              <2> 	WORD_ALIGN		EQU		1
   111                              <2> %endif
   112                              <2> 
   113                              <2> ;==========================================================================
   114                              <2> 
   115                              <2> ;--------------------------------------------------------------------
   116                              <2> ; The undocumented instruction SALC (Set AL According to CF).
   117                              <2> ; Available on all Intel processors and truly compatible clones.
   118                              <2> ; Does not work on the NEC V20/V30 or Sony CXQ70108 processors.
   119                              <2> ;
   120                              <2> ; eSALC
   121                              <2> ;	Parameters:
   122                              <2> ;		Nothing
   123                              <2> ;	Returns:
   124                              <2> ;		AL:		FFh if CF=1
   125                              <2> ;				00h if CF=0
   126                              <2> ;	Corrupts registers:
   127                              <2> ;		Nothing
   128                              <2> ;--------------------------------------------------------------------
   129                              <2> %macro eSALC 0
   130                              <2> 	db		0D6h
   131                              <2> %endmacro
   132                              <2> 
   133                              <2> 
   134                              <2> ;--------------------------------------------------------------------
   135                              <2> ; The AAD instruction (ASCII Adjust before Division).
   136                              <2> ; Available on all Intel processors and truly compatible clones.
   137                              <2> ; Does not work on the NEC V20/V30 or Sony CXQ70108 processors
   138                              <2> ; unless %1 is 10 (0Ah).
   139                              <2> ;
   140                              <2> ; eAAD
   141                              <2> ;	Parameters:
   142                              <2> ;		%1:		Any 8 bit number (0...255)
   143                              <2> ;	Returns:
   144                              <2> ;		AL:		AH * %1 + AL
   145                              <2> ;		AH:		0
   146                              <2> ;		Flags:	Set according to result
   147                              <2> ;	Corrupts registers:
   148                              <2> ;		Nothing
   149                              <2> ;--------------------------------------------------------------------
   150                              <2> %macro eAAD 1
   151                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   152                              <2> 	%if %1 > 255
   153                              <2> 		%error Invalid parameter passed to eAAD (%1 > 255)
   154                              <2> 	%else
   155                              <2> 		db		0D5h, %1
   156                              <2> 	%endif
   157                              <2> %endif
   158                              <2> %endmacro
   159                              <2> 
   160                              <2> 
   161                              <2> ;--------------------------------------------------------------------
   162                              <2> ; The AAM instruction (ASCII Adjust after Multiplication).
   163                              <2> ; Available on all Intel processors and truly compatible clones.
   164                              <2> ; Does not work on the NEC V20/V30 or Sony CXQ70108 processors
   165                              <2> ; unless %1 is 10 (0Ah).
   166                              <2> ;
   167                              <2> ; eAAM
   168                              <2> ;	Parameters:
   169                              <2> ;		%1:		Any 8 bit number except 0 (1...255)
   170                              <2> ;	Returns:
   171                              <2> ;		AL:		AL MOD %1
   172                              <2> ;		AH:		AL / %1
   173                              <2> ;		Flags:	Set according to result
   174                              <2> ;	Corrupts registers:
   175                              <2> ;		Nothing
   176                              <2> ;--------------------------------------------------------------------
   177                              <2> %macro eAAM 1
   178                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   179                              <2> 	%if %1 > 255
   180                              <2> 		%error Invalid parameter passed to eAAM (%1 > 255)
   181                              <2> 	%elif %1 = 0
   182                              <2> 		%error Invalid parameter passed to eAAM (%1 = 0). This would cause a divide-by-zero exception!
   183                              <2> 	%else
   184                              <2> 		db		0D4h, %1
   185                              <2> 	%endif
   186                              <2> %endif
   187                              <2> %endmacro
   188                              <2> 
   189                              <2> 
   190                              <2> ;--------------------------------------------------------------------
   191                              <2> ; Emulates BSF (Bit Scan Forward) instruction when necessary.
   192                              <2> ; BSF is used to find index of least significant bit.
   193                              <2> ;
   194                              <2> ; eBSF
   195                              <2> ;	Parameters:
   196                              <2> ;		%1:		Destination WORD Register for bit index (not CX or same as %2!)
   197                              <2> ;		%2:		Source WORD operand where to search bit (not CX or same as %1!)
   198                              <2> ;	Returns:
   199                              <2> ;		%1:		Index of highest order bit from %2
   200                              <2> ;		ZF:		Set if %2 is zero
   201                              <2> ;				Cleared if %2 is non-zero
   202                              <2> ;	Corrupts registers:
   203                              <2> ;		Nothing
   204                              <2> ;--------------------------------------------------------------------
   205                              <2> %macro eBSF 2
   206                              <2> %ifndef USE_386
   207                              <2> 	push	cx
   208                              <2> 	cmp		WORD %2, BYTE 0		; Source operand is zero?
   209                              <2> 	je		SHORT %%Return		;  If so, return with ZF set
   210                              <2> 
   211                              <2> 	; Set destination to zero and load mask for bit 0
   212                              <2> 	xor		%1, %1
   213                              <2> 	mov		cx, 1
   214                              <2> 
   215                              <2> ALIGN JUMP_ALIGN
   216                              <2> %%BitLoop:
   217                              <2> 	test	%2, cx				; Bit set?
   218                              <2> 	jnz		SHORT %%Return		;  If so, return with ZF cleared
   219                              <2> 	shl		cx, 1				; Prepare to test next bit
   220                              <2> 	inc		%1					; Increment bit index
   221                              <2> 	jmp		SHORT %%BitLoop		; Loop until bit found
   222                              <2> %%Return:
   223                              <2> 	pop		cx
   224                              <2> ;-----------------------------------
   225                              <2> %else
   226                              <2> 	bsf		%1, %2
   227                              <2> %endif
   228                              <2> %endmacro
   229                              <2> 
   230                              <2> 
   231                              <2> ;--------------------------------------------------------------------
   232                              <2> ; Emulates BSR (Bit Scan Reverse) instruction when necessary.
   233                              <2> ; BSR is used to find index of most significant bit.
   234                              <2> ;
   235                              <2> ; eBSR
   236                              <2> ;	Parameters:
   237                              <2> ;		%1:		Destination WORD Register for bit index (not CX or same as %2!)
   238                              <2> ;		%2:		Source WORD operand where to search bit (not CX or same as %1!)
   239                              <2> ;	Returns:
   240                              <2> ;		%1:		Index of highest order bit from %2
   241                              <2> ;		ZF:		Set if %2 is zero
   242                              <2> ;				Cleared if %2 is non-zero
   243                              <2> ;	Corrupts registers:
   244                              <2> ;		Nothing
   245                              <2> ;--------------------------------------------------------------------
   246                              <2> %macro eBSR 2
   247                              <2> %ifndef USE_386
   248                              <2> 	push	cx
   249                              <2> 	cmp		WORD %2, BYTE 0		; Source operand is zero?
   250                              <2> 	je		SHORT %%Return		;  If so, return with ZF set
   251                              <2> 
   252                              <2> 	; Load mask for highest order bit
   253                              <2> 	mov		cx, 1<<15
   254                              <2> 	mov		%1, 15
   255                              <2> 
   256                              <2> ALIGN JUMP_ALIGN
   257                              <2> %%BitLoop:
   258                              <2> 	test	%2, cx				; Bit set?
   259                              <2> 	jnz		SHORT %%Return		;  If so, return with ZF cleared
   260                              <2> 	shr		cx, 1				; Prepare to test next bit
   261                              <2> 	dec		%1					; Decrement bit index
   262                              <2> 	jmp		SHORT %%BitLoop		; Loop until bit found
   263                              <2> %%Return:
   264                              <2> 	pop		cx
   265                              <2> ;-----------------------------------
   266                              <2> %else
   267                              <2> 	bsr		%1, %2
   268                              <2> %endif
   269                              <2> %endmacro
   270                              <2> 
   271                              <2> 
   272                              <2> ;--------------------------------------------------------------------
   273                              <2> ; Conditional Move.
   274                              <2> ;
   275                              <2> ; eCMOVcc
   276                              <2> ;	Parameters:
   277                              <2> ;		%1:		Destination data
   278                              <2> ;		%2:		Source data
   279                              <2> ;	Returns:
   280                              <2> ;		Nothing
   281                              <2> ;	Corrupts registers:
   282                              <2> ;		Nothing
   283                              <2> ;--------------------------------------------------------------------
   284                              <2> %macro eCMOVA 2
   285                              <2> 	jbe		SHORT %%Return
   286                              <2> 	mov		%1, %2
   287                              <2> %%Return:
   288                              <2> %endmacro
   289                              <2> 
   290                              <2> %macro eCMOVC 2
   291                              <2> 	jnc		SHORT %%Return
   292                              <2> 	mov		%1, %2
   293                              <2> %%Return:
   294                              <2> %endmacro
   295                              <2> 
   296                              <2> %macro eCMOVNC 2
   297                              <2> 	jc		SHORT %%Return
   298                              <2> 	mov		%1, %2
   299                              <2> %%Return:
   300                              <2> %endmacro
   301                              <2> 
   302                              <2> %macro eCMOVZ 2
   303                              <2> 	jnz		SHORT %%Return
   304                              <2> 	mov		%1, %2
   305                              <2> %%Return:
   306                              <2> %endmacro
   307                              <2> 
   308                              <2> %macro eCMOVNZ 2
   309                              <2> 	jz		SHORT %%Return
   310                              <2> 	mov		%1, %2
   311                              <2> %%Return:
   312                              <2> %endmacro
   313                              <2> 
   314                              <2> %macro eCMOVE 2
   315                              <2> 	eCMOVZ %1, %2
   316                              <2> %endmacro
   317                              <2> 
   318                              <2> %macro eCMOVNE 2
   319                              <2> 	eCMOVNZ %1, %2
   320                              <2> %endmacro
   321                              <2> 
   322                              <2> %macro eCMOVB 2
   323                              <2> 	jnb		SHORT %%Return
   324                              <2> 	mov		%1, %2
   325                              <2> %%Return:
   326                              <2> %endmacro
   327                              <2> 
   328                              <2> %macro eCMOVS 2
   329                              <2> 	jns		SHORT %%Return
   330                              <2> 	mov		%1, %2
   331                              <2> %%Return:
   332                              <2> %endmacro
   333                              <2> 
   334                              <2> %macro eCMOVNS 2
   335                              <2> 	js		SHORT %%Return
   336                              <2> 	mov		%1, %2
   337                              <2> %%Return:
   338                              <2> %endmacro
   339                              <2> 
   340                              <2> 
   341                              <2> ;--------------------------------------------------------------------
   342                              <2> ; Conditional Set.
   343                              <2> ;
   344                              <2> ; eCSETcc
   345                              <2> ;	Parameters:
   346                              <2> ;		%1:		Destination data
   347                              <2> ;	Returns:
   348                              <2> ;		Nothing
   349                              <2> ;	Corrupts registers:
   350                              <2> ;		Flags
   351                              <2> ;--------------------------------------------------------------------
   352                              <2> %macro eCSETZ 1
   353                              <2> 	mov		%1, 0			; Clear while preserving flags
   354                              <2> 	jnz		SHORT %%Return	; Nothing to set
   355                              <2> 	inc		%1
   356                              <2> %%Return:
   357                              <2> %endmacro
   358                              <2> 
   359                              <2> 
   360                              <2> ;--------------------------------------------------------------------
   361                              <2> ; Moves byte with zero-extending to any Register.
   362                              <2> ;
   363                              <2> ; eMOVZX
   364                              <2> ;	Parameters:
   365                              <2> ;		%1:		Destination Register (SP not supported)
   366                              <2> ;		%2:		Byte register or byte address
   367                              <2> ;	Returns:
   368                              <2> ;		Nothing
   369                              <2> ;	Corrupts registers:
   370                              <2> ;		FLAGS
   371                              <2> ;--------------------------------------------------------------------
   372                              <2> %macro eMOVZX 2
   373                              <2> %ifndef USE_386
   374                              <2> 	%ifidni %1, ax
   375                              <2> 		mov		al, %2
   376                              <2> 		xor		ah, ah
   377                              <2> 	%elifidni %1, bx
   378                              <2> 		mov		bl, %2
   379                              <2> 		xor		bh, bh		; %2 may use BX in effective address
   380                              <2> 	%elifidni %1, cx
   381                              <2> 		mov		cl, %2
   382                              <2> 		xor		ch, ch
   383                              <2> 	%elifidni %1, dx
   384                              <2> 		mov		dl, %2
   385                              <2> 		xor		dh, dh
   386                              <2> 	%else	; SI, DI, BP (all may be used in effective address)
   387                              <2> 		push	ax
   388                              <2> 		mov		al, %2
   389                              <2> 		xor		ah, ah
   390                              <2> 		xchg	ax, %1
   391                              <2> 		pop		ax
   392                              <2> 	%endif
   393                              <2> ;-----------------------------------
   394                              <2> %else
   395                              <2> 	movzx	%1, %2
   396                              <2> %endif
   397                              <2> %endmacro
   398                              <2> 
   399                              <2> 
   400                              <2> ;--------------------------------------------------------------------
   401                              <2> ; Emulates PUSHA instruction when necessary.
   402                              <2> ;
   403                              <2> ; ePUSHA
   404                              <2> ;	Parameters:
   405                              <2> ;		Nothing
   406                              <2> ;	Returns:
   407                              <2> ;		Nothing
   408                              <2> ;	Corrupts registers:
   409                              <2> ;		Nothing
   410                              <2> ;--------------------------------------------------------------------
   411                              <2> %macro ePUSHA 0
   412                              <2> %ifndef USE_186
   413                              <2> 	push	ax
   414                              <2> 	push	cx
   415                              <2> 	push	dx
   416                              <2> 	push	bx
   417                              <2> 	push	sp
   418                              <2> 	push	bp
   419                              <2> 	push	si
   420                              <2> 	push	di
   421                              <2> ;-----------------------------------
   422                              <2> %else
   423                              <2> 	pusha
   424                              <2> %endif
   425                              <2> %endmacro
   426                              <2> 
   427                              <2> 
   428                              <2> ;--------------------------------------------------------------------
   429                              <2> ; Emulates POPA instruction when necessary.
   430                              <2> ;
   431                              <2> ; ePOPA
   432                              <2> ;	Parameters:
   433                              <2> ;		Nothing
   434                              <2> ;	Returns:
   435                              <2> ;		Nothing
   436                              <2> ;	Corrupts registers:
   437                              <2> ;		Nothing
   438                              <2> ;--------------------------------------------------------------------
   439                              <2> %macro ePOPA 0
   440                              <2> %ifndef USE_186
   441                              <2> 	pop		di
   442                              <2> 	pop		si
   443                              <2> 	pop		bp
   444                              <2> 	pop		ax		; Skip SP
   445                              <2> 	pop		bx
   446                              <2> 	pop		dx
   447                              <2> 	pop		cx
   448                              <2> 	pop		ax
   449                              <2> ;-----------------------------------
   450                              <2> %else
   451                              <2> 	popa
   452                              <2> %endif
   453                              <2> %endmacro
   454                              <2> 
   455                              <2> 
   456                              <2> ;--------------------------------------------------------------------
   457                              <2> ; Emulates ENTER instruction when necessary.
   458                              <2> ;
   459                              <2> ; eENTER
   460                              <2> ;	Parameters:
   461                              <2> ;		%1:		Number of bytes to reserve from stack
   462                              <2> ;		%2:		The lexical nesting level (not emulated, set to 0)
   463                              <2> ;	Returns:
   464                              <2> ;		SS:BP:	Ptr to old BP
   465                              <2> ;				([bp-2] points to highest local stack frame word)
   466                              <2> ;	Corrupts registers:
   467                              <2> ;		FLAGS
   468                              <2> ;--------------------------------------------------------------------
   469                              <2> %macro eENTER 2
   470                              <2> %ifndef USE_186
   471                              <2> 	push	bp
   472                              <2> 	mov		bp, sp
   473                              <2> 	sub		sp, %1
   474                              <2> ;-----------------------------------
   475                              <2> %else
   476                              <2> 	enter	%1, %2
   477                              <2> %endif
   478                              <2> %endmacro
   479                              <2> 
   480                              <2> ;--------------------------------------------------------------------
   481                              <2> ; Emulates LEAVE instruction when necessary.
   482                              <2> ;
   483                              <2> ; eLEAVE
   484                              <2> ;	Parameters:
   485                              <2> ;		Nothing
   486                              <2> ;	Returns:
   487                              <2> ;		BP:		What it was before eENTER
   488                              <2> ;	Corrupts registers:
   489                              <2> ;		Nothing
   490                              <2> ;--------------------------------------------------------------------
   491                              <2> %macro eLEAVE 0
   492                              <2> %ifndef USE_186
   493                              <2> 	mov		sp, bp
   494                              <2> 	pop		bp
   495                              <2> ;-----------------------------------
   496                              <2> %else
   497                              <2> 	leave
   498                              <2> %endif
   499                              <2> %endmacro
   500                              <2> 
   501                              <2> 
   502                              <2> ;--------------------------------------------------------------------
   503                              <2> ; Emulates LSS instruction when necessary.
   504                              <2> ;
   505                              <2> ; eLSS
   506                              <2> ;	Parameters:
   507                              <2> ;		%1:		Destination register
   508                              <2> ;		%2:		Source memory address without brackets
   509                              <2> ;	Returns:
   510                              <2> ;		IF:		0 (interrupts disabled)
   511                              <2> ;	Corrupts registers:
   512                              <2> ;		Nothing
   513                              <2> ;--------------------------------------------------------------------
   514                              <2> %macro eLSS 2
   515                              <2> %ifndef USE_386
   516                              <2> 	cli							; Disable interrupts
   517                              <2> 	mov		%1, [%2]			; Load offset
   518                              <2> 	mov		ss, [%2+2]			; Load segment
   519                              <2> ;-----------------------------------
   520                              <2> %else
   521                              <2> 	lss		%1, [%2]
   522                              <2> %endif
   523                              <2> %endmacro
   524                              <2> 
   525                              <2> 
   526                              <2> ;--------------------------------------------------------------------
   527                              <2> ; Repeats string instruction with segment override.
   528                              <2> ; This macro prevents 8088/8086 restart bug.
   529                              <2> ;
   530                              <2> ; eSEG_STR
   531                              <2> ;	Parameters:
   532                              <2> ;		%1:		REP/REPNE or REPE prefix
   533                              <2> ;		%2:		Source segment override (destination is always ES)
   534                              <2> ;		%3:		String instruction
   535                              <2> ;		CX:		Repeat count
   536                              <2> ;	Returns:
   537                              <2> ;		FLAGS for cmps and scas only
   538                              <2> ;	Corrupts registers:
   539                              <2> ;		Nothing
   540                              <2> ;--------------------------------------------------------------------
   541                              <2> %macro eSEG_STR 3
   542                              <2> %ifndef USE_186	; 8088/8086 has string instruction restart bug when more than one prefix
   543                              <2> 	%%Loop:
   544                              <2> 		%1						; REP is the prefix that can be lost
   545                              <2> 		%2						; SEG is the prefix that won't be lost
   546                              <2> 		%3						; String instruction
   547                              <2> 		jcxz	%%End			; Jump to end if no repeats left (preserves FLAGS)
   548                              <2> 		jmp		SHORT %%Loop	; Loop while repeats left
   549                              <2> 	%%End:
   550                              <2> %else	; No bug on V20/V30 and later, don't know about 188/186
   551                              <2> 	%2
   552                              <2> 	%1 %3
   553                              <2> %endif
   554                              <2> %endmacro
   555                              <2> 
   556                              <2> 
   557                              <2> ;--------------------------------------------------------------------
   558                              <2> ; Bit shifts and rotates with immediate.
   559                              <2> ;
   560                              <2> ; eSHIFT_IM
   561                              <2> ;	Parameters:
   562                              <2> ;		%1:		Shift target
   563                              <2> ;		%2:		Number of bits to shift
   564                              <2> ;		%3:		Instruction (SHL, SHR, ROL, ROR, RCL, RCR)
   565                              <2> ;	Returns:
   566                              <2> ;		FLAGS
   567                              <2> ;	Corrupts registers:
   568                              <2> ;		Nothing
   569                              <2> ;--------------------------------------------------------------------
   570                              <2> %macro eSHIFT_IM 3
   571                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   572                              <2> %ifndef USE_186
   573                              <2> 	%ifidni %1, cl
   574                              <2> 		times %2	%3		%1, 1
   575                              <2> 	%elifidni %1, ch
   576                              <2> 		times %2	%3		%1, 1
   577                              <2> 	%elifidni %1, cx
   578                              <2> 		times %2	%3		%1, 1
   579                              <2> 	%else
   580                              <2> 		%if %2 > 3	; Size optimized value
   581                              <2> 			push	cx
   582                              <2> 			mov		cl, %2
   583                              <2> 			%3		%1, cl
   584                              <2> 			pop		cx
   585                              <2> 		%else
   586                              <2> 			times %2	%3		%1, 1
   587                              <2> 		%endif
   588                              <2> 	%endif
   589                              <2> ;-----------------------------------
   590                              <2> %else
   591                              <2> 	%3		%1, %2
   592                              <2> %endif
   593                              <2> %endif
   594                              <2> %endmacro
   595                              <2> 
   596                              <2> %macro eSHR_IM 2
   597                              <2> 	eSHIFT_IM	%1, %2, shr
   598                              <2> %endmacro
   599                              <2> 
   600                              <2> %macro eSHL_IM 2
   601                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   602                              <2> %ifdef USE_386
   603                              <2> 	%if %2 = 1
   604                              <2> 		add		%1, %1	; Same size but faster on 386 and 486. Fails if %1 is a memory operand.
   605                              <2> 	%else
   606                              <2> 		eSHIFT_IM	%1, %2, shl
   607                              <2> 	%endif
   608                              <2> %else
   609                              <2> 	eSHIFT_IM	%1, %2, shl
   610                              <2> %endif
   611                              <2> %endif
   612                              <2> %endmacro
   613                              <2> 
   614                              <2> %macro eROR_IM 2
   615                              <2> 	eSHIFT_IM	%1, %2, ror
   616                              <2> %endmacro
   617                              <2> 
   618                              <2> %macro eROL_IM 2
   619                              <2> 	eSHIFT_IM	%1, %2, rol
   620                              <2> %endmacro
   621                              <2> 
   622                              <2> %macro eRCR_IM 2
   623                              <2> 	eSHIFT_IM	%1, %2, rcr
   624                              <2> %endmacro
   625                              <2> 
   626                              <2> %macro eRCL_IM 2
   627                              <2> 	eSHIFT_IM	%1, %2, rcl
   628                              <2> %endmacro
   629                              <2> 
   630                              <2> 
   631                              <2> ;--------------------------------------------------------------------
   632                              <2> ; Emulates PUSH imm instruction when necessary.
   633                              <2> ;
   634                              <2> ; ePUSH_I
   635                              <2> ;	Parameters:
   636                              <2> ;		%1:		Immediate to push
   637                              <2> ;	Returns:
   638                              <2> ;		Nothing
   639                              <2> ;	Corrupts registers:
   640                              <2> ;		Nothing
   641                              <2> ;--------------------------------------------------------------------
   642                              <2> %macro ePUSH_I 1
   643                              <2> %ifndef USE_186
   644                              <2> 	push	bp					; Immediate goes here
   645                              <2> 	push	bp
   646                              <2> 	mov		bp, sp
   647                              <2> 	mov		WORD [bp+2], %1
   648                              <2> 	pop		bp
   649                              <2> ;-----------------------------------
   650                              <2> %else
   651                              <2> 	push	%1
   652                              <2> %endif
   653                              <2> %endmacro
   654                              <2> 
   655                              <2> 
   656                              <2> ;--------------------------------------------------------------------
   657                              <2> ; Emulates PUSH imm instruction when necessary.
   658                              <2> ; ePUSH_T uses temporary register for faster performance
   659                              <2> ; and smaller code size than ePUSH_I.
   660                              <2> ;
   661                              <2> ; ePUSH_T
   662                              <2> ;	Parameters:
   663                              <2> ;		%1:		Temporary Register
   664                              <2> ;		%2:		Immediate to push
   665                              <2> ;	Returns:
   666                              <2> ;		Nothing
   667                              <2> ;	Corrupts registers:
   668                              <2> ;		%1
   669                              <2> ;--------------------------------------------------------------------
   670                              <2> %macro ePUSH_T 2
   671                              <2> %ifndef USE_186
   672                              <2> 	%ifidni %2, 0
   673                              <2> 		xor		%1, %1
   674                              <2> 	%else
   675                              <2> 		mov		%1, %2
   676                              <2> 	%endif
   677                              <2> 	push	%1
   678                              <2> ;-----------------------------------
   679                              <2> %else
   680                              <2> 	push	%2
   681                              <2> %endif
   682                              <2> %endmacro
   683                              <2> 
   684                              <2> 
   685                              <2> %endif ; EMULATE_INC
   686                              <1> %include "Macros.inc"
   687                              <2> ; Project name	:	Assembly Library
   688                              <2> ; Description	:	This is the place to put various generic macros.
   689                              <2> ;					Should be included immediately after emulate.inc
   690                              <2> %ifndef MACROS_INC
   691                              <2> %define MACROS_INC
   692                              <2> 
   693                              <2> ;--------------------------------------------------------------------
   694                              <2> ; Skips the immediately following 2 byte instruction by using it
   695                              <2> ; as an immediate value to a dummy instruction.
   696                              <2> ; Destroys the contents of %1.
   697                              <2> ;
   698                              <2> ; SKIP2B
   699                              <2> ;	Parameters:
   700                              <2> ;		%1:		Any 16 bit general purpose register or F for flags.
   701                              <2> ;	Returns:
   702                              <2> ;		Nothing
   703                              <2> ;	Corrupts registers:
   704                              <2> ;		%1
   705                              <2> ;--------------------------------------------------------------------
   706                              <2> %macro SKIP2B 1
   707                              <2> 	%ifidni		%1, f
   708                              <2> 		db	03Dh					; Opcode byte for CMP AX, <immed>
   709                              <2> 		;db	0A9h					; Alt. version TEST AX, <immed>
   710                              <2> 	%elifidni	%1, ax
   711                              <2> 		db	0B8h					; Opcode byte for MOV AX, <immed>
   712                              <2> 	%elifidni	%1, cx
   713                              <2> 		db	0B9h					; Opcode byte for MOV CX, <immed>
   714                              <2> 	%elifidni	%1, dx
   715                              <2> 		db	0BAh					; Opcode byte for MOV DX, <immed>
   716                              <2> 	%elifidni	%1, bx
   717                              <2> 		db	0BBh					; Opcode byte for MOV BX, <immed>
   718                              <2> 	%elifidni	%1, sp
   719                              <2> 		db	0BCh					; Opcode byte for MOV SP, <immed>
   720                              <2> 	%elifidni	%1, bp
   721                              <2> 		db	0BDh					; Opcode byte for MOV BP, <immed>
   722                              <2> 	%elifidni	%1, si
   723                              <2> 		db	0BEh					; Opcode byte for MOV SI, <immed>
   724                              <2> 	%elifidni	%1, di
   725                              <2> 		db	0BFh					; Opcode byte for MOV DI, <immed>
   726                              <2> 	%else
   727                              <2> 		%error "Invalid parameter passed to SKIP2B"
   728                              <2> 	%endif
   729                              <2> %endmacro
   730                              <2> 
   731                              <2> 
   732                              <2> ;--------------------------------------------------------------------
   733                              <2> ; Load BDA (Bios Data Area) segment to wanted segment register.
   734                              <2> ;
   735                              <2> ; Use an exclamation point (!) as the third parameter when you want
   736                              <2> ; to force the use of the register in the second parameter. This is
   737                              <2> ; useful when that register needs to be zeroed in subsequent code or
   738                              <2> ; when stack usage is undesirable (ie speed is critical).
   739                              <2> ;
   740                              <2> ; The PRESERVE_FLAGS version will zero the register with a MOV instead
   741                              <2> ; of an XOR, thus preserving the flags.  It is one byte larger on
   742                              <2> ; non-186 or higher systems.
   743                              <2> ;
   744                              <2> ; LOAD_BDA_SEGMENT_TO
   745                              <2> ; LOAD_BDA_SEGMENT_PRESERVE_FLAGS_TO
   746                              <2> ;	Parameters:
   747                              <2> ;		%1:		Destination Segment Register
   748                              <2> ;		%2:		Temporary WORD Register
   749                              <2> ;		%3:		Can be ! or empty
   750                              <2> ;	Returns:
   751                              <2> ;		%1:		BDA segment (zero)
   752                              <2> ;	Corrupts registers:
   753                              <2> ;		%2
   754                              <2> ;--------------------------------------------------------------------
   755                              <2> %macro LOAD_BDA_SEGMENT_TO 2-3
   756                              <2> %ifndef USE_186
   757                              <2> 	xor		%2, %2
   758                              <2> 	mov		%1, %2
   759                              <2> %elifidn %3, !
   760                              <2> 	xor		%2, %2
   761                              <2> 	mov		%1, %2
   762                              <2> %else
   763                              <2> 	push	BYTE 0
   764                              <2> 	pop		%1
   765                              <2> %endif
   766                              <2> %endmacro
   767                              <2> 
   768                              <2> %macro LOAD_BDA_SEGMENT_PRESERVE_FLAGS_TO 2-3
   769                              <2> %ifndef USE_186
   770                              <2> 	mov		%2, 0
   771                              <2> 	mov		%1, %2
   772                              <2> %elifidn %3, !
   773                              <2> 	mov		%2, 0
   774                              <2> 	mov		%1, %2
   775                              <2> %else
   776                              <2> 	push	BYTE 0
   777                              <2> 	pop		%1
   778                              <2> %endif
   779                              <2> %endmacro
   780                              <2> 
   781                              <2> 
   782                              <2> ;--------------------------------------------------------------------
   783                              <2> ; eENTER_STRUCT
   784                              <2> ;	Parameters:
   785                              <2> ;		%1:		Number of bytes to reserve from stack
   786                              <2> ;	Returns:
   787                              <2> ;		SS:BP:	Ptr to beginning of struct reserved from stack
   788                              <2> ;	Corrupts registers:
   789                              <2> ;		FLAGS
   790                              <2> ;--------------------------------------------------------------------
   791                              <2> %macro eENTER_STRUCT 1
   792                              <2> 	push	bp
   793                              <2> 	sub		sp, %1
   794                              <2> 	mov		bp, sp
   795                              <2> %endmacro
   796                              <2> 
   797                              <2> ;--------------------------------------------------------------------
   798                              <2> ; eLEAVE_STRUCT
   799                              <2> ;	Parameters:
   800                              <2> ;		%1:		Number of bytes reserved with eENTER_STRUCT
   801                              <2> ;	Returns:
   802                              <2> ;		BP:		What it was before eENTER_STRUCT
   803                              <2> ;	Corrupts registers:
   804                              <2> ;		FLAGS
   805                              <2> ;--------------------------------------------------------------------
   806                              <2> %macro eLEAVE_STRUCT 1
   807                              <2> 	add		sp, %1
   808                              <2> 	pop		bp
   809                              <2> %endmacro
   810                              <2> 
   811                              <2> 
   812                              <2> %endif ; MACROS_INC
   813                              <1> %include "BiosData.inc"
   814                              <2> ; Project name	:	XTIDE Universal BIOS
   815                              <2> ; Description	:	Equates for BIOS Data Area.
   816                              <2> %ifndef BIOSDATA_INC
   817                              <2> %define BIOSDATA_INC
   818                              <2> 
   819                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   820                              <2> ; BIOS DATA AREA VARIABLES ;
   821                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   822                              <2> 
   823                              <2> ; BIOS Data Area (related to floppy drives and hard disks)
   824                              <2> struc BDA
   825 00000000 <res 00000400>      <2> 					resb	400h	; 40:0h, Start of BDA
   826 00000400 <res 00000002>      <2> 	.wCOM1			resb	2		; 0:400h, Serial I/O Address, Port 1
   827 00000402 <res 00000002>      <2> 	.wCOM2			resb	2		; 0:402h, Serial I/O Address, Port 2
   828 00000404 <res 00000002>      <2> 	.wCOM3			resb	2		; 0:404h, Serial I/O Address, Port 3
   829 00000406 <res 00000002>      <2> 	.wCOM4			resb	2		; 0:406h, Serial I/O Address, Port 4
   830 00000408 <res 00000002>      <2> 	.wLPT1			resb	2		; 0:408h, Parallel I/O Address, Port 1
   831 0000040A <res 00000002>      <2> 	.wLPT2			resb	2		; 0:40Ah, Parallel I/O Address, Port 2
   832 0000040C <res 00000002>      <2> 	.wLPT3			resb	2		; 0:40Ch, Parallel I/O Address, Port 3
   833                              <2> 	.wLPT4:							; 0:40Eh, Parallel I/O Address, Port 4 (PC/XT)
   834 0000040E <res 00000002>      <2> 	.wSegEBDA		resb	2		; 0:40Eh, Extended BIOS Data Area segment (AT+)
   835                              <2> 
   836 00000410 <res 00000002>      <2> 	.wEquipment		resb	2		; 0:410h, Equipment Word
   837 00000412 <res 00000001>      <2> 	.bTest			resb	1		; 0:412h, Manufacturing test
   838 00000413 <res 00000002>      <2> 	.wBaseMem		resb	2		; 0:413h, Base Memory Size in kB
   839                              <2> 	.wAdptrMem:						; 0:415h, Adapter Memory Size (PC/XT)
   840 00000415 <res 00000002>      <2> 	.wError			resb	2		; 0:415h, Error Codes (AT+)
   841 00000417 <res 00000001>      <2> 	.bKBFlgs1		resb	1		; 0:417h, Keyboard, Shift Flags, Set 1
   842 00000418 <res 00000001>      <2> 	.bKBFlgs2		resb	1		; 0:418h, Keyboard, Shift Flags, Set 2
   843 00000419 <res 00000001>      <2> 	.bKBNumpad		resb	1		; 0:419h, Keyboard, ALT+Numpad work area
   844 0000041A <res 00000002>      <2> 	.wKBHead		resb	2		; 0:41Ah, Keyboard, Head of buffer pointer
   845 0000041C <res 00000002>      <2> 	.wKBTail		resb	2		; 0:41Ch, Keyboard, Tail of buffer pointer
   846 0000041E <res 00000020>      <2> 	.rgwKBBuff		resb	32		; 0:41Eh, Keyboard, 16-word buffer
   847                              <2> 
   848 0000043E <res 00000001>      <2> 	.bFDRecal		resb	1		; 0:43Eh, Diskette, Recalibrate status
   849 0000043F <res 00000001>      <2> 	.bFDMotor		resb	1		; 0:43Fh, Diskette, Motor status
   850                              <2> 
   851 00000440 <res 00000001>      <2> 	.bFDMotTime		resb	1		; 0:440h, Diskette, Motor timeout counter
   852 00000441 <res 00000001>      <2> 	.bFDRetST		resb	1		; 0:441h, Diskette, Controller status return code
   853 00000442 <res 00000007>      <2> 	.rgbFDStatus	resb	7		; 0:442h, Diskette, Diskette and Disk Controller status bytes
   854 00000449 <res 00000001>      <2> 	.bVidMode		resb	1		; 0:449h, Video, Mode
   855 0000044A <res 00000002>      <2> 	.wVidColumns	resb	2		; 0:44Ah, Video, Number of columns
   856 0000044C <res 00000002>      <2> 	.wVidBpP		resb	2		; 0:44Ch, Video, Total number of bytes per page
   857 0000044E <res 00000002>      <2> 	.wVidPageOff	resb	2		; 0:44Eh, Video, Current page offset
   858                              <2> 
   859 00000450 <res 00000010>      <2> 	.rgwVidCurPos	resb	16		; 0:450h, Video, Cursor position, pages 0...7
   860                              <2> 
   861 00000460 <res 00000002>      <2> 	.wVidCurShape	resb	2		; 0:460h, Video, Cursor shape
   862 00000462 <res 00000001>      <2> 	.bVidPageIdx	resb	1		; 0:462h, Video, Active display page
   863 00000463 <res 00000002>      <2> 	.wVidPort		resb	2		; 0:463h, Video, I/O Port number base
   864 00000465 <res 00000001>      <2> 	.bVidModeReg	resb	1		; 0:465h, Video, Internal mode register
   865 00000466 <res 00000001>      <2> 	.bVidPalette	resb	1		; 0:466h, Video, Color palette
   866                              <2> 	.wCasTimeCnt:					; 0:467h, Cassette, Time count at data edge (PC)
   867 00000467 <res 00000002>      <2> 	.wGenOff		resb	2		; 0:467h, General use offset (XT+)
   868                              <2> 	.wCasCRC:						; 0:469h, Cassette, CRC register (PC)
   869 00000469 <res 00000002>      <2> 	.wGenSeg		resb	2		; 0:469h, General use segment (XT+)
   870                              <2> 	.bCasLast:						; 0:46Bh, Cassette, Last value read
   871 0000046B <res 00000001>      <2> 	.bLastIRQ		resb	1		; 0:46Bh, Last interrupt that occurred (XT+)
   872 0000046C <res 00000004>      <2> 	.dwTimerTicks	resb	4		; 0:46Ch, Timer ticks count
   873                              <2> 
   874 00000470 <res 00000001>      <2> 	.bTimer24h		resb	1		; 0:470h, Timer ticks rollover flag
   875 00000471 <res 00000001>      <2> 	.bKBCtrlBrk		resb	1		; 0:471h, Keyboard, Ctrl+Break flag
   876 00000472 <res 00000002>      <2> 	.wBoot			resb	2		; 0:472h, Warm boot flag
   877 00000474 <res 00000001>      <2> 	.bHDLastSt		resb	1		; 0:474h, Hard Disk, Status of Last Operation (XT+)
   878 00000475 <res 00000001>      <2> 	.bHDCount		resb	1		; 0:475h, Hard Disk, Number of HDs Attached (XT+)
   879 00000476 <res 00000001>      <2> 	.bHDCtrl		resb	1		; 0:476h, Hard Disk, Control Byte (temp, XT+)
   880 00000477 <res 00000001>      <2> 	.bHDPortOff		resb	1		; 0:477h, Hard Disk, Port Offset (XT)
   881 00000478 <res 00000001>      <2> 	.bLPT1Timeout	resb	1		; 0:478h, Parallel Printer 1, Timeout (XT+)
   882 00000479 <res 00000001>      <2> 	.bLPT2Timeout	resb	1		; 0:479h, Parallel Printer 2, Timeout (XT+)
   883 0000047A <res 00000001>      <2> 	.bLPT3Timeout	resb	1		; 0:47Ah, Parallel Printer 3, Timeout (XT+)
   884 0000047B <res 00000001>      <2> 	.bLPT4Timeout	resb	1		; 0:47Bh, Parallel Printer 4, Timeout (XT+)
   885 0000047C <res 00000001>      <2> 	.bCOM1Timeout	resb	1		; 0:47Ch, Serial 1, Timeout (XT+)
   886 0000047D <res 00000001>      <2> 	.bCOM2Timeout	resb	1		; 0:47Dh, Serial 2, Timeout (XT+)
   887 0000047E <res 00000001>      <2> 	.bCOM3Timeout	resb	1		; 0:47Eh, Serial 3, Timeout (XT+)
   888 0000047F <res 00000001>      <2> 	.bCOM4Timeout	resb	1		; 0:47Fh, Serial 4, Timeout (XT+)
   889                              <2> 
   890 00000480 <res 00000002>      <2> 	.wKBPtrStart	resb	2		; 0:480h, Keyboard, Pointer to start of buffer (XT+)
   891 00000482 <res 00000002>      <2> 	.wKBPtrEnd		resb	2		; 0:482h, Keyboard, Pointer to end of buffer (XT+)
   892 00000484 <res 00000001>      <2> 	.bVidRows		resb	1		; 0:484h, Video, Number of rows (EGA+)
   893 00000485 <res 00000002>      <2> 	.wVidPpC		resb	2		; 0:485h, Video, Pixels per character (EGA+)
   894 00000487 <res 00000001>      <2> 	.bVidOptns		resb	1		; 0:487h, Video, Options (EGA+)
   895 00000488 <res 00000001>      <2> 	.bVidSwitches	resb	1		; 0:488h, Video, Switches (EGA+)
   896 00000489 <res 00000001>      <2> 	.bVidSave1		resb	1		; 0:489h, Video, Save area 1 (VGA+)
   897 0000048A <res 00000001>      <2> 	.bVidSave2		resb	1		; 0:48Ah, Video, Save area 2 (VGA+)
   898 0000048B <res 00000001>      <2> 	.bFDCfgData		resb	1		; 0:48Bh, Diskette, Configuration data (AT+)
   899 0000048C <res 00000001>      <2> 	.bHDStatus		resb	1		; 0:48Ch, Hard Disk, Status Register (AT+)
   900 0000048D <res 00000001>      <2> 	.bHDError		resb	1		; 0:48Dh, Hard Disk, Error Register (AT+)
   901 0000048E <res 00000001>      <2> 	.bHDTaskFlg		resb	1		; 0:48Eh, Hard Disk, Task Complete Flag (AT+)
   902 0000048F <res 00000001>      <2> 	.bFDCtrlInfo	resb	1		; 0:48Fh, Diskette, Controller information (AT+)
   903                              <2> 
   904 00000490 <res 00000001>      <2> 	.bFDMedia0		resb	1		; 0:490h, Diskette 0, Media state (AT+)
   905 00000491 <res 00000001>      <2> 	.bFDMedia1		resb	1		; 0:491h, Diskette 1, Media state (AT+)
   906 00000492 <res 00000001>      <2> 	.bFDOpStart0	resb	1		; 0:492h, Diskette 0, Operational starting state (AT+)
   907 00000493 <res 00000001>      <2> 	.bFDOpStart1	resb	1		; 0:493h, Diskette 1, Operational starting state (AT+)
   908 00000494 <res 00000001>      <2> 	.bFDCurCyl0		resb	1		; 0:494h, Diskette 0, Current cylinder (AT+)
   909 00000495 <res 00000001>      <2> 	.bFDCurCyl1		resb	1		; 0:495h, Diskette 1, Current cylinder (AT+)
   910 00000496 <res 00000001>      <2> 	.bKBFlgs3		resb	1		; 0:496h, Keyboard, Status flags 3 (AT+)
   911 00000497 <res 00000001>      <2> 	.bKBFlgs4		resb	1		; 0:497h, Keyboard, Status flags 4 (AT+)
   912 00000498 <res 00000004>      <2> 	.dwWaitPtr		resb	4		; 0:498h, User's wait flag pointer (AT+)
   913 0000049C <res 00000004>      <2> 	.dwWaitCnt		resb	4		; 0:49Ch, User's wait count (AT+)
   914                              <2> 
   915 000004A0 <res 00000001>      <2> 	.bWaitFlg		resb	1		; 0:4A0h, Wait flag (AT+)
   916 000004A1 <res 00000007>      <2> 	.rgbLAN			resb	7		; 0:4A1h, Local Area Network (AT+)
   917 000004A8 <res 00000004>      <2> 	.dwVidPtr		resb	4		; 0:4A8h, Video, Parameter Control Block Pointer (EGA+)
   918 000004AC <res 00000022>      <2> 					resb	22h		; Reserved from 0:4ACh...0:4CDh
   919                              <2> 
   920 000004CE <res 00000004>      <2> 	.dwDays			resb	4		; 0:4CEh, Clock, Days since 1980 (some BIOSes, AT+)
   921 000004D2 <res 0000002E>      <2> 					resb	2Eh		; Reserved from 0:4D2h...0:4FFh
   922                              <2> 
   923 00000500 <res 00000001>      <2> 	.bPrntScrn		resb	1		; 0:500, Print screen status
   924                              <2> endstruc
   925                              <2> 
   926                              <2> ; BDA struct with only Hard Disk related locations
   927                              <2> struc HDBDA
   928 00000000 <res 00000474>      <2> 					resb	474h
   929 00000474 <res 00000001>      <2> 	.bHDLastSt		resb	1		; 0:474h, Status of Last Operation (XT+)
   930 00000475 <res 00000001>      <2> 	.bHDCount		resb	1		; 0:475h, Number of HDs Attached (XT+)
   931 00000476 <res 00000001>      <2> 	.bHDCtrl		resb	1		; 0:476h, Control Byte (temp, XT+)
   932 00000477 <res 00000001>      <2> 	.bHDPortOff		resb	1		; 0:477h, Port Offset (XT)
   933 00000478 <res 00000015>      <2> 					resb	15h
   934                              <2> 	.bHDStatus:						; 0:48Ch, Status Register (AT+)
   935                              <2> 	.bHDError:						; 0:48Dh, Error Register (AT+)
   936 0000048D <res 00000002>      <2> 	.wHDStAndErr	resb	2
   937 0000048F <res 00000001>      <2> 	.bHDTaskFlg		resb	1		; 0:48Eh, Task Complete Flag (AT+)
   938                              <2> endstruc
   939                              <2> 
   940                              <2> 
   941                              <2> ; Warm Boot Flags for BDA.wBoot
   942                              <2> BOOT_FLAG_COLD			EQU	0
   943                              <2> BOOT_FLAG_WARM			EQU	1234h	; Same effect as CTRL + ALT + DEL, skips memory tests
   944                              <2> BOOT_FLAG_PRESERVE_RAM	EQU	4321h	; No mem test, leave memory unchanged (AT+)
   945                              <2> 
   946                              <2> 
   947                              <2> %endif ; BIOSDATA_INC
   948                              <1> %include "BiosFunctions.inc"
   949                              <2> ; Project name	:	AssemblyLibrary
   950                              <2> ; Description	:	Defines for BIOS functions.
   951                              <2> %ifndef BIOS_FUNCTIONS_INC
   952                              <2> %define BIOS_FUNCTIONS_INC
   953                              <2> 
   954                              <2> ; BIOS interrupts
   955                              <2> BIOS_VIDEO_INTERRUPT_10h		EQU		10h
   956                              <2> BIOS_DISK_INTERRUPT_13h			EQU		13h
   957                              <2> BIOS_SYSTEM_INTERRUPT_15h		EQU		15h
   958                              <2> BIOS_KEYBOARD_INTERRUPT_16h		EQU		16h
   959                              <2> BIOS_BOOT_FAILURE_INTERRUPT_18h	EQU		18h
   960                              <2> BIOS_BOOT_LOADER_INTERRUPT_19h	EQU		19h
   961                              <2> BIOS_DISKETTE_INTERRUPT_40h		EQU		40h
   962                              <2> HD0_DPT_POINTER_41h				EQU		41h
   963                              <2> HD1_DPT_POINTER_46h				EQU		46h
   964                              <2> 
   965                              <2> ; Hardware interrupts
   966                              <2> HARDWARE_IRQ_0_INTERRUPT_08h	EQU		08h		; System timer
   967                              <2> HARDWARE_IRQ_1_INTERRUPT_09h	EQU		09h		; Keyboard
   968                              <2> HARDWARE_IRQ_2_INTERRUPT_0Ah	EQU		0Ah
   969                              <2> HARDWARE_IRQ_3_INTERRUPT_0Bh	EQU		0Bh
   970                              <2> HARDWARE_IRQ_4_INTERRUPT_0Ch	EQU		0Ch
   971                              <2> HARDWARE_IRQ_5_INTERRUPT_0Dh	EQU		0Dh
   972                              <2> HARDWARE_IRQ_6_INTERRUPT_0Eh	EQU		0Eh
   973                              <2> HARDWARE_IRQ_7_INTERRUPT_0Fh	EQU		0Fh
   974                              <2> HARDWARE_IRQ_8_INTERRUPT_70h	EQU		70h
   975                              <2> HARDWARE_IRQ_9_INTERRUPT_71h	EQU		71h
   976                              <2> HARDWARE_IRQ_10_INTERRUPT_72h	EQU		72h
   977                              <2> HARDWARE_IRQ_11_INTERRUPT_73h	EQU		73h
   978                              <2> HARDWARE_IRQ_12_INTERRUPT_74h	EQU		74h
   979                              <2> HARDWARE_IRQ_13_INTERRUPT_75h	EQU		75h
   980                              <2> HARDWARE_IRQ_14_INTERRUPT_76h	EQU		76h
   981                              <2> HARDWARE_IRQ_15_INTERRUPT_77h	EQU		77h
   982                              <2> 
   983                              <2> 
   984                              <2> ; BIOS video functions
   985                              <2> SET_VIDEO_MODE					EQU		00h
   986                              <2> SET_TEXT_MODE_CURSOR_SHAPE		EQU		01h
   987                              <2> SET_CURSOR_POSITION				EQU		02h
   988                              <2> GET_CURSOR_POSITION_AND_SIZE	EQU		03h
   989                              <2> SELECT_ACTIVE_DISPLAY_PAGE		EQU		05h
   990                              <2> TELETYPE_OUTPUT					EQU		0Eh
   991                              <2> 
   992                              <2> ; BIOS disk functions
   993                              <2> READ_SECTORS_INTO_MEMORY		EQU		02h
   994                              <2> GET_DRIVE_PARAMETERS			EQU		08h
   995                              <2> RESET_HARD_DISK					EQU		0Dh
   996                              <2> GET_DISK_TYPE					EQU		15h
   997                              <2> LOTECH_XTCF_FEATURES			EQU		1Eh
   998                              <2> GET_DRIVE_INFORMATION			EQU		25h
   999                              <2> CHECK_EXTENSIONS_PRESENT		EQU		41h
  1000                              <2> GET_EXTENDED_DRIVE_INFORMATION	EQU		48h
  1001                              <2> 
  1002                              <2> ; BIOS system functions
  1003                              <2> OS_HOOK_DEVICE_BUSY				EQU		90h
  1004                              <2> OS_HOOK_DEVICE_POST				EQU		91h
  1005                              <2> 
  1006                              <2> ; BIOS keyboard functions
  1007                              <2> GET_KEYSTROKE					EQU		00h
  1008                              <2> CHECK_FOR_KEYSTROKE				EQU		01h
  1009                              <2> 
  1010                              <2> ; BIOS system functions
  1011                              <2> EVENT_WAIT						EQU		86h
  1012                              <2> 
  1013                              <2> 
  1014                              <2> %endif ; BIOS_FUNCTIONS_INC
  1015                              <1> %include "CgaSnow.inc"
  1016                              <2> ; File name		:	CgaSnow.inc
  1017                              <2> ; Project name	:	AssemblyLibrary
  1018                              <2> ; Created date	:	8.10.2010
  1019                              <2> ; Last update	:	11.10.2010
  1020                              <2> ; Author		:	Tomi Tilli
  1021                              <2> ; Description	:	Macros for preventing CGA snow.
  1022                              <2> %ifndef CGASNOW_INC
  1023                              <2> %define CGASNOW_INC
  1024                              <2> 
  1025                              <2> ;--------------------------------------------------------------------
  1026                              <2> ; WAIT_RETRACE_IF_NECESSARY_THEN
  1027                              <2> ;	Parameters:
  1028                              <2> ;		%1:		Instruction that accessed CGA memory
  1029                              <2> ;		AL:		Character to output
  1030                              <2> ;		AH:		Attribute to output (stosw only)
  1031                              <2> ;		DS:		BDA segment (zero)
  1032                              <2> ;		ES:SI:	Ptr to video memory where to read from (if %1 reads)
  1033                              <2> ;		ES:DI:	Ptr to video memory where to output (if %1 writes)
  1034                              <2> ;	Returns:
  1035                              <2> ;		SI, DI:	Updated according to instruction
  1036                              <2> ;	Corrupts registers:
  1037                              <2> ;		AX, DX
  1038                              <2> ;--------------------------------------------------------------------
  1039                              <2> %macro WAIT_RETRACE_IF_NECESSARY_THEN 1
  1040                              <2> %ifdef ELIMINATE_CGA_SNOW
  1041                              <2> 	%ifidn %1, stosb
  1042                              <2> 		call	CgaSnow_Stosb
  1043                              <2> 	%elifidn %1, stosw
  1044                              <2> 		call	CgaSnow_Stosw
  1045                              <2> 	%elifidn %1, rep movsb
  1046                              <2> 		call	CgaSnow_RepMovsb
  1047                              <2> 	%else
  1048                              <2> 		%error	"Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  1049                              <2> 	%endif
  1050                              <2> %else	; No CGA snow prevention
  1051                              <2> 	%ifidn %1, rep movsb
  1052                              <2> 		eSEG_STR rep, es, movsb
  1053                              <2> 	%else
  1054                              <2> 		%1	; Single instruction
  1055                              <2> 	%endif
  1056                              <2> %endif
  1057                              <2> %endmacro
  1058                              <2> 
  1059                              <2> 
  1060                              <2> ;--------------------------------------------------------------------
  1061                              <2> ; WAIT_UNTIL_SAFE_CGA_WRITE
  1062                              <2> ;	Parameters:
  1063                              <2> ;		DX:		CGA Status Register Address (3DAh)
  1064                              <2> ;	Returns:
  1065                              <2> ;		Nothing
  1066                              <2> ;	Corrupts registers:
  1067                              <2> ;		AL
  1068                              <2> ;--------------------------------------------------------------------
  1069                              <2> %macro WAIT_UNTIL_SAFE_CGA_WRITE 0
  1070                              <2> %%WaitUntilNotInRetrace:
  1071                              <2> 	in		al, dx
  1072                              <2> 	shr		al, 1	; 1 = Bit 0: A 1 indicates that regen-buffer memory access can be
  1073                              <2> 					; made without interfering with the display. (H or V retrace)
  1074                              <2> 	jc		SHORT %%WaitUntilNotInRetrace
  1075                              <2> %%WaitUntilNextRetraceStarts:
  1076                              <2> 	in		al, dx
  1077                              <2> 	shr		al, 1
  1078                              <2> 	jnc		SHORT %%WaitUntilNextRetraceStarts
  1079                              <2> %endmacro
  1080                              <2> 
  1081                              <2> 
  1082                              <2> %endif ; CGASNOW_INC
  1083                              <1> %include "Debug.inc"
  1084                              <2> ; Project name	:	Assembly Library
  1085                              <2> ; Description	:	Debugging macros.
  1086                              <2> %ifndef DEBUG_INC
  1087                              <2> %define DEBUG_INC
  1088                              <2> 
  1089                              <2> 
  1090                              <2> ;--------------------------------------------------------------------
  1091                              <2> ; DISPLAY_DEBUG_WORD_AND_WAIT_ANY_KEY
  1092                              <2> ;	Parameters:
  1093                              <2> ;		%1:		Debug word
  1094                              <2> ;		%2:		Numeric base (2, 10, 16)
  1095                              <2> ;	Returns:
  1096                              <2> ;		Nothing
  1097                              <2> ;	Corrupts registers:
  1098                              <2> ;		Nothing
  1099                              <2> ;--------------------------------------------------------------------
  1100                              <2> %macro DISPLAY_DEBUG_WORD_AND_WAIT_ANY_KEY 2
  1101                              <2> 	pushf
  1102                              <2> 	push	di
  1103                              <2> 	push	bx
  1104                              <2> 	push	ax
  1105                              <2> 
  1106                              <2> 	mov		ax, %1
  1107                              <2> 	mov		bx, %2
  1108                              <2> 	CALL_DISPLAY_LIBRARY PrintWordFromAXwithBaseInBX
  1109                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1110                              <2> 	call	Keyboard_RemoveAllKeystrokesFromBuffer
  1111                              <2> %endif
  1112                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary
  1113                              <2> 
  1114                              <2> 	pop		ax
  1115                              <2> 	pop		bx
  1116                              <2> 	pop		di
  1117                              <2> 	popf
  1118                              <2> %endmacro
  1119                              <2> 
  1120                              <2> 
  1121                              <2> ;--------------------------------------------------------------------
  1122                              <2> ; DISPLAY_DEBUG_CHARACTER_AND_WAIT_ANY_KEY
  1123                              <2> ;	Parameters:
  1124                              <2> ;		%1:		Character to print
  1125                              <2> ;	Returns:
  1126                              <2> ;		Nothing
  1127                              <2> ;	Corrupts registers:
  1128                              <2> ;		Nothing
  1129                              <2> ;--------------------------------------------------------------------
  1130                              <2> %macro DISPLAY_DEBUG_CHARACTER_AND_WAIT_ANY_KEY 1
  1131                              <2> 	pushf
  1132                              <2> 	push	di
  1133                              <2> 	push	ax
  1134                              <2> 
  1135                              <2> 	mov		al, %1
  1136                              <2> 	CALL_DISPLAY_LIBRARY PrintCharacterFromAL
  1137                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1138                              <2> 	call	Keyboard_RemoveAllKeystrokesFromBuffer
  1139                              <2> %endif
  1140                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary
  1141                              <2> 
  1142                              <2> 	pop		ax
  1143                              <2> 	pop		di
  1144                              <2> 	popf
  1145                              <2> %endmacro
  1146                              <2> 
  1147                              <2> 
  1148                              <2> ;--------------------------------------------------------------------
  1149                              <2> ; DISPLAY_DEBUG_CHARACTER
  1150                              <2> ;	Parameters:
  1151                              <2> ;		%1:		Character to print
  1152                              <2> ;	Returns:
  1153                              <2> ;		Nothing
  1154                              <2> ;	Corrupts registers:
  1155                              <2> ;		Nothing
  1156                              <2> ;--------------------------------------------------------------------
  1157                              <2> %macro DISPLAY_DEBUG_CHARACTER 1
  1158                              <2> 	pushf
  1159                              <2> 	push	di
  1160                              <2> 	push	ax
  1161                              <2> 	mov		al, %1
  1162                              <2> 	CALL_DISPLAY_LIBRARY PrintCharacterFromAL
  1163                              <2> 	pop		ax
  1164                              <2> 	pop		di
  1165                              <2> 	popf
  1166                              <2> %endmacro
  1167                              <2> 
  1168                              <2> 
  1169                              <2> ;--------------------------------------------------------------------
  1170                              <2> ; WAIT_ANY_KEY_TO_CONTINUE
  1171                              <2> ;	Parameters:
  1172                              <2> ;		Nothing
  1173                              <2> ;	Returns:
  1174                              <2> ;		Nothing
  1175                              <2> ;	Corrupts registers:
  1176                              <2> ;		Nothing
  1177                              <2> ;--------------------------------------------------------------------
  1178                              <2> %macro WAIT_ANY_KEY_TO_CONTINUE 0
  1179                              <2> 	push	ax
  1180                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1181                              <2> 	call	Keyboard_RemoveAllKeystrokesFromBuffer
  1182                              <2> %endif
  1183                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary
  1184                              <2> 	pop		ax
  1185                              <2> %endmacro
  1186                              <2> 
  1187                              <2> 
  1188                              <2> %endif ; DEBUG_INC
  1189                              <1> %include "Delay.inc"
  1190                              <2> ; Project name	:	Assembly Library
  1191                              <2> ; Description	:	Delay macros.
  1192                              <2> %ifndef DELAY_INC
  1193                              <2> %define DELAY_INC
  1194                              <2> 
  1195                              <2> ;--------------------------------------------------------------------
  1196                              <2> ; Clears prefetch queue by jumping to next instruction.
  1197                              <2> ; This delays much more than nop instruction of fast systems.
  1198                              <2> ;
  1199                              <2> ; JMP_DELAY
  1200                              <2> ;	Parameters
  1201                              <2> ;		Nothing
  1202                              <2> ;	Returns:
  1203                              <2> ;		Nothing
  1204                              <2> ;	Corrupts registers:
  1205                              <2> ;		Nothing
  1206                              <2> ;--------------------------------------------------------------------
  1207                              <2> %macro JMP_DELAY 0
  1208                              <2> 	jmp		SHORT %%NextInstruction
  1209                              <2> %%NextInstruction:
  1210                              <2> %endmacro
  1211                              <2> 
  1212                              <2> 
  1213                              <2> ;--------------------------------------------------------------------
  1214                              <2> ; Mimimun delays (without fetching) with some CPU architectures:
  1215                              <2> ;	8088/8086:	17 cycles for jump + 5 cycles for last comparison
  1216                              <2> ;	286:		10 cycles for jump + 4 cycles for last comparison
  1217                              <2> ;	386:		13 cycles for jump + ? cycles for last comparison
  1218                              <2> ;	486:		 7 cycles for jump + 6 cycles for last comparison
  1219                              <2> ;
  1220                              <2> ; LOOP instruction uses two bytes so aligned fetching will require:
  1221                              <2> ;   8088:		8 cycles (two BYTE reads)
  1222                              <2> ;   8086:		4 cycles (one WORD read)
  1223                              <2> ;   286:		2 cycles + wait states (usually 1)
  1224                              <2> ;   386:		?
  1225                              <2> ;	486:		Fetched only once to internal cache
  1226                              <2> ;
  1227                              <2> ; DELAY_WITH_LOOP_INSTRUCTION_NA	; No JUMP_ALIGN
  1228                              <2> ; DELAY_WITH_LOOP_INSTRUCTION
  1229                              <2> ;	Parameters
  1230                              <2> ;		CX:		Loop iterations (0 is maximum delay with 65536 iterations)
  1231                              <2> ;	Returns:
  1232                              <2> ;		CX:		Zero
  1233                              <2> ;	Corrupts registers:
  1234                              <2> ;		Nothing
  1235                              <2> ;--------------------------------------------------------------------
  1236                              <2> %macro DELAY_WITH_LOOP_INSTRUCTION_NA 0
  1237                              <2> %%StartOfLoop:
  1238                              <2> 	loop	%%StartOfLoop
  1239                              <2> %endmacro
  1240                              <2> 
  1241                              <2> %macro DELAY_WITH_LOOP_INSTRUCTION 0
  1242                              <2> ALIGN JUMP_ALIGN
  1243                              <2> %%StartOfLoop:
  1244                              <2> 	loop	%%StartOfLoop
  1245                              <2> %endmacro
  1246                              <2> 
  1247                              <2> 
  1248                              <2> %endif ; DELAY_INC
  1249                              <1> %include "DosFunctions.inc"
  1250                              <2> ; Project name	:	AssemblyLibrary
  1251                              <2> ; Description	:	Defines for MS-DOS functions.
  1252                              <2> %ifndef DOS_FUNCTIONS_INC
  1253                              <2> %define DOS_FUNCTIONS_INC
  1254                              <2> 
  1255                              <2> ; DOS interrupts
  1256                              <2> DOS_INTERRUPT_21h									EQU		21h
  1257                              <2> DOS_CRITICAL_ERROR_HANDLER_24h						EQU		24h
  1258                              <2> DOS_TSR_MULTIPLEX_INTERRUPT_2Fh						EQU		2Fh
  1259                              <2> 
  1260                              <2> ; DOS drive and file functions
  1261                              <2> SELECT_DEFAULT_DRIVE								EQU		0Eh
  1262                              <2> GET_CURRENT_DEFAULT_DRIVE							EQU		19h
  1263                              <2> GET_DISK_TRANSFER_AREA_ADDRESS						EQU		2Fh
  1264                              <2> GET_DOS_DRIVE_PARAMETER_BLOCK_FOR_SPECIFIC_DRIVE	EQU		32h
  1265                              <2> SET_CURRENT_DIRECTORY								EQU		3Bh
  1266                              <2> CREATE_OR_TRUNCATE_FILE								EQU		3Ch
  1267                              <2> OPEN_EXISTING_FILE									EQU		3Dh
  1268                              <2> CLOSE_FILE											EQU		3Eh
  1269                              <2> READ_FROM_FILE_OR_DEVICE							EQU		3Fh
  1270                              <2> WRITE_TO_FILE_OR_DEVICE								EQU		40h
  1271                              <2> SET_CURRENT_FILE_POSITION							EQU		42h
  1272                              <2> GET_CURRENT_DIRECTORY								EQU		47h
  1273                              <2> FIND_FIRST_MATCHING_FILE							EQU		4Eh
  1274                              <2> FIND_NEXT_MATCHING_FILE								EQU		4Fh
  1275                              <2> 
  1276                              <2> ; DOS functions for TSRs
  1277                              <2> SET_INTERRUPT_VECTOR								EQU		25h
  1278                              <2> GET_INTERRUPT_VECTOR								EQU		35h
  1279                              <2> 
  1280                              <2> ; DOS errors
  1281                              <2> ERR_DOS_DRIVE_NOT_READY								EQU		15h
  1282                              <2> 
  1283                              <2> 
  1284                              <2> 
  1285                              <2> ; DOS Program Segment Prefix (PSP, first 256 (100h) bytes on top of program)
  1286                              <2> struc PSP
  1287 00000000 <res 00000002>      <2> 	.int20hInstruction				resb	2
  1288 00000002 <res 00000002>      <2> 	.wSizeOfMemoryInParagraphs		resb	2
  1289 00000004 <res 00000001>      <2> 	.reservedAt4h					resb	1
  1290 00000005 <res 00000005>      <2> 	.callToDosFunctionDispatcher	resb	5
  1291 0000000A <res 00000004>      <2> 	.fpInt22hTerminate				resb	4
  1292 0000000E <res 00000004>      <2> 	.fpInt23hCtrlC					resb	4
  1293 00000012 <res 00000004>      <2> 	.fpInt24hCriticalError			resb	4
  1294 00000016 <res 00000016>      <2> 	.reservedAt16h					resb	22
  1295 0000002C <res 00000002>      <2> 	.wEnvironmentSegment			resb	2
  1296 0000002E <res 00000022>      <2> 	.reservedAt2Eh					resb	34
  1297 00000050 <res 00000003>      <2> 	.int21hAndRetfInstructions		resb	3
  1298 00000053 <res 00000009>      <2> 	.reservedAt53h					resb	9
  1299 0000005C <res 00000010>      <2> 	.FCB1							resb	16
  1300 0000006C <res 00000014>      <2> 	.FCB2							resb	20
  1301                              <2> 	.DiskTransferArea:
  1302 00000080 <res 00000001>      <2> 	.bCommandLineLength				resb	1
  1303 00000081 <res 0000007F>      <2> 	.szCommandLine					resb	127
  1304                              <2> endstruc
  1305                              <2> 
  1306                              <2> 
  1307                              <2> ; DOS DTA (Disk Transfer Area)
  1308                              <2> struc DTA
  1309                              <2> 	; Undocumented fields
  1310 00000000 <res 00000015>      <2> 	.reservedAt0h		resb	21
  1311                              <2> 	; Documented fields
  1312 00000015 <res 00000001>      <2> 	.bFileAttributes	resb	1	; 15h, Attribute of matching file
  1313 00000016 <res 00000002>      <2> 	.wFileTime			resb	2	; 16h, File time
  1314 00000018 <res 00000002>      <2> 	.wFileDate			resb	2	; 18h, File date
  1315 0000001A <res 00000004>      <2> 	.dwFileSize			resb	4	; 1Ah, File size in bytes
  1316 0000001E <res 0000000D>      <2> 	.szFile				resb	13	; 1Eh, ASCIZ filename + extension
  1317                              <2> endstruc
  1318                              <2> 
  1319                              <2> 
  1320                              <2> %endif ; DOS_FUNCTIONS_INC
  1321                              <1> %include "File.inc"
  1322                              <2> ; File name		:	File.inc
  1323                              <2> ; Project name	:	Assembly Library
  1324                              <2> ; Created date	:	8.10.2010
  1325                              <2> ; Last update	:	6.12.2010
  1326                              <2> ; Author		:	Tomi Tilli
  1327                              <2> ; Description	:	File library defines.
  1328                              <2> %ifndef FILE_INC
  1329                              <2> %define FILE_INC
  1330                              <2> 
  1331                              <2> ; File access and sharing modes
  1332                              <2> struc FILE_ACCESS
  1333 00000000 <res 00000001>      <2> 	.ReadOnly		resb	1
  1334 00000001 <res 00000001>      <2> 	.WriteOnly		resb	1
  1335 00000002 <res 00000001>      <2> 	.ReadAndWrite	resb	1
  1336                              <2> endstruc
  1337                              <2> 
  1338                              <2> ; Origin of file seek
  1339                              <2> struc SEEK_FROM
  1340 00000000 <res 00000001>      <2> 	.startOfFile			resb	1	; 00h
  1341 00000001 <res 00000001>      <2> 	.currentFilePosition	resb	1	; 01h
  1342 00000002 <res 00000001>      <2> 	.endOfFile				resb	1	; 02h
  1343                              <2> endstruc
  1344                              <2> 
  1345                              <2> ; File attribute flags
  1346                              <2> FLG_FILEATTR_READ_ONLY			EQU		(1<<0)
  1347                              <2> FLG_FILEATTR_HIDDEN				EQU		(1<<1)
  1348                              <2> FLG_FILEATTR_SYSTEM				EQU		(1<<2)
  1349                              <2> FLG_FILEATTR_VOLUME_LABEL		EQU		(1<<3)
  1350                              <2> FLG_FILEATTR_DIRECTORY			EQU		(1<<4)
  1351                              <2> FLG_FILEATTR_ARCHIVE			EQU		(1<<5)
  1352                              <2> 
  1353                              <2> 
  1354                              <2> ; Max number of bytes to read/write per DOS call when transferring DX:CX bytes
  1355                              <2> SPLIT_SIZE_FOR_LARGE_TRANSFERS	EQU		(32<<10)
  1356                              <2> 
  1357                              <2> 
  1358                              <2> %endif ; FILE_INC
  1359                              <1> %include "Math.inc"
  1360                              <2> ; Project name	:	Assembly Library
  1361                              <2> ; Description	:	Math related macros.
  1362                              <2> %ifndef MATH_INC
  1363                              <2> %define MATH_INC
  1364                              <2> 
  1365                              <2> FALSE		EQU		0
  1366                              <2> TRUE		EQU		1
  1367                              <2> 
  1368                              <2> 
  1369                              <2> ;--------------------------------------------------------------------
  1370                              <2> ; MIN_U		Unsigned comparison
  1371                              <2> ; MIN_S		Signed comparison
  1372                              <2> ;	Parameters:
  1373                              <2> ;		%1:		Operand 1
  1374                              <2> ;		%2:		Operand 2
  1375                              <2> ;	Returns:
  1376                              <2> ;		%1:		Lesser operand
  1377                              <2> ;	Corrupts registers:
  1378                              <2> ;		Nothing
  1379                              <2> ;--------------------------------------------------------------------
  1380                              <2> %macro MIN_U 2
  1381                              <2> 	cmp		%1, %2				; Is %1 smaller?
  1382                              <2> 	jb		%%Return			;  If so, return
  1383                              <2> 	mov		%1, %2				; Copy %2 to %1
  1384                              <2> ALIGN JUMP_ALIGN
  1385                              <2> %%Return:
  1386                              <2> %endmacro
  1387                              <2> 
  1388                              <2> %macro MIN_S 2
  1389                              <2> 	cmp		%1, %2				; Is %1 smaller?
  1390                              <2> 	jl		%%Return			;  If so, return
  1391                              <2> 	mov		%1, %2				; Copy %2 to %1
  1392                              <2> ALIGN JUMP_ALIGN
  1393                              <2> %%Return:
  1394                              <2> %endmacro
  1395                              <2> 
  1396                              <2> 
  1397                              <2> ;--------------------------------------------------------------------
  1398                              <2> ; MAX_U		Unsigned comparison
  1399                              <2> ; MAX_S		Signed comparison
  1400                              <2> ;	Parameters:
  1401                              <2> ;		%1:		Operand 1
  1402                              <2> ;		%2:		Operand 2
  1403                              <2> ;	Returns:
  1404                              <2> ;		%1:		Greater operand
  1405                              <2> ;	Corrupts registers:
  1406                              <2> ;		Nothing
  1407                              <2> ;--------------------------------------------------------------------
  1408                              <2> %macro MAX_U 2
  1409                              <2> 	cmp		%1, %2				; Is %1 greater?
  1410                              <2> 	ja		%%Return			;  If so, return
  1411                              <2> 	mov		%1, %2				; Copy %2 to %1
  1412                              <2> ALIGN JUMP_ALIGN
  1413                              <2> %%Return:
  1414                              <2> %endmacro
  1415                              <2> 
  1416                              <2> %macro MAX_S 2
  1417                              <2> 	cmp		%1, %2				; Is %1 greater?
  1418                              <2> 	jg		%%Return			;  If so, return
  1419                              <2> 	mov		%1, %2				; Copy %2 to %1
  1420                              <2> ALIGN JUMP_ALIGN
  1421                              <2> %%Return:
  1422                              <2> %endmacro
  1423                              <2> 
  1424                              <2> 
  1425                              <2> ;--------------------------------------------------------------------
  1426                              <2> ; SHL_DXAX
  1427                              <2> ;	Parameters:
  1428                              <2> ;		%1:		Number of bits to shift
  1429                              <2> ;	Returns:
  1430                              <2> ;		DX:AX	Shifted value
  1431                              <2> ;	Corrupts registers:
  1432                              <2> ;		CX
  1433                              <2> ;--------------------------------------------------------------------
  1434                              <2> %macro SHL_DXAX 1
  1435                              <2> 	%ifnidni %1, cx
  1436                              <2> 		mov		cx, %1
  1437                              <2> 	%endif
  1438                              <2> ALIGN JUMP_ALIGN
  1439                              <2> .ShiftNextBit:
  1440                              <2> 	eSHL_IM	ax, 1
  1441                              <2> 	rcl		dx, 1
  1442                              <2> 	loop	.ShiftNextBit
  1443                              <2> %endmacro
  1444                              <2> 
  1445                              <2> 
  1446                              <2> ;--------------------------------------------------------------------
  1447                              <2> ; SHR_DXAX
  1448                              <2> ;	Parameters:
  1449                              <2> ;		%1:		Number of bits to shift
  1450                              <2> ;	Returns:
  1451                              <2> ;		DX:AX	Shifted value
  1452                              <2> ;	Corrupts registers:
  1453                              <2> ;		CX
  1454                              <2> ;--------------------------------------------------------------------
  1455                              <2> %macro SHR_DXAX 1
  1456                              <2> 	%ifnidni %1, cx
  1457                              <2> 		mov		cx, %1
  1458                              <2> 	%endif
  1459                              <2> ALIGN JUMP_ALIGN
  1460                              <2> .ShiftNextBit:
  1461                              <2> 	shr		dx, 1
  1462                              <2> 	rcr		ax, 1
  1463                              <2> 	loop	.ShiftNextBit
  1464                              <2> %endmacro
  1465                              <2> 
  1466                              <2> 
  1467                              <2> %endif ; MATH_INC
  1468                              <1> %include "Registers.inc"
  1469                              <2> ; Project name	:	Assembly Library
  1470                              <2> ; Description	:	Register related macros.
  1471                              <2> %ifndef REGISTERS_INC
  1472                              <2> %define REGISTERS_INC
  1473                              <2> 
  1474                              <2> struc INTPACK
  1475                              <2> %ifdef USE_386
  1476                              <2> ;	.gs				resb	2
  1477                              <2> ;	.fs				resb	2
  1478                              <2> %endif
  1479 00000000 <res 00000002>      <2> 	.es				resb	2
  1480 00000002 <res 00000002>      <2> 	.ds				resb	2
  1481 00000004 <res 00000002>      <2> 	.di				resb	2
  1482 00000006 <res 00000002>      <2> 	.si				resb	2
  1483 00000008 <res 00000002>      <2> 	.bp				resb	2
  1484 0000000A <res 00000002>      <2> 	.sp				resb	2
  1485                              <2> 	.bx:
  1486 0000000C <res 00000001>      <2> 	.bl				resb	1
  1487 0000000D <res 00000001>      <2> 	.bh				resb	1
  1488                              <2> 	.dx:
  1489 0000000E <res 00000001>      <2> 	.dl				resb	1
  1490 0000000F <res 00000001>      <2> 	.dh				resb	1
  1491                              <2> 	.cx:
  1492 00000010 <res 00000001>      <2> 	.cl				resb	1
  1493 00000011 <res 00000001>      <2> 	.ch				resb	1
  1494                              <2> 	.ax:
  1495 00000012 <res 00000001>      <2> 	.al				resb	1
  1496 00000013 <res 00000001>      <2> 	.ah				resb	1
  1497 00000014 <res 00000002>      <2> 	.ip				resb	2
  1498 00000016 <res 00000002>      <2> 	.cs				resb	2
  1499 00000018 <res 00000002>      <2> 	.flags			resb	2
  1500                              <2> endstruc
  1501                              <2> 
  1502                              <2> ; 8086/8088 FLAGS
  1503                              <2> FLG_FLAGS_CF		EQU (1<<0)
  1504                              <2> FLG_FLAGS_PF		EQU (1<<2)
  1505                              <2> FLG_FLAGS_AF		EQU (1<<4)
  1506                              <2> FLG_FLAGS_ZF		EQU (1<<6)
  1507                              <2> FLG_FLAGS_SF		EQU (1<<7)
  1508                              <2> FLG_FLAGS_TF		EQU (1<<8)
  1509                              <2> FLG_FLAGS_IF		EQU (1<<9)
  1510                              <2> FLG_FLAGS_DF		EQU (1<<10)
  1511                              <2> FLG_FLAGS_OF		EQU (1<<11)
  1512                              <2> 
  1513                              <2> 
  1514                              <2> ;--------------------------------------------------------------------
  1515                              <2> ; This macro must be the first thing to call on Interrupt Service Routine.
  1516                              <2> ;
  1517                              <2> ; CREATE_INTPACK_TO_SSBP
  1518                              <2> ;	Parameters
  1519                              <2> ;		Nothing
  1520                              <2> ;	Returns:
  1521                              <2> ;		SS:BP:	Points to INTPACK
  1522                              <2> ;	Corrupts registers:
  1523                              <2> ;		Nothing
  1524                              <2> ;--------------------------------------------------------------------
  1525                              <2> %macro CREATE_INTPACK_TO_SSBP 0
  1526                              <2> 	ePUSHA
  1527                              <2> 	push	ds
  1528                              <2> 	push	es
  1529                              <2> %ifdef USE_386
  1530                              <2> ;	push	fs
  1531                              <2> ;	push	gs
  1532                              <2> %endif
  1533                              <2> 	mov		bp, sp
  1534                              <2> %endmacro
  1535                              <2> 
  1536                              <2> ;--------------------------------------------------------------------
  1537                              <2> ; This macro must be the last thing to call on Interrupt Service Routine.
  1538                              <2> ;
  1539                              <2> ; RESTORE_INTPACK_FROM_SSBP
  1540                              <2> ;	Parameters
  1541                              <2> ;		SS:BP:	Ptr to INTPACK
  1542                              <2> ;	Returns:
  1543                              <2> ;		All Registers will be loaded from INTPACK
  1544                              <2> ;--------------------------------------------------------------------
  1545                              <2> %macro RESTORE_INTPACK_FROM_SSBP 0
  1546                              <2> %ifdef USE_386
  1547                              <2> ;	pop		gs
  1548                              <2> ;	pop		fs
  1549                              <2> %endif
  1550                              <2> 	pop		es
  1551                              <2> 	pop		ds
  1552                              <2> 	ePOPA
  1553                              <2> 	iret
  1554                              <2> %endmacro
  1555                              <2> 
  1556                              <2> 
  1557                              <2> ;--------------------------------------------------------------------
  1558                              <2> ; This macro must be the first thing to call on Interrupt Service Routine.
  1559                              <2> ;
  1560                              <2> ; CREATE_FRAME_INTPACK_TO_SSBP
  1561                              <2> ;	Parameters
  1562                              <2> ;		%1:		Number of extra bytes to reserve before INTPACK
  1563                              <2> ;	Returns:
  1564                              <2> ;		SS:BP:	Points to INTPACK
  1565                              <2> ;	Corrupts registers:
  1566                              <2> ;		Nothing
  1567                              <2> ;--------------------------------------------------------------------
  1568                              <2> %macro CREATE_FRAME_INTPACK_TO_SSBP 1
  1569                              <2> 	ePUSHA
  1570                              <2> 	push	ds
  1571                              <2> 	push	es
  1572                              <2> %ifdef USE_386
  1573                              <2> ;	push	fs
  1574                              <2> ;	push	gs
  1575                              <2> %endif
  1576                              <2> 	sub		sp, BYTE %1
  1577                              <2> 	mov		bp, sp
  1578                              <2> %endmacro
  1579                              <2> 
  1580                              <2> ;--------------------------------------------------------------------
  1581                              <2> ; This macro must be the last thing to call on Interrupt Service Routine.
  1582                              <2> ;
  1583                              <2> ; RESTORE_FRAME_INTPACK_FROM_SSBP
  1584                              <2> ;	Parameters
  1585                              <2> ;		%1:		Number of extra bytes in INTPACK
  1586                              <2> ;		SS:BP:	Ptr to INTPACK
  1587                              <2> ;	Returns:
  1588                              <2> ;		All Registers will be loaded from INTPACK
  1589                              <2> ;--------------------------------------------------------------------
  1590                              <2> %macro RESTORE_FRAME_INTPACK_FROM_SSBP 1
  1591                              <2> 	add		sp, BYTE %1
  1592                              <2> %ifdef USE_386
  1593                              <2> ;	pop		gs
  1594                              <2> ;	pop		fs
  1595                              <2> %endif
  1596                              <2> 	pop		es
  1597                              <2> 	pop		ds
  1598                              <2> 	ePOPA
  1599                              <2> 	iret
  1600                              <2> %endmacro
  1601                              <2> 
  1602                              <2> 
  1603                              <2> ;--------------------------------------------------------------------
  1604                              <2> ; NORMALIZE_FAR_POINTER
  1605                              <2> ;	Parameters:
  1606                              <2> ;		%1:%2:		Far pointer to normalize
  1607                              <2> ;		%3:			Scratch register
  1608                              <2> ;		%4:			Scratch register
  1609                              <2> ;	Returns:
  1610                              <2> ;		%1:%2:		Normalized far pointer
  1611                              <2> ;	Corrupts registers:
  1612                              <2> ;		%3, %4
  1613                              <2> ;--------------------------------------------------------------------
  1614                              <2> %macro NORMALIZE_FAR_POINTER 4
  1615                              <2> 	mov		%4, %2				; Copy offset to scratch reg
  1616                              <2> 	and		%2, BYTE 0Fh		; Clear offset bits 15...4
  1617                              <2> 	eSHR_IM	%4, 4				; Divide offset by 16
  1618                              <2> 	mov		%3, %1				; Copy segment to scratch reg
  1619                              <2> 	add		%3, %4				; Add shifted offset to segment
  1620                              <2> 	mov		%1, %3				; Set normalized segment
  1621                              <2> %endmacro
  1622                              <2> 
  1623                              <2> 
  1624                              <2> ;--------------------------------------------------------------------
  1625                              <2> ; COPY_SSBP_TO_ESDI
  1626                              <2> ; COPY_SSBP_TO_DSSI
  1627                              <2> ; COPY_DSSI_TO_ESDI
  1628                              <2> ; COPY_ESDI_to_DSSI
  1629                              <2> ;	Parameters
  1630                              <2> ;		Nothing
  1631                              <2> ;	Returns:
  1632                              <2> ;		Copies farm pointer to different segment/pointer register pair
  1633                              <2> ;	Corrupts registers:
  1634                              <2> ;		Nothing
  1635                              <2> ;--------------------------------------------------------------------
  1636                              <2> %macro COPY_SSBP_TO_ESDI 0
  1637                              <2> 	push	ss
  1638                              <2> 	pop		es
  1639                              <2> 	mov		di, bp
  1640                              <2> %endmacro
  1641                              <2> 
  1642                              <2> %macro COPY_SSBP_TO_DSSI 0
  1643                              <2> 	push	ss
  1644                              <2> 	pop		ds
  1645                              <2> 	mov		si, bp
  1646                              <2> %endmacro
  1647                              <2> 
  1648                              <2> %macro COPY_DSSI_TO_ESDI 0
  1649                              <2> 	push	ds
  1650                              <2> 	pop		es
  1651                              <2> 	mov		di, si
  1652                              <2> %endmacro
  1653                              <2> 
  1654                              <2> %macro COPY_ESDI_to_DSSI 0
  1655                              <2> 	push	es
  1656                              <2> 	pop		ds
  1657                              <2> 	mov		si, di
  1658                              <2> %endmacro
  1659                              <2> 
  1660                              <2> 
  1661                              <2> 
  1662                              <2> %endif ; REGISTERS_INC
  1663                              <1> %include "SystemTimer.inc"
  1664                              <2> ; Project name	:	Assembly Library
  1665                              <2> ; Description	:	System Timer (8254) relates equates and macros.
  1666                              <2> %ifndef SYSTEMTIMER_INC
  1667                              <2> %define SYSTEMTIMER_INC
  1668                              <2> 
  1669                              <2> ; Timer/Counter to program
  1670                              <2> TIMER_0									EQU	(0<<6)
  1671                              <2> TIMER_1									EQU	(1<<6)
  1672                              <2> TIMER_2									EQU	(2<<6)
  1673                              <2> 
  1674                              <2> ; Counter commands
  1675                              <2> LATCH									EQU	(0<<4)	; Counter Latch Command (latches the count for reading)
  1676                              <2> READ_OR_WRITE_LSB_ONLY					EQU	(1<<4)	; MSB is always zero
  1677                              <2> READ_OR_WRITE_MSB_ONLY					EQU	(2<<4)	; LSB is always zero
  1678                              <2> READ_OR_WRITE_LSB_THEN_MSB				EQU	(3<<4)
  1679                              <2> 
  1680                              <2> ; Timer modes
  1681                              <2> MODE_0_SINGLE_TIMEOUT					EQU	(0<<1)	; Interrupt on Terminal Count
  1682                              <2> MODE_1_ONE_SHOT							EQU	(1<<1)	; Hardware Retriggerable One-Shot
  1683                              <2> MODE_2_RATE_GENERATOR					EQU	(2<<1)
  1684                              <2> MODE_3_SQUARE_WAVE_MODE					EQU	(3<<1)
  1685                              <2> MODE_4_SOFTWARE_TRIGGERED_STROBE		EQU	(4<<1)
  1686                              <2> MODE_5_HARDWARE_RETRIGGERABLE_STROBE	EQU	(5<<1)
  1687                              <2> 
  1688                              <2> ; Binary / BCD Mode
  1689                              <2> BINARY_COUNTER							EQU	0
  1690                              <2> BCD_COUNTER								EQU	1
  1691                              <2> 
  1692                              <2> 
  1693                              <2> ; Ports
  1694                              <2> COUNT_REGISTER_0						EQU	40h		; Timer 0 Count Register (System Timer Ticks)
  1695                              <2> COUNT_REGISTER_1						EQU	41h		; Timer 1 Count Register (DRAM Refresh)
  1696                              <2> COUNT_REGISTER_2						EQU	42h		; Timer 2 Count Register (General Use)
  1697                              <2> CONTROL_WORD_REGISTER_out				EQU	43h
  1698                              <2> 
  1699                              <2> ; Timer 2 is connected to PC Speaker that can be controller from port 61h.
  1700                              <2> SPEAKER_CONTROL_REGISTER				EQU	61h
  1701                              <2> FLG_TIMER_2_OUTPUT_in					EQU	(1<<5)	; AT+ only
  1702                              <2> FLG_SPEAKER_DATA_ENABLED				EQU	(1<<1)
  1703                              <2> FLG_SPEAKER_GATE_TIMER_2_ON				EQU	(1<<0)
  1704                              <2> 
  1705                              <2> 
  1706                              <2> ; The duration of one tick
  1707                              <2> TIMER_CYCLE_TIME						EQU	838		; nanosecs
  1708                              <2> 
  1709                              <2> 
  1710                              <2> 
  1711                              <2> 
  1712                              <2> ;--------------------------------------------------------------------
  1713                              <2> ; OUTPUT_COUNTER_COMMAND_TO
  1714                              <2> ;	Parameters:
  1715                              <2> ;		%1:		TIMER_0, TIMER_1 or TIMER_2
  1716                              <2> ;		%2:		Command to counter
  1717                              <2> ;		%3:		Timer mode
  1718                              <2> ;		%4:		BINARY_COUNTER or BCD_COUNTER
  1719                              <2> ;	Returns:
  1720                              <2> ;		Nothing
  1721                              <2> ;	Corrupts registers:
  1722                              <2> ;		AL
  1723                              <2> ;--------------------------------------------------------------------
  1724                              <2> %macro OUTPUT_COUNTER_COMMAND_TO 4
  1725                              <2> 	mov		al, %1 | %2 | %3 | %4
  1726                              <2> 	out		CONTROL_WORD_REGISTER_out, al
  1727                              <2> %endmacro
  1728                              <2> 
  1729                              <2> 
  1730                              <2> ;--------------------------------------------------------------------
  1731                              <2> ; WRITE_COUNT_FROM_AL_TO
  1732                              <2> ; WRITE_COUNT_FROM_AX_TO
  1733                              <2> ;	Parameters:
  1734                              <2> ;		%1:		TIMER_0, TIMER_1 or TIMER_2
  1735                              <2> ;		AX:		Count to write to timer
  1736                              <2> ;	Returns:
  1737                              <2> ;		Nothing
  1738                              <2> ;	Corrupts registers:
  1739                              <2> ;		AL (WRITE_COUNT_FROM_AX_TO only)
  1740                              <2> ;--------------------------------------------------------------------
  1741                              <2> %macro WRITE_COUNT_FROM_AL_TO 1
  1742                              <2> 	%ifidni %1, TIMER_0
  1743                              <2> 		out		COUNT_REGISTER_0, al
  1744                              <2> 	%elifidni %1, TIMER_1
  1745                              <2> 		out		COUNT_REGISTER_1, al
  1746                              <2> 	%elifidni %1, TIMER_2
  1747                              <2> 		out		COUNT_REGISTER_2, al
  1748                              <2> 	%else
  1749                              <2> 		%error "Invalid timer name passed to WRITE_COUNT_FROM_AL_TO"
  1750                              <2> 	%endif
  1751                              <2> %endmacro
  1752                              <2> 
  1753                              <2> %macro WRITE_COUNT_FROM_AX_TO 1
  1754                              <2> 	%ifidni %1, TIMER_0
  1755                              <2> 		out		COUNT_REGISTER_0, al
  1756                              <2> 		mov		al, ah
  1757                              <2> 		out		COUNT_REGISTER_0, al
  1758                              <2> 	%elifidni %1, TIMER_1
  1759                              <2> 		out		COUNT_REGISTER_1, al
  1760                              <2> 		mov		al, ah
  1761                              <2> 		out		COUNT_REGISTER_1, al
  1762                              <2> 	%elifidni %1, TIMER_2
  1763                              <2> 		out		COUNT_REGISTER_2, al
  1764                              <2> 		mov		al, ah
  1765                              <2> 		out		COUNT_REGISTER_2, al
  1766                              <2> 	%else
  1767                              <2> 		%error "Invalid timer name passed to WRITE_COUNT_FROM_AX_TO"
  1768                              <2> 	%endif
  1769                              <2> %endmacro
  1770                              <2> 
  1771                              <2> 
  1772                              <2> ;--------------------------------------------------------------------
  1773                              <2> ; READ_COUNT_TO_AL_FROM
  1774                              <2> ; READ_COUNT_TO_AX_FROM
  1775                              <2> ;	Parameters:
  1776                              <2> ;		%1:		TIMER_0, TIMER_1 or TIMER_2
  1777                              <2> ;	Returns:
  1778                              <2> ;		AL/AX:	Counter value
  1779                              <2> ;	Corrupts registers:
  1780                              <2> ;		Nothing
  1781                              <2> ;--------------------------------------------------------------------
  1782                              <2> %macro READ_COUNT_TO_AL_FROM 1
  1783                              <2> 	%ifidni %1, TIMER_0
  1784                              <2> 		in		al, COUNT_REGISTER_0
  1785                              <2> 	%elifidni %1, TIMER_1
  1786                              <2> 		in		al, COUNT_REGISTER_1
  1787                              <2> 	%elifidni %1, TIMER_2
  1788                              <2> 		in		al, COUNT_REGISTER_2
  1789                              <2> 	%else
  1790                              <2> 		%error "Invalid timer name passed to READ_COUNT_TO_AL_FROM"
  1791                              <2> 	%endif
  1792                              <2> %endmacro
  1793                              <2> 
  1794                              <2> %macro READ_COUNT_TO_AX_FROM 1
  1795                              <2> 	%ifidni %1, TIMER_0
  1796                              <2> 		in		al, COUNT_REGISTER_0
  1797                              <2> 		mov		ah, al
  1798                              <2> 		in		al, COUNT_REGISTER_0
  1799                              <2> 	%elifidni %1, TIMER_1
  1800                              <2> 		in		al, COUNT_REGISTER_1
  1801                              <2> 		mov		ah, al
  1802                              <2> 		in		al, COUNT_REGISTER_1
  1803                              <2> 	%elifidni %1, TIMER_2
  1804                              <2> 		in		al, COUNT_REGISTER_2
  1805                              <2> 		mov		ah, al
  1806                              <2> 		in		al, COUNT_REGISTER_2
  1807                              <2> 	%else
  1808                              <2> 		%error "Invalid timer name passed to READ_COUNT_TO_AX_FROM"
  1809                              <2> 	%endif
  1810                              <2> 		xchg	al, ah
  1811                              <2> %endmacro
  1812                              <2> 
  1813                              <2> 
  1814                              <2> ;--------------------------------------------------------------------
  1815                              <2> ; START_PRECISE_EVENT_TIMER
  1816                              <2> ;	Parameters:
  1817                              <2> ;		Nothing
  1818                              <2> ;	Returns:
  1819                              <2> ;		Nothing
  1820                              <2> ;	Corrupts registers:
  1821                              <2> ;		AL
  1822                              <2> ;--------------------------------------------------------------------
  1823                              <2> %macro START_PRECISE_EVENT_TIMER 0
  1824                              <2> 	in		al, SPEAKER_CONTROL_REGISTER
  1825                              <2> 	or		al, FLG_SPEAKER_GATE_TIMER_2_ON
  1826                              <2> 	out		SPEAKER_CONTROL_REGISTER, al
  1827                              <2> %endmacro
  1828                              <2> 
  1829                              <2> 
  1830                              <2> ;--------------------------------------------------------------------
  1831                              <2> ; STOP_PRECISE_EVENT_TIMER
  1832                              <2> ;	Parameters:
  1833                              <2> ;		Nothing
  1834                              <2> ;	Returns:
  1835                              <2> ;		Nothing
  1836                              <2> ;	Corrupts registers:
  1837                              <2> ;		AL
  1838                              <2> ;--------------------------------------------------------------------
  1839                              <2> %macro STOP_PRECISE_EVENT_TIMER 0
  1840                              <2> 	in		al, SPEAKER_CONTROL_REGISTER
  1841                              <2> 	and		al, ~(FLG_SPEAKER_DATA_ENABLED | FLG_SPEAKER_GATE_TIMER_2_ON)
  1842                              <2> 	out		SPEAKER_CONTROL_REGISTER, al
  1843                              <2> %endmacro
  1844                              <2> 
  1845                              <2> 
  1846                              <2> %endif ; SYSTEMTIMER_INC
  1847                              <1> 
  1848                              <1> 
  1849                              <1> ; Library dependencies
  1850                              <1> %ifdef INCLUDE_MENU_DIALOGS
  1851                              <1> 	%include "Dialog.inc"
  1852                              <1> 	%define INCLUDE_MENU_LIBRARY
  1853                              <1> 	%define INCLUDE_FILE_LIBRARY
  1854                              <1> %endif
  1855                              <1> 
  1856                              <1> %ifdef INCLUDE_MENU_LIBRARY
  1857                              <1> 	%include "Menu.inc"
  1858                              <1> 	%include "MenuEvents.inc"
  1859                              <1> 	%define INCLUDE_KEYBOARD_LIBRARY
  1860                              <1> 	%define INCLUDE_TIME_LIBRARY
  1861                              <1> %endif
  1862                              <1> 
  1863                              <1> %ifdef INCLUDE_KEYBOARD_LIBRARY
  1864                              <1> 	%define INCLUDE_DISPLAY_LIBRARY
  1865                              <1> 	%define INCLUDE_UTIL_LIBRARY
  1866                              <1> %endif
  1867                              <1> 
  1868                              <1> %ifdef INCLUDE_DISPLAY_LIBRARY
  1869                              <1> 	%include "Display.inc"
  1870                              <2> ; Project name	:	AssemblyLibrary
  1871                              <2> ; Description	:	Defines for display library.
  1872                              <2> %ifndef DISPLAY_INC
  1873                              <2> %define DISPLAY_INC
  1874                              <2> 
  1875                              <2> %ifndef MODULE_STRINGS_COMPRESSED_PRECOMPRESS
  1876                              <2> ;--------------------------------------------------------------------
  1877                              <2> ; Display Library users need to use these macros since it will provide
  1878                              <2> ; compatibility with future library versions.
  1879                              <2> ;
  1880                              <2> ; CALL_DISPLAY_LIBRARY
  1881                              <2> ; JMP_DISPLAY_LIBRARY
  1882                              <2> ;	Parameters:
  1883                              <2> ;		%1:			Function to call (functionName from DISPLAY_LIB)
  1884                              <2> ;		Registers:	Depends on function to call
  1885                              <2> ;	Returns:
  1886                              <2> ;		Depends on function to call
  1887                              <2> ;	Corrupts registers:
  1888                              <2> ;		AX (unless used as a return register), DI
  1889                              <2> ;--------------------------------------------------------------------
  1890                              <2> %macro CALL_DISPLAY_LIBRARY 1
  1891                              <2> 	%ifidn %1, PushDisplayContext
  1892                              <2> 		call	DisplayContext_Push
  1893                              <2> 	%elifidn %1, PopDisplayContext
  1894                              <2> 		call	DisplayContext_Pop
  1895                              <2> 	%elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
  1896                              <2> 		call	DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
  1897                              <2> 	%else
  1898                              <2> 		mov		di, %1
  1899                              <2> 		call	Display_FunctionFromDI
  1900                              <2> 	%endif
  1901                              <2> %endmacro
  1902                              <2> 
  1903                              <2> %macro JMP_DISPLAY_LIBRARY 1
  1904                              <2> 	%ifidn %1, PushDisplayContext
  1905                              <2> 		jmp		DisplayContext_Push
  1906                              <2> 	%elifidn %1, PopDisplayContext
  1907                              <2> 		call	DisplayContext_Pop
  1908                              <2> 		ret
  1909                              <2> 	%elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
  1910                              <2> 		jmp		DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
  1911                              <2> 	%elifidn %1, FormatNullTerminatedStringFromCSSI
  1912                              <2> 		mov		di, %1
  1913                              <2> 		call	Display_FunctionFromDI
  1914                              <2> 		ret
  1915                              <2> 	%else
  1916                              <2> 		mov		di, %1
  1917                              <2> 		jmp		Display_FunctionFromDI
  1918                              <2> 	%endif
  1919                              <2> %endmacro
  1920                              <2> 
  1921                              <2> %if 0
  1922                              <2> ;;;
  1923                              <2> ;;; struc no longer needed with direct calls to functions
  1924                              <2> ;;;
  1925                              <2> 
  1926                              <2> ; Display library functions
  1927                              <2> struc DISPLAY_LIB
  1928                              <2> 	.PushDisplayContext:
  1929                              <2> 	.PopDisplayContext:
  1930                              <2> 	.InitializeDisplayContext						resb	2
  1931                              <2> 
  1932                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1933                              <2> 	.SetCharacterPointerFromBXAX					resb	2
  1934                              <2> %endif
  1935                              <2> 	.SetCharOutputFunctionFromAXwithAttribFlagInBL	resb	2
  1936                              <2> 	.SetCharacterOutputParameterFromAX				resb	2
  1937                              <2> 	.SetCharacterAttributeFromAL					resb	2
  1938                              <2> 	.SetCursorShapeFromAX							resb	2
  1939                              <2> 	.SetCursorCoordinatesFromAX						resb	2
  1940                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  1941                              <2> 	.SetNewPageFromAL								resb	2
  1942                              <2> %endif
  1943                              <2> 	.SynchronizeDisplayContextToHardware			resb	2
  1944                              <2> 
  1945                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1946                              <2> 	.GetCharacterPointerToBXAX						resb	2
  1947                              <2> %endif
  1948                              <2> 	.GetSoftwareCoordinatesToAX						resb	2
  1949                              <2> 	.GetColumnsToALandRowsToAH						resb	2
  1950                              <2> 
  1951                              <2> 	.FormatNullTerminatedStringFromCSSI				resb	2
  1952                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1953                              <2> 	.PrintSignedWordFromAXWithBaseInBX				resb	2
  1954                              <2> %endif
  1955                              <2> 	.PrintWordFromAXwithBaseInBX					resb	2
  1956                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  1957                              <2> 	.PrintQWordFromSSBPwithBaseInBX					resb	2
  1958                              <2> %endif
  1959                              <2> 	.PrintCharBufferFromBXSIwithLengthInCX			resb	2
  1960                              <2> 	.PrintNullTerminatedStringFromBXSI				resb	2
  1961                              <2> 	.PrintNullTerminatedStringFromCSSI				resb	2
  1962                              <2> 	.PrintRepeatedCharacterFromALwithCountInCX		resb	2
  1963                              <2> 	.PrintCharacterFromAL							resb	2
  1964                              <2> 	.PrintNewlineCharacters							resb	2
  1965                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1966                              <2> 	.ClearAreaWithHeightInAHandWidthInAL			resb	2
  1967                              <2> %endif
  1968                              <2> 	.ClearScreenWithCharInALandAttrInAH				resb	2
  1969                              <2> endstruc
  1970                              <2> %endif
  1971                              <2> 
  1972                              <2> ; Attribute flags for DISPLAY_LIB.SetCharacterOutputFunctionFromAXwithAttributeFlagInBL
  1973                              <2> ATTRIBUTES_NOT_USED							EQU		0
  1974                              <2> ATTRIBUTES_ARE_USED							EQU		FLG_CONTEXT_ATTRIBUTES
  1975                              <2> 
  1976                              <2> ; Character output functions for DISPLAY_LIB.SetCharacterOutputFunctionFromAXwithAttributeFlagInBL
  1977                              <2> TELETYPE_OUTPUT_WITH_ATTRIBUTE				EQU		DisplayCharOut_TeletypeOutputWithAttribute
  1978                              <2> TELETYPE_OUTPUT_WITHOUT_ATTRIBUTE			EQU		DisplayCharOut_TeletypeOutput
  1979                              <2> TELETYPE_OUTPUT_USING_BIOS					EQU		DisplayCharOut_BiosTeletypeOutput
  1980                              <2> FAST_OUTPUT_WITH_ATTRIBUTE_ONLY				EQU		DisplayCharOut_Attribute
  1981                              <2> FAST_OUTPUT_WITH_CHAR_ONLY					EQU		DisplayCharOut_Character
  1982                              <2> FAST_OUTPUT_WITH_CHAR_AND_ATTRIBUTE			EQU		DisplayCharOut_CharacterWithAttribute
  1983                              <2> BUFFER_OUTPUT_WITH_CHAR_ONLY				EQU		DisplayCharOut_WriteCharacterToBuffer
  1984                              <2> 
  1985                              <2> DEFAULT_CHARACTER_OUTPUT					EQU		TELETYPE_OUTPUT_WITH_ATTRIBUTE
  1986                              <2> 
  1987                              <2> 
  1988                              <2> struc VIDEO_BDA
  1989 00000000 <res 00000449>      <2> 						resb	449h
  1990 00000449 <res 00000001>      <2> 	.bMode				resb	1		; 0:449h, Video, Mode
  1991 0000044A <res 00000002>      <2> 	.wColumns			resb	2		; 0:44Ah, Video, Number of columns
  1992 0000044C <res 00000002>      <2> 	.wBytesPerPage		resb	2		; 0:44Ch, Video, Total number of bytes per page
  1993 0000044E <res 00000002>      <2> 	.wPageOffset		resb	2		; 0:44Eh, Video, Current page offset
  1994 00000450 <res 00000004>      <2> 	.rgwCursors			resb	4		; 0:450h, Video, Cursor position, pages 0...1
  1995 00000454 <res 0000000C>      <2> 	.displayContext		resb	12		; Our own display context (normally cursors for pages 2...7)
  1996 00000460 <res 00000002>      <2> 	.wCursorShape		resb	2		; 0:460h, Video, Cursor shape
  1997 00000462 <res 00000001>      <2> 	.bActivePage		resb	1		; 0:462h, Video, Active display page
  1998 00000463 <res 00000002>      <2> 	.wVideoPort			resb	2		; 0:463h, Video, I/O Port number base
  1999 00000465 <res 00000001>      <2> 	.bInternalModeReg	resb	1		; 0:465h, Video, Internal mode register
  2000 00000466 <res 00000001>      <2> 	.bColorPalette		resb	1		; 0:466h, Video, Color palette
  2001                              <2> endstruc
  2002                              <2> 
  2003                              <2> struc DISPLAY_CONTEXT
  2004 00000000 <res 00000004>      <2> 	.fpCursorPosition	resb	4	; Far pointer to cursor position in video memory
  2005 00000004 <res 00000002>      <2> 	.fnCharOut			resb	2	; Function to draw character with
  2006 00000006 <res 00000002>      <2> 	.wCharOutParam		resb	2	; User parameter for custom character output function
  2007 00000008 <res 00000002>      <2> 	.wCursorShape		resb	2	; Current cursor shape
  2008 0000000A <res 00000001>      <2> 	.bAttribute			resb	1	; Selected character attribute
  2009 0000000B <res 00000001>      <2> 	.bFlags				resb	1	; Display context flags
  2010                              <2> endstruc
  2011                              <2> 
  2012                              <2> ; Display context flags
  2013                              <2> FLG_CONTEXT_ATTRIBUTES		EQU		(1<<0)	; Character output function uses attributes
  2014                              <2> FLG_CONTEXT_CGA				EQU		(1<<1)	; CGA detected so prevent CGA snow
  2015                              <2> 
  2016                              <2> 
  2017                              <2> ; Text mode character attribute byte bits for CGA+ (color adapters)
  2018                              <2> FLG_COLOR_FORE_BLUE			EQU		(1<<0)
  2019                              <2> FLG_COLOR_FORE_GREEN		EQU		(1<<1)
  2020                              <2> FLG_COLOR_FORE_RED			EQU		(1<<2)
  2021                              <2> FLG_COLOR_FORE_INTENSITY	EQU		(1<<3)
  2022                              <2> FLG_COLOR_FORE_FONT_B		EQU		(1<<3)	; Select font set B (if available, EGA+)
  2023                              <2> FLG_COLOR_BACK_BLUE			EQU		(1<<4)
  2024                              <2> FLG_COLOR_BACK_GREEN		EQU		(1<<5)
  2025                              <2> FLG_COLOR_BACK_RED			EQU		(1<<6)
  2026                              <2> FLG_COLOR_BACK_INTENSITY	EQU		(1<<7)	; Intensity when blinking is disabled
  2027                              <2> FLG_COLOR_BLINK				EQU		(1<<7)	; Blinking color when enabled (enabled by default)
  2028                              <2> 
  2029                              <2> ; CGA colors
  2030                              <2> %define COLOR_ATTRIBUTE(foreground, background)	( (foreground) | ((background)<<4) )
  2031                              <2> COLOR_BLACK					EQU		0
  2032                              <2> COLOR_BLUE					EQU		1
  2033                              <2> COLOR_GREEN					EQU		2
  2034                              <2> COLOR_CYAN					EQU		3
  2035                              <2> COLOR_RED					EQU		4
  2036                              <2> COLOR_MAGENTA				EQU		5
  2037                              <2> COLOR_BROWN					EQU		6
  2038                              <2> COLOR_WHITE					EQU		7		; Last background color if blinking enabled
  2039                              <2> COLOR_GRAY					EQU		8
  2040                              <2> COLOR_LIGHT_BLUE			EQU		9
  2041                              <2> COLOR_LIGHT_GREEN			EQU		10
  2042                              <2> COLOR_LIGHT_CYAN			EQU		11
  2043                              <2> COLOR_LIGHT_RED				EQU		12
  2044                              <2> COLOR_LIGHT_MAGENTA			EQU		13
  2045                              <2> COLOR_YELLOW				EQU		14
  2046                              <2> COLOR_BRIGHT_WHITE			EQU		15
  2047                              <2> 
  2048                              <2> 
  2049                              <2> ; Text mode character attribute byte bits for MDA (monochrome adapters)
  2050                              <2> ; (attributes 00h, 08h, 80h, 88h, 70h, 78h, F0h and F8h are exceptions)
  2051                              <2> FLG_MONO_UNDERLINE			EQU		(1<<1)
  2052                              <2> FLG_MONO_INTENSITY			EQU		(1<<3)
  2053                              <2> FLG_MONO_BLINK				EQU		(1<<7)
  2054                              <2> 
  2055                              <2> ; Text mode character attribute bytes for MDA/Hercules (monochrome adapters)
  2056                              <2> ; *Not displayed on some monitors
  2057                              <2> MONO_HIDDEN					EQU		00h		; Not displayed (same for 08h, 80h and 88h)
  2058                              <2> MONO_UNDERLINE				EQU		01h		; Underlined
  2059                              <2> MONO_NORMAL					EQU		07h		; Normal (white on black)
  2060                              <2> MONO_BRIGHT_UNDERLINE		EQU		09h		; High intensity, underlined
  2061                              <2> MONO_BRIGHT					EQU		0Fh		; High intensity
  2062                              <2> MONO_REVERSE				EQU		70h		; Reverse video (black on white)
  2063                              <2> MONO_REVERSE_DARK			EQU		78h		; (dark green on green)
  2064                              <2> MONO_BLINK					EQU		87h		; Blinking white on black*
  2065                              <2> MONO_BRIGHT_BLINK			EQU		8Fh		; Blinking high intensity*
  2066                              <2> MONO_REVERSE_BLINK			EQU		0F0h	; Blinking reverse video
  2067                              <2> MONO_REVERSE_DARK_BLINK		EQU		0F8h	; (blinking dark green on green)
  2068                              <2> 
  2069                              <2> 
  2070                              <2> ; Cursor position macro for DX register
  2071                              <2> %define CURSOR_XY(x, y)	( (x) | ((y)<<8) )
  2072                              <2> 
  2073                              <2> ; Cursor shapes
  2074                              <2> CURSOR_NORMAL_COLOR			EQU		0607h		; Two line cursor near or at the bottom of cell (not valid for IBM MDA)
  2075                              <2> CURSOR_NORMAL_MDA			EQU		0B0Ch		; Scanlines 11 and 12
  2076                              <2> CURSOR_HIDDEN				EQU		2000h
  2077                              <2> 
  2078                              <2> 
  2079                              <2> ; Display modes
  2080                              <2> CGA_TEXT_MODE_BW40			EQU		0		; Applications should use...
  2081                              <2> CGA_TEXT_MODE_CO40			EQU		1
  2082                              <2> CGA_TEXT_MODE_BW80			EQU		2		; ..black, white and bright white attributes only
  2083                              <2> CGA_TEXT_MODE_CO80			EQU		3
  2084                              <2> MDA_TEXT_MODE				EQU		7		; Real monochrome attributes available
  2085                              <2> 
  2086                              <2> 
  2087                              <2> ; Display segments
  2088                              <2> COLOR_TEXT_SEGMENT			EQU		0B800h	; Text modes 0...3 (CGA+)
  2089                              <2> MONO_TEXT_SEGMENT			EQU		0B000h	; Text mode 7 (MDA, Hercules)
  2090                              <2> 
  2091                              <2> OFFSET_TO_CGA_STATUS_REGISTER	EQU		6	; Base port 3D4h + 6 = 3DAh
  2092                              <2> CGA_STATUS_REGISTER				EQU		3DAh
  2093                              <2> 
  2094                              <2> %endif ; MODULE_STRINGS_COMPRESS_PRECOMPRESS
  2095                              <2> 
  2096                              <2> ; Control characters for teletype output
  2097                              <2> NULL						EQU		00h
  2098                              <2> SOH							EQU		01h		; Start of heading
  2099                              <2> STX							EQU		02h		; Start of text
  2100                              <2> BELL						EQU		07h		; Bell
  2101                              <2> BS							EQU		08h		; Backspace
  2102                              <2> TAB							EQU		09h		; Horizontal TAB
  2103                              <2> LF							EQU		0Ah		; Line feed (newline)
  2104                              <2> CR							EQU		0Dh		; Carriage return
  2105                              <2> ESC							EQU		1Bh		; Escape
  2106                              <2> 
  2107                              <2> ; Non ASCII characters (code page 437)
  2108                              <2> BETA										EQU		225
  2109                              <2> QUOTATION_MARK								EQU		34
  2110                              <2> DOUBLE_TOP_RIGHT_CORNER						EQU		187
  2111                              <2> DOUBLE_TOP_LEFT_CORNER						EQU		201
  2112                              <2> DOUBLE_BOTTOM_RIGHT_CORNER					EQU		188
  2113                              <2> DOUBLE_BOTTOM_LEFT_CORNER					EQU		200
  2114                              <2> DOUBLE_VERTICAL								EQU		186
  2115                              <2> DOUBLE_HORIZONTAL							EQU		205
  2116                              <2> DOUBLE_VERTICAL_TO_RIGHT_SINGLE				EQU		199
  2117                              <2> DOUBLE_VERTICAL_TO_LEFT_SINGLE				EQU		182
  2118                              <2> DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL	EQU		181
  2119                              <2> DOUBLE_RIGHT_HORIZONTAL_TO_SINGLE_VERTICAL	EQU		198
  2120                              <2> SINGLE_VERTICAL								EQU		179
  2121                              <2> SINGLE_HORIZONTAL							EQU		196
  2122                              <2> SINGLE_LEFT_HORIZONTAL_TO_VERTICAL			EQU		180
  2123                              <2> SINGLE_RIGHT_HORIZONTAL_TO_VERTICAL			EQU		195
  2124                              <2> ANGLE_QUOTE_LEFT							EQU		174
  2125                              <2> ANGLE_QUOTE_RIGHT							EQU		175
  2126                              <2> BLOCK_MOSTLY_BACKGROUND						EQU		176
  2127                              <2> BLOCK_EVEN_BACKGROUND_AND_FOREGROUND		EQU		177
  2128                              <2> BLOCK_MOSTLY_FOREGROUND						EQU		178
  2129                              <2> BLOCK_FULL_FOREGROUND						EQU		219
  2130                              <2> ONE_HALF									EQU		171
  2131                              <2> ONE_QUARTER									EQU		172
  2132                              <2> 
  2133                              <2> 
  2134                              <2> ; Background character for clearing screen
  2135                              <2> %ifndef SCREEN_BACKGROUND_CHARACTER
  2136                              <2> 	%define	SCREEN_BACKGROUND_CHARACTER		BLOCK_MOSTLY_BACKGROUND
  2137                              <2> %endif
  2138                              <2> %ifndef SCREEN_BACKGROUND_ATTRIBUTE
  2139                              <2> 	%define	SCREEN_BACKGROUND_ATTRIBUTE		MONO_NORMAL
  2140                              <2> %endif
  2141                              <2> %define SCREEN_BACKGROUND_CHARACTER_AND_ATTRIBUTE	(SCREEN_BACKGROUND_CHARACTER | (SCREEN_BACKGROUND_ATTRIBUTE<<8))
  2142                              <2> %define DOS_BACKGROUND_CHARACTER_AND_ATTRIBUTE		(' ' | (MONO_NORMAL<<8))
  2143                              <2> 
  2144                              <2> %endif ; DISPLAY_INC
  2145                              <1> 	%define INCLUDE_STRING_LIBRARY
  2146                              <1> %endif
  2147                              <1> 
  2148                              <1> %ifdef INCLUDE_STRING_LIBRARY
  2149                              <1> 	%define INCLUDE_UTIL_LIBRARY
  2150                              <1> %endif
  2151                              <1> 
  2152                              <1> %ifdef INCLUDE_FILE_LIBRARY
  2153                              <1> 	%define INCLUDE_UTIL_LIBRARY
  2154                              <1> %endif
  2155                              <1> 
  2156                              <1> 
  2157                              <1> %endif ; ASSEMBLY_LIBRARY_INC
  2158                                  	%include "ModuleDependency.inc"	; Dependency checks for optional modules. Must be included second!
  2159                              <1> ; Project name	:	XTIDE Universal BIOS
  2160                              <1> ; Description	:	Dependencies for optional modules.
  2161                              <1> 
  2162                              <1> ;
  2163                              <1> ; XTIDE Universal BIOS and Associated Tools
  2164                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2165                              <1> ;
  2166                              <1> ; This program is free software; you can redistribute it and/or modify
  2167                              <1> ; it under the terms of the GNU General Public License as published by
  2168                              <1> ; the Free Software Foundation; either version 2 of the License, or
  2169                              <1> ; (at your option) any later version.
  2170                              <1> ;
  2171                              <1> ; This program is distributed in the hope that it will be useful,
  2172                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2173                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2174                              <1> ; GNU General Public License for more details.
  2175                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2176                              <1> ;
  2177                              <1> 
  2178                              <1> ; Allow RELOCATE_INT13H_STACK only for AT builds
  2179                              <1> %ifndef USE_AT
  2180                              <1> 	%ifdef RELOCATE_INT13H_STACK
  2181                              <1> 		%undef RELOCATE_INT13H_STACK
  2182                              <1> 		%warning "RELOCATE_INT13H_STACK is not supported for XT builds!"
  2183                              <1> 	%endif
  2184                              <1> %endif
  2185                              <1> 
  2186                              <1> 
  2187                              <1> %ifdef MODULE_SERIAL_FLOPPY
  2188                              <1> 	%ifndef MODULE_SERIAL
  2189                              <1> 		%define MODULE_SERIAL
  2190                              <1> 	%endif
  2191                              <1> %endif
  2192                              <1> 
  2193                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
  2194                              <1> 	%define MODULE_8BIT_IDE
  2195                              <1> 	%include "DmaController.inc"
  2196                              <1> 	%include "XTCF.inc"				; For Lo-tech XT-CF
  2197                              <1> 	%include "JRIDE_ISA.inc"		; For JR-IDE/ISA
  2198                              <1> %endif
  2199                              <1> 
  2200                              <1> ; Include module specific .INC files
  2201                              <1> %ifdef MODULE_8BIT_IDE
  2202                              <1> 	%include "IDE_8bit.inc"			; For IDE 8-bit data port macros
  2203                              <2> ; Project name	:	XTIDE Universal BIOS
  2204                              <2> ; Description	:	Macros for accessing data port(s) on 8-bit
  2205                              <2> ;					IDE controllers.
  2206                              <2> 
  2207                              <2> ;
  2208                              <2> ; XTIDE Universal BIOS and Associated Tools
  2209                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2210                              <2> ;
  2211                              <2> ; This program is free software; you can redistribute it and/or modify
  2212                              <2> ; it under the terms of the GNU General Public License as published by
  2213                              <2> ; the Free Software Foundation; either version 2 of the License, or
  2214                              <2> ; (at your option) any later version.
  2215                              <2> ;
  2216                              <2> ; This program is distributed in the hope that it will be useful,
  2217                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2218                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2219                              <2> ; GNU General Public License for more details.
  2220                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2221                              <2> ;
  2222                              <2> 
  2223                              <2> %ifndef IDE_8BIT_INC
  2224                              <2> %define IDE_8BIT_INC
  2225                              <2> 
  2226                              <2> ;--------------------------------------------------------------------
  2227                              <2> ; UNROLL_SECTORS_IN_CX_TO_DWORDS
  2228                              <2> ; UNROLL_SECTORS_IN_CX_TO_QWORDS
  2229                              <2> ; UNROLL_SECTORS_IN_CX_TO_OWORDS
  2230                              <2> ;	Parameters:
  2231                              <2> ;		CX:		Number of sectors in block
  2232                              <2> ;	Returns:
  2233                              <2> ;		CX:		Number of DWORDs, QWORDs or OWORDs in block
  2234                              <2> ;	Corrupts registers:
  2235                              <2> ;		Nothing
  2236                              <2> ;--------------------------------------------------------------------
  2237                              <2> %macro UNROLL_SECTORS_IN_CX_TO_DWORDS 0
  2238                              <2> %ifdef USE_186
  2239                              <2> 	shl		cx, 7
  2240                              <2> %else
  2241                              <2> 	xchg	cl, ch		; Sectors to WORDs (SHL CX, 8)
  2242                              <2> 	shr		cx, 1
  2243                              <2> %endif
  2244                              <2> %endmacro
  2245                              <2> 
  2246                              <2> %macro UNROLL_SECTORS_IN_CX_TO_QWORDS 0
  2247                              <2> %ifdef USE_186
  2248                              <2> 	shl		cx, 6
  2249                              <2> %else
  2250                              <2> 	UNROLL_SECTORS_IN_CX_TO_DWORDS
  2251                              <2> 	shr		cx, 1
  2252                              <2> %endif
  2253                              <2> %endmacro
  2254                              <2> 
  2255                              <2> %macro UNROLL_SECTORS_IN_CX_TO_OWORDS 0
  2256                              <2> %ifdef USE_186
  2257                              <2> 	shl		cx, 5
  2258                              <2> %else
  2259                              <2> ;	UNROLL_SECTORS_IN_CX_TO_QWORDS
  2260                              <2> ;	shr		cx, 1
  2261                              <2> 	mov		ch, cl		; 2 bytes shorter but possibly slower
  2262                              <2> 	mov		cl, 3
  2263                              <2> 	shr		cx, cl
  2264                              <2> %endif
  2265                              <2> %endmacro
  2266                              <2> 
  2267                              <2> 
  2268                              <2> ;--------------------------------------------------------------------
  2269                              <2> ; Emulates INSW for XTIDE.
  2270                              <2> ;
  2271                              <2> ; XTIDE_INSW
  2272                              <2> ;	Parameters:
  2273                              <2> ;		BL:		Bit mask for toggling XTIDE data low/high reg
  2274                              <2> ;		DX:		XTIDE Data Low Register address
  2275                              <2> ;		ES:DI:	Ptr to destination buffer
  2276                              <2> ;	Returns:
  2277                              <2> ;		ES:DI:	Incremented/decremented for next word
  2278                              <2> ;	Corrupts registers:
  2279                              <2> ;		AL, FLAGS
  2280                              <2> ;--------------------------------------------------------------------
  2281                              <2> %macro XTIDE_INSW 0
  2282                              <2> %ifdef USE_186	; INS instruction available
  2283                              <2> 	insb						; Load low byte from port DX to [ES:DI]
  2284                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
  2285                              <2> 	insb						; Load high byte from port DX to [ES:DI]
  2286                              <2> 	xor		dl, bl				; Restore to IDE Data Register
  2287                              <2> %else	; If 8088/8086
  2288                              <2> 	in		al, dx				; Load low byte from port
  2289                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
  2290                              <2> 	stosb						; Store byte to [ES:DI]
  2291                              <2> 	in		al, dx				; Load high byte from port
  2292                              <2> 	xor		dl, bl				; Restore to IDE Data Register
  2293                              <2> 	stosb						; Store byte to [ES:DI]
  2294                              <2> %endif
  2295                              <2> %endmacro
  2296                              <2> 
  2297                              <2> 
  2298                              <2> ;--------------------------------------------------------------------
  2299                              <2> ; Emulates OUTSW for XTIDE.
  2300                              <2> ;
  2301                              <2> ; XTIDE_OUTSW
  2302                              <2> ;	Parameters:
  2303                              <2> ;		BL:		Bit mask for toggling XTIDE data low/high reg
  2304                              <2> ;		DX:		XTIDE Data Low Register address
  2305                              <2> ;		DS:SI:	Ptr to source buffer
  2306                              <2> ;	Returns:
  2307                              <2> ;		SI:		Incremented/decremented for next word
  2308                              <2> ;	Corrupts registers:
  2309                              <2> ;		AX, FLAGS
  2310                              <2> ;--------------------------------------------------------------------
  2311                              <2> %macro XTIDE_OUTSW 0
  2312                              <2> %ifdef USE_186	; OUTS instruction available
  2313                              <2> 	lodsb						; Load low byte from [DS:SI] to AL
  2314                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
  2315                              <2> 	outsb						; Output high byte from [DS:SI]
  2316                              <2> 	xor		dl, bl				; XTIDE Data High Reg to Data Low Reg
  2317                              <2> 	out		dx, al				; Output low byte from AL
  2318                              <2> %else	; If 8088/8086
  2319                              <2> 	lodsw						; Load word from [DS:SI]
  2320                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
  2321                              <2> 	xchg	al, ah				; => AL=high byte, AH=low byte
  2322                              <2> 	out		dx, al				; Output high byte
  2323                              <2> 	xor		dl, bl				; XTIDE Data High Reg to Data Low Reg
  2324                              <2> 	mov		al, ah				; Copy low byte to AL
  2325                              <2> 	out		dx, al				; Output low byte
  2326                              <2> %endif
  2327                              <2> %endmacro
  2328                              <2> 
  2329                              <2> 
  2330                              <2> ;--------------------------------------------------------------------
  2331                              <2> ; Emulates OUTSW for modified XTIDE.
  2332                              <2> ;
  2333                              <2> ; XTIDE_MOD_OUTSW
  2334                              <2> ;	Parameters:
  2335                              <2> ;		DX:		XTIDE Data Low Register address
  2336                              <2> ;		DS:SI:	Ptr to source buffer
  2337                              <2> ;	Returns:
  2338                              <2> ;		SI:		Incremented/decremented for next word
  2339                              <2> ;	Corrupts registers:
  2340                              <2> ;		AX, FLAGS
  2341                              <2> ;--------------------------------------------------------------------
  2342                              <2> %macro XTIDE_MOD_OUTSW 0
  2343                              <2> %ifdef USE_186	; OUTS instruction available
  2344                              <2> 	lodsb						; Load low byte from [DS:SI] to AL
  2345                              <2> 	inc		dx					; IDE Data Reg to XTIDE MOD Data High Reg
  2346                              <2> 	outsb						; Output high byte from [DS:SI]
  2347                              <2> 	dec		dx					; XTIDE Data High Reg to Data Low Reg
  2348                              <2> 	out		dx, al				; Output low byte from AL
  2349                              <2> %else	; If 8088/8086
  2350                              <2> 	lodsw						; Load word from [DS:SI]
  2351                              <2> 	inc		dx					; IDE Data Reg to XTIDE MOD Data High Reg
  2352                              <2> 	xchg	al, ah				; => AL=high byte, AH=low byte
  2353                              <2> 	out		dx, al				; Output high byte
  2354                              <2> 	dec		dx					; XTIDE Data High Reg to Data Low Reg
  2355                              <2> 	mov		al, ah				; Copy low byte to AL
  2356                              <2> 	out		dx, al				; Output low byte
  2357                              <2> %endif
  2358                              <2> %endmacro
  2359                              <2> 
  2360                              <2> 
  2361                              <2> %endif ; IDE_8BIT_INC
  2362                              <1> %endif
  2363                              <1> 
  2364                              <1> %ifdef MODULE_ADVANCED_ATA
  2365                              <1> 	%include "Vision.inc"			; For QDI Vision QD65xx VLB IDE Controllers
  2366                              <1> %endif
  2367                              <1> 
  2368                              <1> %ifdef MODULE_EBIOS
  2369                              <1> 	%include "EBIOS.inc"			; Equates for EBIOS functions
  2370                              <1> %endif
  2371                              <1> 
  2372                              <1> %ifdef MODULE_HOTKEYS
  2373                              <1> 	%include "HotkeyBar.inc"		; For Hotkeys
  2374                              <1> %endif
  2375                              <1> 
  2376                              <1> %ifdef MODULE_BOOT_MENU
  2377                              <1> 	%include "BootMenu.inc"			; For Boot Menu
  2378                              <1> %endif
  2379                              <1> 
  2380                              <1> %ifdef MODULE_BOOT_MENU OR MODULE_HOTKEYS
  2381                              <1> 	%define MODULE_DRIVEXLATE
  2382                              <1> %endif
  2383                              <1> 
  2384                              <1> %ifdef MODULE_IRQ
  2385                              <1> 	%include "IntController.inc"
  2386                              <1> %endif
  2387                              <1> 
  2388                              <1> 
  2389                              <1> ; Included modules for ROMVARS.wFlags
  2390                              <1> %ifdef MODULE_8BIT_IDE
  2391                              <1> 	MAIN_FLG_MODULE_8BIT_IDE	EQU	FLG_ROMVARS_MODULE_8BIT_IDE
  2392                              <1> %else
  2393                              <1> 	MAIN_FLG_MODULE_8BIT_IDE	EQU	0
  2394                              <1> %endif
  2395                              <1> 
  2396                              <1> %ifdef MODULE_ADVANCED_ATA
  2397                              <1> 	MAIN_FLG_MODULE_ADVANCED_ATA	EQU	FLG_ROMVARS_MODULE_ADVANCED_ATA
  2398                              <1> %else
  2399                              <1> 	MAIN_FLG_MODULE_ADVANCED_ATA	EQU	0
  2400                              <1> %endif
  2401                              <1> 
  2402                              <1> %ifdef MODULE_BOOT_MENU
  2403                              <1> 	MAIN_FLG_MODULE_BOOT_MENU	EQU	FLG_ROMVARS_MODULE_BOOT_MENU
  2404                              <1> %else
  2405                              <1> 	MAIN_FLG_MODULE_BOOT_MENU	EQU	0
  2406                              <1> %endif
  2407                              <1> 
  2408                              <1> %ifdef MODULE_EBIOS
  2409                              <1> 	MAIN_FLG_MODULE_EBIOS	EQU	FLG_ROMVARS_MODULE_EBIOS
  2410                              <1> %else
  2411                              <1> 	MAIN_FLG_MODULE_EBIOS	EQU	0
  2412                              <1> %endif
  2413                              <1> 
  2414                              <1> %ifdef MODULE_HOTKEYS
  2415                              <1> 	MAIN_FLG_MODULE_HOTKEYS	EQU	FLG_ROMVARS_MODULE_HOTKEYS
  2416                              <1> %else
  2417                              <1> 	MAIN_FLG_MODULE_HOTKEYS	EQU	0
  2418                              <1> %endif
  2419                              <1> 
  2420                              <1> %ifdef MODULE_IRQ
  2421                              <1> 	MAIN_FLG_MODULE_IRQ		EQU	FLG_ROMVARS_MODULE_IRQ
  2422                              <1> %else
  2423                              <1> 	MAIN_FLG_MODULE_IRQ		EQU	0
  2424                              <1> %endif
  2425                              <1> 
  2426                              <1> %ifdef MODULE_SERIAL
  2427                              <1> 	MAIN_FLG_MODULE_SERIAL	EQU	FLG_ROMVARS_MODULE_SERIAL
  2428                              <1> %else
  2429                              <1> 	MAIN_FLG_MODULE_SERIAL	EQU	0
  2430                              <1> %endif
  2431                              <1> 
  2432                              <1> %ifdef MODULE_SERIAL_FLOPPY
  2433                              <1> 	MAIN_FLG_MODULE_SERIAL_FLOPPY	EQU	FLG_ROMVARS_MODULE_SERIAL_FLOPPY
  2434                              <1> %else
  2435                              <1> 	MAIN_FLG_MODULE_SERIAL_FLOPPY	EQU	0
  2436                              <1> %endif
  2437                              <1> 
  2438                              <1> %ifdef MODULE_STRINGS_COMPRESSED
  2439                              <1> 	MAIN_FLG_MODULE_STRINGS_COMPRESSED	EQU	FLG_ROMVARS_MODULE_STRINGS_COMPRESSED
  2440                              <1> %else
  2441                              <1> 	MAIN_FLG_MODULE_STRINGS_COMPRESSED	EQU	0
  2442                              <1> %endif
  2443                              <1> 
  2444                              <1> %ifdef MODULE_FEATURE_SETS
  2445                              <1> 	MAIN_FLG_MODULE_FEATURE_SETS	EQU	FLG_ROMVARS_MODULE_FEATURE_SETS
  2446                              <1> %else
  2447                              <1> 	MAIN_FLG_MODULE_FEATURE_SETS	EQU	0
  2448                              <1> %endif
  2449                              <1> 
  2450                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
  2451                              <1> 	MAIN_FLG_MODULE_8BIT_IDE_ADVANCED	EQU	FLG_ROMVARS_MODULE_8BIT_IDE_ADVANCED
  2452                              <1> %else
  2453                              <1> 	MAIN_FLG_MODULE_8BIT_IDE_ADVANCED	EQU	0
  2454                              <1> %endif
  2455                              <1> 
  2456                              <1> MASK_ROMVARS_INCLUDED_MODULES	EQU	MAIN_FLG_MODULE_8BIT_IDE | MAIN_FLG_MODULE_ADVANCED_ATA | MAIN_FLG_MODULE_BOOT_MENU | MAIN_FLG_MODULE_EBIOS | MAIN_FLG_MODULE_HOTKEYS | MAIN_FLG_MODULE_IRQ | MAIN_FLG_MODULE_SERIAL 
  2457                              <1> 
  2458                                  	%include "Version.inc"
  2459                              <1> ; /*
  2460                              <1> ; Project name	:	XTIDE Universal BIOS
  2461                              <1> ; Description	:	Version information.
  2462                              <1> 
  2463                              <1> ;
  2464                              <1> ; XTIDE Universal BIOS and Associated Tools
  2465                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2466                              <1> ;
  2467                              <1> ; This program is free software; you can redistribute it and/or modify
  2468                              <1> ; it under the terms of the GNU General Public License as published by
  2469                              <1> ; the Free Software Foundation; either version 2 of the License, or
  2470                              <1> ; (at your option) any later version.
  2471                              <1> ;
  2472                              <1> ; This program is distributed in the hope that it will be useful,
  2473                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2474                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2475                              <1> ; GNU General Public License for more details.
  2476                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2477                              <1> ;
  2478                              <1> 
  2479                              <1> ;--------------------------------------------------------------------------------
  2480                              <1> ;
  2481                              <1> ; Assembler Version
  2482                              <1> ;
  2483                              <1> 
  2484                              <1> %ifndef VERSION_INC
  2485                              <1> %define VERSION_INC
  2486                              <1> 
  2487                              <1> 
  2488                              <1> %define TITLE_STRING_START	"-=XTIDE Universal BIOS "
  2489                              <1> %ifdef USE_AT
  2490                              <1> 	%ifdef USE_386
  2491                              <1> 		%define	TITLE_STRING_END	"(386)=-",NULL
  2492                              <1> 	%else
  2493                              <1> 		%define	TITLE_STRING_END	"(AT)=-",NULL
  2494                              <1> 	%endif
  2495                              <1> %elifdef USE_186
  2496                              <1> 	%define	TITLE_STRING_END	"(XT+)=-",NULL
  2497                              <1> %else
  2498                              <1> 	%define	TITLE_STRING_END	"(XT)=-",NULL
  2499                              <1> %endif
  2500                              <1> 
  2501                              <1> %define	TITLE_STRING			TITLE_STRING_START, TITLE_STRING_END
  2502                              <1> %define	ROM_VERSION_STRING		"v2.0.0",BETA,"3+ (",__DATE__,")",NULL
  2503                              <1> %define	FLASH_SIGNATURE			"XTIDE203"	; Do not terminate with NULL
  2504                              <1> 
  2505                              <1> 
  2506                              <1> %endif ; VERSION_INC
  2507                              <1> 
  2508                              <1> %if 0			; equivalent of a NASM comment block
  2509                              <1> ;*/
  2510                              <1> 
  2511                              <1> //--------------------------------------------------------------------------------
  2512                              <1> //
  2513                              <1> // C/C++ Version
  2514                              <1> //
  2515                              <1> 
  2516                              <1> #define BETA " Beta "
  2517                              <1> 
  2518                              <1> #define ROM_VERSION_STRING		"v2.0.0" BETA "3 (" __DATE__ ")"
  2519                              <1> 
  2520                              <1> /*
  2521                              <1> %endif
  2522                              <1> ;*/
  2523                                  	%include "ATA_ID.inc"			; For ATA Drive Information structs
  2524                              <1> ; Project name	:	XTIDE Universal BIOS
  2525                              <1> ; Description	:	ATA Identify Drive information.
  2526                              <1> 
  2527                              <1> ;
  2528                              <1> ; XTIDE Universal BIOS and Associated Tools
  2529                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2530                              <1> ;
  2531                              <1> ; This program is free software; you can redistribute it and/or modify
  2532                              <1> ; it under the terms of the GNU General Public License as published by
  2533                              <1> ; the Free Software Foundation; either version 2 of the License, or
  2534                              <1> ; (at your option) any later version.
  2535                              <1> ;
  2536                              <1> ; This program is distributed in the hope that it will be useful,
  2537                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2538                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2539                              <1> ; GNU General Public License for more details.
  2540                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2541                              <1> ;
  2542                              <1> 
  2543                              <1> %ifndef ATA_ID_INC
  2544                              <1> %define ATA_ID_INC
  2545                              <1> 
  2546                              <1> ; Maximum valid P-CHS parameters
  2547                              <1> MAX_VALID_PCHS_CYLINDERS			EQU		16383
  2548                              <1> MAX_VALID_PCHS_HEADS				EQU		16
  2549                              <1> MAX_VALID_PCHS_SECTORS_PER_TRACK	EQU		63
  2550                              <1> 
  2551                              <1> 
  2552                              <1> ; PIO Minimum Cycle Times (t0)
  2553                              <1> ; Timings for Advanced Modes (3 and above) can be read from ATA info WORDs 67 and 68
  2554                              <1> ; Those usually have the same Cycle Time as below
  2555                              <1> PIO_0_MIN_CYCLE_TIME_NS		EQU		600
  2556                              <1> PIO_1_MIN_CYCLE_TIME_NS		EQU		383
  2557                              <1> PIO_2_MIN_CYCLE_TIME_NS		EQU		240
  2558                              <1> PIO_3_MIN_CYCLE_TIME_NS		EQU		180
  2559                              <1> PIO_4_MIN_CYCLE_TIME_NS		EQU		120
  2560                              <1> PIO_5_MIN_CYCLE_TIME_NS		EQU		100		; CF specification
  2561                              <1> PIO_6_MIN_CYCLE_TIME_NS		EQU		80		; CF specification
  2562                              <1> 
  2563                              <1> ; PIO Minimum Address Valid Times (t1)
  2564                              <1> PIO_0_MIN_ADDRESS_VALID_NS	EQU		70
  2565                              <1> PIO_1_MIN_ADDRESS_VALID_NS	EQU		50
  2566                              <1> PIO_2_MIN_ADDRESS_VALID_NS	EQU		30
  2567                              <1> PIO_3_MIN_ADDRESS_VALID_NS	EQU		30
  2568                              <1> PIO_4_MIN_ADDRESS_VALID_NS	EQU		25
  2569                              <1> PIO_5_MIN_ADDRESS_VALID_NS	EQU		15
  2570                              <1> PIO_6_MIN_ADDRESS_VALID_NS	EQU		10
  2571                              <1> 
  2572                              <1> ; PIO Minimum Active Times (t2)
  2573                              <1> PIO_0_MIN_ACTIVE_TIME_NS	EQU		165
  2574                              <1> PIO_1_MIN_ACTIVE_TIME_NS	EQU		125
  2575                              <1> PIO_2_MIN_ACTIVE_TIME_NS	EQU		100
  2576                              <1> PIO_3_MIN_ACTIVE_TIME_NS	EQU		80
  2577                              <1> PIO_4_MIN_ACTIVE_TIME_NS	EQU		70
  2578                              <1> PIO_5_MIN_ACTIVE_TIME_NS	EQU		65
  2579                              <1> PIO_6_MIN_ACTIVE_TIME_NS	EQU		55
  2580                              <1> 
  2581                              <1> ; PIO Minimum Recovery Times or Inactive Times (t2i) can be calculated
  2582                              <1> ; from Minimum Cycle Time (t0) - Minimum Active Time (t2) - Address Valid Time (t1).
  2583                              <1> ; I'm not sure about this calculation so correct me if I'm wrong!
  2584                              <1> ; Recovery time should be calculated at run time since Cycle Time t0 can be
  2585                              <1> ; read from ATA information (ATA2+) but most drives just report the
  2586                              <1> ; Min Cycle Times listed above.
  2587                              <1> 
  2588                              <1> 
  2589                              <1> 
  2590                              <1> ; ATA-1 Drive Information struct
  2591                              <1> ; F = Fixed value
  2592                              <1> ; V = Variable value
  2593                              <1> ; R = Reserved word
  2594                              <1> ; X = Vendor specific word
  2595                              <1> struc ATA1
  2596 00000000 <res 00000002>      <1> 	.wGenCfg	resw 1	; 0F, General configuration bit-significant information
  2597 00000002 <res 00000002>      <1> 	.wCylCnt	resw 1	; 1F, Number of cylinders
  2598 00000004 <res 00000002>      <1> 				resw 1	; 2R
  2599 00000006 <res 00000002>      <1> 	.wHeadCnt	resw 1	; 3F, Number of heads
  2600 00000008 <res 00000002>      <1> 	.wBpTrck	resw 1	; 4F, Number of unformatted bytes per track
  2601 0000000A <res 00000002>      <1> 	.wBpSect	resw 1	; 5F, Number of unformatted bytes per sector
  2602 0000000C <res 00000002>      <1> 	.wSPT		resw 1	; 6F, Number of sectors per track
  2603 0000000E <res 00000006>      <1> 				resw 3	; 7...9X
  2604 00000014 <res 00000014>      <1> 	.strSerial	resb 20	; 10...19F, Serial number (20 ASCII characters, 0000h=not specified)
  2605 00000028 <res 00000002>      <1> 	.wBuffType	resw 1	; 20F, Buffer type
  2606 0000002A <res 00000002>      <1> 	.wBuffSize	resw 1	; 21F, Buffer size in 512 byte increments (0000h=not specified)
  2607 0000002C <res 00000002>      <1> 	.wEccCnt	resw 1	; 22F, # of ECC bytes avail on read/write long cmds (0000h=not spec'd)
  2608 0000002E <res 00000008>      <1> 	.strFirmW	resb 8	; 23...26F, Firmware revision (8 ASCII characters, 0000h=not specified)
  2609 00000036 <res 00000028>      <1> 	.strModel	resb 40	; 27...46F, Model number (40 ASCII characters, 0000h=not specified)
  2610 0000005E <res 00000001>      <1> 	.bBlckSize	resb 1	; 47[0-7]F, Maximum number of sectors that can be transferred
  2611                              <1> 						;          per interrupt on read and write multiple commands
  2612                              <1> 						;		   (00h=Read/write multiple commands not implemented)
  2613 0000005F <res 00000001>      <1> 				resb 1	; 47[8-15]X
  2614 00000060 <res 00000002>      <1> 	.wDWIO		resw 1	; 48F, Can perform doubleword I/O (boolean)
  2615 00000062 <res 00000002>      <1> 	.wCaps		resw 1	; 49FRX, Capabilities
  2616 00000064 <res 00000002>      <1> 				resw 1	; 50R
  2617 00000066 <res 00000001>      <1> 				resb 1	; 51[0-7]X
  2618 00000067 <res 00000001>      <1> 	.bPioMode	resb 1	; 51[8-15]F, PIO data transfer cycle timing mode (0, 1 or 2)
  2619 00000068 <res 00000001>      <1> 				resb 1	; 52[0-7]X
  2620 00000069 <res 00000001>      <1> 	.bDMATiming	resb 1	; 52[8-15]F, DMA data transfer cycle timing mode
  2621 0000006A <res 00000002>      <1> 	.wFields	resw 1	; 53FVR, Field (next words) validity bits
  2622                              <1> 
  2623                              <1> 	; Words 54-58 are valid only if bit0 is set in .wFields
  2624 0000006C <res 00000002>      <1> 	.wCurCyls	resw 1	; 54V, Number of current cylinders
  2625 0000006E <res 00000002>      <1> 	.wCurHeads	resw 1	; 55V, Number of current heads
  2626 00000070 <res 00000002>      <1> 	.wCurSPT	resw 1	; 56V, Number of current sectors per track
  2627 00000072 <res 00000004>      <1> 	.dwCurSCnt	resd 1	; 57...58V, Current capacity in sectors
  2628                              <1> 
  2629                              <1> 	; Words 59-63 are always valid
  2630 00000076 <res 00000001>      <1> 	.bBlockSel	resb 1	; 59[0-7]V, Current setting for number of sectors that
  2631                              <1> 						;           can be transferred per interrupt on R/W multiple command
  2632 00000077 <res 00000001>      <1> 	.bBlockFlgs	resb 1	; 59[8-15]VR, bit 0 set if Multiple sector setting is valid
  2633 00000078 <res 00000004>      <1> 	.dwLBACnt	resd 1	; 60...61F, Total number of user addressable sectors (LBA mode only)
  2634 0000007C <res 00000001>      <1> 	.bSDMASupp	resb 1	; 62[0-7]F, Single word DMA transfer modes supported
  2635 0000007D <res 00000001>      <1> 	.bSDMAAct	resb 1	; 62[8-15]V, Single word DMA transfer mode active
  2636 0000007E <res 00000001>      <1> 	.bMDMASupp	resb 1	; 63[0-7]F, Multiword DMA transfer modes supported
  2637 0000007F <res 00000001>      <1> 	.bMDMAAct	resb 1	; 63[8-15]V, Multiword DMA transfer mode active
  2638                              <1> endstruc
  2639                              <1> 
  2640                              <1> A1_MODEL_NUMBER_LENGTH	EQU	40		; 40 ASCII characters
  2641                              <1> 
  2642                              <1> ; ATA-1 Word 0, General configuration
  2643                              <1> A1_wGenCfg_NONMAG		EQU	(1<<15)	; Reserved for non-magnetic drives
  2644                              <1> A1_wGenCfg_FGAPREQ		EQU	(1<<14)	; Format speed tolerance gap required
  2645                              <1> A1_wGenCfg_TRCKOFF		EQU	(1<<13)	; Track offset option available
  2646                              <1> A1_wGenCfg_DATAOFF		EQU	(1<<12)	; Data strobe offset option available
  2647                              <1> A1_wGenCfg_ROTTOL		EQU	(1<<11)	; Rotational speed tolerance is > 0,5%
  2648                              <1> A1_wGenCfg_XFERFAST		EQU (1<<10)	; Disk transfer rate > 10 Mbs
  2649                              <1> A1_wGenCfg_XFERMED		EQU	(1<<9)	; Disk transfer rate > 5Mbs but <= 10Mbs
  2650                              <1> A1_wGenCfg_XFERSLOW		EQU (1<<8)	; Disk transfer rate <= 5Mbs
  2651                              <1> A1_wGenCfg_REMOVABLE	EQU	(1<<7)	; Removable cartridge drive
  2652                              <1> A1_wGenCfg_FIXED		EQU	(1<<6)	; Fixed drive
  2653                              <1> A1_wGenCfg_MOTCTRL		EQU	(1<<5)	; Spindle motor control option implemented
  2654                              <1> A1_wGenCfg_HEADSLOW		EQU	(1<<4)	; Head switch time > 15 usec
  2655                              <1> A1_wGenCfg_NOTMFM		EQU	(1<<3)	; Not MFM encoded
  2656                              <1> A1_wGenCfg_SOFTSECT		EQU	(1<<2)	; Soft sectored
  2657                              <1> A1_wGenCfg_HARDSECT		EQU	(1<<1)	; Hard sectored
  2658                              <1> 
  2659                              <1> ; ATA-1 Word 49, Capabilities
  2660                              <1> A1_wCaps_LBA			EQU	(1<<9)	; LBA supported
  2661                              <1> A1_wCaps_DMA			EQU	(1<<8)	; DMA supported
  2662                              <1> 
  2663                              <1> ; ATA-1 Word 53, Fields
  2664                              <1> A1_wFields_54to58		EQU	(1<<0)	; The fields reported in words 54-58 are valid
  2665                              <1> 
  2666                              <1> ; ATA-1 Word 59 high byte, Block mode flags
  2667                              <1> A1_bBlockFlgs_VALID		EQU	(1<<0)	; Multiple sector setting (bBlockSel) is valid
  2668                              <1> 
  2669                              <1> 
  2670                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2671                              <1> 
  2672                              <1> ; ATA-2 Drive Information struct
  2673                              <1> ; F = Fixed value
  2674                              <1> ; V = Variable value
  2675                              <1> ; R = Reserved word
  2676                              <1> ; X = Vendor specific word
  2677                              <1> struc ATA2
  2678 00000000 <res 00000002>      <1> 	.wGenCfg	resw 1	; 0F, General configuration bit-significant information
  2679 00000002 <res 00000002>      <1> 	.wCylCnt	resw 1	; 1F, Number of logical cylinders
  2680 00000004 <res 00000002>      <1> 				resw 1	; 2R
  2681 00000006 <res 00000002>      <1> 	.wHeadCnt	resw 1	; 3F, Number of logical heads
  2682 00000008 <res 00000002>      <1> 				resw 1	; 4X
  2683 0000000A <res 00000002>      <1> 				resw 1	; 5X
  2684 0000000C <res 00000002>      <1> 	.wSPT		resw 1	; 6F, Number of logical sectors per track
  2685 0000000E <res 00000006>      <1> 				resw 3	; 7...9X
  2686 00000014 <res 00000014>      <1> 	.strSerial	resb 20	; 10...19F, Serial number (20 ASCII characters, 0000h=not specified)
  2687 00000028 <res 00000002>      <1> 				resw 1	; 20X
  2688 0000002A <res 00000002>      <1> 				resw 1	; 21X
  2689 0000002C <res 00000002>      <1> 	.wEccCnt	resw 1	; 22F, # of ECC bytes avail on read/write long cmds (0000h=not spec'd)
  2690 0000002E <res 00000008>      <1> 	.strFirmW	resb 8	; 23...26F, Firmware revision (8 ASCII characters, 0000h=not specified)
  2691 00000036 <res 00000028>      <1> 	.strModel	resb 40	; 27...46F, Model number (40 ASCII characters, 0000h=not specified)
  2692 0000005E <res 00000001>      <1> 	.bBlckSize	resb 1	; 47[0-7]F, Maximum number of sectors that can be transferred
  2693                              <1> 						;          per interrupt on read and write multiple commands
  2694                              <1> 						;		   (00h=Read/write multiple commands not implemented)
  2695 0000005F <res 00000001>      <1> 				resb 1	; 47[8-15]X
  2696 00000060 <res 00000002>      <1> 				resw 1	; 48R
  2697 00000062 <res 00000002>      <1> 	.wCaps		resw 1	; 49FRX, Capabilities
  2698 00000064 <res 00000002>      <1> 				resw 1	; 50R
  2699 00000066 <res 00000001>      <1> 				resb 1	; 51[0-7]X
  2700 00000067 <res 00000001>      <1> 	.bPIOTiming	resb 1	; 51[8-15]F, PIO data transfer cycle timing mode
  2701 00000068 <res 00000001>      <1> 				resb 1	; 52[0-7]X
  2702 00000069 <res 00000001>      <1> 	.bDMATiming	resb 1	; 52[8-15]F, DMA data transfer cycle timing mode
  2703 0000006A <res 00000002>      <1> 	.wFields	resw 1	; 53FVR, Field (next words) validity bits
  2704                              <1> 
  2705                              <1> 	; Words 54-58 are valid only if bit0 is set in .wFields
  2706 0000006C <res 00000002>      <1> 	.wCurCyls	resw 1	; 54V, Number of current logical cylinders
  2707 0000006E <res 00000002>      <1> 	.wCurHeads	resw 1	; 55V, Number of current logical heads
  2708 00000070 <res 00000002>      <1> 	.wCurSPT	resw 1	; 56V, Number of current logical sectors per track
  2709 00000072 <res 00000004>      <1> 	.dwCurSCnt	resd 1	; 57...58V, Current capacity in sectors
  2710                              <1> 
  2711                              <1> 	; Words 59-63 are always valid
  2712 00000076 <res 00000001>      <1> 	.bBlockSel	resb 1	; 59[0-7]V, Current setting for number of sectors that
  2713                              <1> 						;           can be transferred per interrupt on R/W multiple command
  2714 00000077 <res 00000001>      <1> 	.bBlockFlgs	resb 1	; 59[8-15]VR, bit 0 set if Multiple sector setting is valid
  2715 00000078 <res 00000004>      <1> 	.dwLBACnt	resd 1	; 60...61F, Total number of user addressable sectors (LBA mode only)
  2716 0000007C <res 00000001>      <1> 	.bSDMASupp	resb 1	; 62[0-7]F, Single word DMA transfer modes supported
  2717 0000007D <res 00000001>      <1> 	.bSDMAAct	resb 1	; 62[8-15]V, Single word DMA transfer mode active
  2718 0000007E <res 00000001>      <1> 	.bMDMASupp	resb 1	; 63[0-7]F, Multiword DMA transfer modes supported
  2719 0000007F <res 00000001>      <1> 	.bMDMAAct	resb 1	; 63[8-15]V, Multiword DMA transfer mode active
  2720                              <1> 
  2721                              <1> 	; Words 64-70 are valid only if bit1 is set in .wFields (ATA2+)
  2722 00000080 <res 00000001>      <1> 	.bPIOSupp	resb 1	; 64[0-7]F, Advanced PIO Transfer Modes Supported
  2723 00000081 <res 00000001>      <1> 				resb 1	; 64[8-15]R
  2724 00000082 <res 00000002>      <1> 	.wMDMAMinCy	resw 1	; 65F, Minimum Multiword DMA Transfer Cycle Time Per Word
  2725 00000084 <res 00000002>      <1> 	.wMDMARecCy	resw 1	; 66F, Manufacturers Recommended Multiword DMA Transfer Cycle Time
  2726 00000086 <res 00000002>      <1> 	.wPIOMinCy	resw 1	; 67F, Minimum PIO Transfer Cycle Time Without Flow Control
  2727 00000088 <res 00000002>      <1> 	.wPIOMinCyF	resw 1	; 68F, Minimum PIO Transfer Cycle Time With IORDY Flow Control
  2728                              <1> endstruc
  2729                              <1> 
  2730                              <1> ; ATA-2 Word 0, General configuration
  2731                              <1> A2_wGenCfg_NONMAG		EQU	(1<<15)	; Reserved for non-magnetic drives
  2732                              <1> A2_wGenCfg_REMOVABLE	EQU	(1<<7)	; Removable media device
  2733                              <1> A2_wGenCfg_FIXED		EQU	(1<<6)	; Not removable controller and/or device
  2734                              <1> 
  2735                              <1> ; ATA-1 Word 49, Capabilities
  2736                              <1> A2_wCaps_TIMER			EQU	(1<<13)	; Standby timer values as specified in this standard are supported
  2737                              <1> A2_wCaps_IORDY			EQU	(1<<11)	; IORDY supported
  2738                              <1> A2_wCaps_CANDISIORDY	EQU	(1<<10)	; IORDY can be disabled
  2739                              <1> A2_wCaps_LBA			EQU	(1<<9)	; LBA supported
  2740                              <1> A2_wCaps_DMA			EQU	(1<<8)	; DMA supported
  2741                              <1> 
  2742                              <1> ; ATA-2 Word 53, Fields
  2743                              <1> A2_wFields_54to58		EQU	(1<<0)	; The fields reported in words 54-58 are valid
  2744                              <1> A2_wFields_64to70		EQU	(1<<1)	; The fields reported in words 64-70 are valid
  2745                              <1> 
  2746                              <1> ; ATA-2 Word 59 high byte, Block mode flags
  2747                              <1> A2_bBlockFlgs_VALID		EQU	(1<<0)	; Multiple sector setting (bBlockSel) is valid
  2748                              <1> 
  2749                              <1> ; ATA-2 Word 64, Advanced PIO transfer modes supported
  2750                              <1> A2_bPIOSupp_PIO3		EQU	(1<<0)
  2751                              <1> A2_bPIOSupp_PIO4		EQU	(1<<1)
  2752                              <1> 
  2753                              <1> 
  2754                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2755                              <1> 
  2756                              <1> ; ATA-6 Drive Information struct
  2757                              <1> ; F = Fixed value
  2758                              <1> ; V = Variable value
  2759                              <1> ; R = Reserved word
  2760                              <1> ; X = Vendor specific word
  2761                              <1> struc ATA6
  2762 00000000 <res 00000002>      <1> 	.wGenCfg	resw 1	; 0F, General configuration bit-significant information
  2763 00000002 <res 00000002>      <1> 				resw 1	; 1X, Obsolete (Number of logical cylinders)
  2764 00000004 <res 00000002>      <1> 				resw 1	; 2V, Specific configuration
  2765 00000006 <res 00000002>      <1> 				resw 1	; 3X, Obsolete (Number of logical heads)
  2766 00000008 <res 00000002>      <1> 				resw 1	; 4X
  2767 0000000A <res 00000002>      <1> 				resw 1	; 5X
  2768 0000000C <res 00000002>      <1> 				resw 1	; 6X, Obsolete (Number of logical sectors per track)
  2769 0000000E <res 00000004>      <1> 				resw 2	; 7...8V, Reserved for assignment by the CompactFlash Association
  2770 00000012 <res 00000002>      <1> 				resw 1	; 9X
  2771 00000014 <res 00000014>      <1> 	.strSerial	resb 20	; 10...19F, Serial number (20 ASCII characters, 0000h=not specified)
  2772 00000028 <res 00000002>      <1> 				resw 1	; 20X
  2773 0000002A <res 00000002>      <1> 				resw 1	; 21X
  2774 0000002C <res 00000002>      <1> 				resw 1	; 22X, Obsolete (# of ECC bytes avail on read/write long cmds (0000h=not spec'd))
  2775 0000002E <res 00000008>      <1> 	.strFirmW	resb 8	; 23...26F, Firmware revision (8 ASCII characters, 0000h=not specified)
  2776 00000036 <res 00000028>      <1> 	.strModel	resb 40	; 27...46F, Model number (40 ASCII characters, 0000h=not specified)
  2777 0000005E <res 00000001>      <1> 	.bBlckSize	resb 1	; 47[0-7]F, Maximum number of sectors that can be transferred
  2778                              <1> 						;           per interrupt on read and write multiple commands
  2779                              <1> 						;		    (00h=Read/write multiple commands not implemented)
  2780 0000005F <res 00000001>      <1> 				resb 1	; 47[8-15]F, 80h
  2781 00000060 <res 00000002>      <1> 				resw 1	; 48R
  2782 00000062 <res 00000002>      <1> 	.wCaps		resw 1	; 49FX, Capabilities
  2783 00000064 <res 00000002>      <1> 	.wCapsHigh	resw 1	; 50FX, Capabilities 2
  2784 00000066 <res 00000002>      <1> 				resw 1	; 51X, Obsolete (PIO data transfer cycle timing mode)
  2785 00000068 <res 00000002>      <1> 				resw 1	; 52X, Obsolete (DMA data transfer cycle timing mode)
  2786 0000006A <res 00000002>      <1> 	.wFields	resw 1	; 53FX, Field (next words) validity bits
  2787                              <1> 
  2788                              <1> 	; Words 54-58 are valid only if bit0 is set in .wFields
  2789 0000006C <res 00000002>      <1> 				resw 1	; 54X, Obsolete (Number of current logical cylinders)
  2790 0000006E <res 00000002>      <1> 				resw 1	; 55X, Obsolete (Number of current logical heads)
  2791 00000070 <res 00000002>      <1> 				resw 1	; 56X, Obsolete (Number of current logical sectors per track)
  2792 00000072 <res 00000004>      <1> 				resd 1	; 57...58X, Obsolete (Current capacity in sectors)
  2793                              <1> 
  2794                              <1> 	; Words 59-63 are always valid
  2795 00000076 <res 00000001>      <1> 	.bBlockSel	resb 1	; 59[0-7]V, Current setting for number of sectors that
  2796                              <1> 						;           can be transferred per interrupt on R/W multiple command
  2797 00000077 <res 00000001>      <1> 	.bBlockFlgs	resb 1	; 59[8-15]VR, bit 0 set if Multiple sector setting is valid
  2798 00000078 <res 00000004>      <1> 	.dwLBACnt	resd 1	; 60...61F, Total number of user addressable sectors (LBA-28)
  2799 0000007C <res 00000001>      <1> 				resb 1	; 62[0-7]X, Obsolete (Single word DMA transfer modes supported)
  2800 0000007D <res 00000001>      <1> 				resb 1	; 62[8-15]X, Obsolete (Single word DMA transfer mode active)
  2801 0000007E <res 00000002>      <1> 	.wMDMA		resw 1	; 63FV, Multiword DMA transfer modes supported and active
  2802                              <1> 
  2803                              <1> 	; Words 64-70 are valid only if bit1 is set in .wFields (ATA2+)
  2804 00000080 <res 00000001>      <1> 	.bPIOSupp	resb 1	; 64[0-7]F, Advanced PIO Transfer Modes Supported
  2805 00000081 <res 00000001>      <1> 				resb 1	; 64[8-15]R
  2806 00000082 <res 00000002>      <1> 	.wMDMAMinCy	resw 1	; 65F, Minimum Multiword DMA Transfer Cycle Time Per Word
  2807 00000084 <res 00000002>      <1> 	.wMDMARecCy	resw 1	; 66F, Manufacturers Recommended Multiword DMA Transfer Cycle Time
  2808 00000086 <res 00000002>      <1> 	.wPIOMinCy	resw 1	; 67F, Minimum PIO Transfer Cycle Time Without Flow Control
  2809 00000088 <res 00000002>      <1> 	.wPIOMinCyF	resw 1	; 68F, Minimum PIO Transfer Cycle Time With IORDY Flow Control
  2810 0000008A <res 00000004>      <1> 				resw 71-69	; 69...70R
  2811                              <1> 
  2812                              <1> 	; Words 71...74 are reserved for IDENTIFY PACKET DEVICE command
  2813 0000008E <res 00000008>      <1> 				resw 75-71	; 71...74R
  2814                              <1> 
  2815 00000096 <res 00000002>      <1> 	.wQueue		resw 1	; 75[0-4]F, Maximum queue depth - 1
  2816 00000098 <res 00000008>      <1> 				resw 80-76	; 76...79R
  2817                              <1> 
  2818 000000A0 <res 00000002>      <1> 	.wMajorVer	resw 1	; 80F, Major Version Number
  2819 000000A2 <res 00000002>      <1> 	.wMinorVer	resw 1	; 81F, Minor Version Number
  2820 000000A4 <res 00000002>      <1> 	.wSetSup82	resw 1	; 82F, Command set supported
  2821 000000A6 <res 00000002>      <1> 	.wSetSup83	resw 1	; 83F, Command sets supported
  2822 000000A8 <res 00000002>      <1> 	.wSetSup84	resw 1	; 84F, Command set / Feature supported extension
  2823 000000AA <res 00000002>      <1> 	.wEnFor82	resw 1	; 85FV, Command set / feature enabled (for word 82)
  2824 000000AC <res 00000002>      <1> 	.wEnFor83	resw 1	; 86FV, Command set / feature enabled (for word 83)
  2825 000000AE <res 00000002>      <1> 	.wEnFor84	resw 1	; 87FV, Command set / feature enabled (for word 84)
  2826                              <1> 
  2827                              <1> 	; Word 88 is valid only if bit2 is set in .wFields (word 53)
  2828 000000B0 <res 00000002>      <1> 	.wUDMA		resw 1	; 88FV, Ultra DMA Mode support
  2829                              <1> 
  2830 000000B2 <res 00000002>      <1> 	.wEraseTime	resw 1	; 89F, Time required for security erase unit completion
  2831 000000B4 <res 00000002>      <1> 	.wEnhErTime	resw 1	; 90F, Time required for Enhanced security erase completion
  2832 000000B6 <res 00000002>      <1> 	.wCurPower	resw 1	; 91V, Current advanced power management value
  2833 000000B8 <res 00000002>      <1> 	.wPWRev		resw 1	; 92V, Master Password Revision Code
  2834 000000BA <res 00000002>      <1> 	.wReset		resw 1	; 93FV, Hardware reset result
  2835 000000BC <res 00000001>      <1> 	.bCurAcous	resb 1	; 94[0-7]V, Current automatic acoustic management value
  2836 000000BD <res 00000001>      <1> 	.bRecAcous	resb 1	; 94[8-15]V, Vendors recommended acoustic management value
  2837 000000BE <res 0000000A>      <1> 				resw 100-95		; 95...99R
  2838 000000C8 <res 00000008>      <1> 	.qwLBACnt	resb 8	; 100...103V, Total number of user addressable sectors (LBA48)
  2839 000000D0 <res 0000002E>      <1> 				resw 127-104	; 104...126R
  2840 000000FE <res 00000002>      <1> 	.wRMSN		resw 1	; 127F, Removable Media Status Notification feature set support
  2841 00000100 <res 00000002>      <1> 	.wSecurity	resw 1	; 128FV, Security Status
  2842 00000102 <res 0000003E>      <1> 				resw 160-129	; 129...157X, Vendor Specific
  2843 00000140 <res 00000002>      <1> 	.wCFAPower	resw 1	; 160FV, CFA Power Mode 1
  2844 00000142 <res 0000001E>      <1> 				resw 176-161	; 161...175R, Reserved for assignment by the CompactFlash Association
  2845 00000160 <res 0000003C>      <1> 	.strMediaSr	resw 206-176	; 176...205V, Current media serial number
  2846 0000019C <res 00000062>      <1> 				resw 255-206	; 206...254R
  2847                              <1> 	.wIntegrityWord:
  2848 000001FE <res 00000001>      <1> 	.bSignature	resb 1	; 255[0-7]X, Signature
  2849 000001FF <res 00000001>      <1> 	.bChecksum	resb 1	; 255[8-15]X, Checksum
  2850                              <1> endstruc
  2851                              <1> 
  2852                              <1> ; ATA-6 Word 0, General configuration
  2853                              <1> A6_wGenCfg_REMOVABLE	EQU	(1<<7)	; Removable media device
  2854                              <1> A6_wGenCfg_INCOMPLETE	EQU	(1<<2)	; Response incomplete
  2855                              <1> 
  2856                              <1> ; ATA-6 Word 49, Capabilities
  2857                              <1> A6_wCaps_TIMER			EQU	(1<<13)	; Standby timer values as specified in this standard are supported
  2858                              <1> A6_wCaps_IORDY			EQU	(1<<11)	; IORDY supported
  2859                              <1> A6_wCaps_CANDISIORDY	EQU	(1<<10)	; IORDY can be disabled
  2860                              <1> A6_wCaps_LBA			EQU	(1<<9)	; LBA supported
  2861                              <1> A6_wCaps_DMA			EQU	(1<<8)	; DMA supported
  2862                              <1> 
  2863                              <1> ; ATA-6 Word 53, Fields
  2864                              <1> A6_wFields_88			EQU	(1<<2)	; The fields reported in word 88 are valid
  2865                              <1> A6_wFields_64to70		EQU	(1<<1)	; The fields reported in words 64-70 are valid
  2866                              <1> 
  2867                              <1> ; ATA-6 Word 59 high byte, Block mode flags
  2868                              <1> A6_bBlockFlgs_VALID		EQU	(1<<0)	; Multiple sector setting (bBlockSel) is valid
  2869                              <1> 
  2870                              <1> ; ATA-6 Word 63, Multiword DMA Mode
  2871                              <1> A6_wMDMA_MODE2_SELECTED	EQU	(1<<10)	; Multiword DMA mode 2 is selected
  2872                              <1> A6_wMDMA_MODE1_SELECTED	EQU	(1<<9)	; Multiword DMA mode 1 is selected
  2873                              <1> A6_wMDMA_MODE0_SELECTED	EQU	(1<<8)	; Multiword DMA mode 0 is selected
  2874                              <1> A6_wMDMA_MODE2_SUPRTD	EQU	(1<<2)	; Multiword DMA mode 2 and below are supported
  2875                              <1> A6_wMDMA_MODE1_SUPRTD	EQU	(1<<1)	; Multiword DMA mode 1 and below are supported
  2876                              <1> A6_wMDMA_MODE0_SUPRTD	EQU	(1<<0)	; Multiword DMA mode 0 is supported
  2877                              <1> 
  2878                              <1> ; ATA-6 Word 80, Major version number
  2879                              <1> A6_wMajorVer_ATA6		EQU	(1<<6)
  2880                              <1> A6_wMajorVer_ATA5		EQU	(1<<5)
  2881                              <1> A6_wMajorVer_ATA4		EQU	(1<<4)
  2882                              <1> A6_wMajorVer_ATA3		EQU	(1<<3)
  2883                              <1> 
  2884                              <1> ; ATA-6 Word 82, Command set supported
  2885                              <1> A6_wSetSup82_NOP		EQU	(1<<14)	; NOP command supported
  2886                              <1> A6_wSetSup82_RDBUFF		EQU	(1<<13)	; READ BUFFER command supported
  2887                              <1> A6_wSetSup82_WRBUFF		EQU	(1<<12)	; WRITE BUFFER command supported
  2888                              <1> A6_wSetSup82_PROT_AREA	EQU	(1<<10)	; Host Protected Area feature set supported
  2889                              <1> A6_wSetSup82_DEV_RESET	EQU	(1<<9)	; DEVICE RESET command supported
  2890                              <1> A6_wSetSup82_SERVICE	EQU	(1<<8)	; SERVICE interrupt supported
  2891                              <1> A6_wSetSup82_RELEASE	EQU	(1<<7)	; Release interrupt supported
  2892                              <1> A6_wSetSup82_LOOKAHEAD	EQU	(1<<6)	; Look-ahead supported
  2893                              <1> A6_wSetSup82_WRCACHE	EQU	(1<<5)	; Write cache supported
  2894                              <1> A6_wSetSup82_POWERMAN	EQU	(1<<3)	; Power Management feature set supported
  2895                              <1> A6_wSetSup82_REM_MEDIA	EQU	(1<<2)	; Removable Media feature set supported
  2896                              <1> A6_wSetSup82_SECURITY	EQU	(1<<1)	; Security Mode feature set supported
  2897                              <1> A6_wSetSup82_SMART		EQU	(1<<0)	; SMART feature set supported
  2898                              <1> 
  2899                              <1> ; ATA-6 Word 83, Command sets supported
  2900                              <1> A6_wSetSup83_FLUSH_EXT	EQU	(1<<13)	; FLUSH CACHE EXT command supported
  2901                              <1> A6_wSetSup83_FLUSH		EQU	(1<<12)	; FLUSH CACHE command supported
  2902                              <1> A6_wSetSup83_CFG		EQU	(1<<11)	; Device Configuration Overlay feature set supported
  2903                              <1> A6_wSetSup83_LBA48		EQU	(1<<10)	; 48-bit LBA feature set supported
  2904                              <1> A6_wSetSup83_ACOUSTIC	EQU	(1<<9)	; Automatic Acoustic Management feature set supported
  2905                              <1> A6_wSetSup83_SET_MAX	EQU	(1<<8)	; SET MAX security extension supported
  2906                              <1> A6_wSetSup83_FEATURES	EQU	(1<<6)	; SET FEATURES subcommand required to spinup after power-up
  2907                              <1> A6_wSetSup83_POWERUP	EQU	(1<<5)	; Power-Up In Standby feature set supported
  2908                              <1> A6_wSetSup83_RMSN		EQU	(1<<4)	; Removable Media Status Notification feature set supported
  2909                              <1> A6_wSetSup83_APM		EQU	(1<<3)	; Advanced Power Management feature set supported
  2910                              <1> A6_wSetSup83_CFA		EQU	(1<<2)	; CFA feature set supported
  2911                              <1> A6_wSetSup83_DMAQUEUED	EQU	(1<<1)	; READ/WRITE DMA QUEUED supported
  2912                              <1> A6_wSetSup83_MICROCODE	EQU	(1<<0)	; DOWNLOAD MICROCODE command supported
  2913                              <1> 
  2914                              <1> ; ATA-6 Word 84, Command set/feature supported extension
  2915                              <1> A6_wSetSup84_GENLOG		EQU	(1<<5)	; General Purpose Logging feature set supported
  2916                              <1> A6_wSetSup84_MEDIAPASS	EQU	(1<<3)	; Media Card Pass Through Command feature set supported
  2917                              <1> A6_wSetSup84_MEDIASER	EQU	(1<<2)	; Media serial number supported
  2918                              <1> A6_wSetSup84_SMARTTEST	EQU	(1<<1)	; SMART self-test supported
  2919                              <1> A6_wSetSup84_SMARTLOG	EQU	(1<<0)	; SMART error logging supported
  2920                              <1> 
  2921                              <1> ; ATA-6 Word 85, Command set/feature enabled (supported by word 82)
  2922                              <1> A6_wEnFor82_NOP			EQU	(1<<14)	; NOP command enabled
  2923                              <1> A6_wEnFor82_RDBUFF		EQU	(1<<13)	; READ BUFFER command enabled
  2924                              <1> A6_wEnFor82_WRBUFF		EQU	(1<<12)	; WRITE BUFFER command enabled
  2925                              <1> A6_wEnFor82_PROT_AREA	EQU	(1<<10)	; Host Protected Area feature set enabled
  2926                              <1> A6_wEnFor82_DEV_RESET	EQU	(1<<9)	; DEVICE RESET command enabled
  2927                              <1> A6_wEnFor82_SERVICE		EQU	(1<<8)	; SERVICE interrupt enabled
  2928                              <1> A6_wEnFor82_RELEASE		EQU	(1<<7)	; Release interrupt enabled
  2929                              <1> A6_wEnFor82_LOOKAHEAD	EQU	(1<<6)	; Look-ahead enabled
  2930                              <1> A6_wEnFor82_WRCACHE		EQU	(1<<5)	; Write cache enabled
  2931                              <1> A6_wEnFor82_POWERMAN	EQU	(1<<3)	; Power Management feature set enabled
  2932                              <1> A6_wEnFor82_REM_MEDIA	EQU	(1<<2)	; Removable Media feature set enabled
  2933                              <1> A6_wEnFor82_SECURITY	EQU	(1<<1)	; Security Mode feature set enabled
  2934                              <1> A6_wEnFor82_SMART		EQU	(1<<0)	; SMART feature set enabled
  2935                              <1> 
  2936                              <1> ; ATA-6 Word 86, Command set/feature enabled (supported by word 83)
  2937                              <1> A6_wEnFor83_FLUSH_EXT	EQU	(1<<13)	; FLUSH CACHE EXT command supported
  2938                              <1> A6_wEnFor83_FLUSH		EQU	(1<<12)	; FLUSH CACHE command supported
  2939                              <1> A6_wEnFor83_CFG			EQU	(1<<11)	; Device Configuration Overlay supported
  2940                              <1> A6_wEnFor83_LBA48		EQU	(1<<10)	; 48-bit LBA feature set supported
  2941                              <1> A6_wEnFor83_ACOUSTIC	EQU	(1<<9)	; Automatic Acoustic Management feature set enabled
  2942                              <1> A6_wEnFor83_SET_MAX		EQU	(1<<8)	; SET MAX security extension enabled by SET MAX SET PASSWORD
  2943                              <1> A6_wEnFor83_FEATURES	EQU	(1<<6)	; SET FEATURES subcommand required to spinup after power-up
  2944                              <1> A6_wEnFor83_POWERUP		EQU	(1<<5)	; Power-Up In Standby feature set enabled
  2945                              <1> A6_wEnFor83_RMSN		EQU	(1<<4)	; Removable Media Status Notification feature set enabled
  2946                              <1> A6_wEnFor83_APM			EQU	(1<<3)	; Advanced Power Management feature set enabled
  2947                              <1> A6_wEnFor83_CFA			EQU	(1<<2)	; CFA feature set enabled
  2948                              <1> A6_wEnFor83_DMAQUEUED	EQU	(1<<1)	; READ/WRITE DMA QUEUED supported
  2949                              <1> A6_wEnFor83_MICROCODE	EQU	(1<<0)	; DOWNLOAD MICROCODE command supported
  2950                              <1> 
  2951                              <1> ; ATA-6 Word 87, Command set/feature default
  2952                              <1> A6_wEnFor84_GENLOG		EQU	(1<<5)	; General Purpose Logging feature set supported
  2953                              <1> A6_wEnFor84_MEDIAPASS	EQU	(1<<3)	; Media Card Pass Through Command feature set enabled
  2954                              <1> A6_wEnFor84_MEDIASER	EQU	(1<<2)	; Media serial number is valid
  2955                              <1> A6_wEnFor84_SMARTTEST	EQU	(1<<1)	; SMART self-test supported
  2956                              <1> A6_wEnFor84_SMARTLOG	EQU	(1<<0)	; SMART error logging supported
  2957                              <1> 
  2958                              <1> ; ATA-6 Word 88, Ultra DMA Mode
  2959                              <1> A6_wUDMA_MODE5_SELECTED	EQU	(1<<13)	; Ultra DMA mode 5 is selected
  2960                              <1> A6_wUDMA_MODE4_SELECTED	EQU	(1<<12)	; Ultra DMA mode 4 is selected
  2961                              <1> A6_wUDMA_MODE3_SELECTED	EQU	(1<<11)	; Ultra DMA mode 3 is selected
  2962                              <1> A6_wUDMA_MODE2_SELECTED	EQU	(1<<10)	; Ultra DMA mode 2 is selected
  2963                              <1> A6_wUDMA_MODE1_SELECTED	EQU	(1<<9)	; Ultra DMA mode 1 is selected
  2964                              <1> A6_wUDMA_MODE0_SELECTED	EQU	(1<<8)	; Ultra DMA mode 0 is selected
  2965                              <1> A6_wUDMA_MODE5_SUPRTD	EQU	(1<<5)	; Ultra DMA mode 5 and below are supported
  2966                              <1> A6_wUDMA_MODE4_SUPRTD	EQU	(1<<4)	; Ultra DMA mode 4 and below are supported
  2967                              <1> A6_wUDMA_MODE3_SUPRTD	EQU	(1<<3)	; Ultra DMA mode 3 and below are supported
  2968                              <1> A6_wUDMA_MODE2_SUPRTD	EQU	(1<<2)	; Ultra DMA mode 2 and below are supported
  2969                              <1> A6_wUDMA_MODE1_SUPRTD	EQU	(1<<1)	; Ultra DMA mode 1 and below are supported
  2970                              <1> A6_wUDMA_MODE0_SUPRTD	EQU	(1<<0)	; Ultra DMA mode 0 is supported
  2971                              <1> 
  2972                              <1> ; ATA-6 Word 93, Hardware reset result
  2973                              <1> A6_wReset_CBLID_BELOW	EQU	(1<<13)	; Device detected CBLID- above ViH
  2974                              <1> A6_wReset_DEV1_PDIAG	EQU	(1<<11)	; Device 1 asserted PDIAG-
  2975                              <1> A6_wReset_DEV0_RESP_D1	EQU	(1<<6)	; Device 0 responds when Device 1 is selected
  2976                              <1> A6_wReset_DEV0_DASP		EQU	(1<<5)	; Device 0 detected the assertion of DASP-
  2977                              <1> A6_wReset_DEV0_PDIAG	EQU	(1<<4)	; Device 0 detected the assertion of PDIAG
  2978                              <1> A6_wReset_DEV0_PASSED	EQU	(1<<3)	; Device 0 passed diagnostics
  2979                              <1> A6_wReset_MASK_DEV1_DETERMINE	EQU ((1<<10)|(1<<9))	; These bits indicate how Device 1 determined the device number
  2980                              <1> A6_wReset_MASK_DEV0_DETERMINE	EQU ((1<<2)|(1<<1))		; These bits indicate how Device 0 determined the device number:
  2981                              <1> A6_wReset_RESERVED		EQU	00b
  2982                              <1> A6_wReset_JUMPER		EQU	01b		; a jumper was used
  2983                              <1> A6_wReset_CSEL			EQU	10b		; the CSEL signal was used
  2984                              <1> A6_wReset_UNKNOWN		EQU	11b		; some other method was used or the method is unknown
  2985                              <1> 
  2986                              <1> ; ATA-6 Word 127, Removable Media Status Notification feature set support
  2987                              <1> A6_wRMSN_SUPPORTED		EQU	(1<<0)	; Removable Media Status Notification feature supported
  2988                              <1> 
  2989                              <1> ; ATA-6 Word 128, Security status
  2990                              <1> A6_wSecurity_MAX		EQU	(1<<8)	; Security level 0 = High, 1 = Maximum
  2991                              <1> A6_wSecurity_ENH_ERASE	EQU	(1<<5)	; Enhanced security erase supported
  2992                              <1> A6_wSecurity_EXPIRED	EQU	(1<<4)	; Security count expired
  2993                              <1> A6_wSecurity_FROZEN		EQU	(1<<3)	; Security frozen
  2994                              <1> A6_wSecurity_LOCKED		EQU	(1<<2)	; Security locked
  2995                              <1> A6_wSecurity_ENABLED	EQU	(1<<1)	; Security enabled
  2996                              <1> A6_wSecurity_SUPPORTED	EQU	(1<<0)	; Security supported
  2997                              <1> 
  2998                              <1> ; ATA-6 Word 160, CFA Power Mode 1
  2999                              <1> A6_wCFAPower_WORDSUPP	EQU	(1<<15)	; Word 160 supported
  3000                              <1> A6_wCFAPower_REQUIRED	EQU	(1<<13)	; CFA power mode 1 is required for one or more commands implemented by the device
  3001                              <1> A6_wCFAPower_DISABLED	EQU	(1<<12)	; CFA power mode 1 disabled
  3002                              <1> A6_wCFAPower_MASK_mA	EQU	0FFFh	; Maximum current in mA
  3003                              <1> 
  3004                              <1> ; ATA-6 WORD 255, Integrity Word (Signature and Checksum)
  3005                              <1> A6_wIntegrity_SIGNATURE	EQU	0A5h
  3006                              <1> 
  3007                              <1> 
  3008                              <1> %endif ; ATA_ID_INC
  3009                                  	%include "IdeRegisters.inc"		; For ATA Registers, flags and commands
  3010                              <1> ; Project name	:	XTIDE Universal BIOS
  3011                              <1> ; Description	:	Equates for IDE registers, flags and commands.
  3012                              <1> 
  3013                              <1> ;
  3014                              <1> ; XTIDE Universal BIOS and Associated Tools
  3015                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3016                              <1> ;
  3017                              <1> ; This program is free software; you can redistribute it and/or modify
  3018                              <1> ; it under the terms of the GNU General Public License as published by
  3019                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3020                              <1> ; (at your option) any later version.
  3021                              <1> ;
  3022                              <1> ; This program is distributed in the hope that it will be useful,
  3023                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3024                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3025                              <1> ; GNU General Public License for more details.
  3026                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3027                              <1> ;
  3028                              <1> 
  3029                              <1> %ifndef IDEREGISTERS_INC
  3030                              <1> %define IDEREGISTERS_INC
  3031                              <1> 
  3032                              <1> ; IDE Register offsets from Command Block base port
  3033                              <1> DATA_REGISTER					EQU		0
  3034                              <1> ERROR_REGISTER_in				EQU		1		; Read only
  3035                              <1> FEATURES_REGISTER_out			EQU		1		; Write only, ATA1+
  3036                              <1> ;WRITE_PRECOMPENSATION_out		EQU		1		; Write only, Obsolete on ATA1+
  3037                              <1> SECTOR_COUNT_REGISTER			EQU		2
  3038                              <1> SECTOR_NUMBER_REGISTER			EQU		3		; LBA Low Register
  3039                              <1> LOW_CYLINDER_REGISTER			EQU		4		; LBA Middle Register
  3040                              <1> HIGH_CYLINDER_REGISTER			EQU		5		; LBA High Register
  3041                              <1> LBA_LOW_REGISTER				EQU		3		; LBA 7...0, LBA48 31...24
  3042                              <1> LBA_MIDDLE_REGISTER				EQU		4		; LBA 15...8, LBA48 39...32
  3043                              <1> LBA_HIGH_REGISTER				EQU		5		; LBA 23...16, LBA48 47...40
  3044                              <1> DRIVE_AND_HEAD_SELECT_REGISTER	EQU		6		; LBA28 27...24
  3045                              <1> STATUS_REGISTER_in				EQU		7		; Read only
  3046                              <1> COMMAND_REGISTER_out			EQU		7		; Write only
  3047                              <1> ;XTIDE_DATA_HIGH_REGISTER		EQU		8		; Non-standard (actually first Control Block reg)
  3048                              <1> 
  3049                              <1> ; IDE Register offsets from Control Block base port
  3050                              <1> ; (usually Command Block base port + 200h)
  3051                              <1> ALTERNATE_STATUS_REGISTER_in	EQU		6		; Read only
  3052                              <1> DEVICE_CONTROL_REGISTER_out		EQU		6		; Write only
  3053                              <1> ;DRIVE_ADDRESS_REGISTER			EQU		7		; Obsolete on ATA2+
  3054                              <1> 
  3055                              <1> ; Bit mask for XTIDE mod with reversed A0 and A3 address lines
  3056                              <1> MASK_A3_AND_A0_ADDRESS_LINES	EQU		((1<<3) | (1<<0))
  3057                              <1> 
  3058                              <1> ; Bit definitions for IDE Error Register
  3059                              <1> FLG_ERROR_BBK			EQU		(1<<7)	; Bad Block Detected (reserved on ATA2+, command dependent on ATA4+)
  3060                              <1> FLG_ERROR_UNC			EQU		(1<<6)	; Uncorrectable Data Error (command dependent on ATA4+)
  3061                              <1> FLG_ERROR_MC			EQU		(1<<5)	; Media Changed (command dependent on ATA4+)
  3062                              <1> FLG_ERROR_IDNF			EQU		(1<<4)	; ID Not Found (command dependent on ATA4+)
  3063                              <1> FLG_ERROR_MCR			EQU		(1<<3)	; Media Change Request (command dependent on ATA4+)
  3064                              <1> FLG_ERROR_ABRT			EQU		(1<<2)	; Command Aborted
  3065                              <1> FLG_ERROR_TK0NF			EQU		(1<<1)	; Track 0 Not Found (command dependent on ATA4+)
  3066                              <1> FLG_ERROR_AMNF			EQU		(1<<0)	; Address Mark Not Found (command dependent on ATA4+)
  3067                              <1> 
  3068                              <1> ; Bit definitions for IDE Drive and Head Select Register
  3069                              <1> FLG_DRVNHEAD_LBA		EQU		(1<<6)	; LBA Addressing enabled (instead of CHS)
  3070                              <1> FLG_DRVNHEAD_DRV		EQU		(1<<4)	; Drive Select (0=Master, 1=Slave)
  3071                              <1> MASK_DRVNHEAD_HEAD		EQU		0Fh		; Head select bits (bits 0...3)
  3072                              <1> MASK_DRVNHEAD_SET		EQU		0A0h	; Bits that must be set to 1 on ATA1 (reserved on ATA2+)
  3073                              <1> 
  3074                              <1> ; Bit definitions for IDE Status Register
  3075                              <1> FLG_STATUS_BSY			EQU		(1<<7)	; Busy (other flags undefined when set)
  3076                              <1> FLG_STATUS_DRDY			EQU		(1<<6)	; Device Ready
  3077                              <1> FLG_STATUS_DF			EQU		(1<<5)	; Device Fault (command dependent on ATA4+)
  3078                              <1> FLG_STATUS_DSC			EQU		(1<<4)	; Device Seek Complete (command dependent on ATA4+)
  3079                              <1> FLG_STATUS_DRQ			EQU		(1<<3)	; Data Request
  3080                              <1> FLG_STATUS_CORR			EQU		(1<<2)	; Corrected Data (obsolete on ATA4+)
  3081                              <1> FLG_STATUS_IDX			EQU		(1<<1)	; Index (vendor specific on ATA2+, obsolete on ATA4+)
  3082                              <1> FLG_STATUS_ERR			EQU		(1<<0)	; Error
  3083                              <1> 
  3084                              <1> ; Bit definitions for IDE Device Control Register
  3085                              <1> ; Bit 0 must be zero, unlisted bits are reserved.
  3086                              <1> ;FLG_DEVCONTROL_HOB		EQU		(1<<7)	; High Order Byte (ATA6+)
  3087                              <1> ;FLG_DEVCONTROL_O8H		EQU		(1<<3)	; Drive has more than 8 heads (pre-ATA only, 1 on ATA1, reserved on ATA2+)
  3088                              <1> FLG_DEVCONTROL_SRST		EQU		(1<<2)	; Software Reset
  3089                              <1> FLG_DEVCONTROL_nIEN		EQU		(1<<1)	; Negated Interrupt Enable (IRQ disabled when set)
  3090                              <1> 
  3091                              <1> ; Commands for IDE Controller
  3092                              <1> COMMAND_RECALIBRATE						EQU		10h
  3093                              <1> COMMAND_READ_SECTORS					EQU		20h
  3094                              <1> COMMAND_READ_SECTORS_EXT				EQU		24h		; LBA48
  3095                              <1> COMMAND_WRITE_SECTORS					EQU		30h
  3096                              <1> COMMAND_WRITE_SECTORS_EXT				EQU		34h		; LBA48
  3097                              <1> COMMAND_VERIFY_SECTORS					EQU		40h
  3098                              <1> COMMAND_VERIFY_SECTORS_EXT				EQU		42h		; LBA48
  3099                              <1> COMMAND_SEEK							EQU		70h
  3100                              <1> COMMAND_INITIALIZE_DEVICE_PARAMETERS	EQU		91h
  3101                              <1> COMMAND_SET_MULTIPLE_MODE				EQU		0C6h	; Block mode
  3102                              <1> COMMAND_READ_MULTIPLE					EQU		0C4h	; Block mode
  3103                              <1> COMMAND_READ_MULTIPLE_EXT				EQU		29h		; LBA48, Block mode
  3104                              <1> COMMAND_WRITE_MULTIPLE					EQU		0C5h	; Block mode
  3105                              <1> COMMAND_WRITE_MULTIPLE_EXT				EQU		39h		; LBA48, Block mode
  3106                              <1> COMMAND_IDENTIFY_DEVICE					EQU		0ECh
  3107                              <1> COMMAND_SET_FEATURES					EQU		0EFh
  3108                              <1> COMMAND_IDLE							EQU		0E3h
  3109                              <1> 
  3110                              <1> 
  3111                              <1> ; Subcommands for COMMAND_SET_FEATURES
  3112                              <1> FEATURE_ENABLE_8BIT_PIO_TRANSFER_MODE	EQU		01h		; CFA feature set only
  3113                              <1> FEATURE_ENABLE_WRITE_CACHE				EQU		02h
  3114                              <1> FEATURE_DISABLE_8BIT_PIO_TRANSFER_MODE	EQU		81h		; CFA feature set only
  3115                              <1> FEATURE_DISABLE_WRITE_CACHE				EQU		82h		; Can also be used to flush cache
  3116                              <1> FEATURE_SET_TRANSFER_MODE				EQU		03h		; Transfer mode goes to the Sector Count Register
  3117                              <1> 	PIO_DEFAULT_MODE					EQU		0h
  3118                              <1> 	PIO_DEFAULT_MODE_DISABLE_IORDY		EQU		1h
  3119                              <1> 	PIO_FLOW_CONTROL_MODE_xxx			EQU		(1<<3)	; Bits 2...0 hold the PIO mode
  3120                              <1> 
  3121                              <1> 
  3122                              <1> %endif ; IDEREGISTERS_INC
  3123                                  	%include "Int13h.inc"			; Equates for INT 13h functions
  3124                              <1> ; Project name	:	XTIDE Universal BIOS
  3125                              <1> ; Description	:	Equates used in INT 13h functions.
  3126                              <1> 
  3127                              <1> ;
  3128                              <1> ; XTIDE Universal BIOS and Associated Tools
  3129                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3130                              <1> ;
  3131                              <1> ; This program is free software; you can redistribute it and/or modify
  3132                              <1> ; it under the terms of the GNU General Public License as published by
  3133                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3134                              <1> ; (at your option) any later version.
  3135                              <1> ;
  3136                              <1> ; This program is distributed in the hope that it will be useful,
  3137                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3138                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3139                              <1> ; GNU General Public License for more details.
  3140                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3141                              <1> ;
  3142                              <1> 
  3143                              <1> %ifndef INT13H_INC
  3144                              <1> %define INT13H_INC
  3145                              <1> 
  3146                              <1> ; Hard Disk function (INT 13h) return status codes in AH
  3147                              <1> RET_HD_SUCCESS			EQU		0h		; Operation successful, no error occurred
  3148                              <1> RET_HD_INVALID			EQU		1h		; Invalid value passed or unsupported func
  3149                              <1> RET_HD_ADDRMARK			EQU		2h		; Missing address mark
  3150                              <1> RET_HD_WRITEPROT		EQU		3h		; Removable media is write protected
  3151                              <1> RET_HD_NOT_FOUND		EQU		4h		; Requested sector not found
  3152                              <1> RET_HD_RESETFAIL		EQU		5h		; Reset failed
  3153                              <1> RET_HD_CHANGED			EQU		6h		; Media changed
  3154                              <1> RET_HD_PARAMACT			EQU		7h		; Drive parameter activity failed
  3155                              <1> RET_HD_OVERRUN			EQU		8h		; DMA overrun
  3156                              <1> RET_HD_BOUNDARY			EQU		9h		; Data boundary error
  3157                              <1> RET_HD_BADSECTOR		EQU		0Ah		; Bad sector detected
  3158                              <1> RET_HD_BADTRACK			EQU		0Bh		; Bad track detected
  3159                              <1> RET_HD_UNCORRECC		EQU		10h		; Uncorrectable ECC error
  3160                              <1> RET_HD_ECC				EQU		11h		; Corrected ECC error
  3161                              <1> RET_HD_CONTROLLER		EQU		20h		; Hard disk controller or drive problem
  3162                              <1> RET_HD_NOMEDIA			EQU		31h		; No media in removable media drive
  3163                              <1> RET_HD_SEEK_FAIL		EQU		40h		; Seek operation failed
  3164                              <1> RET_HD_TIMEOUT			EQU		80h		; Drive failed to respond
  3165                              <1> RET_HD_NOTREADY			EQU		0AAh	; Drive is not ready or is not selected
  3166                              <1> RET_HD_NOTLOCKED		EQU		0B0h	; Volume not locked in drive
  3167                              <1> RET_HD_LOCKED			EQU		0B1h	; Volume locked in drive
  3168                              <1> RET_HD_NOTREMOVABLE		EQU		0B2h	; Volume not removable
  3169                              <1> RET_HD_INUSE			EQU		0B3h	; Volume in use
  3170                              <1> RET_HD_LOCKEXCEEDED		EQU		0B4h	; Lock count exceeded
  3171                              <1> RET_HD_EJECTFAIL		EQU		0B5h	; Valid eject request failed
  3172                              <1> RET_HD_UNDEFINED		EQU		0BBh	; Undefined error occurred
  3173                              <1> RET_HD_WRFAULT			EQU		0CCh	; Write fault on selected drive
  3174                              <1> RET_HD_STATUSERR		EQU		0E0h	; Status error without error
  3175                              <1> RET_HD_SENSEFAIL		EQU		0FFh	; Sense operation failed
  3176                              <1> 
  3177                              <1> 
  3178                              <1> ; Floppy Drive types returned by INT 13h, AH=08h
  3179                              <1> FLOPPY_TYPE_525_OR_35_DD	EQU	0
  3180                              <1> FLOPPY_TYPE_525_DD			EQU	1
  3181                              <1> FLOPPY_TYPE_525_HD			EQU	2
  3182                              <1> FLOPPY_TYPE_35_DD			EQU	3
  3183                              <1> FLOPPY_TYPE_35_HD			EQU	4
  3184                              <1> FLOPPY_TYPE_35_ED			EQU	6
  3185                              <1> 
  3186                              <1> 
  3187                              <1> %define TIMEOUT_AND_STATUS_TO_WAIT(timeout, status)		(((timeout)<<8) | (status))
  3188                              <1> 
  3189                              <1> 
  3190                              <1> %endif ; INT13H_INC
  3191                                  	%include "CustomDPT.inc"		; For Disk Parameter Table
  3192                              <1> ; Project name	:	XTIDE Universal BIOS
  3193                              <1> ; Description	:	Defines for DPT structs containing custom
  3194                              <1> ;					Disk Parameter Table used by this BIOS.
  3195                              <1> 
  3196                              <1> ;
  3197                              <1> ; XTIDE Universal BIOS and Associated Tools
  3198                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3199                              <1> ;
  3200                              <1> ; This program is free software; you can redistribute it and/or modify
  3201                              <1> ; it under the terms of the GNU General Public License as published by
  3202                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3203                              <1> ; (at your option) any later version.
  3204                              <1> ;
  3205                              <1> ; This program is distributed in the hope that it will be useful,
  3206                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3207                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3208                              <1> ; GNU General Public License for more details.
  3209                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3210                              <1> ;
  3211                              <1> 
  3212                              <1> %ifndef CUSTOMDPT_INC
  3213                              <1> %define CUSTOMDPT_INC
  3214                              <1> 
  3215                              <1> ; Base DPT for all device types
  3216                              <1> struc DPT
  3217                              <1> 	; General Disk Parameter Table related
  3218                              <1> 	.wFlags:
  3219 00000000 <res 00000001>      <1> 	.bFlagsLow				resb	1
  3220 00000001 <res 00000001>      <1> 	.bFlagsHigh				resb	1
  3221 00000002 <res 00000001>      <1> 	.bIdevarsOffset			resb	1	; Offset to IDEVARS for this drive
  3222 00000003 <res 00000001>      <1> 	.bInitError				resb	1	; Flags for AH=09h initialization errors
  3223 00000004 <res 00000002>      <1> 	.wBasePort				resb	2	; Segment for JR-IDE/ISA
  3224                              <1> 
  3225                              <1> 	; CHS variables
  3226 00000006 <res 00000002>      <1> 	.wLchsCylinders			resb	2	; (1...1027, yes 1027)
  3227                              <1> 	.wLchsHeadsAndSectors:
  3228 00000008 <res 00000001>      <1> 	.bLchsHeads				resb	1	; (1...255)
  3229 00000009 <res 00000001>      <1> 	.bLchsSectorsPerTrack	resb	1	; (1...63)
  3230 0000000A <res 00000001>      <1> 	.bPchsHeads				resb	1	; (1...16)
  3231                              <1> 
  3232                              <1> 	; LBA and remaining P-CHS variables
  3233                              <1> %ifdef MODULE_EBIOS
  3234                              <1> 	.bPchsSectorsPerTrack	resb	1
  3235                              <1> 	.wPchsCylinders			resb	2
  3236                              <1> 	.twLbaSectors			resb	6	; 48-bit sector count for LBA addressing
  3237                              <1> %endif
  3238 0000000B <res 00000001>      <1> 							alignb	2	; WORD alignment for DPT_SERIAL or DPT_ATA
  3239                              <1> endstruc
  3240                              <1> 
  3241                              <1> 	; Bit definitions for DPT.bFlagsLow
  3242                              <1> 	MASKL_DPT_CHS_SHIFT_COUNT			EQU	(3<<0)				; Bits 0...1, P-CHS to L-CHS bit shift count (0...3)
  3243                              <1> 	MASKL_DPT_TRANSLATEMODE				EQU	MASK_DRVPARAMS_TRANSLATEMODE	; Bits 2...3, NORMAL, LARGE or Assisted LBA addressing mode
  3244                              <1> 	FLGL_DPT_ASSISTED_LBA				EQU	(1<<(TRANSLATEMODE_FIELD_POSITION+1))
  3245                              <1> 	FLGL_DPT_SLAVE						EQU	FLG_DRVNHEAD_DRV	; Bit 4, Drive is a Slave Drive
  3246                              <1> %ifdef MODULE_IRQ
  3247                              <1> 	FLGL_DPT_ENABLE_IRQ					EQU	(1<<5)				; Bit 5, Enable IRQ
  3248                              <1> %endif
  3249                              <1> %ifdef MODULE_EBIOS
  3250                              <1> 	FLGL_DPT_LBA_AND_EBIOS_SUPPORTED	EQU	FLG_DRVNHEAD_LBA	; Bit 6, Drive supports LBA and so EBIOS functions can be supported
  3251                              <1> 	FLGL_DPT_LBA48						EQU	(1<<7)				; Bit 7, Drive supports 48-bit LBA (Must be bit 7!)
  3252                              <1> %endif
  3253                              <1> 
  3254                              <1> 
  3255                              <1> 	; Bit definitions for DPT.bFlagsHigh
  3256                              <1> 	FLGH_DPT_BLOCK_MODE_SUPPORTED		EQU	(1<<1)	; Bit 1, Use block transfer commands (must be bit 1!)
  3257                              <1> %ifdef MODULE_SERIAL
  3258                              <1> 	FLGH_DPT_SERIAL_DEVICE				EQU	(1<<2)	; Bit 2, Serial Port Device
  3259                              <1> %endif
  3260                              <1> %ifdef MODULE_IRQ
  3261                              <1> 	FLGH_DPT_INTERRUPT_IN_SERVICE		EQU	(1<<3)	; Bit 3, Set when waiting for IRQ
  3262                              <1> %endif
  3263                              <1> %ifdef MODULE_FEATURE_SETS
  3264                              <1> 	FLGH_DPT_POWER_MANAGEMENT_SUPPORTED	EQU (1<<5)	; Bit 5, Drive supports power management
  3265                              <1> %endif
  3266                              <1> %ifdef MODULE_ADVANCED_ATA
  3267                              <1> 	FLGH_DPT_IORDY						EQU	(1<<7)	; Bit 7, Controller and Drive supports IORDY
  3268                              <1> %endif
  3269                              <1> 
  3270                              <1> 	; Serial device only
  3271                              <1> %ifdef MODULE_SERIAL_FLOPPY
  3272                              <1> 	FLGH_DPT_SERIAL_FLOPPY						EQU	(1<<4)
  3273                              <1> 	FLGH_DPT_SERIAL_FLOPPY_TYPE_MASK			EQU	0e0h
  3274                              <1> 	FLGH_DPT_SERIAL_FLOPPY_TYPE_FIELD_POSITION	EQU	5
  3275                              <1> %endif
  3276                              <1> 
  3277                              <1> 
  3278                              <1> 	; Flags for DPT_ADVANCED_ATA.bInitError
  3279                              <1> 	FLG_INITERROR_FAILED_TO_SELECT_DRIVE				EQU (1<<0)
  3280                              <1> 	FLG_INITERROR_FAILED_TO_INITIALIZE_CHS_PARAMETERS	EQU (1<<1)
  3281                              <1> 	FLG_INITERROR_FAILED_TO_SET_WRITE_CACHE				EQU (1<<2)
  3282                              <1> 	FLG_INITERROR_FAILED_TO_RECALIBRATE_DRIVE			EQU (1<<3)
  3283                              <1> 	FLG_INITERROR_FAILED_TO_SET_BLOCK_MODE				EQU (1<<4)
  3284                              <1> 	FLG_INITERROR_FAILED_TO_SET_PIO_MODE				EQU (1<<5)
  3285                              <1> 	FLG_INITERROR_FAILED_TO_INITIALIZE_STANDBY_TIMER	EQU	(1<<6)
  3286                              <1> 	FLG_INITERROR_FAILED_TO_SET_XTCF_MODE				EQU	(1<<7)
  3287                              <1> 	FLG_INITERROR_FAILED_TO_SET_8BIT_MODE				EQU	FLG_INITERROR_FAILED_TO_SET_XTCF_MODE
  3288                              <1> 
  3289                              <1> 
  3290                              <1> 
  3291                              <1> ; DPT for ATA devices
  3292                              <1> struc DPT_ATA
  3293 00000000 <res 0000000C>      <1> 	.dpt					resb	DPT_size
  3294 0000000C <res 00000001>      <1> 	.bDevice				resb	1	; Device Type from IDEVARS (overrided when 32-bit controller detected)
  3295 0000000D <res 00000001>      <1> 	.bBlockSize				resb	1	; Current block size in sectors (do not set to zero!)
  3296                              <1> endstruc
  3297                              <1> 
  3298                              <1> 
  3299                              <1> 
  3300                              <1> ; Additional variables needed to initialize and reset Advanced IDE Controllers.
  3301                              <1> ; EBDA must be reserved for DPTs when using these!
  3302                              <1> %ifdef MODULE_ADVANCED_ATA
  3303                              <1> struc DPT_ADVANCED_ATA
  3304                              <1> 	.dpt_ata				resb	DPT_ATA_size
  3305                              <1> 	.wControllerID			resb	2	; Controller specific ID WORD (from Advanced Controller detection)
  3306                              <1> 	.wControllerBasePort	resb	2	; Advanced Controller port (not IDE port)
  3307                              <1> 	.wMinPioCycleTime		resb	2	; Minimum PIO Cycle Time in ns
  3308                              <1> 	.bPioMode				resb	1	; Best supported PIO mode
  3309                              <1> 							alignb	2
  3310                              <1> endstruc
  3311                              <1> %endif
  3312                              <1> 
  3313                              <1> 
  3314                              <1> ; DPT for Serial devices
  3315                              <1> %ifdef MODULE_SERIAL
  3316                              <1> struc DPT_SERIAL
  3317                              <1> 	.dpt					resb	DPT_size
  3318                              <1> 	.wSerialPortAndBaud:
  3319                              <1> 	.bSerialPort			resb	1	; Serial connection I/O port address, divided by 4
  3320                              <1> 	.bSerialBaud			resb 	1	; Serial connection baud rate divisor
  3321                              <1> endstruc
  3322                              <1> 
  3323                              <1> ; On performance critical situations we compare DPT_ATA.bDevice without checking FLGH_DPT_SERIAL_DEVICE
  3324                              <1> ; first! DPT_ATA.bDevice uses small values so there will be no problems.
  3325                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  3326                              <1> 	%if DPT_SERIAL.bSerialPort <> DPT_ATA.bDevice
  3327                              <1> 		%error "DPT_ATA.bDevice and DPT_SERIAL.bSerialPort must be in same offsets!"
  3328                              <1> 	%endif
  3329                              <1> %endif
  3330                              <1> %endif ; MODULE_SERIAL
  3331                              <1> 
  3332                              <1> 
  3333                              <1> ; This is the common size for all DPTs. All DPTs must be equal size.
  3334                              <1> %ifdef MODULE_ADVANCED_ATA
  3335                              <1> 	LARGEST_DPT_SIZE			EQU		DPT_ADVANCED_ATA_size
  3336                              <1> %else
  3337                              <1> 	LARGEST_DPT_SIZE			EQU		DPT_ATA_size
  3338                              <1> %endif
  3339                              <1> 
  3340                              <1> 
  3341                              <1> 	; Number of Sectors per Track is fixed to 63 for LBA assist calculation.
  3342                              <1> 	; 1024 cylinders, 256 heads, 63 sectors = 8.4 GB limit (but DOS does not support more than 255 heads)
  3343                              <1> 	MAX_LCHS_CYLINDERS			EQU		1024
  3344                              <1> 	LBA_ASSIST_SPT				EQU		63
  3345                              <1> 
  3346                              <1> 
  3347                              <1> %endif ; CUSTOMDPT_INC
  3348                                  	%include "RomVars.inc"			; For ROMVARS and IDEVARS structs
  3349                              <1> ; Project name	:	XTIDE Universal BIOS
  3350                              <1> ; Description	:	Defines for ROMVARS struct containing variables stored
  3351                              <1> ;			in BIOS ROM.
  3352                              <1> 
  3353                              <1> ;
  3354                              <1> ; XTIDE Universal BIOS and Associated Tools
  3355                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3356                              <1> ;
  3357                              <1> ; This program is free software; you can redistribute it and/or modify
  3358                              <1> ; it under the terms of the GNU General Public License as published by
  3359                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3360                              <1> ; (at your option) any later version.
  3361                              <1> ;
  3362                              <1> ; This program is distributed in the hope that it will be useful,
  3363                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3364                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3365                              <1> ; GNU General Public License for more details.
  3366                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3367                              <1> ;
  3368                              <1> 
  3369                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
  3370                              <1> 
  3371                              <1> 
  3372                              <1> %ifndef ROMVARS_INC
  3373                              <1> %define ROMVARS_INC
  3374                              <1> 
  3375                              <1> ; ROM Variables. Written to the ROM image before flashing.
  3376                              <1> struc ROMVARS
  3377 00000000 <res 00000002>      <1> 	.wRomSign			resb	2	; ROM Signature (AA55h)
  3378 00000002 <res 00000001>      <1> 	.bRomSize			resb	1	; ROM size in 512 byte blocks
  3379 00000003 <res 00000003>      <1> 	.rgbJump			resb	3	; First instruction to ROM init (jmp)
  3380                              <1> 
  3381 00000006 <res 00000008>      <1> 	.rgbSign			resb	8	; Signature for XTIDE Configurator Program
  3382 0000000E <res 0000001F>      <1> 	.szTitle			resb	31	; BIOS title string
  3383 0000002D <res 00000019>      <1> 	.szVersion			resb	25	; BIOS version string
  3384                              <1> 
  3385 00000046 <res 00000002>      <1> 	.wFlags				resb	2	; Word for ROM flags
  3386 00000048 <res 00000002>      <1> 	.wDisplayMode			resb	2	; Display mode for boot menu
  3387 0000004A <res 00000002>      <1> 	.wBootTimeout			resb	2	; Boot Menu selection timeout in system timer ticks
  3388 0000004C <res 00000001>      <1> 	.bIdeCnt			resb	1	; Number of available IDE controllers
  3389 0000004D <res 00000001>      <1> 	.bBootDrv			resb	1	; Default drive to boot from
  3390 0000004E <res 00000001>      <1> 	.bMinFddCnt			resb	1	; Minimum number of Floppy Drives
  3391 0000004F <res 00000001>      <1> 	.bStealSize			resb	1	; Number of 1kB blocks stolen from 640kB base RAM
  3392 00000050 <res 00000001>      <1> 	.bIdleTimeout			resb	1	; Standby timer value
  3393                              <1> 
  3394                              <1> 	.ideVarsBegin:
  3395 00000051 <res 00000012>      <1> 	.ideVars0			resb	IDEVARS_size
  3396 00000063 <res 00000012>      <1> 	.ideVars1			resb	IDEVARS_size
  3397 00000075 <res 00000012>      <1> 	.ideVars2			resb	IDEVARS_size
  3398 00000087 <res 00000012>      <1> 	.ideVars3			resb	IDEVARS_size
  3399                              <1> 
  3400                              <1> %ifdef MODULE_SERIAL
  3401                              <1> 	.ideVarsSerialAuto		resb	IDEVARS_size
  3402                              <1> %endif
  3403                              <1> 
  3404                              <1> 	.ideVarsEnd:
  3405                              <1> endstruc
  3406                              <1> 
  3407                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  3408                              <1> 	%if ROMVARS.ideVarsEnd & 0xff00 <> 0
  3409                              <1> 		%error ".ideVars structures must fit within the first 256 bytes of the ROM image"
  3410                              <1> 	%endif
  3411                              <1> 	%if (ROMVARS.ideVarsEnd - ROMVARS.ideVarsBegin) = 0
  3412                              <1> 		%error "there must be at least one .ideVars structure, it would be bizarre if this were not true, but it is assumed in the ah0h reset code."
  3413                              <1> 	%endif
  3414                              <1> %endif
  3415                              <1> 
  3416                              <1> NUMBER_OF_IDEVARS					EQU	((ROMVARS.ideVarsEnd - ROMVARS.ideVarsBegin) / IDEVARS_size)
  3417                              <1> 
  3418                              <1> ; Bit defines for ROMVARS.wFlags
  3419                              <1> FLG_ROMVARS_FULLMODE					EQU	(1<<0)	; Full operating mode (steals base RAM, supports EBIOS etc.)
  3420                              <1> FLG_ROMVARS_SERIAL_SCANDETECT 				EQU	(1<<3)	; Scan COM ports at the end of drive detection.  Can also be invoked
  3421                              <1> 									; by holding down the ALT key at the end of drive detection.
  3422                              <1> 									; (Conveniently, this is 8, a fact we exploit when testing the bit)
  3423                              <1> 
  3424                              <1> ; Here in case the configuration needs to know functionality is present
  3425                              <1> FLG_ROMVARS_MODULE_FEATURE_SETS				EQU	(1<<5)
  3426                              <1> FLG_ROMVARS_MODULE_8BIT_IDE				EQU	(1<<6)
  3427                              <1> FLG_ROMVARS_MODULE_8BIT_IDE_ADVANCED			EQU	(1<<7)
  3428                              <1> FLG_ROMVARS_MODULE_ADVANCED_ATA				EQU	(1<<8)
  3429                              <1> FLG_ROMVARS_MODULE_BOOT_MENU				EQU	(1<<9)
  3430                              <1> FLG_ROMVARS_MODULE_EBIOS				EQU	(1<<10)
  3431                              <1> FLG_ROMVARS_MODULE_HOTKEYS				EQU	(1<<11)
  3432                              <1> FLG_ROMVARS_MODULE_IRQ					EQU	(1<<12)
  3433                              <1> FLG_ROMVARS_MODULE_SERIAL				EQU	(1<<13)
  3434                              <1> FLG_ROMVARS_MODULE_SERIAL_FLOPPY			EQU	(1<<14)
  3435                              <1> FLG_ROMVARS_MODULE_STRINGS_COMPRESSED			EQU	(1<<15)
  3436                              <1> 
  3437                              <1> 
  3438                              <1> ; Boot Menu Display Modes (see Assembly Library Display.inc for standard modes)
  3439                              <1> DEFAULT_TEXT_MODE					EQU	4
  3440                              <1> 
  3441                              <1> 
  3442                              <1> ; Controller specific variables
  3443                              <1> struc IDEVARS
  3444                              <1> ;;; Word 0
  3445                              <1> 	.wSerialPortAndBaud:						; Serial connection port (low, divided by 4) and baud rate divisor (high)
  3446                              <1> 	.wBasePort:							; IDE Base Port for Command Block (usual) Registers
  3447 00000000 <res 00000001>      <1> 	.bSerialPort					resb	1
  3448 00000001 <res 00000001>      <1> 	.bSerialBaud					resb	1
  3449                              <1> 
  3450                              <1> ;;; Word 1
  3451                              <1> 	.wControlBlockPort:
  3452                              <1> 	.bXTCFcontrolRegister:						; XT-CFv3 port used to initiate a DMA transfer
  3453 00000002 <res 00000001>      <1> 	.bSerialUnused					resb	1	; IDE Base Port for Control Block Registers
  3454                              <1> 
  3455                              <1> 	.wSerialCOMPortCharAndDevice:					; In DetectPrint, we grab the COM Port char and Device at the same time
  3456 00000003 <res 00000001>      <1> 	.bSerialCOMPortChar				resb	1	; Serial connection COM port number/letter
  3457                              <1> 
  3458                              <1> ;;; Word 2
  3459 00000004 <res 00000001>      <1> 	.bDevice					resb	1	; Device type
  3460 00000005 <res 00000001>      <1> 	.bIRQ						resb	1	; Interrupt Request Number
  3461                              <1> 
  3462                              <1> ;;; And more...
  3463 00000006 <res 00000006>      <1> 	.drvParamsMaster				resb	DRVPARAMS_size
  3464 0000000C <res 00000006>      <1> 	.drvParamsSlave					resb	DRVPARAMS_size
  3465                              <1> endstruc
  3466                              <1> 
  3467                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  3468                              <1> 	%if IDEVARS.bSerialCOMPortChar+1 != IDEVARS.bDevice
  3469                              <1> 		%error "IDEVARS.bSerialCOMPortChar needs to come immediately before IDEVARS.bDevice so that both bytes can be fetched at the same time inside DetectPrint.asm"
  3470                              <1> 	%endif
  3471                              <1> %endif
  3472                              <1> 
  3473                              <1> STANDARD_CONTROL_BLOCK_OFFSET				EQU		200h
  3474                              <1> XTIDE_CONTROL_BLOCK_OFFSET				EQU		8h	; for XTIDE, A3 is used to control selected register (CS0 vs CS1)
  3475                              <1> XTCF_CONTROL_BLOCK_OFFSET				EQU		10h	; and for XT-CF (all varients), it's A4
  3476                              <1> 
  3477                              <1> ; Default values for Port and PortCtrl, shared with the configurator
  3478                              <1> ;
  3479                              <1> DEVICE_XTIDE_DEFAULT_PORT				EQU		300h	; Also the default port for XT-CF
  3480                              <1> DEVICE_XTIDE_DEFAULT_PORTCTRL				EQU		(DEVICE_XTIDE_DEFAULT_PORT + XTIDE_CONTROL_BLOCK_OFFSET)
  3481                              <1> DEVICE_XTCF_DEFAULT_PORTCTRL				EQU		(DEVICE_XTIDE_DEFAULT_PORT + XTCF_CONTROL_BLOCK_OFFSET)
  3482                              <1> 
  3483                              <1> DEVICE_ATA_PRIMARY_PORT					EQU		1F0h
  3484                              <1> DEVICE_ATA_PRIMARY_PORTCTRL				EQU		(DEVICE_ATA_PRIMARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
  3485                              <1> 
  3486                              <1> DEVICE_ATA_SECONDARY_PORT				EQU		170h
  3487                              <1> DEVICE_ATA_SECONDARY_PORTCTRL				EQU		(DEVICE_ATA_SECONDARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
  3488                              <1> 
  3489                              <1> DEVICE_ATA_TERTIARY_PORT				EQU		1E8h
  3490                              <1> DEVICE_ATA_TERTIARY_PORTCTRL				EQU		(DEVICE_ATA_TERTIARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
  3491                              <1> 
  3492                              <1> DEVICE_ATA_QUATERNARY_PORT				EQU		168h
  3493                              <1> DEVICE_ATA_QUATERNARY_PORTCTRL				EQU		(DEVICE_ATA_QUATERNARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
  3494                              <1> 
  3495                              <1> 
  3496                              <1> ; Device types for IDEVARS.bDevice
  3497                              <1> ; IDE Devices are grouped so device numbers cannot be changed without modifying code elsewhere!
  3498                              <1> ;
  3499                              <1> COUNT_OF_STANDARD_IDE_DEVICES				EQU	2	; 16- and 32-bit controllers
  3500                              <1> COUNT_OF_8BIT_IDE_DEVICES				EQU	7
  3501                              <1> COUNT_OF_ALL_IDE_DEVICES				EQU	(COUNT_OF_8BIT_IDE_DEVICES + COUNT_OF_STANDARD_IDE_DEVICES)
  3502                              <1> ; Standard port mapped I/O
  3503                              <1> DEVICE_16BIT_ATA					EQU	(0<<1)
  3504                              <1> DEVICE_32BIT_ATA					EQU	(1<<1)
  3505                              <1> DEVICE_8BIT_ATA						EQU	((COUNT_OF_STANDARD_IDE_DEVICES+0)<<1)	; 16- or 32-bit controller in 8-bit mode
  3506                              <1> DEVICE_8BIT_XTIDE_REV1					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+1)<<1)
  3507                              <1> ; Address lines A0 and A3 are swapped
  3508                              <1> DEVICE_8BIT_XTIDE_REV2					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+2)<<1)	; Or rev 1 with swapped A0 and A3
  3509                              <1> ; IDE Register offsets are SHL 1
  3510                              <1> ; Note: ordering swapped to support XT-CFv3 and all other XT-CF derivatives
  3511                              <1> DEVICE_8BIT_XTCF_PIO8					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+3)<<1)	; XT-CF using 8-bit PIO mode
  3512                              <1> DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD			EQU	((COUNT_OF_STANDARD_IDE_DEVICES+4)<<1)	; XT-CF using 8-bit PIO mode, but with 16-bit instructions
  3513                              <1> DEVICE_8BIT_XTCF_DMA					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+5)<<1)	; XT-CFv3 using DMA
  3514                              <1> ; Memory Mapped I/O
  3515                              <1> DEVICE_8BIT_JRIDE_ISA					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+6)<<1)	; JR-IDE/ISA (Memory Mapped I/O)
  3516                              <1> ; Virtual devices
  3517                              <1> DEVICE_SERIAL_PORT					EQU	(COUNT_OF_ALL_IDE_DEVICES<<1)
  3518                              <1> 
  3519                              <1> 
  3520                              <1> 
  3521                              <1> ; Master/Slave drive specific parameters
  3522                              <1> struc DRVPARAMS
  3523 00000000 <res 00000002>      <1> 	.wFlags						resb	2	; Drive flags
  3524                              <1> 	.dwMaximumLBA:							; User specified maximum number of sectors
  3525 00000002 <res 00000002>      <1> 	.wCylinders					resb	2	; User specified cylinders (1...16383)
  3526                              <1> 	.wHeadsAndSectors:
  3527 00000004 <res 00000001>      <1> 	.bHeads						resb	1	; User specified Heads (1...16)
  3528 00000005 <res 00000001>      <1> 	.bSect						resb	1	; User specified Sectors per track (1...63)
  3529                              <1> endstruc
  3530                              <1> 
  3531                              <1> ; Bit defines for DRVPARAMS.wFlags
  3532                              <1> 	MASK_DRVPARAMS_WRITECACHE			EQU	(3<<0)	; Bits 0...1, Drive internal write cache settings (must start at bit 0)
  3533                              <1> 	DEFAULT_WRITE_CACHE				EQU	0	; Must be 0
  3534                              <1> 	DISABLE_WRITE_CACHE				EQU	1
  3535                              <1> 	ENABLE_WRITE_CACHE				EQU	2
  3536                              <1> 	MASK_DRVPARAMS_TRANSLATEMODE			EQU	(3<<TRANSLATEMODE_FIELD_POSITION)	; Bits 2...3, Position shared with DPT
  3537                              <1> 	TRANSLATEMODE_FIELD_POSITION			EQU	2
  3538                              <1> 	TRANSLATEMODE_NORMAL				EQU	0
  3539                              <1> 	TRANSLATEMODE_LARGE				EQU	1
  3540                              <1> 	TRANSLATEMODE_ASSISTED_LBA			EQU	2	; 28-bit or 48-bit LBA
  3541                              <1> 	TRANSLATEMODE_AUTO				EQU	3	; Only available in ROMVARS, not in DPTs
  3542                              <1> 	FLG_DRVPARAMS_BLOCKMODE				EQU	(1<<4)	; Enable Block mode transfers
  3543                              <1> 	FLG_DRVPARAMS_USERCHS				EQU	(1<<5)	; User specified P-CHS values
  3544                              <1> 	MAX_USER_CYLINDERS				EQU	16383
  3545                              <1> 	MAX_USER_HEADS					EQU	16
  3546                              <1> 	MAX_USER_SECTORS_PER_TRACK			EQU	63
  3547                              <1> 	FLG_DRVPARAMS_USERLBA				EQU	(1<<6)	; User specified LBA value
  3548                              <1> 	MIN_USER_LBA_COUNT				EQU	((MAX_USER_CYLINDERS*MAX_USER_HEADS*MAX_USER_SECTORS_PER_TRACK)+1)
  3549                              <1> 	MAX_USER_LBA_COUNT				EQU	((2^28)-1)
  3550                              <1> 
  3551                              <1> 
  3552                              <1> %endif ; ROMVARS_INC
  3553                                  	%include "RamVars.inc"			; For RAMVARS struct
  3554                              <1> ; Project name	:	XTIDE Universal BIOS
  3555                              <1> ; Description	:	RAMVARS struct containing BIOS variables stored in RAM.
  3556                              <1> 
  3557                              <1> ;
  3558                              <1> ; XTIDE Universal BIOS and Associated Tools
  3559                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3560                              <1> ;
  3561                              <1> ; This program is free software; you can redistribute it and/or modify
  3562                              <1> ; it under the terms of the GNU General Public License as published by
  3563                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3564                              <1> ; (at your option) any later version.
  3565                              <1> ;
  3566                              <1> ; This program is distributed in the hope that it will be useful,
  3567                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3568                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3569                              <1> ; GNU General Public License for more details.
  3570                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3571                              <1> ;
  3572                              <1> 
  3573                              <1> %ifndef RAMVARS_INC
  3574                              <1> %define RAMVARS_INC
  3575                              <1> 
  3576                              <1> ; Segment when RAMVARS is stored to top of interrupt vectors.
  3577                              <1> %ifndef USE_AT
  3578                              <1> 	LITE_MODE_RAMVARS_SEGMENT	EQU		30h
  3579                              <1> %endif
  3580                              <1> 
  3581                              <1> 
  3582                              <1> %ifdef MODULE_SERIAL_FLOPPY OR MODULE_DRIVEXLATE
  3583                              <1> 	%define NEED_XLATEVARS
  3584                              <1> %endif
  3585                              <1> 
  3586                              <1> 
  3587                              <1> ; RAM Variables.
  3588                              <1> ; Variables should be kept to minimum since they might be located
  3589                              <1> ; at the top of interrupt vectors.
  3590                              <1> struc RAMVARS
  3591                              <1> %ifdef RELOCATE_INT13H_STACK
  3592                              <1> 						resb	252
  3593                              <1> 	.dwStackChangeDSDI:
  3594                              <1> 	.wStackChangeDI		resb	2	; Used during stack
  3595                              <1> 	.wStackChangeDS		resb	2	; switching only
  3596                              <1> 	.rgbTopOfStack:					; 256 bytes of stack
  3597                              <1> 	.fpInt13hEntryStack	resb	4
  3598                              <1> %endif
  3599                              <1> 	.wDrvDetectSignature:			; Signature when BIOS is in drive detection mode
  3600 00000000 <res 00000004>      <1> 	.fpOldI13h			resb	4	; Far pointer to old INT 13h handler
  3601 00000004 <res 00000002>      <1> 	.wSignature			resb	2	; Sign for finding stolen 1...64 kiB
  3602 00000006 <res 00000001>      <1> 	.bTimeoutTicksLeft	resb	1
  3603 00000007 <res 00000001>      <1> 	.bLastTimeoutUpdate	resb	1
  3604                              <1> 
  3605                              <1> 	.wFirstDrvAndCount:
  3606 00000008 <res 00000001>      <1> 	.bFirstDrv			resb	1	; Number of first drive for this BIOS
  3607                              <1> 	.wDrvCntAndFlopCnt:				; Both the hard disk and floppy counts in one word
  3608                              <1> 									; (yes, misaligned, but it is only used this way during initialization)
  3609 00000009 <res 00000001>      <1> 	.bDrvCnt			resb	1	; Number of drives handled by this BIOS
  3610                              <1> 
  3611                              <1> 	; Variables for drive number translation
  3612                              <1> %ifdef NEED_XLATEVARS
  3613                              <1> 	.xlateVars			resb	XLATEVARS_size
  3614                              <1> %endif
  3615                              <1> endstruc
  3616                              <1> 
  3617                              <1> ; Note!!! .wDrvDetectSignature and .wSignature are intentionally in different locations.
  3618                              <1> RAMVARS_RAM_SIGNATURE			EQU	"Xu"	; RAMVARS signature for .wSignature
  3619                              <1> RAMVARS_DRV_DETECT_SIGNATURE	EQU	5A5Ah	; Signature when BIOS is in drive detection mode
  3620                              <1> 
  3621                              <1> 
  3622                              <1> %ifdef NEED_XLATEVARS
  3623                              <1> ; Variables for translating drive numbers.
  3624                              <1> 	struc XLATEVARS
  3625                              <1> 	%ifdef MODULE_SERIAL_FLOPPY
  3626                              <1> 		.bFlopCreateCnt:
  3627                              <1> 		.bFlopCntAndFirst	resb	1	; Normally, packed starting floppy drive number (high order 7 bits)
  3628                              <1> 										; and number of drives (low order bit, max 2 drives supported).
  3629                              <1> 										; During initialization, until the end of DetectDrives_FromAllIDEControllers,
  3630                              <1> 										; this byte contains the raw number of floppy drives seen
  3631                              <1> 										; (using .bFlopCreateCnt)
  3632                              <1> 	%else
  3633                              <1> 							resb	1	; alignment
  3634                              <1> 	%endif
  3635                              <1> 
  3636                              <1> 	%ifdef MODULE_DRIVEXLATE
  3637                              <1> 		.bXlatedDrv			resb	1	; Drive number after translation
  3638                              <1> 		.wFDandHDswap:
  3639                              <1> 		.bFDSwap			resb	1	; Floppy Drive to swap to 00h and vice versa
  3640                              <1> 		.bHDSwap			resb	1	; Hard Drive to swap to 80h and vice versa
  3641                              <1> 	%else
  3642                              <1> 							resb	1	; alignment
  3643                              <1> 	%endif
  3644                              <1> 	endstruc
  3645                              <1> %endif
  3646                              <1> 
  3647                              <1> %ifdef MODULE_SERIAL_FLOPPY
  3648                              <1>   %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  3649                              <1> 	%if RAMVARS.xlateVars != RAMVARS.bDrvCnt+1 || XLATEVARS.bFlopCreateCnt != 0
  3650                              <1> 		%error "bFlopCreateCnt needs to be the first thing in XLATEVARS, and .xlateVars needs to come immediately after .bDrvCnt.  In at least one place, we read .wDrvCntAndFlopCnt to get both counts in one fetch"
  3651                              <1> 	%endif
  3652                              <1>   %endif
  3653                              <1> %endif
  3654                              <1> 
  3655                              <1> 
  3656                              <1> 
  3657                              <1> ;
  3658                              <1> ; IDEPACK NOTE: The first six bytes of this structure are directly put on the
  3659                              <1> ; wire for MODULE_SERIAL, please do not change the order or insert other members.
  3660                              <1> ;
  3661                              <1> struc IDEPACK	; PIOVARS and MEMPIOVARS overwrite the first 7 bytes
  3662 00000000 <res 00000001>      <1> 	.bFeatures				resb	1
  3663 00000001 <res 00000001>      <1> 	.bDrvAndHead			resb	1	; LBA28 27...24
  3664                              <1> 
  3665                              <1> 	.wSectorCountAndLbaLow:
  3666 00000002 <res 00000001>      <1> 	.bSectorCount			resb	1
  3667                              <1> 	.bSectorNumber:
  3668 00000003 <res 00000001>      <1> 	.bLbaLow				resb	1	; LBA 7...0
  3669                              <1> 
  3670                              <1> 	.wCylinder:
  3671                              <1> 	.wLbaMiddleAndHigh:
  3672 00000004 <res 00000001>      <1> 	.bLbaMiddle				resb	1	; LBA 15...8
  3673 00000005 <res 00000001>      <1> 	.bLbaHigh				resb	1	; LBA 23...16
  3674                              <1> 
  3675 00000006 <res 00000001>      <1> 	.bCommand				resb	1
  3676 00000007 <res 00000001>      <1> 	.bDeviceControl			resb	1	; Offset 7 shared with PIOVARS and MEMPIOVARS
  3677 00000008 <res 00000001>      <1> 							resb	1	; Used by PIOVARS and MEMPIOVARS
  3678                              <1> 
  3679                              <1> %ifdef MODULE_EBIOS
  3680                              <1> 	; Parameters for 48-bit LBA
  3681                              <1> 	.bLbaLowExt				resb	1	; LBA48 31...24
  3682                              <1> 	.wLbaMiddleAndHighExt:
  3683                              <1> 	.bLbaMiddleExt			resb	1	; LBA48 39...32
  3684                              <1> 	.bLbaHighExt			resb	1	; LBA48 47...40
  3685                              <1> %endif
  3686                              <1> 
  3687 00000009 <res 0000001A>      <1> 	.intpack				resb	INTPACK_size
  3688                              <1> endstruc
  3689                              <1> 
  3690                              <1> SIZE_OF_IDEPACK_WITHOUT_INTPACK		EQU	(IDEPACK_size - INTPACK_size)
  3691                              <1> 
  3692                              <1> 
  3693                              <1> %endif ; RAMVARS_INC
  3694                                  	%include "BootVars.inc"			; For BOOTVARS struct
  3695                              <1> ; Project name	:	XTIDE Universal BIOS
  3696                              <1> ; Description	:	Defines for BOOTVARS struct used by boot menu
  3697                              <1> ;					and drive initialization.
  3698                              <1> 
  3699                              <1> ;
  3700                              <1> ; XTIDE Universal BIOS and Associated Tools
  3701                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3702                              <1> ;
  3703                              <1> ; This program is free software; you can redistribute it and/or modify
  3704                              <1> ; it under the terms of the GNU General Public License as published by
  3705                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3706                              <1> ; (at your option) any later version.
  3707                              <1> ;
  3708                              <1> ; This program is distributed in the hope that it will be useful,
  3709                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3710                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3711                              <1> ; GNU General Public License for more details.
  3712                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3713                              <1> ;
  3714                              <1> 
  3715                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
  3716                              <1> 
  3717                              <1> %ifndef BOOTVARS_INC
  3718                              <1> %define BOOTVARS_INC
  3719                              <1> 
  3720                              <1> ; Default drives
  3721                              <1> DEFAULT_FLOPPY_DRIVE_LETTER				EQU	'A'
  3722                              <1> DEFAULT_HARD_DRIVE_LETTER				EQU	'C'
  3723                              <1> 
  3724                              <1> ; Number of times to retry booting before accepting error
  3725                              <1> BOOT_READ_RETRY_TIMES		EQU		3
  3726                              <1> 
  3727                              <1> 
  3728                              <1> 
  3729                              <1> ; Pre-boot variables. These do not exist after successful boot to OS.
  3730                              <1> ; Segment is always 0000h, same as BDA segment
  3731                              <1> struc BOOTVARS
  3732 00000000 <res 00007C00>      <1> 						resb	7C00h
  3733                              <1> 	.rgbAtaInfo:						; 7C00h, ATA Information for drive detection
  3734 00007C00 <res 00000200>      <1> 	.rgbBootSect		resb 	512		; 7C00h, Boot sector
  3735 00007E00 <res 00000100>      <1> 						resb	256		; Boot Menu stack
  3736                              <1> 	.rgbMnuStack:
  3737 00007F00 <res 00000004>      <1> 	.dwPostStack		resb	4		; POST stack pointer when entering INT 19h
  3738                              <1> 
  3739                              <1> %ifdef MODULE_8BIT_IDE
  3740 00007F04 <res 00000002>      <1> 	.wNextXTCFportToScan	resb	2	; Needed for XT-CF port autodetection
  3741                              <1> %endif
  3742                              <1> %ifdef MODULE_HOTKEYS
  3743                              <1> 	.hotkeyVars				resb	HOTKEYVARS_size
  3744                              <1> %endif
  3745                              <1> 	.rgDrvDetectInfo:					; Array containing DRVDETECTINFO structs
  3746                              <1> endstruc
  3747                              <1> 
  3748                              <1> 
  3749                              <1> %ifdef MODULE_HOTKEYS
  3750                              <1> 
  3751                              <1> struc HOTKEYVARS
  3752                              <1> 	.wTimeWhenDisplayed	resb	2		; System time (ticks) when Hotkey bar was first displayed
  3753                              <1> 	.wFddAndHddLetters:
  3754                              <1> 	.bFddLetter			resb	1		; Floppy Drive letter hotkey (upper case)
  3755                              <1> 	.bHddLetter			resb	1		; Hard Drive letter hotkey (upper case). Must be after .bFddLetter!
  3756                              <1> 	.bFlags				resb	1		; Must be just after .bHddLetter!  (dependency in Hotkeybar.asm)
  3757                              <1> 	.bScancode			resb	1		; Function hotkey scancode, must be just after .bFlags!
  3758                              <1> endstruc
  3759                              <1> 
  3760                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  3761                              <1> %if HOTKEYVARS.bFddLetter+1 != HOTKEYVARS.bHddLetter || HOTKEYVARS.bHddLetter+1 != HOTKEYVARS.bFlags || HOTKEYVARS.bFlags+1 != HOTKEYVARS.bScancode
  3762                              <1> %error "HOTKEYVARS: bytes need to come in the order .bFddLetter, then .bHddLetter, then .bFlags, then .bScancode"
  3763                              <1> %endif
  3764                              <1> %endif
  3765                              <1> 
  3766                              <1> ; Bit defines for HOTKEYVARS.bFlags
  3767                              <1> FLG_HOTKEY_HD_FIRST			EQU		(1<<0)	; First try to boot from HDD, then FDD
  3768                              <1> 
  3769                              <1> %endif ; MODULE_HOTKEYS
  3770                              <1> 
  3771                              <1> struc DRVDETECTINFO
  3772                              <1> 	.StartOfDrvDetectInfo:
  3773 00000000 <res 0000001E>      <1> 	.szDrvName				resb	MAX_HARD_DISK_NAME_LENGTH
  3774 0000001E <res 00000002>      <1> 							resb	2	; Zero word (ensures string terminates)
  3775 00000020 <res 00000002>      <1> 	.wInitErrorFlags		resb	2	; Errors during initialization
  3776                              <1> 
  3777                              <1> 	; DRVDETECTINFO's size must be an even multiple of DPT's size
  3778 00000022 <res 00000008>      <1> 	.EndOfDriveDetectInfo:	resb	LARGEST_DPT_SIZE - (.EndOfDriveDetectInfo % LARGEST_DPT_SIZE)
  3779                              <1> endstruc
  3780                              <1> 
  3781                              <1> ; Boot Menu Information Table. These are generated for all XTIDE Universal
  3782                              <1> ; BIOS drives. Available only until boot is successful.
  3783                              <1> MAX_HARD_DISK_NAME_LENGTH			EQU		30		; Bytes reserved for drive name
  3784                              <1> DPT_DRVDETECTINFO_SIZE_MULTIPLIER	EQU		DRVDETECTINFO_size / LARGEST_DPT_SIZE
  3785                              <1> 
  3786                              <1> 
  3787                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  3788                              <1> 
  3789                              <1> %if MAX_HARD_DISK_NAME_LENGTH % 2 <> 0
  3790                              <1> 	%error "MAX_HARD_DISK_NAME_LENGTH needs to be a multiple of 2, memory is moved with word operations."
  3791                              <1> %endif
  3792                              <1> 
  3793                              <1> %if DRVDETECTINFO_size % LARGEST_DPT_SIZE <> 0
  3794                              <1> 	%error "DRVDETECTINFO's size must be an even multiple of DPT's size.  Add or remove padding at the bottom of DRVDETECTINFO to bring the two sizes into alignment.  As DRVDETECTINFO is only used at boot time, with pl
  3795                              <1> %endif
  3796                              <1> 
  3797                              <1> %if DRVDETECTINFO.szDrvName <> 0
  3798                              <1> 	%error "DRVDETECTINFO.szDrvName is assumed to be the first member of struc DRVDETECTINFO, in BootMenuPrint_RefreshItem"
  3799                              <1> %endif
  3800                              <1> 
  3801                              <1> %endif
  3802                              <1> 
  3803                              <1> 
  3804                              <1> ;--------------------------------------------------------------------
  3805                              <1> ; Stores POST stack pointer to BOOTVARS.
  3806                              <1> ;
  3807                              <1> ; STORE_POST_STACK_POINTER
  3808                              <1> ;	Parameters:
  3809                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  3810                              <1> ;	Returns:
  3811                              <1> ;		Nothing
  3812                              <1> ;	Corrupts registers:
  3813                              <1> ;		Nothing
  3814                              <1> ;--------------------------------------------------------------------
  3815                              <1> %macro STORE_POST_STACK_POINTER 0
  3816                              <1> 	mov		[es:BOOTVARS.dwPostStack], sp
  3817                              <1> 	mov		[es:BOOTVARS.dwPostStack+2], ss
  3818                              <1> %endmacro
  3819                              <1> 
  3820                              <1> 
  3821                              <1> ;--------------------------------------------------------------------
  3822                              <1> ; Initializes stack for boot menu usage.
  3823                              <1> ; POST stack is not large enough when DPTs are stored to 30:0h.
  3824                              <1> ;
  3825                              <1> ; Note regarding LOAD_BDA_SEGMENT_TO: If you force the use of SP
  3826                              <1> ; then you also have to unconditionally enable the CLI/STI pair.
  3827                              <1> ; The reason for this is that only some buggy 808x CPU:s need the
  3828                              <1> ; CLI/STI instruction pair when changing stacks. Other CPU:s disable
  3829                              <1> ; interrupts automatically when SS is modified for the duration of
  3830                              <1> ; the immediately following instruction to give time to change SP.
  3831                              <1> ;
  3832                              <1> ; SWITCH_TO_BOOT_MENU_STACK
  3833                              <1> ;	Parameters:
  3834                              <1> ;		Nothing
  3835                              <1> ;	Returns:
  3836                              <1> ;		SS:SP:	Pointer to top of Boot Menu stack
  3837                              <1> ;	Corrupts registers:
  3838                              <1> ;		Nothing
  3839                              <1> ;--------------------------------------------------------------------
  3840                              <1> %macro SWITCH_TO_BOOT_MENU_STACK 0
  3841                              <1> %ifndef USE_186
  3842                              <1> 	cli									; Disable interrupts
  3843                              <1> %endif
  3844                              <1> 	LOAD_BDA_SEGMENT_TO	ss, sp
  3845                              <1> 	mov		sp, BOOTVARS.rgbMnuStack	; Load offset to stack
  3846                              <1> %ifndef USE_186
  3847                              <1> 	sti									; Enable interrupts
  3848                              <1> %endif
  3849                              <1> %endmacro
  3850                              <1> 
  3851                              <1> 
  3852                              <1> ;--------------------------------------------------------------------
  3853                              <1> ; Restores SS and SP to initial boot loader values.
  3854                              <1> ;
  3855                              <1> ; Note! Must return with AX=0 and CF preserved.
  3856                              <1> ; See Int19hMenu_JumpToBootSector_or_RomBoot.
  3857                              <1> ;
  3858                              <1> ; SWITCH_BACK_TO_POST_STACK
  3859                              <1> ;	Parameters:
  3860                              <1> ;		AX:		BDA and Interrupt Vector segment (zero)
  3861                              <1> ;	Returns:
  3862                              <1> ;		SS:SP:	Ptr to POST stack
  3863                              <1> ;	Corrupts registers:
  3864                              <1> ;		Nothing (not even FLAGS)
  3865                              <1> ;--------------------------------------------------------------------
  3866                              <1> %macro SWITCH_BACK_TO_POST_STACK 0
  3867                              <1> %ifndef USE_386
  3868                              <1> 	cli
  3869                              <1> 	mov		ss, ax
  3870                              <1> 	mov		sp, [ss:BOOTVARS.dwPostStack]
  3871                              <1> 	mov		ss, [ss:BOOTVARS.dwPostStack+2]
  3872                              <1> 	sti
  3873                              <1> %else
  3874                              <1> 	mov		ss, ax
  3875                              <1> 	lss		sp, [ss:BOOTVARS.dwPostStack]
  3876                              <1> %endif
  3877                              <1> %endmacro
  3878                              <1> 
  3879                              <1> 
  3880                              <1> %endif ; BOOTVARS_INC
  3881                                  	%include "IdeIO.inc"			; Macros for IDE port I/O
  3882                              <1> ; Project name	:	XTIDE Universal BIOS
  3883                              <1> ; Description	:	Macros for normal I/O mapped ATA controllers.
  3884                              <1> 
  3885                              <1> ;
  3886                              <1> ; XTIDE Universal BIOS and Associated Tools
  3887                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3888                              <1> ;
  3889                              <1> ; This program is free software; you can redistribute it and/or modify
  3890                              <1> ; it under the terms of the GNU General Public License as published by
  3891                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3892                              <1> ; (at your option) any later version.
  3893                              <1> ;
  3894                              <1> ; This program is distributed in the hope that it will be useful,
  3895                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3896                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3897                              <1> ; GNU General Public License for more details.
  3898                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3899                              <1> ;
  3900                              <1> 
  3901                              <1> %ifndef IDE_IO_INC
  3902                              <1> %define IDE_IO_INC
  3903                              <1> 
  3904                              <1> ;--------------------------------------------------------------------
  3905                              <1> ; OUTPUT_AL_TO_IDE_REGISTER
  3906                              <1> ; OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER
  3907                              <1> ;	Parameters:
  3908                              <1> ;		AL:		Byte to output
  3909                              <1> ;		%1:		IDE Register				(OUTPUT_AL_TO_IDE_REGISTER)
  3910                              <1> ;				IDE Control Block Register	(OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER)
  3911                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
  3912                              <1> ;	Returns:
  3913                              <1> ;		Nothing
  3914                              <1> ;	Corrupts registers:
  3915                              <1> ;		BX, DX
  3916                              <1> ;--------------------------------------------------------------------
  3917                              <1> %macro OUTPUT_AL_TO_IDE_REGISTER 1
  3918                              <1> %ifndef MODULE_8BIT_IDE	; Standard IDE controllers only
  3919                              <1> 
  3920                              <1> 	%ifnidni %1, dx
  3921                              <1> 		mov		dx, %1
  3922                              <1> 	%endif
  3923                              <1> 	add		dx, [di+DPT.wBasePort]
  3924                              <1> 	out		dx, al
  3925                              <1> 
  3926                              <1> %else	; Register translations required
  3927                              <1> 
  3928                              <1> 	%ifnidni %1, dl
  3929                              <1> 		mov		dl, %1
  3930                              <1> 	%endif
  3931                              <1> 	call	IdeIO_OutputALtoIdeRegisterInDL
  3932                              <1> 
  3933                              <1> %endif
  3934                              <1> %endmacro
  3935                              <1> 
  3936                              <1> 
  3937                              <1> %macro OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER 1
  3938                              <1> %ifndef MODULE_8BIT_IDE	; Standard IDE controllers only
  3939                              <1> 
  3940                              <1> 	%ifnidni %1, dx
  3941                              <1> 		mov		dx, %1
  3942                              <1> 	%endif
  3943                              <1> 	eMOVZX	bx, BYTE [di+DPT.bIdevarsOffset]
  3944                              <1> 	add		dx, [cs:bx+IDEVARS.wControlBlockPort]
  3945                              <1> 	out		dx, al
  3946                              <1> 
  3947                              <1> %else	; Register translations required
  3948                              <1> 
  3949                              <1> 	%ifnidni %1, dl
  3950                              <1> 		mov		dl, %1
  3951                              <1> 	%endif
  3952                              <1> 	call	IdeIO_OutputALtoIdeControlBlockRegisterInDL
  3953                              <1> 
  3954                              <1> %endif
  3955                              <1> %endmacro
  3956                              <1> 
  3957                              <1> 
  3958                              <1> ;--------------------------------------------------------------------
  3959                              <1> ; INPUT_TO_AL_FROM_IDE_REGISTER
  3960                              <1> ;	Parameters:
  3961                              <1> ;		%1:		IDE Register
  3962                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
  3963                              <1> ;	Returns:
  3964                              <1> ;		AL:		Inputted byte
  3965                              <1> ;	Corrupts registers:
  3966                              <1> ;		BX, DX
  3967                              <1> ;--------------------------------------------------------------------
  3968                              <1> %macro INPUT_TO_AL_FROM_IDE_REGISTER 1
  3969                              <1> %ifndef MODULE_8BIT_IDE	; Standard IDE controllers only
  3970                              <1> 
  3971                              <1> 	%ifnidni %1, dx
  3972                              <1> 		mov		dx, %1
  3973                              <1> 	%endif
  3974                              <1> 	add		dx, [di+DPT.wBasePort]
  3975                              <1> 	in		al, dx
  3976                              <1> 
  3977                              <1> %else	; Register translations required
  3978                              <1> 
  3979                              <1> 	%ifnidni %1, dl
  3980                              <1> 		mov		dl, %1
  3981                              <1> 	%endif
  3982                              <1> 		call	IdeIO_InputToALfromIdeRegisterInDL
  3983                              <1> 
  3984                              <1> %endif
  3985                              <1> %endmacro
  3986                              <1> 
  3987                              <1> 
  3988                              <1> %endif ; IDE_IO_INC
  3989                                  	%include "DeviceIDE.inc"		; For IDE device equates
  3990                              <1> ; Project name	:	XTIDE Universal BIOS
  3991                              <1> ; Description	:	Device specific equates for IDE drives.
  3992                              <1> 
  3993                              <1> ;
  3994                              <1> ; XTIDE Universal BIOS and Associated Tools
  3995                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3996                              <1> ;
  3997                              <1> ; This program is free software; you can redistribute it and/or modify
  3998                              <1> ; it under the terms of the GNU General Public License as published by
  3999                              <1> ; the Free Software Foundation; either version 2 of the License, or
  4000                              <1> ; (at your option) any later version.
  4001                              <1> ;
  4002                              <1> ; This program is distributed in the hope that it will be useful,
  4003                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4004                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4005                              <1> ; GNU General Public License for more details.
  4006                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  4007                              <1> ;
  4008                              <1> 
  4009                              <1> %ifndef DEVICEIDE_INC
  4010                              <1> %define DEVICEIDE_INC
  4011                              <1> 
  4012                              <1> ; Reset delays
  4013                              <1> HSR0_RESET_WAIT_US		EQU		6		; Delay must be at least 5 us
  4014                              <1> HSR1_RESET_WAIT_US		EQU		2100	; Delay must be at least 2 ms
  4015                              <1> 
  4016                              <1> ; Polling timeout delays (system timer ticks, 1 tick = 54.9 ms)
  4017                              <1> TIMEOUT_DRQ				EQU		255			;   14 s (some CF cards occasionally have long write delays)
  4018                              <1> TIMEOUT_SELECT_DRIVE_DURING_DRIVE_DETECTION	EQU	(500/55)	;  500 ms
  4019                              <1> TIMEOUT_MOTOR_STARTUP	EQU		(10000/55)	;   10 s
  4020                              <1> TIMEOUT_MAXIMUM			EQU		255			; We would actually want 31 seconds here but I don't think there are so slow drives
  4021                              <1> 
  4022                              <1> %ifdef MODULE_FEATURE_SETS
  4023                              <1> 	TIMEOUT_BSY			EQU		TIMEOUT_MOTOR_STARTUP
  4024                              <1> 	TIMEOUT_DRDY		EQU		TIMEOUT_MOTOR_STARTUP
  4025                              <1> %else
  4026                              <1> 	TIMEOUT_BSY			EQU		(2600/55)	; 2600 ms
  4027                              <1> 	TIMEOUT_DRDY		EQU		(2600/55)	; 2600 ms
  4028                              <1> %endif
  4029                              <1> 
  4030                              <1> %endif ; DEVICEIDE_INC
  4031                                  
  4032                                  
  4033                                  
  4034                                  ; Section containing code
  4035                                  SECTION .text
  4036                                  
  4037                                  ; ROM variables (must start at offset 0)
  4038                                  CNT_ROM_BLOCKS		EQU		BIOS_SIZE / 512		; number of 512B blocks, 16 = 8kB BIOS
  4039                                  istruc ROMVARS
  4040 00000000 55AA                    	at	ROMVARS.wRomSign,	dw	0AA55h			; PC ROM signature
  4041 00000002 10                      	at	ROMVARS.bRomSize,	db	CNT_ROM_BLOCKS	; ROM size in 512B blocks
  4042 00000003 E96A03                  	at	ROMVARS.rgbJump,	jmp	Initialize_FromMainBiosRomSearch
  4043 00000006 5854494445323033        	at	ROMVARS.rgbSign,	db	FLASH_SIGNATURE
  4044 0000000E 2D3D58544944452055-     	at	ROMVARS.szTitle,	db	TITLE_STRING
  4045 00000017 6E6976657273616C20-
  4046 00000020 42494F532028585429-
  4047 00000029 3D2D00             
  4048 0000002C 0076322E302E30E133-     	at	ROMVARS.szVersion,	db	ROM_VERSION_STRING
  4049 00000035 2B2028323031332D30-
  4050 0000003E 342D30332900       
  4051                                  
  4052                                  ;---------------------------;
  4053                                  ; AT Build default settings ;
  4054                                  ;---------------------------;
  4055                                  %ifdef USE_AT
  4056                                  	at	ROMVARS.wFlags,			dw	FLG_ROMVARS_FULLMODE | MASK_ROMVARS_INCLUDED_MODULES
  4057                                  	at	ROMVARS.wDisplayMode,	dw	DEFAULT_TEXT_MODE
  4058                                  %ifdef MODULE_BOOT_MENU
  4059                                  	at	ROMVARS.wBootTimeout,	dw	BOOT_MENU_DEFAULT_TIMEOUT
  4060                                  %endif
  4061                                  	at	ROMVARS.bIdeCnt,		db	2						; Number of supported controllers
  4062                                  	at	ROMVARS.bBootDrv,		db	80h						; Boot Menu default drive
  4063                                  	at	ROMVARS.bMinFddCnt, 	db	0						; Do not force minimum number of floppy drives
  4064                                  	at	ROMVARS.bStealSize,		db	1						; Steal 1kB from base memory
  4065                                  	at	ROMVARS.bIdleTimeout,	db	0						; Standby timer disabled by default
  4066                                  
  4067                                  	at	ROMVARS.ideVars0+IDEVARS.wBasePort,			dw	DEVICE_ATA_PRIMARY_PORT 		; Controller Command Block base port
  4068                                  	at	ROMVARS.ideVars0+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_PRIMARY_PORTCTRL 	; Controller Control Block base port
  4069                                  	at	ROMVARS.ideVars0+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
  4070                                  	at	ROMVARS.ideVars0+IDEVARS.bIRQ,				db	14
  4071                                  	at	ROMVARS.ideVars0+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4072                                  	at	ROMVARS.ideVars0+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4073                                  
  4074                                  	at	ROMVARS.ideVars1+IDEVARS.wBasePort,			dw	DEVICE_ATA_SECONDARY_PORT
  4075                                  	at	ROMVARS.ideVars1+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_SECONDARY_PORTCTRL
  4076                                  	at	ROMVARS.ideVars1+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
  4077                                  	at	ROMVARS.ideVars1+IDEVARS.bIRQ,				db	15
  4078                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4079                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4080                                  
  4081                                  	at	ROMVARS.ideVars2+IDEVARS.wBasePort,			dw	DEVICE_ATA_TERTIARY_PORT
  4082                                  	at	ROMVARS.ideVars2+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_TERTIARY_PORTCTRL
  4083                                  	at	ROMVARS.ideVars2+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
  4084                                  	at	ROMVARS.ideVars2+IDEVARS.bIRQ,				db	0
  4085                                  	at	ROMVARS.ideVars2+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4086                                  	at	ROMVARS.ideVars2+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4087                                  
  4088                                  	at	ROMVARS.ideVars3+IDEVARS.wBasePort,			dw	DEVICE_ATA_QUATERNARY_PORT
  4089                                  	at	ROMVARS.ideVars3+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_QUATERNARY_PORTCTRL
  4090                                  	at	ROMVARS.ideVars3+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
  4091                                  	at	ROMVARS.ideVars3+IDEVARS.bIRQ,				db	0
  4092                                  	at	ROMVARS.ideVars3+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4093                                  	at	ROMVARS.ideVars3+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4094                                  
  4095                                  %ifdef MODULE_SERIAL
  4096                                  	at	ROMVARS.ideVarsSerialAuto+IDEVARS.bDevice,		db	DEVICE_SERIAL_PORT
  4097                                  %endif
  4098                                  %else
  4099                                  ;-----------------------------------;
  4100                                  ; XT and XT+ Build default settings ;
  4101                                  ;-----------------------------------;
  4102 00000044 00<rept>4080            	at	ROMVARS.wFlags,			dw	MASK_ROMVARS_INCLUDED_MODULES
  4103 00000048 0400                    	at	ROMVARS.wDisplayMode,	dw	DEFAULT_TEXT_MODE
  4104                                  %ifdef MODULE_BOOT_MENU
  4105                                  	at	ROMVARS.wBootTimeout,	dw	BOOT_MENU_DEFAULT_TIMEOUT
  4106                                  %endif
  4107                                  %ifdef MODULE_8BIT_IDE_ADVANCED
  4108                                  	at	ROMVARS.bIdeCnt,		db	2						; Number of supported controllers
  4109                                  %else
  4110 0000004A 00<rept>01              	at  ROMVARS.bIdeCnt,		db	1
  4111                                  %endif
  4112 0000004D 80                      	at	ROMVARS.bBootDrv,		db	80h						; Boot Menu default drive
  4113 0000004E 00                      	at	ROMVARS.bMinFddCnt, 	db	0						; Do not force minimum number of floppy drives
  4114 0000004F 01                      	at	ROMVARS.bStealSize,		db	1						; Steal 1kB from base memory in full mode
  4115 00000050 00                      	at	ROMVARS.bIdleTimeout,	db	0						; Standby timer disabled by default
  4116                                  
  4117 00000051 0003                    	at	ROMVARS.ideVars0+IDEVARS.wBasePort,			dw	DEVICE_XTIDE_DEFAULT_PORT			; Controller Command Block base port
  4118 00000053 0803                    	at	ROMVARS.ideVars0+IDEVARS.wControlBlockPort,	dw	DEVICE_XTIDE_DEFAULT_PORTCTRL		; Controller Control Block base port
  4119 00000055 06                      	at	ROMVARS.ideVars0+IDEVARS.bDevice,			db	DEVICE_8BIT_XTIDE_REV1
  4120 00000056 001D                    	at	ROMVARS.ideVars0+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4121 00000058 00<rept>1D              	at	ROMVARS.ideVars0+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4122                                  
  4123                                  %ifdef MODULE_8BIT_IDE_ADVANCED
  4124                                  	at	ROMVARS.ideVars1+IDEVARS.bXTCFcontrolRegister,	db	XTCF_8BIT_PIO_MODE
  4125                                  	at	ROMVARS.ideVars1+IDEVARS.bDevice,				db	DEVICE_8BIT_XTCF_PIO8
  4126                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4127                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4128                                  %else
  4129 0000005E 00<rept>1D              	at	ROMVARS.ideVars1+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4130 0000006A 00<rept>1D              	at	ROMVARS.ideVars1+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4131                                  %endif
  4132                                  
  4133 00000070 00<rept>1D              	at	ROMVARS.ideVars2+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4134 0000007C 00<rept>1D              	at	ROMVARS.ideVars2+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4135                                  
  4136 00000082 00<rept>1D              	at	ROMVARS.ideVars3+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4137 0000008E 00<rept>1D              	at	ROMVARS.ideVars3+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4138                                  
  4139                                  %ifdef MODULE_SERIAL
  4140                                  	at	ROMVARS.ideVarsSerialAuto+IDEVARS.bDevice,		db	DEVICE_SERIAL_PORT
  4141                                  %endif
  4142                                  %endif
  4143 00000094 00<rept>                iend
  4144                                  
  4145                                  	; Strings are first to avoid them moving unnecessarily when code is turned on and off with %ifdef's
  4146                                  	; since some groups of strings need to be on the same 256-byte page.
  4147                                  	;
  4148                                  %ifdef MODULE_STRINGS_COMPRESSED
  4149                                  	%define STRINGSCOMPRESSED_STRINGS
  4150                                  	%include "StringsCompressed.asm"
  4151                              <1> ;;;======================================================================
  4152                              <1> ;;;
  4153                              <1> ;;; This file is generated by StringsCompress.pl from source in Strings.asm
  4154                              <1> ;;; DO NOT EDIT DIRECTLY - See the makefile for how to rebuild this file.
  4155                              <1> ;;; This file only needs to be rebuilt if Strings.asm is changed.
  4156                              <1> ;;;
  4157                              <1> ;;;======================================================================
  4158                              <1> 
  4159                              <1> %ifdef STRINGSCOMPRESSED_STRINGS
  4160                              <1> 
  4161                              <1> ; Project name	:	XTIDE Universal BIOS
  4162                              <1> ; Description	:	Strings and equates for BIOS messages.
  4163                              <1> 
  4164                              <1> ;
  4165                              <1> ; XTIDE Universal BIOS and Associated Tools
  4166                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  4167                              <1> ;
  4168                              <1> ; This program is free software; you can redistribute it and/or modify
  4169                              <1> ; it under the terms of the GNU General Public License as published by
  4170                              <1> ; the Free Software Foundation; either version 2 of the License, or
  4171                              <1> ; (at your option) any later version.
  4172                              <1> ;
  4173                              <1> ; This program is distributed in the hope that it will be useful,
  4174                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4175                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4176                              <1> ; GNU General Public License for more details.
  4177                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  4178                              <1> ;
  4179                              <1> 
  4180                              <1> %ifdef MODULE_STRINGS_COMPRESSED_PRECOMPRESS
  4181                              <1> %include "Display.inc"
  4182                              <1> %endif
  4183                              <1> 
  4184                              <1> ; Section containing code
  4185                              <1> SECTION .text
  4186                              <1> 
  4187                              <1> ; The following strings are used by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
  4188                              <1> ; To support an optimization in that code, these strings must start on the same 256 byte page,
  4189                              <1> ; which is checked at assembly time below.
  4190                              <1> ;
  4191                              <1> g_szDetectStart:
  4192                              <1> g_szDetectMaster:		; db	"Master",NULL
  4193                              <1>                  		; db	 4dh,  61h,  73h,  74h,  65h,  72h,  00h    ; uncompressed
  4194 00000099 5367797A6BB8        <1>                  		  db	 53h,  67h,  79h,  7ah,  6bh, 0b8h          ; compressed
  4195                              <1> 
  4196                              <1> g_szDetectSlave:		; db	"Slave ",NULL
  4197                              <1>                 		; db	 53h,  6ch,  61h,  76h,  65h,  20h,  00h    ; uncompressed
  4198 0000009F 5972677C6B00        <1>                 		  db	 59h,  72h,  67h,  7ch,  6bh,  00h          ; compressed
  4199                              <1> 
  4200                              <1> g_szDetectOuter:		; db	"%s at %s: ",NULL
  4201                              <1>                 		; db	 25h,  73h,  20h,  61h,  74h,  20h,  25h,  73h,  3ah,  20h,  00h    ; uncompressed
  4202 000000A5 3D2067FA3D4000      <1>                 		  db	 3dh,  20h,  67h, 0fah,  3dh,  40h,  00h                            ; compressed
  4203                              <1> 
  4204                              <1> %ifdef MODULE_SERIAL
  4205                              <1> g_szDetectCOM:			; db	"COM%c%s",NULL
  4206                              <1>               			; db	 43h,  4fh,  4dh,  25h,  63h,  25h,  73h,  00h    ; uncompressed
  4207                              <1>               			  db	 49h,  55h,  53h,  3ch,  1dh                      ; compressed
  4208                              <1> 
  4209                              <1> g_szDetectCOMAuto:		; db	" Detect",NULL
  4210                              <1>                   		; db	 20h,  44h,  65h,  74h,  65h,  63h,  74h,  00h    ; uncompressed
  4211                              <1>                   		  db	 20h,  4ah,  6bh,  7ah,  6bh,  69h, 0bah          ; compressed
  4212                              <1> 
  4213                              <1> g_szDetectCOMSmall:		; db	"/%u%u00",NULL					; IDE Master at COM1/9600:
  4214                              <1>                    		; db	 2fh,  25h,  75h,  25h,  75h,  30h,  30h,  00h    ; uncompressed
  4215                              <1>                    		  db	 2ah,  35h,  35h,  33h,  13h                      ; compressed
  4216                              <1> 
  4217                              <1> g_szDetectCOMLarge:		; db	"/%u.%uK",NULL					; IDE Master at COM1/19.2K:
  4218                              <1>                    		; db	 2fh,  25h,  75h,  2eh,  25h,  75h,  4bh,  00h    ; uncompressed
  4219                              <1>                    		  db	 2ah,  35h,  29h,  35h,  91h                      ; compressed
  4220                              <1> 
  4221                              <1> %endif
  4222                              <1> g_szDetectEnd:
  4223                              <1> g_szDetectPort:			; db	"%x",NULL						; IDE Master at 1F0h:
  4224                              <1>                			; db	 25h,  78h,  00h    ; uncompressed
  4225 000000AC 17                  <1>                			  db	 17h                ; compressed
  4226                              <1> 
  4227                              <1> 
  4228                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4229                              <1> %if ((g_szDetectEnd-$$) & 0xff00) <> ((g_szDetectStart-$$) & 0xff00)
  4230                              <1> %error "g_szDetect* strings must start on the same 256 byte page, required by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP.  Please move this block up or down within Strings.asm"
  4231                              <1> %endif
  4232                              <1> %endif
  4233                              <1> 
  4234                              <1> 
  4235                              <1> ; POST drive detection strings
  4236                              <1> g_szDashForZero:	; db	"- ",NULL	; Required by Display Library
  4237                              <1>                 	; db	 2dh,  20h,  00h    ; uncompressed
  4238 000000AD 2800                <1>                 	  db	 28h,  00h          ; compressed
  4239                              <1> 
  4240                              <1> g_szRomAt:			; db	LF,CR
  4241                              <1>           			; db	 0ah,  0dh    ; uncompressed
  4242 000000AF 39                  <1>           			  db	 39h          ; compressed
  4243                              <1> 
  4244                              <1> 	; db	"%s @ %x",LF,CR						; -=XTIDE ... =- @ Segment
  4245                              <1> 	; db	 25h,  73h,  20h,  40h,  20h,  25h,  78h,  0ah,  0dh    ; uncompressed
  4246 000000B0 3D20C63739          <1> 	  db	 3dh,  20h, 0c6h,  37h,  39h                            ; compressed
  4247                              <1> 
  4248                              <1> 	; db	"%s",LF,CR							; version string
  4249                              <1> 	; db	 25h,  73h,  0ah,  0dh    ; uncompressed
  4250 000000B5 3D39                <1> 	  db	 3dh,  39h                ; compressed
  4251                              <1> 
  4252                              <1> 	; db	"Released under GNU GPL v2",LF,CR
  4253                              <1> 	; db	 52h,  65h,  6ch,  65h,  61h,  73h,  65h,  64h,  20h,  75h,  6eh,  64h,  65h,  72h,  20h,  47h,  4eh,  55h,  20h,  47h,  50h,  4ch,  20h,  76h,  32h,  0ah,  0dh    ; uncompressed
  4254 000000B7 586B726B67796BEA7B- <1> 	  db	 58h,  6bh,  72h,  6bh,  67h,  79h,  6bh, 0eah,  7bh,  74h,  6ah,  6bh, 0f8h,  4dh,  54h, 0dbh,  4dh,  56h, 0d2h,  7ch,  2ch,  39h                                  ; compressed
  4255 000000C0 746A6BF84D54DB4D56- <1>
  4256 000000C9 D27C2C39            <1>
  4257                              <1> 
  4258                              <1> 	; db	LF,CR,NULL
  4259                              <1> 	; db	 0ah,  0dh,  00h    ; uncompressed
  4260 000000CD 19                  <1> 	  db	 19h                ; compressed
  4261                              <1> 
  4262                              <1> %ifdef MODULE_BOOT_MENU
  4263                              <1> g_szBootMenuTitle:	; db	"%s%c",LF,CR						; -=XTIDE ... =- and null (eaten)
  4264                              <1>                   	; db	 25h,  73h,  25h,  63h,  0ah,  0dh    ; uncompressed
  4265                              <1>                   	  db	 3dh,  3ch,  39h                      ; compressed
  4266                              <1> 
  4267                              <1> 	; db	"%s",NULL							; version string
  4268                              <1> 	; db	 25h,  73h,  00h    ; uncompressed
  4269                              <1> 	  db	 1dh                ; compressed
  4270                              <1> 
  4271                              <1> %endif
  4272                              <1> g_szDriveName:		; db	"%z",LF,CR,NULL
  4273                              <1>               		; db	 25h,  7ah,  0ah,  0dh,  00h    ; uncompressed
  4274 000000CE 3E19                <1>               		  db	 3eh,  19h                      ; compressed
  4275                              <1> 
  4276                              <1> 
  4277                              <1> 
  4278                              <1> ; Boot loader strings
  4279                              <1> g_szTryToBoot:			; db	"Booting %c",ANGLE_QUOTE_RIGHT,"%c",LF,CR,NULL
  4280                              <1>               			; db	 42h,  6fh,  6fh,  74h,  69h,  6eh,  67h,  20h,  25h,  63h, 0afh,  25h,  63h,  0ah,  0dh,  00h    ; uncompressed
  4281 000000D0 4875757A6F74ED3C24- <1>               			  db	 48h,  75h,  75h,  7ah,  6fh,  74h, 0edh,  3ch,  24h,  3ch,  19h                                  ; compressed
  4282 000000D9 3C19                <1>
  4283                              <1> 
  4284                              <1> g_szBootSectorNotFound:	; db	"Boot sector " 			; String fall through...
  4285                              <1>                        	; db	 42h,  6fh,  6fh,  74h,  20h,  73h,  65h,  63h,  74h,  6fh,  72h,  20h    ; uncompressed
  4286 000000DB 487575FA796B697A75- <1>                        	  db	 48h,  75h,  75h, 0fah,  79h,  6bh,  69h,  7ah,  75h, 0f8h                ; compressed
  4287 000000E4 F8                  <1>
  4288                              <1> 
  4289                              <1> g_szNotFound:			; db	"not found",LF,CR,NULL
  4290                              <1>              			; db	 6eh,  6fh,  74h,  20h,  66h,  6fh,  75h,  6eh,  64h,  0ah,  0dh,  00h    ; uncompressed
  4291 000000E5 7475FA6C757B746A19  <1>              			  db	 74h,  75h, 0fah,  6ch,  75h,  7bh,  74h,  6ah,  19h                      ; compressed
  4292                              <1> 
  4293                              <1> g_szReadError:			; db	"Error %x!",LF,CR,NULL
  4294                              <1>               			; db	 45h,  72h,  72h,  6fh,  72h,  20h,  25h,  78h,  21h,  0ah,  0dh,  00h    ; uncompressed
  4295 000000EE 4B787875F8372519    <1>               			  db	 4bh,  78h,  78h,  75h, 0f8h,  37h,  25h,  19h                            ; compressed
  4296                              <1> 
  4297                              <1> 
  4298                              <1> 
  4299                              <1> %ifdef MODULE_HOTKEYS
  4300                              <1> ; Hotkey Bar strings
  4301                              <1> g_szFDD:				; db	"FDD [%c]",NULL			; "FDD [A]"
  4302                              <1>         				; db	 46h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
  4303                              <1>         				  db	 4ch,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
  4304                              <1> 
  4305                              <1> g_szHDD:				; db	"HDD [%c]",NULL			; "HDD [C]"
  4306                              <1>         				; db	 48h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
  4307                              <1>         				  db	 4eh,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
  4308                              <1> 
  4309                              <1> %ifdef MODULE_BOOT_MENU
  4310                              <1> g_szBootMenu:			; db	"BootMnu%c",NULL		; "BootMnu", location of %c doesn't matter
  4311                              <1>              			; db	 42h,  6fh,  6fh,  74h,  4dh,  6eh,  75h,  25h,  63h,  00h    ; uncompressed
  4312                              <1>              			  db	 48h,  75h,  75h,  7ah,  53h,  74h,  7bh,  1ch                ; compressed
  4313                              <1> 
  4314                              <1> %endif ; MODULE_BOOT_MENU
  4315                              <1> g_szHotkey:				; db	"%A%c%c%A%s%A ",NULL	; "CHDD [A] ", "F2BootMnu " or "F8RomBoot "
  4316                              <1>            				; db	 25h,  41h,  25h,  63h,  25h,  63h,  25h,  41h,  25h,  73h,  25h,  41h,  20h,  00h    ; uncompressed
  4317                              <1>            				  db	 3bh,  3ch,  3ch,  3bh,  3dh,  3bh,  00h                                              ; compressed
  4318                              <1> 
  4319                              <1> %ifdef MODULE_SERIAL
  4320                              <1> g_szHotComDetect:		; db	"ComDtct%c",NULL		; "ComDtct", location of %c doesn't matter
  4321                              <1>                  		; db	 43h,  6fh,  6dh,  44h,  74h,  63h,  74h,  25h,  63h,  00h    ; uncompressed
  4322                              <1>                  		  db	 49h,  75h,  73h,  4ah,  7ah,  69h,  7ah,  1ch                ; compressed
  4323                              <1> 
  4324                              <1> %endif ; MODULE_SERIAL
  4325                              <1> %endif ; MODULE_HOTKEYS
  4326                              <1> 
  4327                              <1> %ifdef MODULE_BOOT_MENU
  4328                              <1> g_szRomBootDash:		; db	" -  "					; String fall through to g_szRomBoot
  4329                              <1>                 		; db	 20h,  2dh,  20h,  20h    ; uncompressed
  4330                              <1>                 		  db	 20h,  28h,  20h,  20h    ; compressed
  4331                              <1> 
  4332                              <1> %endif
  4333                              <1> %ifdef MODULE_HOTKEYS OR MODULE_BOOT_MENU
  4334                              <1> g_szRomBoot:			; db	"Rom%cBoot",NULL		; "RomBoot" or "Rom Boot"
  4335                              <1>             			; db	 52h,  6fh,  6dh,  25h,  63h,  42h,  6fh,  6fh,  74h,  00h    ; uncompressed
  4336                              <1>             			  db	 58h,  75h,  73h,  3ch,  48h,  75h,  75h, 0bah                ; compressed
  4337                              <1> 
  4338                              <1> %endif
  4339                              <1> 
  4340                              <1> 
  4341                              <1> %ifdef MODULE_BOOT_MENU
  4342                              <1> ; Boot Menu Floppy Disk strings
  4343                              <1> ;
  4344                              <1> ; The following strings are used by BootMenuPrint_RefreshInformation
  4345                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
  4346                              <1> ; which is checked at assembly time below.
  4347                              <1> ;
  4348                              <1> g_szFddStart:
  4349                              <1> g_szFddUnknown:		; db	"Unknown",NULL
  4350                              <1>                		; db	 55h,  6eh,  6bh,  6eh,  6fh,  77h,  6eh,  00h    ; uncompressed
  4351                              <1>                		  db	 5bh,  74h,  71h,  74h,  75h,  7dh, 0b4h          ; compressed
  4352                              <1> 
  4353                              <1> g_szFddSizeOr:		; db	"5",ONE_QUARTER,QUOTATION_MARK," or 3",ONE_HALF,QUOTATION_MARK," DD",NULL
  4354                              <1>               		; db	 35h, 0ach,  22h,  20h,  6fh,  72h,  20h,  33h, 0abh,  22h,  20h,  44h,  44h,  00h    ; uncompressed
  4355                              <1>               		  db	 2eh,  21h,  26h,  20h,  75h, 0f8h,  2dh,  22h,  26h,  20h,  4ah,  8ah                ; compressed
  4356                              <1> 
  4357                              <1> g_szFddSize:		; db	"%s",QUOTATION_MARK,", %u kiB",NULL	; 3", 1440 kiB
  4358                              <1>             		; db	 25h,  73h,  22h,  2ch,  20h,  25h,  75h,  20h,  6bh,  69h,  42h,  00h    ; uncompressed
  4359                              <1>             		  db	 3dh,  26h,  27h,  20h,  35h,  20h,  71h,  6fh,  88h                      ; compressed
  4360                              <1> 
  4361                              <1> g_szFddThreeHalf:	; db	"3",ONE_HALF,NULL
  4362                              <1>                  	; db	 33h, 0abh,  00h    ; uncompressed
  4363                              <1>                  	  db	 2dh,  02h          ; compressed
  4364                              <1> 
  4365                              <1> g_szFddEnd:
  4366                              <1> g_szFddFiveQuarter:	; db	"5",ONE_QUARTER,NULL
  4367                              <1>                    	; db	 35h, 0ach,  00h    ; uncompressed
  4368                              <1>                    	  db	 2eh,  01h          ; compressed
  4369                              <1> 
  4370                              <1> 
  4371                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4372                              <1> %if ((g_szFddStart-$$) & 0xff00) <> ((g_szFddEnd-$$) & 0xff00)
  4373                              <1> %error "g_szFdd* strings must start on the same 256 byte page, required by the BootMenuPrint_RefreshInformation routines for floppy drives.  Please move this block up or down within Strings.asm"
  4374                              <1> %endif
  4375                              <1> %endif
  4376                              <1> 
  4377                              <1> 
  4378                              <1> g_szAddressingModes:
  4379                              <1> g_szNORMAL:		; db	"NORMAL",NULL
  4380                              <1>            		; db	 4eh,  4fh,  52h,  4dh,  41h,  4ch,  00h    ; uncompressed
  4381                              <1>            		  db	 54h,  55h,  58h,  53h,  47h,  92h          ; compressed
  4382                              <1> 
  4383                              <1> g_szLARGE:		; db	"LARGE ",NULL
  4384                              <1>           		; db	 4ch,  41h,  52h,  47h,  45h,  20h,  00h    ; uncompressed
  4385                              <1>           		  db	 52h,  47h,  58h,  4dh,  4bh,  00h          ; compressed
  4386                              <1> 
  4387                              <1> g_szLBA:		; db	"LBA   ",NULL
  4388                              <1>         		; db	 4ch,  42h,  41h,  20h,  20h,  20h,  00h    ; uncompressed
  4389                              <1>         		  db	 52h,  48h, 0c7h,  20h,  00h                ; compressed
  4390                              <1> 
  4391                              <1> g_szAddressingModes_Displacement equ (g_szLARGE - g_szAddressingModes)
  4392                              <1> ;
  4393                              <1> ; Ensure that addressing modes are correctly spaced in memory
  4394                              <1> ;
  4395                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4396                              <1> %if g_szNORMAL <> g_szAddressingModes
  4397                              <1> %error "g_szAddressingModes Displacement Incorrect 1"
  4398                              <1> %endif
  4399                              <1> %if g_szLARGE <> g_szNORMAL + g_szAddressingModes_Displacement
  4400                              <1> %error "g_szAddressingModes Displacement Incorrect 2"
  4401                              <1> %endif
  4402                              <1> %if g_szLBA <> g_szLARGE + g_szAddressingModes_Displacement
  4403                              <1> %error "g_szAddressingModes Displacement Incorrect 3"
  4404                              <1> %endif
  4405                              <1> %endif
  4406                              <1> 
  4407                              <1> 
  4408                              <1> g_szDeviceTypeValues:
  4409                              <1> g_szDeviceTypeValues_16bit:		; db	" 16",NULL
  4410                              <1>                            		; db	 20h,  31h,  36h,  00h    ; uncompressed
  4411                              <1>                            		  db	 20h,  2bh,  0fh          ; compressed
  4412                              <1> 
  4413                              <1> g_szDeviceTypeValues_32bit:		; db	" 32",NULL
  4414                              <1>                            		; db	 20h,  33h,  32h,  00h    ; uncompressed
  4415                              <1>                            		  db	 20h,  2dh,  0ch          ; compressed
  4416                              <1> 
  4417                              <1> g_szDeviceTypeValues_8bit:		; db	"  8",NULL
  4418                              <1>                           		; db	 20h,  20h,  38h,  00h    ; uncompressed
  4419                              <1>                           		  db	 20h,  20h,  10h          ; compressed
  4420                              <1> 
  4421                              <1> g_szDeviceTypeValues_XTIDEr1:	; db	"D8 ",NULL	; Dual 8-bit
  4422                              <1>                              	; db	 44h,  38h,  20h,  00h    ; uncompressed
  4423                              <1>                              	  db	 4ah,  30h,  00h          ; compressed
  4424                              <1> 
  4425                              <1> g_szDeviceTypeValues_XTIDEr2:	; db	"X8 ",NULL	; A0<->A3 swapped 8-bit
  4426                              <1>                              	; db	 58h,  38h,  20h,  00h    ; uncompressed
  4427                              <1>                              	  db	 5eh,  30h,  00h          ; compressed
  4428                              <1> 
  4429                              <1> g_szDeviceTypeValues_XTCFpio8:	; db	"T8 ",NULL	; True 8-bit
  4430                              <1>                               	; db	 54h,  38h,  20h,  00h    ; uncompressed
  4431                              <1>                               	  db	 5ah,  30h,  00h          ; compressed
  4432                              <1> 
  4433                              <1> g_szDeviceTypeValues_XTCFdma:	; db	"8MA",NULL	; DMA 8-bit
  4434                              <1>                              	; db	 38h,  4dh,  41h,  00h    ; uncompressed
  4435                              <1>                              	  db	 30h,  53h,  87h          ; compressed
  4436                              <1> 
  4437                              <1> g_szDeviceTypeValues_XTCFmem:	; db	"M8 ",NULL	; Memory Mapped 8-bit
  4438                              <1>                              	; db	 4dh,  38h,  20h,  00h    ; uncompressed
  4439                              <1>                              	  db	 53h,  30h,  00h          ; compressed
  4440                              <1> 
  4441                              <1> g_szDeviceTypeValues_JrIde:		; db	"M8 ",NULL
  4442                              <1>                            		; db	 4dh,  38h,  20h,  00h    ; uncompressed
  4443                              <1>                            		  db	 53h,  30h,  00h          ; compressed
  4444                              <1> 
  4445                              <1> g_szDeviceTypeValues_Serial:	; db	"SER",NULL
  4446                              <1>                             	; db	 53h,  45h,  52h,  00h    ; uncompressed
  4447                              <1>                             	  db	 59h,  4bh,  98h          ; compressed
  4448                              <1> 
  4449                              <1> 
  4450                              <1> g_szDeviceTypeValues_Displacement equ (g_szDeviceTypeValues_32bit - g_szDeviceTypeValues)
  4451                              <1> ;
  4452                              <1> ; Ensure that device type strings are correctly spaced in memory
  4453                              <1> ;
  4454                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4455                              <1> %if g_szDeviceTypeValues_16bit <> g_szDeviceTypeValues
  4456                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 1"
  4457                              <1> %endif
  4458                              <1> %if g_szDeviceTypeValues_32bit <> g_szDeviceTypeValues_16bit + g_szDeviceTypeValues_Displacement
  4459                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
  4460                              <1> %endif
  4461                              <1> %if g_szDeviceTypeValues_8bit <> g_szDeviceTypeValues_32bit + g_szDeviceTypeValues_Displacement
  4462                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
  4463                              <1> %endif
  4464                              <1> %if g_szDeviceTypeValues_XTIDEr1 <> g_szDeviceTypeValues_8bit + g_szDeviceTypeValues_Displacement
  4465                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 3"
  4466                              <1> %endif
  4467                              <1> %if g_szDeviceTypeValues_XTIDEr2 <> g_szDeviceTypeValues_XTIDEr1 + g_szDeviceTypeValues_Displacement
  4468                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 4"
  4469                              <1> %endif
  4470                              <1> %if g_szDeviceTypeValues_XTCFpio8 <> g_szDeviceTypeValues_XTIDEr2 + g_szDeviceTypeValues_Displacement
  4471                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 5"
  4472                              <1> %endif
  4473                              <1> %if g_szDeviceTypeValues_XTCFdma <> g_szDeviceTypeValues_XTCFpio8 + g_szDeviceTypeValues_Displacement
  4474                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 6"
  4475                              <1> %endif
  4476                              <1> %if g_szDeviceTypeValues_XTCFmem <> g_szDeviceTypeValues_XTCFdma + g_szDeviceTypeValues_Displacement
  4477                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 7"
  4478                              <1> %endif
  4479                              <1> %if g_szDeviceTypeValues_JrIde <> g_szDeviceTypeValues_XTCFmem + g_szDeviceTypeValues_Displacement
  4480                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 8"
  4481                              <1> %endif
  4482                              <1> %if g_szDeviceTypeValues_Serial <> g_szDeviceTypeValues_JrIde + g_szDeviceTypeValues_Displacement
  4483                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 9"
  4484                              <1> %endif
  4485                              <1> %endif
  4486                              <1> 
  4487                              <1> 
  4488                              <1> g_szSelectionTimeout:	; db	DOUBLE_BOTTOM_LEFT_CORNER,DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL,"%ASelection in %2-u s",NULL
  4489                              <1>                      	; db	0c8h, 0b5h,  25h,  41h,  53h,  65h,  6ch,  65h,  63h,  74h,  69h,  6fh,  6eh,  20h,  69h,  6eh,  20h,  25h,  32h,  2dh,  75h,  20h,  73h,  00h    ; uncompressed
  4490                              <1>                      	  db	 31h,  32h,  3bh,  59h,  6bh,  72h,  6bh,  69h,  7ah,  6fh,  75h, 0f4h,  6fh, 0f4h,  3ah,  20h, 0b9h                                              ; compressed
  4491                              <1> 
  4492                              <1> 
  4493                              <1> 
  4494                              <1> ; Boot Menu information strings
  4495                              <1> g_szCapacity:			; db	"Capacity : %s",NULL
  4496                              <1>              			; db	 43h,  61h,  70h,  61h,  63h,  69h,  74h,  79h,  20h,  3ah,  20h,  25h,  73h,  00h    ; uncompressed
  4497                              <1>              			  db	 49h,  67h,  76h,  67h,  69h,  6fh,  7ah, 0ffh, 0c0h,  1dh                            ; compressed
  4498                              <1> 
  4499                              <1> g_szCapacityNum:		; db	"%5-u.%u %ciB",NULL
  4500                              <1>                 		; db	 25h,  35h,  2dh,  75h,  2eh,  25h,  75h,  20h,  25h,  63h,  69h,  42h,  00h    ; uncompressed
  4501                              <1>                 		  db	 36h,  29h,  35h,  20h,  3ch,  6fh,  88h                                        ; compressed
  4502                              <1> 
  4503                              <1> g_szInformation:		; db	"%s",LF,CR
  4504                              <1>                 		; db	 25h,  73h,  0ah,  0dh    ; uncompressed
  4505                              <1>                 		  db	 3dh,  39h                ; compressed
  4506                              <1> 
  4507                              <1> 	; db	"Addr. ",SINGLE_VERTICAL,"Block",SINGLE_VERTICAL,"Bus",SINGLE_VERTICAL,"IRQ",SINGLE_VERTICAL,"Reset",LF,CR
  4508                              <1> 	; db	 41h,  64h,  64h,  72h,  2eh,  20h, 0b3h,  42h,  6ch,  6fh,  63h,  6bh, 0b3h,  42h,  75h,  73h, 0b3h,  49h,  52h,  51h, 0b3h,  52h,  65h,  73h,  65h,  74h,  0ah,  0dh    ; uncompressed
  4509                              <1> 	  db	 47h,  6ah,  6ah,  78h,  29h,  20h,  23h,  48h,  72h,  75h,  69h,  71h,  23h,  48h,  7bh,  79h,  23h,  4fh,  58h,  57h,  23h,  58h,  6bh,  79h,  6bh,  7ah,  39h          ; compressed
  4510                              <1> 
  4511                              <1> 	; db	"%s",SINGLE_VERTICAL,"%5-u",SINGLE_VERTICAL,"%s",SINGLE_VERTICAL," %2-I",SINGLE_VERTICAL,"%5-x",NULL
  4512                              <1> 	; db	 25h,  73h, 0b3h,  25h,  35h,  2dh,  75h, 0b3h,  25h,  73h, 0b3h,  20h,  25h,  32h,  2dh,  49h, 0b3h,  25h,  35h,  2dh,  78h,  00h    ; uncompressed
  4513                              <1> 	  db	 3dh,  23h,  36h,  23h,  3dh,  23h,  20h,  34h,  23h,  18h                                                                            ; compressed
  4514                              <1> 
  4515                              <1> 
  4516                              <1> 
  4517                              <1> ; Boot Menu menuitem strings
  4518                              <1> ;
  4519                              <1> ; The following strings are used by BootMenuPrint_* routines.
  4520                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
  4521                              <1> ; which is checked at assembly time below.
  4522                              <1> ;
  4523                              <1> g_szDriveNumSpace:		; db	" "							; leading space, used if drive number is less than 0fh
  4524                              <1>                   		; db	 20h    ; uncompressed
  4525                              <1>                   		  db	 20h    ; compressed
  4526                              <1> 
  4527                              <1> ; must come immediately before g_szDriveNum!
  4528                              <1> g_szBootMenuPrintStart:
  4529                              <1> g_szDriveNum:			; db	"%x %s",NULL
  4530                              <1>              			; db	 25h,  78h,  20h,  25h,  73h,  00h    ; uncompressed
  4531                              <1>              			  db	 37h,  20h,  1dh                      ; compressed
  4532                              <1> 
  4533                              <1> g_szDriveNumBNSpace:	; db	" "							; leading space, used if drive number is less than 0fh
  4534                              <1>                     	; db	 20h    ; uncompressed
  4535                              <1>                     	  db	 20h    ; compressed
  4536                              <1> 
  4537                              <1> ; must come immediately before g_szDriveNumBOOTNFO!
  4538                              <1> g_szDriveNumBOOTNFO:	; db	"%x %z",NULL
  4539                              <1>                     	; db	 25h,  78h,  20h,  25h,  7ah,  00h    ; uncompressed
  4540                              <1>                     	  db	 37h,  20h,  1eh                      ; compressed
  4541                              <1> 
  4542                              <1> g_szFloppyDrv:			; db	"Floppy Drive %c",NULL
  4543                              <1>               			; db	 46h,  6ch,  6fh,  70h,  70h,  79h,  20h,  44h,  72h,  69h,  76h,  65h,  20h,  25h,  63h,  00h    ; uncompressed
  4544                              <1>               			  db	 4ch,  72h,  75h,  76h,  76h, 0ffh,  4ah,  78h,  6fh,  7ch, 0ebh,  1ch                            ; compressed
  4545                              <1> 
  4546                              <1> g_szBootMenuPrintEnd:
  4547                              <1> g_szForeignHD:			; db	"Foreign Hard Disk",NULL
  4548                              <1>               			; db	 46h,  6fh,  72h,  65h,  69h,  67h,  6eh,  20h,  48h,  61h,  72h,  64h,  20h,  44h,  69h,  73h,  6bh,  00h    ; uncompressed
  4549                              <1>               			  db	 4ch,  75h,  78h,  6bh,  6fh,  6dh, 0f4h,  4eh,  67h,  78h, 0eah,  4ah,  6fh,  79h, 0b1h                      ; compressed
  4550                              <1> 
  4551                              <1> 
  4552                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4553                              <1> %if ((g_szBootMenuPrintStart-$$) & 0xff00) <> ((g_szBootMenuPrintEnd-$$) & 0xff00)
  4554                              <1> %error "g_szBootMenuPrint* strings must start on the same 256 byte page, required by the BootMenuPrint_* routines.  Please move this block up or down within Strings.asm"
  4555                              <1> %endif
  4556                              <1> %if g_szDriveNumSpace+1 != g_szDriveNum || g_szDriveNumBNSpace+1 != g_szDriveNumBOOTNFO
  4557                              <1> %error "g_szDriveNumSpace or g_szDriveNumBNSpace are out of position"
  4558                              <1> %endif
  4559                              <1> %endif
  4560                              <1> 
  4561                              <1> %endif ; MODULE_BOOT_MENU
  4562                              <1> 
  4563                              <1> 
  4564                              <1> ;------------------------------------------------------------------------------------------
  4565                              <1> ;
  4566                              <1> ; Tables for StringsCompress.pl
  4567                              <1> ;
  4568                              <1> ; Items can be added and removed from this table as needed, with the following rules:
  4569                              <1> ;  * Formats follow the special characters.  But other than that, order makes no difference.
  4570                              <1> ;  * Some of the formats require "even" and "odd" numbering.  Even tells the code that
  4571                              <1> ;    it is a "number-" format, otherwise it doesn't interpret a number first.  The easiest
  4572                              <1> ;    way to maintain this is to move one of the "n/a" items to/from the front of the format
  4573                              <1> ;    list to maintain the even/odd.
  4574                              <1> ;  * Values do not need to remain consistent across versions.  This table is only used
  4575                              <1> ;    internally to this file.
  4576                              <1> ;  * There can only be 32 of these (0-31).
  4577                              <1> ;  * Keeping the list short is good - this translates to a table in the compressed version.
  4578                              <1> ;    An error will be reported if a character or format is no longer being used by any
  4579                              <1> ;    strings above.
  4580                              <1> ;  * Please keep items sequential for ease of further editing.
  4581                              <1> ;
  4582                              <1> ;$translate{ord(' ')} = 0;    [StringsCompress Processed]
  4583                              <1> ;$translate{172}      = 1;     # ONE_QUARTER    [StringsCompress Processed]
  4584                              <1> ;$translate{171}      = 2;     # ONE_HALF    [StringsCompress Processed]
  4585                              <1> ;$translate{179}      = 3;     # SINGLE_VERTICAL    [StringsCompress Processed]
  4586                              <1> ;$translate{175}      = 4;     # ANGLE_QUOTE_RIGHT    [StringsCompress Processed]
  4587                              <1> ;$translate{ord('!')} = 5;    [StringsCompress Processed]
  4588                              <1> ;$translate{ord('"')} = 6;    [StringsCompress Processed]
  4589                              <1> ;$translate{ord(',')} = 7;    [StringsCompress Processed]
  4590                              <1> ;$translate{ord('-')} = 8;    [StringsCompress Processed]
  4591                              <1> ;$translate{ord('.')} = 9;    [StringsCompress Processed]
  4592                              <1> ;$translate{ord('/')} = 10;    [StringsCompress Processed]
  4593                              <1> ;$translate{ord('1')} = 11;    [StringsCompress Processed]
  4594                              <1> ;$translate{ord('2')} = 12;    [StringsCompress Processed]
  4595                              <1> ;$translate{ord('3')} = 13;    [StringsCompress Processed]
  4596                              <1> ;$translate{ord('5')} = 14;    [StringsCompress Processed]
  4597                              <1> ;$translate{ord('6')} = 15;    [StringsCompress Processed]
  4598                              <1> ;$translate{ord('8')} = 16;    [StringsCompress Processed]
  4599                              <1> ;$translate{200}      = 17;    # DOUBLE_BOTTOM_LEFT_CORNER    [StringsCompress Processed]
  4600                              <1> ;$translate{181}      = 18;    # DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL    [StringsCompress Processed]
  4601                              <1> ;$translate{ord('0')} = 19;    [StringsCompress Processed]
  4602                              <1> ;
  4603                              <1> ; Formats begin immediately after the last Translated character (they are in the same table)
  4604                              <1> ;
  4605                              <1> ;$format_begin = 20;    [StringsCompress Processed]
  4606                              <1> ;
  4607                              <1> ;$format{"2-I"} = 20;        # must be even    [StringsCompress Processed]
  4608                              <1> ;$format{"u"}   = 21;        # must be odd    [StringsCompress Processed]
  4609                              <1> ;$format{"5-u"} = 22;        # must be even    [StringsCompress Processed]
  4610                              <1> ;$format{"x"}   = 23;        # must be odd    [StringsCompress Processed]
  4611                              <1> ;$format{"5-x"} = 24;        # must be even    [StringsCompress Processed]
  4612                              <1> ;$format{"nl"}  = 25;        # n/a    [StringsCompress Processed]
  4613                              <1> ;$format{"2-u"} = 26;        # must be even    [StringsCompress Processed]
  4614                              <1> ;$format{"A"}   = 27;        # n/a    [StringsCompress Processed]
  4615                              <1> ;$format{"c"}   = 28;        # n/a    [StringsCompress Processed]
  4616                              <1> ;$format{"s"}   = 29;        # n/a, normal string from DS    [StringsCompress Processed]
  4617                              <1> ;$format{"z"}   = 30;        # n/a, boot string from BDA    [StringsCompress Processed]
  4618                              <1> ;
  4619                              <1> ; NOTE: The last $format cannot exceed 31 (stored in a 5-bit quantity).
  4620                              <1> ;
  4621                              <1> ; Starting point for the "normal" range, typically around 0x40 to cover upper and lower case
  4622                              <1> ; letters.  If lower case 'z' is not used, 0x3a can be a good choice as it adds ':' to the
  4623                              <1> ; front end.
  4624                              <1> ;
  4625                              <1> ;$normal_base = 0x3a;    [StringsCompress Processed]
  4626                              <1> ;
  4627                              <1> ; End of StringsCompress.pl information
  4628                              <1> ;
  4629                              <1> ;;; end of input stream
  4630                              <1> 
  4631                              <1> %endif ; STRINGSCOMPRESSED_STRINGS
  4632                              <1> 
  4633                              <1> %ifdef STRINGSCOMPRESSED_TABLES
  4634                              <1> 
  4635                              <1> StringsCompressed_NormalBase     equ   58
  4636                              <1> 
  4637                              <1> StringsCompressed_FormatsBegin   equ   20
  4638                              <1> 
  4639                              <1> StringsCompressed_TranslatesAndFormats:
  4640                              <1>         db     32  ; 0
  4641                              <1>         db     172  ; 1
  4642                              <1>         db     171  ; 2
  4643                              <1>         db     179  ; 3
  4644                              <1>         db     175  ; 4
  4645                              <1>         db     33  ; 5
  4646                              <1>         db     34  ; 6
  4647                              <1>         db     44  ; 7
  4648                              <1>         db     45  ; 8
  4649                              <1>         db     46  ; 9
  4650                              <1>         db     47  ; 10
  4651                              <1>         db     49  ; 11
  4652                              <1>         db     50  ; 12
  4653                              <1>         db     51  ; 13
  4654                              <1>         db     53  ; 14
  4655                              <1>         db     54  ; 15
  4656                              <1>         db     56  ; 16
  4657                              <1>         db     200  ; 17
  4658                              <1>         db     181  ; 18
  4659                              <1>         db     48  ; 19
  4660                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I)    ; 20
  4661                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u)    ; 21
  4662                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u)    ; 22
  4663                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x)    ; 23
  4664                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x)    ; 24
  4665                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl)    ; 25
  4666                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u)    ; 26
  4667                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A)    ; 27
  4668                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c)    ; 28
  4669                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s)    ; 29
  4670                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z)    ; 30
  4671                              <1> 
  4672                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4673                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_I || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I > 255
  4674                              <1> %error "DisplayFormatCompressed_Format_2_I is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4675                              <1> %endif
  4676                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u > 255
  4677                              <1> %error "DisplayFormatCompressed_Format_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4678                              <1> %endif
  4679                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u > 255
  4680                              <1> %error "DisplayFormatCompressed_Format_5_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4681                              <1> %endif
  4682                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x > 255
  4683                              <1> %error "DisplayFormatCompressed_Format_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4684                              <1> %endif
  4685                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x > 255
  4686                              <1> %error "DisplayFormatCompressed_Format_5_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4687                              <1> %endif
  4688                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_nl || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl > 255
  4689                              <1> %error "DisplayFormatCompressed_Format_nl is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4690                              <1> %endif
  4691                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u > 255
  4692                              <1> %error "DisplayFormatCompressed_Format_2_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4693                              <1> %endif
  4694                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_A || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A > 255
  4695                              <1> %error "DisplayFormatCompressed_Format_A is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4696                              <1> %endif
  4697                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_c || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c > 255
  4698                              <1> %error "DisplayFormatCompressed_Format_c is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4699                              <1> %endif
  4700                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_s || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s > 255
  4701                              <1> %error "DisplayFormatCompressed_Format_s is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4702                              <1> %endif
  4703                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_z || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z > 255
  4704                              <1> %error "DisplayFormatCompressed_Format_z is out of range of DisplayFormatCompressed_BaseFormatOffset"
  4705                              <1> %endif
  4706                              <1> %endif
  4707                              <1> 
  4708                              <1> ;; translated usage stats
  4709                              <1> ;; 33:1
  4710                              <1> ;; 32:34
  4711                              <1> ;; 181:1
  4712                              <1> ;; 53:2
  4713                              <1> ;; 48:2
  4714                              <1> ;; 200:1
  4715                              <1> ;; 46:3
  4716                              <1> ;; 179:8
  4717                              <1> ;; 44:1
  4718                              <1> ;; 50:2
  4719                              <1> ;; 51:3
  4720                              <1> ;; 47:2
  4721                              <1> ;; 172:2
  4722                              <1> ;; 34:3
  4723                              <1> ;; 49:1
  4724                              <1> ;; 56:7
  4725                              <1> ;; 45:2
  4726                              <1> ;; 175:1
  4727                              <1> ;; 171:2
  4728                              <1> ;; 54:1
  4729                              <1> ;; total translated: 20
  4730                              <1> 
  4731                              <1> ;; format usage stats
  4732                              <1> ;; A:4
  4733                              <1> ;; 2-u:1
  4734                              <1> ;; 5-u:2
  4735                              <1> ;; x:5
  4736                              <1> ;; s:14
  4737                              <1> ;; 5-x:1
  4738                              <1> ;; nl:12
  4739                              <1> ;; 2-I:1
  4740                              <1> ;; u:6
  4741                              <1> ;; c:13
  4742                              <1> ;; z:2
  4743                              <1> ;; total format: 11
  4744                              <1> 
  4745                              <1> ;; alphabet usage stats
  4746                              <1> ;; 58,::2
  4747                              <1> ;; 59,;:
  4748                              <1> ;; 60,<:
  4749                              <1> ;; 61,=:
  4750                              <1> ;; 62,>:
  4751                              <1> ;; 63,?:
  4752                              <1> ;; 64,@:1
  4753                              <1> ;; 65,A:5
  4754                              <1> ;; 66,B:9
  4755                              <1> ;; 67,C:3
  4756                              <1> ;; 68,D:11
  4757                              <1> ;; 69,E:3
  4758                              <1> ;; 70,F:3
  4759                              <1> ;; 71,G:3
  4760                              <1> ;; 72,H:2
  4761                              <1> ;; 73,I:1
  4762                              <1> ;; 74,J:
  4763                              <1> ;; 75,K:1
  4764                              <1> ;; 76,L:4
  4765                              <1> ;; 77,M:7
  4766                              <1> ;; 78,N:2
  4767                              <1> ;; 79,O:2
  4768                              <1> ;; 80,P:1
  4769                              <1> ;; 81,Q:1
  4770                              <1> ;; 82,R:7
  4771                              <1> ;; 83,S:3
  4772                              <1> ;; 84,T:1
  4773                              <1> ;; 85,U:2
  4774                              <1> ;; 86,V:
  4775                              <1> ;; 87,W:
  4776                              <1> ;; 88,X:1
  4777                              <1> ;; 89,Y:
  4778                              <1> ;; 90,Z:
  4779                              <1> ;; 91,[:2
  4780                              <1> ;; 92,\:
  4781                              <1> ;; 93,]:2
  4782                              <1> ;; 94,^:
  4783                              <1> ;; 95,_:
  4784                              <1> ;; 96,`:
  4785                              <1> ;; 97,a:7
  4786                              <1> ;; 98,b:
  4787                              <1> ;; 99,c:6
  4788                              <1> ;; 100,d:6
  4789                              <1> ;; 101,e:15
  4790                              <1> ;; 102,f:1
  4791                              <1> ;; 103,g:2
  4792                              <1> ;; 104,h:
  4793                              <1> ;; 105,i:9
  4794                              <1> ;; 106,j:
  4795                              <1> ;; 107,k:4
  4796                              <1> ;; 108,l:5
  4797                              <1> ;; 109,m:2
  4798                              <1> ;; 110,n:11
  4799                              <1> ;; 111,o:20
  4800                              <1> ;; 112,p:3
  4801                              <1> ;; 113,q:
  4802                              <1> ;; 114,r:11
  4803                              <1> ;; 115,s:7
  4804                              <1> ;; 116,t:15
  4805                              <1> ;; 117,u:4
  4806                              <1> ;; 118,v:3
  4807                              <1> ;; 119,w:1
  4808                              <1> ;; 120,x:
  4809                              <1> ;; 121,y:2
  4810                              <1> ;; alphabet used count: 45
  4811                              <1> %endif ; STRINGSCOMPRESSED_TABLES
  4812                              <1> 
  4813                                  %else
  4814                                  	%include "Strings.asm"			; For BIOS message strings
  4815                                  %endif
  4816                                  
  4817                                  	; Libraries, data, Initialization and drive detection
  4818                                  
  4819                                  	%include "AssemblyLibrary.asm"
  4820                              <1> ; Project name	:	Assembly Library
  4821                              <1> ; Description	:	Assembly Library main file. This is the only file that
  4822                              <1> ;					needs to be included.
  4823                              <1> 
  4824                              <1> ;
  4825                              <1> ; XTIDE Universal BIOS and Associated Tools
  4826                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  4827                              <1> ;
  4828                              <1> ; This program is free software; you can redistribute it and/or modify
  4829                              <1> ; it under the terms of the GNU General Public License as published by
  4830                              <1> ; the Free Software Foundation; either version 2 of the License, or
  4831                              <1> ; (at your option) any later version.
  4832                              <1> ;
  4833                              <1> ; This program is distributed in the hope that it will be useful,
  4834                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4835                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4836                              <1> ; GNU General Public License for more details.
  4837                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  4838                              <1> ;
  4839                              <1> 
  4840                              <1> ; Section containing code
  4841                              <1> SECTION .text
  4842                              <1> 
  4843                              <1> %ifdef INCLUDE_DISPLAY_LIBRARY
  4844                              <1>   %ifndef DISPLAY_JUMP_ALIGN
  4845                              <1> 	%define DISPLAY_JUMP_ALIGN 1
  4846                              <1>   %endif
  4847                              <1> 	%include "CgaSnow.asm"
  4848                              <2> ; Project name	:	Assembly Library
  4849                              <2> ; Description	:	Functions for preventing CGA snow.
  4850                              <2> 
  4851                              <2> ;
  4852                              <2> ; XTIDE Universal BIOS and Associated Tools
  4853                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  4854                              <2> ;
  4855                              <2> ; This program is free software; you can redistribute it and/or modify
  4856                              <2> ; it under the terms of the GNU General Public License as published by
  4857                              <2> ; the Free Software Foundation; either version 2 of the License, or
  4858                              <2> ; (at your option) any later version.
  4859                              <2> ;
  4860                              <2> ; This program is distributed in the hope that it will be useful,
  4861                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4862                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4863                              <2> ; GNU General Public License for more details.
  4864                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  4865                              <2> ;
  4866                              <2> 
  4867                              <2> ; Section containing code
  4868                              <2> SECTION .text
  4869                              <2> 
  4870                              <2> ;--------------------------------------------------------------------
  4871                              <2> ; CgaSnow_IsCgaPresent
  4872                              <2> ;	Parameters:
  4873                              <2> ;		DS:		BDA segment (zero)
  4874                              <2> ;	Returns:
  4875                              <2> ;		CF:		Set if CGA detected
  4876                              <2> ;				Cleared if CGA not detected
  4877                              <2> ;	Corrupts registers:
  4878                              <2> ;		AX
  4879                              <2> ;--------------------------------------------------------------------
  4880                              <2> ALIGN DISPLAY_JUMP_ALIGN
  4881                              <2> CgaSnow_IsCgaPresent:
  4882 000000F6 813E6304D403        <2> 	cmp		WORD [BDA.wVidPort], CGA_STATUS_REGISTER - OFFSET_TO_CGA_STATUS_REGISTER
  4883 000000FC 7509                <2> 	jne		SHORT .CgaNotFound
  4884                              <2> 
  4885                              <2> 	; All standard CGA modes use 25 rows but only EGA and later store it to BDA.
  4886 000000FE 803E840419          <2> 	cmp		BYTE [BDA.bVidRows], 25
  4887 00000103 7D02                <2> 	jge		SHORT .CgaNotFound
  4888 00000105 F9                  <2> 	stc
  4889 00000106 C3                  <2> 	ret
  4890                              <2> ALIGN DISPLAY_JUMP_ALIGN
  4891                              <2> .CgaNotFound:
  4892 00000107 F8                  <2> 	clc
  4893 00000108 C3                  <2> 	ret
  4894                              <2> 
  4895                              <2> 
  4896                              <2> ; CGA snow prevention must be kept optional to avoid unnecessary
  4897                              <2> ; overhead when building programs meant for non-CGA systems.
  4898                              <2> %ifdef ELIMINATE_CGA_SNOW
  4899                              <2> 
  4900                              <2> ;--------------------------------------------------------------------
  4901                              <2> ; CgaSnow_Stosb
  4902                              <2> ; CgaSnow_Stosw
  4903                              <2> ;	Parameters:
  4904                              <2> ;		AL:		Character to output
  4905                              <2> ;		AH:		Attribute to output (CgaSnow_StoswWithoutCgaSnow only)
  4906                              <2> ;		DS:		BDA segment (zero)
  4907                              <2> ;		ES:DI:	Ptr to video memory where to output
  4908                              <2> ;	Returns:
  4909                              <2> ;		DI:		Incremented for next character
  4910                              <2> ;	Corrupts registers:
  4911                              <2> ;		AX, DX
  4912                              <2> ;--------------------------------------------------------------------
  4913                              <2> ALIGN DISPLAY_JUMP_ALIGN
  4914                              <2> CgaSnow_Stosb:
  4915                              <2> 	call	LoadCgaStatusRegisterAddressToDXifCgaPresent
  4916                              <2> 	jz		SHORT .StosbWithoutWaitSinceUnknownPort
  4917                              <2> 
  4918                              <2> 	mov		ah, al
  4919                              <2> 	cli				; Interrupt request would mess up timing
  4920                              <2> 	WAIT_UNTIL_SAFE_CGA_WRITE
  4921                              <2> 	mov		al, ah
  4922                              <2> .StosbWithoutWaitSinceUnknownPort:
  4923                              <2> 	stosb
  4924                              <2> 	sti
  4925                              <2> 	ret
  4926                              <2> 
  4927                              <2> ALIGN DISPLAY_JUMP_ALIGN
  4928                              <2> CgaSnow_Stosw:
  4929                              <2> 	push	bx
  4930                              <2> 	call	LoadCgaStatusRegisterAddressToDXifCgaPresent
  4931                              <2> 	jz		SHORT .StoswWithoutWaitSinceUnknownPort
  4932                              <2> 
  4933                              <2> 	xchg	bx, ax
  4934                              <2> 	cli				; Interrupt request would mess up timing
  4935                              <2> 	WAIT_UNTIL_SAFE_CGA_WRITE
  4936                              <2> 	xchg	ax, bx
  4937                              <2> .StoswWithoutWaitSinceUnknownPort:
  4938                              <2> 	stosw
  4939                              <2> 	sti
  4940                              <2> 	pop		bx
  4941                              <2> 	ret
  4942                              <2> 
  4943                              <2> 
  4944                              <2> ;--------------------------------------------------------------------
  4945                              <2> ; CgaSnow_RepMovsb
  4946                              <2> ;	Parameters:
  4947                              <2> ;		CX:		Number of characters to copy
  4948                              <2> ;		DS:		BDA segment (zero)
  4949                              <2> ;		ES:SI:	Ptr to video memory where to read from
  4950                              <2> ;		ES:DI:	Ptr to video memory where to write to
  4951                              <2> ;	Returns:
  4952                              <2> ;		SI, DI:	Updated for next character
  4953                              <2> ;	Corrupts registers:
  4954                              <2> ;		AX, CX, DX
  4955                              <2> ;--------------------------------------------------------------------
  4956                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  4957                              <2> 	%ifdef MODULE_STRINGS_COMPRESSED
  4958                              <2> 		%define EXCLUDE
  4959                              <2> 	%endif
  4960                              <2> 	%ifdef MODULE_BOOT_MENU
  4961                              <2> 		%undef EXCLUDE
  4962                              <2> 	%endif
  4963                              <2> %endif
  4964                              <2> 
  4965                              <2> %ifndef EXCLUDE
  4966                              <2> ALIGN DISPLAY_JUMP_ALIGN
  4967                              <2> CgaSnow_RepMovsb:
  4968                              <2> 	call	LoadCgaStatusRegisterAddressToDXifCgaPresent
  4969                              <2> 	jz		SHORT .RepMovsbWithoutWaitSinceUnknownPort
  4970                              <2> 
  4971                              <2> .MovsbNextByte:
  4972                              <2> 	cli				; Interrupt request would mess up timing
  4973                              <2> 	WAIT_UNTIL_SAFE_CGA_WRITE
  4974                              <2> 	es movsb
  4975                              <2> 	sti
  4976                              <2> 	loop	.MovsbNextByte
  4977                              <2> 	ret
  4978                              <2> .RepMovsbWithoutWaitSinceUnknownPort:
  4979                              <2> 	eSEG_STR rep, es, movsb
  4980                              <2> 	ret
  4981                              <2> %endif
  4982                              <2> %undef EXCLUDE
  4983                              <2> 
  4984                              <2> 
  4985                              <2> ;--------------------------------------------------------------------
  4986                              <2> ; LoadCgaStatusRegisterAddressToDXifCgaPresent
  4987                              <2> ;	Parameters:
  4988                              <2> ;		DS:		BDA segment (zero)
  4989                              <2> ;	Returns:
  4990                              <2> ;		DX:		CGA Status Register Address
  4991                              <2> ;		ZF:		Set if CGA not present
  4992                              <2> ;				Cleared if CGA present
  4993                              <2> ;	Corrupts registers:
  4994                              <2> ;		Nothing
  4995                              <2> ;--------------------------------------------------------------------
  4996                              <2> ALIGN DISPLAY_JUMP_ALIGN
  4997                              <2> LoadCgaStatusRegisterAddressToDXifCgaPresent:
  4998                              <2> 	test	BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], FLG_CONTEXT_CGA
  4999                              <2> 	jz		SHORT .NoCgaDetected
  5000                              <2> 	mov		dx, CGA_STATUS_REGISTER
  5001                              <2> ALIGN DISPLAY_JUMP_ALIGN, ret
  5002                              <2> .NoCgaDetected:
  5003                              <2> 	ret
  5004                              <2> 
  5005                              <2> 
  5006                              <2> %endif ; ELIMINATE_CGA_SNOW
  5007                              <1> 	%include "Display.asm"
  5008                              <2> ; Project name	:	Assembly Library
  5009                              <2> ; Description	:	Display Library functions for CALL_DISPLAY_LIBRARY macro
  5010                              <2> ;					that users should use to make library call.
  5011                              <2> 
  5012                              <2> ;
  5013                              <2> ; XTIDE Universal BIOS and Associated Tools
  5014                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5015                              <2> ;
  5016                              <2> ; This program is free software; you can redistribute it and/or modify
  5017                              <2> ; it under the terms of the GNU General Public License as published by
  5018                              <2> ; the Free Software Foundation; either version 2 of the License, or
  5019                              <2> ; (at your option) any later version.
  5020                              <2> ;
  5021                              <2> ; This program is distributed in the hope that it will be useful,
  5022                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5023                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5024                              <2> ; GNU General Public License for more details.
  5025                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5026                              <2> ;
  5027                              <2> 
  5028                              <2> ; Section containing code
  5029                              <2> SECTION .text
  5030                              <2> 
  5031                              <2> ;--------------------------------------------------------------------
  5032                              <2> ; DisplayFunctionFromDI
  5033                              <2> ;	Parameters:
  5034                              <2> ;		DI:		Function to call (DISPLAY_LIB.functionName)
  5035                              <2> ;		Others:	Depends on function to call (DX cannot be parameter)
  5036                              <2> ;	Returns:
  5037                              <2> ;		Depends on function to call
  5038                              <2> ;	Corrupts registers:
  5039                              <2> ;		AX (unless used as a return register), DI
  5040                              <2> ;--------------------------------------------------------------------
  5041                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5042                              <2> Display_FunctionFromDI:
  5043 00000109 06                  <2> 	push	es
  5044 0000010A 1E                  <2> 	push	ds
  5045 0000010B 52                  <2> 	push	dx
  5046                              <2> 
  5047 0000010C FC                  <2> 	cld
  5048                              <2> 	LOAD_BDA_SEGMENT_TO	ds, dx
  5049                              <3> %ifndef USE_186
  5050 0000010D 31D2                <3>  xor %2, %2
  5051 0000010F 8EDA                <3>  mov %1, %2
  5052                              <3> %elifidn %3, !
  5053                              <3>  xor %2, %2
  5054                              <3>  mov %1, %2
  5055                              <3> %else
  5056                              <3>  push BYTE 0
  5057                              <3>  pop %1
  5058                              <3> %endif
  5059 00000111 89FA                <2> 	mov		dx, di
  5060 00000113 C43E5404            <2> 	les		di, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
  5061 00000117 FFD2                <2> 	call	dx
  5062 00000119 893E5404            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], di
  5063                              <2> 
  5064 0000011D 5A                  <2> 	pop		dx
  5065 0000011E 1F                  <2> 	pop		ds
  5066 0000011F 07                  <2> 	pop		es
  5067 00000120 C3                  <2> 	ret
  5068                              <2> 
  5069                              <2> ;--------------------------------------------------------------------
  5070                              <2> ; Display_FormatNullTerminatedStringFromCSSI
  5071                              <2> ;	Parameters:
  5072                              <2> ;		Same as DisplayPrint_FormattedNullTerminatedStringFromCSSI
  5073                              <2> ;	Returns:
  5074                              <2> ;		Stack variables will be cleaned
  5075                              <2> ;	Corrupts registers:
  5076                              <2> ;		AX
  5077                              <2> ;--------------------------------------------------------------------
  5078                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5079                              <2> Display_FormatNullTerminatedStringFromCSSI:
  5080 00000121 58                  <2> 	pop		ax					; Discard return address to inside Display_FunctionFromDI
  5081 00000122 E8F700              <2> 	call	DisplayPrint_FormattedNullTerminatedStringFromCSSI
  5082 00000125 893E5404            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], di
  5083                              <2> 
  5084 00000129 5A                  <2> 	pop		dx
  5085 0000012A 1F                  <2> 	pop		ds
  5086 0000012B 07                  <2> 	pop		es
  5087                              <2> 
  5088 0000012C 58                  <2> 	pop		ax					; Pop return address
  5089 0000012D 89EC                <2> 	mov		sp, bp				; Clean stack variables
  5090 0000012F FFE0                <2> 	jmp		ax
  5091                              <2> 
  5092                              <2> 
  5093                              <2> 	%define InitializeDisplayContext						DisplayContext_Initialize
  5094                              <2> 
  5095                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5096                              <2> 	%define SetCharacterPointerFromBXAX						DisplayContext_SetCharacterPointerFromBXAX
  5097                              <2> %endif
  5098                              <2> 	%define SetCharOutputFunctionFromAXwithAttribFlagInBL	DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL
  5099                              <2> 	%define SetCharacterOutputParameterFromAX				DisplayContext_SetCharacterOutputParameterFromAX
  5100                              <2> 	%define SetCharacterAttributeFromAL						DisplayContext_SetCharacterAttributeFromAL
  5101                              <2> 	%define SetCursorShapeFromAX							DisplayCursor_SetShapeFromAX
  5102                              <2> 	%define SetCursorCoordinatesFromAX						DisplayCursor_SetCoordinatesFromAX
  5103                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  5104                              <2> 	%define SetNewPageFromAL								DisplayPage_SetFromAL
  5105                              <2> %endif
  5106                              <2> 	%define SynchronizeDisplayContextToHardware				DisplayContext_SynchronizeToHardware
  5107                              <2> 
  5108                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5109                              <2> 	%define GetCharacterPointerToBXAX						DisplayContext_GetCharacterPointerToBXAX
  5110                              <2> %endif
  5111                              <2> 	%define GetSoftwareCoordinatesToAX						DisplayCursor_GetSoftwareCoordinatesToAX
  5112                              <2> 	%define GetColumnsToALandRowsToAH						DisplayPage_GetColumnsToALandRowsToAH
  5113                              <2> 
  5114                              <2> 	%define FormatNullTerminatedStringFromCSSI				Display_FormatNullTerminatedStringFromCSSI
  5115                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5116                              <2> 	%define PrintSignedWordFromAXWithBaseInBX				DisplayPrint_SignedWordFromAXWithBaseInBX
  5117                              <2> %endif
  5118                              <2> 	%define PrintWordFromAXwithBaseInBX						DisplayPrint_WordFromAXWithBaseInBX
  5119                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  5120                              <2> 	%define PrintQWordFromSSBPwithBaseInBX					DisplayPrint_QWordFromSSBPwithBaseInBX
  5121                              <2> %endif
  5122                              <2> 	%define PrintCharBufferFromBXSIwithLengthInCX			DisplayPrint_CharacterBufferFromBXSIwithLengthInCX
  5123                              <2> 	%define PrintNullTerminatedStringFromBXSI				DisplayPrint_NullTerminatedStringFromBXSI
  5124                              <2> 	%define PrintNullTerminatedStringFromCSSI				DisplayPrint_NullTerminatedStringFromCSSI
  5125                              <2> 	%define PrintRepeatedCharacterFromALwithCountInCX		DisplayPrint_RepeatCharacterFromALwithCountInCX
  5126                              <2> 	%define PrintCharacterFromAL							DisplayPrint_CharacterFromAL
  5127                              <2> 	%define PrintNewlineCharacters							DisplayPrint_Newline
  5128                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5129                              <2> 	%define ClearAreaWithHeightInAHandWidthInAL				DisplayPrint_ClearAreaWithHeightInAHandWidthInAL
  5130                              <2> %endif
  5131                              <2> 	%define ClearScreenWithCharInALandAttrInAH				DisplayPrint_ClearScreenWithCharInALandAttributeInAH
  5132                              <2> 
  5133                              <1> 	%include "DisplayCharOut.asm"
  5134                              <2> ; Project name	:	Assembly Library
  5135                              <2> ; Description	:	Functions for outputting characters to video memory.
  5136                              <2> ;					These functions are meant to be called by Display_CharacterFromAL
  5137                              <2> ;					and Display_RepeatCharacterFromAL using function pointer
  5138                              <2> ;					stored in DISPLAY_CONTEXT.
  5139                              <2> 
  5140                              <2> ;
  5141                              <2> ; XTIDE Universal BIOS and Associated Tools
  5142                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5143                              <2> ;
  5144                              <2> ; This program is free software; you can redistribute it and/or modify
  5145                              <2> ; it under the terms of the GNU General Public License as published by
  5146                              <2> ; the Free Software Foundation; either version 2 of the License, or
  5147                              <2> ; (at your option) any later version.
  5148                              <2> ;
  5149                              <2> ; This program is distributed in the hope that it will be useful,
  5150                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5151                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5152                              <2> ; GNU General Public License for more details.
  5153                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5154                              <2> ;
  5155                              <2> 
  5156                              <2> ; Section containing code
  5157                              <2> SECTION .text
  5158                              <2> 
  5159                              <2> ;--------------------------------------------------------------------
  5160                              <2> ; DisplayCharOut_TeletypeOutputWithAttribute
  5161                              <2> ; DisplayCharOut_TeletypeOutput
  5162                              <2> ;	Parameters:
  5163                              <2> ;		AL:		Character to output
  5164                              <2> ;		AH:		Attribute to output
  5165                              <2> ;		DS:		BDA segment (zero)
  5166                              <2> ;		ES:DI:	Ptr to video memory where to output
  5167                              <2> ;	Returns:
  5168                              <2> ;		DI:		Incremented for next character
  5169                              <2> ;	Corrupts registers:
  5170                              <2> ;		AX, DX
  5171                              <2> ;--------------------------------------------------------------------
  5172                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5173                              <2> DisplayCharOut_TeletypeOutputWithAttribute:
  5174 00000131 3C20                <2> 	cmp		al, ' '							; Printable character?
  5175 00000133 7206                <2> 	jb		SHORT DisplayCharOut_BiosTeletypeOutput
  5176                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosw
  5177                              <3> %ifdef ELIMINATE_CGA_SNOW
  5178                              <3>  %ifidn %1, stosb
  5179                              <3>  call CgaSnow_Stosb
  5180                              <3>  %elifidn %1, stosw
  5181                              <3>  call CgaSnow_Stosw
  5182                              <3>  %elifidn %1, rep movsb
  5183                              <3>  call CgaSnow_RepMovsb
  5184                              <3>  %else
  5185                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  5186                              <3>  %endif
  5187                              <3> %else
  5188                              <3>  %ifidn %1, rep movsb
  5189                              <3>  eSEG_STR rep, es, movsb
  5190                              <3>  %else
  5191 00000135 AB                  <3>  %1
  5192                              <3>  %endif
  5193                              <3> %endif
  5194 00000136 C3                  <2> 	ret
  5195                              <2> 
  5196                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5197                              <2> DisplayCharOut_TeletypeOutput:
  5198 00000137 3C20                <2> 	cmp		al, ' '							; Printable character?
  5199 00000139 7319                <2> 	jae		SHORT DisplayCharOut_Character
  5200                              <2> 	; Fall to DisplayCharOut_BiosTeletypeOutput
  5201                              <2> 
  5202                              <2> ;--------------------------------------------------------------------
  5203                              <2> ; DisplayCharOut_BiosTeletypeOutput
  5204                              <2> ;	Parameters:
  5205                              <2> ;		AL:		Control character
  5206                              <2> ;		DS:		BDA segment (zero)
  5207                              <2> ;		ES:DI:	Ptr to video memory where to output
  5208                              <2> ;	Returns:
  5209                              <2> ;		DI:		Incremented for next character
  5210                              <2> ;	Corrupts registers:
  5211                              <2> ;		AX, DX
  5212                              <2> ;--------------------------------------------------------------------
  5213                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5214                              <2> DisplayCharOut_BiosTeletypeOutput:
  5215 0000013B 50                  <2> 	push	ax
  5216 0000013C E8BA00              <2> 	call	DisplayCursor_SynchronizeCoordinatesToHardware
  5217 0000013F 58                  <2> 	pop		ax
  5218                              <2> 
  5219                              <2> 	; Output character with BIOS
  5220 00000140 53                  <2> 	push	bx
  5221 00000141 B40E                <2> 	mov		ah, TELETYPE_OUTPUT
  5222 00000143 8A3E6204            <2> 	mov		bh, [VIDEO_BDA.bActivePage]
  5223 00000147 CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  5224 00000149 5B                  <2> 	pop		bx
  5225                              <2> 
  5226 0000014A E88800              <2> 	call	DisplayCursor_GetHardwareCoordinatesToAX
  5227 0000014D EB61                <2> 	jmp		DisplayCursor_SetCoordinatesFromAX
  5228                              <2> 
  5229                              <2> 
  5230                              <2> ;--------------------------------------------------------------------
  5231                              <2> ; DisplayCharOut_Attribute
  5232                              <2> ; DisplayCharOut_Character
  5233                              <2> ; DisplayCharOut_CharacterWithAttribute
  5234                              <2> ;	Parameters:
  5235                              <2> ;		AL:		Character to output
  5236                              <2> ;		AH:		Attribute to output
  5237                              <2> ;		DS:		BDA segment (zero)
  5238                              <2> ;		ES:DI:	Ptr to video memory where to output
  5239                              <2> ;	Returns:
  5240                              <2> ;		DI:		Incremented for next character
  5241                              <2> ;	Corrupts registers:
  5242                              <2> ;		AX, DX
  5243                              <2> ;--------------------------------------------------------------------
  5244                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5245                              <2> DisplayCharOut_Attribute:
  5246 0000014F 86C4                <2> 	xchg	al, ah				; Swap character and attribute
  5247 00000151 47                  <2> 	inc		di					; Skip character
  5248                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosb
  5249                              <3> %ifdef ELIMINATE_CGA_SNOW
  5250                              <3>  %ifidn %1, stosb
  5251                              <3>  call CgaSnow_Stosb
  5252                              <3>  %elifidn %1, stosw
  5253                              <3>  call CgaSnow_Stosw
  5254                              <3>  %elifidn %1, rep movsb
  5255                              <3>  call CgaSnow_RepMovsb
  5256                              <3>  %else
  5257                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  5258                              <3>  %endif
  5259                              <3> %else
  5260                              <3>  %ifidn %1, rep movsb
  5261                              <3>  eSEG_STR rep, es, movsb
  5262                              <3>  %else
  5263 00000152 AA                  <3>  %1
  5264                              <3>  %endif
  5265                              <3> %endif
  5266 00000153 C3                  <2> 	ret
  5267                              <2> 
  5268                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5269                              <2> DisplayCharOut_Character:
  5270                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosb
  5271                              <3> %ifdef ELIMINATE_CGA_SNOW
  5272                              <3>  %ifidn %1, stosb
  5273                              <3>  call CgaSnow_Stosb
  5274                              <3>  %elifidn %1, stosw
  5275                              <3>  call CgaSnow_Stosw
  5276                              <3>  %elifidn %1, rep movsb
  5277                              <3>  call CgaSnow_RepMovsb
  5278                              <3>  %else
  5279                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  5280                              <3>  %endif
  5281                              <3> %else
  5282                              <3>  %ifidn %1, rep movsb
  5283                              <3>  eSEG_STR rep, es, movsb
  5284                              <3>  %else
  5285 00000154 AA                  <3>  %1
  5286                              <3>  %endif
  5287                              <3> %endif
  5288 00000155 47                  <2> 	inc		di					; Skip attribute
  5289 00000156 C3                  <2> 	ret
  5290                              <2> 
  5291                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5292                              <2> DisplayCharOut_CharacterWithAttribute:
  5293                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosw
  5294                              <3> %ifdef ELIMINATE_CGA_SNOW
  5295                              <3>  %ifidn %1, stosb
  5296                              <3>  call CgaSnow_Stosb
  5297                              <3>  %elifidn %1, stosw
  5298                              <3>  call CgaSnow_Stosw
  5299                              <3>  %elifidn %1, rep movsb
  5300                              <3>  call CgaSnow_RepMovsb
  5301                              <3>  %else
  5302                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  5303                              <3>  %endif
  5304                              <3> %else
  5305                              <3>  %ifidn %1, rep movsb
  5306                              <3>  eSEG_STR rep, es, movsb
  5307                              <3>  %else
  5308 00000157 AB                  <3>  %1
  5309                              <3>  %endif
  5310                              <3> %endif
  5311 00000158 C3                  <2> 	ret
  5312                              <2> 
  5313                              <2> 
  5314                              <2> ;--------------------------------------------------------------------
  5315                              <2> ; DisplayCharOut_WriteCharacterToBuffer
  5316                              <2> ;	Parameters:
  5317                              <2> ;		AL:		Character to output
  5318                              <2> ;		DS:		BDA segment (zero)
  5319                              <2> ;		ES:DI:	Ptr to destination string buffer
  5320                              <2> ;		DISPLAY_CONTEXT.wCharOutParam:	Characters left in buffer
  5321                              <2> ;	Returns:
  5322                              <2> ;		ES:DI:	Updated for next character
  5323                              <2> ;	Corrupts registers:
  5324                              <2> ;		AX, DX
  5325                              <2> ;--------------------------------------------------------------------
  5326                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5327                              <2> DisplayCharOut_WriteCharacterToBuffer:
  5328 00000159 833E5A0400          <2> 	cmp		WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam], BYTE 0
  5329 0000015E 7405                <2> 	je		SHORT .BufferFull
  5330 00000160 AA                  <2> 	stosb
  5331 00000161 FF0E5A04            <2> 	dec		WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam]
  5332                              <2> .BufferFull:
  5333 00000165 C3                  <2> 	ret
  5334                              <1> 	%include "DisplayContext.asm"
  5335                              <2> ; Project name	:	Assembly Library
  5336                              <2> ; Description	:	Functions for managing display context.
  5337                              <2> 
  5338                              <2> ;
  5339                              <2> ; XTIDE Universal BIOS and Associated Tools
  5340                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5341                              <2> ;
  5342                              <2> ; This program is free software; you can redistribute it and/or modify
  5343                              <2> ; it under the terms of the GNU General Public License as published by
  5344                              <2> ; the Free Software Foundation; either version 2 of the License, or
  5345                              <2> ; (at your option) any later version.
  5346                              <2> ;
  5347                              <2> ; This program is distributed in the hope that it will be useful,
  5348                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5349                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5350                              <2> ; GNU General Public License for more details.
  5351                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5352                              <2> ;
  5353                              <2> 
  5354                              <2> ; Section containing code
  5355                              <2> SECTION .text
  5356                              <2> 
  5357                              <2> ;--------------------------------------------------------------------
  5358                              <2> ; DisplayContext_Initialize
  5359                              <2> ;	Parameters:
  5360                              <2> ;		DS:		BDA segment (zero)
  5361                              <2> ;	Returns:
  5362                              <2> ;		Nothing
  5363                              <2> ;	Corrupts registers:
  5364                              <2> ;		AX, DX, DI
  5365                              <2> ;--------------------------------------------------------------------
  5366                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5367                              <2> DisplayContext_Initialize:
  5368 00000166 C7065804[3101]      <2> 	mov		WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fnCharOut], DEFAULT_CHARACTER_OUTPUT
  5369 0000016C C6065E0407          <2> 	mov		BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], SCREEN_BACKGROUND_ATTRIBUTE
  5370 00000171 E82E00              <2> 	call	DisplayCursor_GetDefaultCursorShapeToAX
  5371 00000174 A35C04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCursorShape], ax
  5372                              <2> 	; Fall to .DetectAndSetDisplaySegment
  5373                              <2> 
  5374                              <2> ;--------------------------------------------------------------------
  5375                              <2> ; .DetectAndSetDisplaySegment
  5376                              <2> ;	Parameters:
  5377                              <2> ;		DS:		BDA segment (zero)
  5378                              <2> ;	Returns:
  5379                              <2> ;		Nothing
  5380                              <2> ;	Corrupts registers:
  5381                              <2> ;		AX, DX
  5382                              <2> ;--------------------------------------------------------------------
  5383                              <2> .DetectAndSetDisplaySegment:
  5384 00000177 B800B8              <2> 	mov		ax, COLOR_TEXT_SEGMENT
  5385 0000017A 803E490407          <2> 	cmp		BYTE [VIDEO_BDA.bMode], MDA_TEXT_MODE
  5386                              <2> 	eCMOVE	ah, MONO_TEXT_SEGMENT >> 8
  5387                              <3>  eCMOVZ %1, %2
  5388 0000017F 7502                <4>  jnz SHORT %%Return
  5389 00000181 B4B0                <4>  mov %1, %2
  5390                              <4> %%Return:
  5391 00000183 A35604              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition+2], ax
  5392                              <2> 	; Fall to .InitializeFlags
  5393                              <2> 
  5394                              <2> ;--------------------------------------------------------------------
  5395                              <2> ; .InitializeFlags
  5396                              <2> ;	Parameters:
  5397                              <2> ;		DS:		BDA segment (zero)
  5398                              <2> ;	Returns:
  5399                              <2> ;		Nothing
  5400                              <2> ;	Corrupts registers:
  5401                              <2> ;		AX, DX
  5402                              <2> ;--------------------------------------------------------------------
  5403                              <2> .InitializeFlags:
  5404 00000186 B201                <2> 	mov		dl, FLG_CONTEXT_ATTRIBUTES
  5405 00000188 E86BFF              <2> 	call	CgaSnow_IsCgaPresent
  5406 0000018B 7303                <2> 	jnc		SHORT .DoNotSetCgaFlag
  5407 0000018D 80CA02              <2> 	or		dl, FLG_CONTEXT_CGA
  5408                              <2> .DoNotSetCgaFlag:
  5409 00000190 88165F04            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], dl
  5410                              <2> 	; Fall to .InitializeCursor
  5411                              <2> 
  5412                              <2> ;--------------------------------------------------------------------
  5413                              <2> ; .InitializeCursor
  5414                              <2> ;	Parameters:
  5415                              <2> ;		DS:		BDA segment (zero)
  5416                              <2> ;	Returns:
  5417                              <2> ;		Nothing
  5418                              <2> ;	Corrupts registers:
  5419                              <2> ;		AX, DX
  5420                              <2> ;--------------------------------------------------------------------
  5421                              <2> .InitializeCursor:
  5422 00000194 E83E00              <2> 	call	DisplayCursor_GetHardwareCoordinatesToAX	; Coordinates before init
  5423 00000197 E81600              <2> 	call	DisplayCursor_SetCoordinatesFromAX			; Cursor to Display Context
  5424                              <2> 	; Fall to DisplayContext_SynchronizeToHardware
  5425                              <2> 
  5426                              <2> ;--------------------------------------------------------------------
  5427                              <2> ; DisplayContext_SynchronizeToHardware
  5428                              <2> ;	Parameters:
  5429                              <2> ;		DS:		BDA segment (zero)
  5430                              <2> ;	Returns:
  5431                              <2> ;		Nothing
  5432                              <2> ;	Corrupts registers:
  5433                              <2> ;		AX, DX
  5434                              <2> ;--------------------------------------------------------------------
  5435                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5436                              <2> DisplayContext_SynchronizeToHardware:
  5437 0000019A E86B00              <2> 	call	DisplayPage_SynchronizeToHardware
  5438 0000019D E84300              <2> 	call	DisplayCursor_SynchronizeShapeToHardware
  5439 000001A0 EB57                <2> 	jmp		DisplayCursor_SynchronizeCoordinatesToHardware
  5440                              <2> 
  5441                              <2> 
  5442                              <2> ;--------------------------------------------------------------------
  5443                              <2> ; DisplayContext_Push
  5444                              <2> ; DisplayContext_Pop
  5445                              <2> ;	Parameters:
  5446                              <2> ;		Nothing
  5447                              <2> ;	Returns:
  5448                              <2> ;		Nothing
  5449                              <2> ;	Corrupts registers:
  5450                              <2> ;		AX, DI
  5451                              <2> ;--------------------------------------------------------------------
  5452                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5453                              <2> 	%ifndef MODULE_BOOT_MENU
  5454                              <2> 		%define EXCLUDE
  5455                              <2> 	%endif
  5456                              <2> %endif
  5457                              <2> 
  5458                              <2> %ifndef EXCLUDE
  5459                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5460                              <2> DisplayContext_Push:
  5461                              <2> 	mov		di, ds					; Backup DS
  5462                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax
  5463                              <2> 	pop		ax						; Pop return address
  5464                              <2> 
  5465                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  5466                              <2> 	%assign i 0
  5467                              <2> 	%rep DISPLAY_CONTEXT_size / 2
  5468                              <2> 		push	WORD [VIDEO_BDA.displayContext + i]
  5469                              <2> 	%assign i i+2
  5470                              <2> 	%endrep
  5471                              <2> %endif
  5472                              <2> 
  5473                              <2> 	mov		ds, di					; Restore DS
  5474                              <2> 	jmp		ax
  5475                              <2> 
  5476                              <2> 
  5477                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5478                              <2> DisplayContext_Pop:
  5479                              <2> 	mov		di, ds					; Backup DS
  5480                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax
  5481                              <2> 	pop		ax						; Pop return address
  5482                              <2> 
  5483                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  5484                              <2> 	%assign i DISPLAY_CONTEXT_size-2
  5485                              <2> 	%rep DISPLAY_CONTEXT_size / 2
  5486                              <2> 		pop		WORD [VIDEO_BDA.displayContext + i]
  5487                              <2> 	%assign i i-2
  5488                              <2> 	%endrep
  5489                              <2> %endif
  5490                              <2> 
  5491                              <2> 	push	ax						; Push return address
  5492                              <2> 	push	dx
  5493                              <2> 	call	DisplayContext_SynchronizeToHardware
  5494                              <2> 	pop		dx
  5495                              <2> 	mov		ds, di					; Restore DS
  5496                              <2> 	ret
  5497                              <2> %endif ; EXCLUDE
  5498                              <2> %undef EXCLUDE
  5499                              <2> 
  5500                              <2> 
  5501                              <2> ;--------------------------------------------------------------------
  5502                              <2> ; DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
  5503                              <2> ;	Parameters:
  5504                              <2> ;		CX:		Off screen buffer length in characters
  5505                              <2> ;		ES:BX:	Ptr to off screen buffer
  5506                              <2> ;	Returns:
  5507                              <2> ;		Nothing
  5508                              <2> ;	Corrupts registers:
  5509                              <2> ;		AX, DI
  5510                              <2> ;--------------------------------------------------------------------
  5511                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5512                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5513                              <2> DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX:
  5514                              <2> 	push	ds
  5515                              <2> 
  5516                              <2> 	LOAD_BDA_SEGMENT_TO	ds, di
  5517                              <2> 	xchg	ax, bx
  5518                              <2> 	mov		bx, es
  5519                              <2> 	call	DisplayContext_SetCharacterPointerFromBXAX	; ES:DI now has the pointer
  5520                              <2> 
  5521                              <2> 	mov		bl, ATTRIBUTES_NOT_USED
  5522                              <2> 	mov		ax, BUFFER_OUTPUT_WITH_CHAR_ONLY
  5523                              <2> 	call	DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL
  5524                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam], cx
  5525                              <2> 
  5526                              <2> 	mov		bx, di
  5527                              <2> 	pop		ds
  5528                              <2> 	ret
  5529                              <2> %endif ; EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5530                              <2> 
  5531                              <2> 
  5532                              <2> ;--------------------------------------------------------------------
  5533                              <2> ; DisplayContext_SetCharacterPointerFromBXAX
  5534                              <2> ;	Parameters:
  5535                              <2> ;		BX:AX:	Ptr to destination for next character to output
  5536                              <2> ;		DS:		BDA segment (zero)
  5537                              <2> ;	Returns:
  5538                              <2> ;		ES:DI:	Pointer that was in BX:AX
  5539                              <2> ;	Corrupts registers:
  5540                              <2> ;		AX
  5541                              <2> ;--------------------------------------------------------------------
  5542                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5543                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5544                              <2> DisplayContext_SetCharacterPointerFromBXAX:
  5545                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], ax
  5546                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition+2], bx
  5547                              <2> 	xchg	di, ax
  5548                              <2> 	mov		es, bx
  5549                              <2> 	ret
  5550                              <2> %endif
  5551                              <2> 
  5552                              <2> 
  5553                              <2> ;--------------------------------------------------------------------
  5554                              <2> ; DisplayContext_GetCharacterPointerToBXAX
  5555                              <2> ;	Parameters:
  5556                              <2> ;		DS:		BDA segment (zero)
  5557                              <2> ;	Returns:
  5558                              <2> ;		BX:AX:	Ptr to destination for next character to output
  5559                              <2> ;	Corrupts registers:
  5560                              <2> ;		Nothing
  5561                              <2> ;--------------------------------------------------------------------
  5562                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5563                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5564                              <2> DisplayContext_GetCharacterPointerToBXAX:
  5565                              <2> 	mov		ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
  5566                              <2> 	mov		bx, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition+2]
  5567                              <2> 	ret
  5568                              <2> %endif
  5569                              <2> 
  5570                              <2> 
  5571                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5572                              <2> 	%ifndef MODULE_BOOT_MENU
  5573                              <2> 		%define EXCLUDE
  5574                              <2> 	%endif
  5575                              <2> %endif
  5576                              <2> ;--------------------------------------------------------------------
  5577                              <2> ; DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL
  5578                              <2> ;	Parameters:
  5579                              <2> ;		AX:		Offset to character output function
  5580                              <2> ;		BL:		Attribute Flag
  5581                              <2> ;		DS:		BDA segment (zero)
  5582                              <2> ;	Returns:
  5583                              <2> ;		Nothing
  5584                              <2> ;	Corrupts registers:
  5585                              <2> ;		BL
  5586                              <2> ;--------------------------------------------------------------------
  5587                              <2> %ifndef EXCLUDE	; 1 of 3
  5588                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5589                              <2> DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL:
  5590                              <2> 	and		bl, FLG_CONTEXT_ATTRIBUTES
  5591                              <2> 	and		BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], ~FLG_CONTEXT_ATTRIBUTES
  5592                              <2> 	or		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], bl
  5593                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fnCharOut], ax
  5594                              <2> 	ret
  5595                              <2> %endif
  5596                              <2> 
  5597                              <2> 
  5598                              <2> ;--------------------------------------------------------------------
  5599                              <2> ; DisplayContext_SetCharacterAttributeFromAL
  5600                              <2> ;	Parameters:
  5601                              <2> ;		AL:		Character attribute
  5602                              <2> ;		DS:		BDA segment (zero)
  5603                              <2> ;	Returns:
  5604                              <2> ;		Nothing
  5605                              <2> ;	Corrupts registers:
  5606                              <2> ;		Nothing
  5607                              <2> ;--------------------------------------------------------------------
  5608                              <2> %ifndef EXCLUDE	; 2 of 3
  5609                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5610                              <2> DisplayContext_SetCharacterAttributeFromAL:
  5611                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], al
  5612                              <2> 	ret
  5613                              <2> %endif
  5614                              <2> 
  5615                              <2> 
  5616                              <2> ;--------------------------------------------------------------------
  5617                              <2> ; DisplayContext_SetCharacterOutputParameterFromAX
  5618                              <2> ;	Parameters:
  5619                              <2> ;		AX:		Parameter for Character Output function
  5620                              <2> ;		DS:		BDA segment (zero)
  5621                              <2> ;	Returns:
  5622                              <2> ;		Nothing
  5623                              <2> ;	Corrupts registers:
  5624                              <2> ;		Nothing
  5625                              <2> ;--------------------------------------------------------------------
  5626                              <2> %ifndef EXCLUDE	; 3 of 3
  5627                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5628                              <2> DisplayContext_SetCharacterOutputParameterFromAX:
  5629                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam], ax
  5630                              <2> 	ret
  5631                              <2> %endif
  5632                              <2> 
  5633                              <2> %undef EXCLUDE
  5634                              <2> 
  5635                              <2> 
  5636                              <2> ;--------------------------------------------------------------------
  5637                              <2> ; DisplayContext_GetCharacterOutputParameterToDX
  5638                              <2> ;	Parameters:
  5639                              <2> ;		DS:		BDA segment (zero)
  5640                              <2> ;	Returns:
  5641                              <2> ;		DX:		User parameter for Character Output function
  5642                              <2> ;	Corrupts registers:
  5643                              <2> ;		Nothing
  5644                              <2> ;--------------------------------------------------------------------
  5645                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  5646                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5647                              <2> DisplayContext_GetCharacterOutputParameterToDX:
  5648                              <2> 	mov		dx, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam]
  5649                              <2> 	ret
  5650                              <2> %endif
  5651                              <2> 
  5652                              <2> 
  5653                              <2> ;--------------------------------------------------------------------
  5654                              <2> ; DisplayContext_GetCharacterOffsetToAXfromByteOffsetInAX
  5655                              <2> ;	Parameters:
  5656                              <2> ;		AX:		Offset in bytes from some character to another
  5657                              <2> ;		DS:		BDA segment (zero)
  5658                              <2> ;	Returns:
  5659                              <2> ;		AX:		Offset in characters from some character to another
  5660                              <2> ;	Corrupts registers:
  5661                              <2> ;		Nothing
  5662                              <2> ;--------------------------------------------------------------------
  5663                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  5664                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5665                              <2> DisplayContext_GetCharacterOffsetToAXfromByteOffsetInAX:
  5666                              <2> 	test	BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], FLG_CONTEXT_ATTRIBUTES
  5667                              <2> 	jz		SHORT ReturnOffsetInAX
  5668                              <2> 	sar		ax, 1		; BYTE count to WORD count
  5669                              <2> 	ret
  5670                              <2> %endif
  5671                              <2> 
  5672                              <2> 
  5673                              <2> ;--------------------------------------------------------------------
  5674                              <2> ; DisplayContext_GetByteOffsetToAXfromCharacterOffsetInAX
  5675                              <2> ;	Parameters:
  5676                              <2> ;		AX:		Offset in characters from some character to another
  5677                              <2> ;		DS:		BDA segment (zero)
  5678                              <2> ;	Returns:
  5679                              <2> ;		AX:		Offset in bytes from some character to another
  5680                              <2> ;	Corrupts registers:
  5681                              <2> ;		Nothing
  5682                              <2> ;--------------------------------------------------------------------
  5683                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  5684                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5685                              <2> DisplayContext_GetByteOffsetToAXfromCharacterOffsetInAX:
  5686                              <2> 	test	BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], FLG_CONTEXT_ATTRIBUTES
  5687                              <2> 	jz		SHORT ReturnOffsetInAX
  5688                              <2> 	sal		ax, 1		; WORD count to BYTE count
  5689                              <2> ALIGN DISPLAY_JUMP_ALIGN, ret
  5690                              <2> ReturnOffsetInAX:
  5691                              <2> 	ret
  5692                              <2> %endif
  5693                              <1> 	%include "DisplayCursor.asm"
  5694                              <2> ; Project name	:	Assembly Library
  5695                              <2> ; Description	:	Functions for managing display cursor.
  5696                              <2> 
  5697                              <2> ;
  5698                              <2> ; XTIDE Universal BIOS and Associated Tools
  5699                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5700                              <2> ;
  5701                              <2> ; This program is free software; you can redistribute it and/or modify
  5702                              <2> ; it under the terms of the GNU General Public License as published by
  5703                              <2> ; the Free Software Foundation; either version 2 of the License, or
  5704                              <2> ; (at your option) any later version.
  5705                              <2> ;
  5706                              <2> ; This program is distributed in the hope that it will be useful,
  5707                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5708                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5709                              <2> ; GNU General Public License for more details.
  5710                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5711                              <2> ;
  5712                              <2> 
  5713                              <2> ; Section containing code
  5714                              <2> SECTION .text
  5715                              <2> 
  5716                              <2> ;--------------------------------------------------------------------
  5717                              <2> ; DisplayCursor_GetDefaultCursorShapeToAX
  5718                              <2> ;	Parameters:
  5719                              <2> ;		DS:		BDA segment (zero)
  5720                              <2> ;	Returns:
  5721                              <2> ;		AX:		Default text mode cursor shape
  5722                              <2> ;	Corrupts registers:
  5723                              <2> ;		Nothing
  5724                              <2> ;--------------------------------------------------------------------
  5725                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5726                              <2> DisplayCursor_GetDefaultCursorShapeToAX:
  5727 000001A2 B80706              <2> 	mov		ax, CURSOR_NORMAL_COLOR				; CGA, EGA, VGA cursor
  5728 000001A5 803E490407          <2> 	cmp		BYTE [VIDEO_BDA.bMode], MDA_TEXT_MODE
  5729                              <2> 	eCMOVE	ax, CURSOR_NORMAL_MDA				; MDA cursor
  5730                              <3>  eCMOVZ %1, %2
  5731 000001AA 7503                <4>  jnz SHORT %%Return
  5732 000001AC B80C0B              <4>  mov %1, %2
  5733                              <4> %%Return:
  5734 000001AF C3                  <2> 	ret
  5735                              <2> 
  5736                              <2> 
  5737                              <2> ;--------------------------------------------------------------------
  5738                              <2> ; DisplayCursor_SetShapeFromAX
  5739                              <2> ;	Parameters:
  5740                              <2> ;		AX:		Cursor shape (AH=Start scan line, AL=End scan line)
  5741                              <2> ;		DS:		BDA segment (zero)
  5742                              <2> ;	Returns:
  5743                              <2> ;		Nothing
  5744                              <2> ;	Corrupts registers:
  5745                              <2> ;		Nothing
  5746                              <2> ;--------------------------------------------------------------------
  5747                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5748                              <2> 	%ifndef MODULE_BOOT_MENU
  5749                              <2> 		%define EXCLUDE
  5750                              <2> 	%endif
  5751                              <2> %endif
  5752                              <2> 
  5753                              <2> %ifndef EXCLUDE
  5754                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5755                              <2> DisplayCursor_SetShapeFromAX:
  5756                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCursorShape], ax
  5757                              <2> 	ret
  5758                              <2> %endif
  5759                              <2> %undef EXCLUDE
  5760                              <2> 
  5761                              <2> 
  5762                              <2> ;--------------------------------------------------------------------
  5763                              <2> ; DisplayCursor_SetCoordinatesFromAX
  5764                              <2> ;	Parameters:
  5765                              <2> ;		AL:		Cursor column (X-coordinate)
  5766                              <2> ;		AH:		Cursor row (Y-coordinate)
  5767                              <2> ;		DS:		BDA segment (zero)
  5768                              <2> ;	Returns:
  5769                              <2> ;		DI:		Offset to cursor location in video RAM
  5770                              <2> ;	Corrupts registers:
  5771                              <2> ;		AX, DX
  5772                              <2> ;--------------------------------------------------------------------
  5773                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5774                              <2> DisplayCursor_SetCoordinatesFromAX:
  5775 000001B0 92                  <2> 	xchg	dx, ax
  5776 000001B1 A14A04              <2> 	mov		ax, [VIDEO_BDA.wColumns]		; Column count, 40 or 80
  5777 000001B4 F6E6                <2> 	mul		dh								; AX = Column count * row index
  5778 000001B6 30F6                <2> 	xor		dh, dh
  5779 000001B8 01D0                <2> 	add		ax, dx							; Add column offset
  5780                              <2> 	eSHL_IM	ax, 1							; Convert to WORD offset
  5781                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  5782                              <3> %ifdef USE_386
  5783                              <3>  %if %2 = 1
  5784                              <3>  add %1, %1
  5785                              <3>  %else
  5786                              <3>  eSHIFT_IM %1, %2, shl
  5787                              <3>  %endif
  5788                              <3> %else
  5789                              <3>  eSHIFT_IM %1, %2, shl
  5790                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  5791                              <4> %ifndef USE_186
  5792                              <4>  %ifidni %1, cl
  5793                              <4>  times %2 %3 %1, 1
  5794                              <4>  %elifidni %1, ch
  5795                              <4>  times %2 %3 %1, 1
  5796                              <4>  %elifidni %1, cx
  5797                              <4>  times %2 %3 %1, 1
  5798                              <4>  %else
  5799                              <4>  %if %2 > 3
  5800                              <4>  push cx
  5801                              <4>  mov cl, %2
  5802                              <4>  %3 %1, cl
  5803                              <4>  pop cx
  5804                              <4>  %else
  5805 000001BA D1E0                <4>  times %2 %3 %1, 1
  5806                              <4>  %endif
  5807                              <4>  %endif
  5808                              <4> 
  5809                              <4> %else
  5810                              <4>  %3 %1, %2
  5811                              <4> %endif
  5812                              <4> %endif
  5813                              <3> %endif
  5814                              <3> %endif
  5815 000001BC 03064E04            <2> 	add		ax, [VIDEO_BDA.wPageOffset]		; AX = Video RAM offset
  5816 000001C0 A35404              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], ax
  5817 000001C3 97                  <2> 	xchg	di, ax
  5818 000001C4 C3                  <2> 	ret
  5819                              <2> 
  5820                              <2> 
  5821                              <2> ;--------------------------------------------------------------------
  5822                              <2> ; DisplayCursor_GetSoftwareCoordinatesToAX
  5823                              <2> ;	Parameters:
  5824                              <2> ;		AX:		Offset to cursor location in selected page
  5825                              <2> ;		DS:		BDA segment (zero)
  5826                              <2> ;	Returns:
  5827                              <2> ;		AL:		Cursor column (X-coordinate)
  5828                              <2> ;		AH:		Cursor row (Y-coordinate)
  5829                              <2> ;	Corrupts registers:
  5830                              <2> ;		Nothing
  5831                              <2> ;--------------------------------------------------------------------
  5832                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5833                              <2> DisplayCursor_GetSoftwareCoordinatesToAX:
  5834 000001C5 A15404              <2> 	mov		ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
  5835 000001C8 2B064E04            <2> 	sub		ax, [VIDEO_BDA.wPageOffset]
  5836 000001CC D1E8                <2> 	shr		ax, 1							; WORD offset to character offset
  5837 000001CE F6364A04            <2> 	div		BYTE [VIDEO_BDA.wColumns]		; AL = full rows, AH = column index for last row
  5838 000001D2 86C4                <2> 	xchg	al, ah
  5839 000001D4 C3                  <2> 	ret
  5840                              <2> 
  5841                              <2> 
  5842                              <2> ;--------------------------------------------------------------------
  5843                              <2> ; DisplayCursor_GetHardwareCoordinatesToAX
  5844                              <2> ;	Parameters:
  5845                              <2> ;		DS:		BDA segment (zero)
  5846                              <2> ;	Returns:
  5847                              <2> ;		AL:		Hardware cursor column (X-coordinate)
  5848                              <2> ;		AH:		Hardware cursor row (Y-coordinate)
  5849                              <2> ;	Corrupts registers:
  5850                              <2> ;		DX
  5851                              <2> ;--------------------------------------------------------------------
  5852                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5853                              <2> DisplayCursor_GetHardwareCoordinatesToAX:
  5854 000001D5 51                  <2> 	push	cx
  5855 000001D6 53                  <2> 	push	bx
  5856                              <2> 
  5857 000001D7 B403                <2> 	mov		ah, GET_CURSOR_POSITION_AND_SIZE
  5858 000001D9 8A3E6204            <2> 	mov		bh, [VIDEO_BDA.bActivePage]
  5859 000001DD CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  5860 000001DF 92                  <2> 	xchg	ax, dx
  5861                              <2> 
  5862 000001E0 5B                  <2> 	pop		bx
  5863 000001E1 59                  <2> 	pop		cx
  5864 000001E2 C3                  <2> 	ret
  5865                              <2> 
  5866                              <2> 
  5867                              <2> ;--------------------------------------------------------------------
  5868                              <2> ; DisplayCursor_SynchronizeShapeToHardware
  5869                              <2> ;	Parameters:
  5870                              <2> ;		DS:		BDA segment (zero)
  5871                              <2> ;	Returns:
  5872                              <2> ;		Nothing
  5873                              <2> ;	Corrupts registers:
  5874                              <2> ;		AX, DX
  5875                              <2> ;--------------------------------------------------------------------
  5876                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5877                              <2> DisplayCursor_SynchronizeShapeToHardware:
  5878 000001E3 8B165C04            <2> 	mov		dx, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCursorShape]
  5879                              <2> 	; Fall to .SetHardwareCursorShapeFromDX
  5880                              <2> 
  5881                              <2> ;--------------------------------------------------------------------
  5882                              <2> ; .SetHardwareCursorShapeFromDX
  5883                              <2> ;	Parameters:
  5884                              <2> ;		DX:		Cursor shape
  5885                              <2> ;		DS:		BDA segment (zero)
  5886                              <2> ;	Returns:
  5887                              <2> ;		Nothing
  5888                              <2> ;	Corrupts registers:
  5889                              <2> ;		AX
  5890                              <2> ;--------------------------------------------------------------------
  5891                              <2> .SetHardwareCursorShapeFromDX:
  5892 000001E7 3B166004            <2> 	cmp		dx, [VIDEO_BDA.wCursorShape]
  5893 000001EB 740B                <2> 	je		SHORT .Return					; Return if no changes
  5894 000001ED 51                  <2> 	push	cx
  5895 000001EE 89D1                <2> 	mov		cx, dx							; BIOS wants cursor shape in CX
  5896 000001F0 A04904              <2> 	mov		al, [VIDEO_BDA.bMode]			; Load video mode to prevent lock ups on some BIOSes
  5897 000001F3 B401                <2> 	mov		ah, SET_TEXT_MODE_CURSOR_SHAPE
  5898 000001F5 CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  5899 000001F7 59                  <2> 	pop		cx
  5900                              <2> .Return:
  5901 000001F8 C3                  <2> 	ret
  5902                              <2> 
  5903                              <2> 
  5904                              <2> ;--------------------------------------------------------------------
  5905                              <2> ; DisplayCursor_SynchronizeCoordinatesToHardware
  5906                              <2> ;	Parameters:
  5907                              <2> ;		DS:		BDA segment (zero)
  5908                              <2> ;	Returns:
  5909                              <2> ;		Nothing
  5910                              <2> ;	Corrupts registers:
  5911                              <2> ;		AX, DX
  5912                              <2> ;--------------------------------------------------------------------
  5913                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5914                              <2> DisplayCursor_SynchronizeCoordinatesToHardware:
  5915 000001F9 E8C9FF              <2> 	call	DisplayCursor_GetSoftwareCoordinatesToAX
  5916                              <2> 	; Fall to .SetHardwareCursorCoordinatesFromAX
  5917                              <2> 
  5918                              <2> ;--------------------------------------------------------------------
  5919                              <2> ; .SetHardwareCursorCoordinatesFromAX
  5920                              <2> ;	Parameters:
  5921                              <2> ;		AL:		Cursor column (X-coordinate)
  5922                              <2> ;		AH:		Cursor row (Y-coordinate)
  5923                              <2> ;		DS:		BDA segment (zero)
  5924                              <2> ;	Returns:
  5925                              <2> ;		Nothing
  5926                              <2> ;	Corrupts registers:
  5927                              <2> ;		AX, DX
  5928                              <2> ;--------------------------------------------------------------------
  5929                              <2> .SetHardwareCursorCoordinatesFromAX:
  5930 000001FC 53                  <2> 	push	bx
  5931 000001FD 92                  <2> 	xchg	dx, ax							; BIOS wants coordinates in DX
  5932 000001FE B402                <2> 	mov		ah, SET_CURSOR_POSITION
  5933 00000200 8A3E6204            <2> 	mov		bh, [VIDEO_BDA.bActivePage]
  5934 00000204 CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  5935 00000206 5B                  <2> 	pop		bx
  5936 00000207 C3                  <2> 	ret
  5937                              <1> 	%include "DisplayPage.asm"
  5938                              <2> ; Project name	:	Assembly Library
  5939                              <2> ; Description	:	Functions for managing display page.
  5940                              <2> 
  5941                              <2> ;
  5942                              <2> ; XTIDE Universal BIOS and Associated Tools
  5943                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5944                              <2> ;
  5945                              <2> ; This program is free software; you can redistribute it and/or modify
  5946                              <2> ; it under the terms of the GNU General Public License as published by
  5947                              <2> ; the Free Software Foundation; either version 2 of the License, or
  5948                              <2> ; (at your option) any later version.
  5949                              <2> ;
  5950                              <2> ; This program is distributed in the hope that it will be useful,
  5951                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5952                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5953                              <2> ; GNU General Public License for more details.
  5954                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5955                              <2> ;
  5956                              <2> 
  5957                              <2> ; Section containing code
  5958                              <2> SECTION .text
  5959                              <2> 
  5960                              <2> ;--------------------------------------------------------------------
  5961                              <2> ; DisplayPage_SetFromAL
  5962                              <2> ;	Parameters:
  5963                              <2> ;		AL:		New display page
  5964                              <2> ;		DS:		BDA segment (zero)
  5965                              <2> ;	Returns:
  5966                              <2> ;		Nothing
  5967                              <2> ;	Corrupts registers:
  5968                              <2> ;		AX, DX
  5969                              <2> ;--------------------------------------------------------------------
  5970                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  5971                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5972                              <2> DisplayPage_SetFromAL:
  5973                              <2> 	xor		ah, ah
  5974                              <2> 	mul		WORD [VIDEO_BDA.wBytesPerPage]		; AX = Offset to page
  5975                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], ax
  5976                              <2> 	ret
  5977                              <2> %endif
  5978                              <2> 
  5979                              <2> 
  5980                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5981                              <2> 	%define EXCLUDE
  5982                              <2> 	%ifdef MODULE_HOTKEYS
  5983                              <2> 		%undef EXCLUDE
  5984                              <2> 	%endif
  5985                              <2> 	%ifdef MODULE_BOOT_MENU
  5986                              <2> 		%undef EXCLUDE
  5987                              <2> 	%endif
  5988                              <2> %endif
  5989                              <2> 
  5990                              <2> %ifndef EXCLUDE
  5991                              <2> ;--------------------------------------------------------------------
  5992                              <2> ; DisplayPage_GetColumnsToALandRowsToAH
  5993                              <2> ;	Parameters:
  5994                              <2> ;		DS:		BDA segment (zero)
  5995                              <2> ;	Returns:
  5996                              <2> ;		AL:		Number of columns in selected text mode
  5997                              <2> ;		AH:		Number of rows in selected text mode
  5998                              <2> ;	Corrupts registers:
  5999                              <2> ;		Nothing
  6000                              <2> ;--------------------------------------------------------------------
  6001                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6002                              <2> DisplayPage_GetColumnsToALandRowsToAH:
  6003                              <2> 	mov		al, [VIDEO_BDA.wColumns]		; 40 or 80
  6004                              <2> 	mov		ah, 25							; Always 25 rows on standard text modes
  6005                              <2> 	ret
  6006                              <2> %endif
  6007                              <2> %undef EXCLUDE
  6008                              <2> 
  6009                              <2> ;--------------------------------------------------------------------
  6010                              <2> ; DisplayPage_SynchronizeToHardware
  6011                              <2> ;	Parameters:
  6012                              <2> ;		DS:		BDA segment (zero)
  6013                              <2> ;	Returns:
  6014                              <2> ;		Nothing
  6015                              <2> ;	Corrupts registers:
  6016                              <2> ;		AX, DX
  6017                              <2> ;--------------------------------------------------------------------
  6018                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6019                              <2> DisplayPage_SynchronizeToHardware:
  6020 00000208 31D2                <2> 	xor		dx, dx
  6021 0000020A A15404              <2> 	mov		ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
  6022 0000020D F7364C04            <2> 	div		WORD [VIDEO_BDA.wBytesPerPage]	; AX = Page
  6023                              <2> 
  6024 00000211 3A066204            <2> 	cmp		al, [VIDEO_BDA.bActivePage]
  6025 00000215 7404                <2> 	je		SHORT .Return					; Same page, no need to synchronize
  6026 00000217 B405                <2> 	mov		ah, SELECT_ACTIVE_DISPLAY_PAGE
  6027 00000219 CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  6028                              <2> .Return:
  6029 0000021B C3                  <2> 	ret
  6030                              <1> 	%include "DisplayPrint.asm"					; must come before DisplayFormat/DisplayFormatCompressed
  6031                              <2> ; Project name	:	Assembly Library
  6032                              <2> ; Description	:	Functions for display output.
  6033                              <2> 
  6034                              <2> ;
  6035                              <2> ; XTIDE Universal BIOS and Associated Tools
  6036                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  6037                              <2> ;
  6038                              <2> ; This program is free software; you can redistribute it and/or modify
  6039                              <2> ; it under the terms of the GNU General Public License as published by
  6040                              <2> ; the Free Software Foundation; either version 2 of the License, or
  6041                              <2> ; (at your option) any later version.
  6042                              <2> ;
  6043                              <2> ; This program is distributed in the hope that it will be useful,
  6044                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6045                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6046                              <2> ; GNU General Public License for more details.
  6047                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  6048                              <2> ;
  6049                              <2> 
  6050                              <2> ; Section containing code
  6051                              <2> SECTION .text
  6052                              <2> 
  6053                              <2> 
  6054                              <2> ;--------------------------------------------------------------------
  6055                              <2> ; Supports following formatting types:
  6056                              <2> ;	%a		Specifies attribute for next character
  6057                              <2> ;	%A		Specifies attribute for remaining string (or until next %A)
  6058                              <2> ;	%d		Prints signed 16-bit decimal integer
  6059                              <2> ;	%u		Prints unsigned 16-bit decimal integer
  6060                              <2> ;	%x		Prints 16-bit hexadecimal integer
  6061                              <2> ;	%s		Prints string (from CS segment)
  6062                              <2> ;	%S		Prints string (far pointer)
  6063                              <2> ;	%c		Prints character
  6064                              <2> ;	%t		Prints character number of times (character needs to be pushed first, then repeat times)
  6065                              <2> ;	%%		Prints '%' character (no parameter pushed)
  6066                              <2> ;
  6067                              <2> ;	Any placeholder can be set to minimum length by specifying
  6068                              <2> ;	minimum number of characters. For example %8d would append spaces
  6069                              <2> ;	after integer so that at least 8 characters would be printed.
  6070                              <2> ;
  6071                              <2> ;	When placing '-' after number, then spaces will be used for prepending.
  6072                              <2> ;	For example %8-d would prepend integer with spaces so that at least
  6073                              <2> ;	8 characters would be printed.
  6074                              <2> ;
  6075                              <2> ; DisplayPrint_FormattedNullTerminatedStringFromCSSI
  6076                              <2> ;	Parameters:
  6077                              <2> ;		BP:		SP before pushing parameters
  6078                              <2> ;		DS:		BDA segment (zero)
  6079                              <2> ;		CS:SI:	Pointer to string to format
  6080                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6081                              <2> ;		Stack:	Parameters for formatting placeholders.
  6082                              <2> ;				Parameter for first placeholder must be pushed first.
  6083                              <2> ;				Low word must pushed first for placeholders requiring
  6084                              <2> ;				32-bit parameters (two words).
  6085                              <2> ;	Returns:
  6086                              <2> ;		DI:		Updated offset to video RAM
  6087                              <2> ;	Corrupts registers:
  6088                              <2> ;		AX, DX
  6089                              <2> ;--------------------------------------------------------------------
  6090                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6091                              <2> DisplayPrint_FormattedNullTerminatedStringFromCSSI:
  6092 0000021C 55                  <2> 	push	bp
  6093 0000021D 56                  <2> 	push	si
  6094 0000021E 51                  <2> 	push	cx
  6095 0000021F 53                  <2> 	push	bx
  6096 00000220 FF365E04            <2> 	push	WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute]
  6097                              <2> 
  6098 00000224 4D                  <2> 	dec		bp					; Point BP to...
  6099 00000225 4D                  <2> 	dec		bp					; ...first stack parameter
  6100 00000226 E87700              <2> 	call	DisplayFormat_ParseCharacters
  6101                              <2> 
  6102                              <2> 	; Pop original character attribute
  6103 00000229 58                  <2> 	pop		ax
  6104 0000022A A25E04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], al
  6105                              <2> 
  6106 0000022D 5B                  <2> 	pop		bx
  6107 0000022E 59                  <2> 	pop		cx
  6108 0000022F 5E                  <2> 	pop		si
  6109 00000230 5D                  <2> 	pop		bp
  6110                              <2> 
  6111 00000231 C3                  <2> 	ret
  6112                              <2> 
  6113                              <2> 
  6114                              <2> ;--------------------------------------------------------------------
  6115                              <2> ; DisplayPrint_SignedWordFromAXWithBaseInBX
  6116                              <2> ;	Parameters:
  6117                              <2> ;		AX:		Word to display
  6118                              <2> ;		BX:		Integer base (binary=2, octal=8, decimal=10, hexadecimal=16)
  6119                              <2> ;		DS:		BDA segment (zero)
  6120                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6121                              <2> ;	Returns:
  6122                              <2> ;		DI:		Updated offset to video RAM
  6123                              <2> ;	Corrupts registers:
  6124                              <2> ;		AX, DX
  6125                              <2> ;--------------------------------------------------------------------
  6126                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6127                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6128                              <2> DisplayPrint_SignedWordFromAXWithBaseInBX:
  6129                              <2> 	test	ax, ax
  6130                              <2> 	jns		SHORT DisplayPrint_WordFromAXWithBaseInBX
  6131                              <2> 
  6132                              <2> 	push	ax
  6133                              <2> 	mov		al, '-'
  6134                              <2> 	call	DisplayPrint_CharacterFromAL
  6135                              <2> 	pop		ax
  6136                              <2> 	neg		ax
  6137                              <2> 	; Fall to DisplayPrint_WordFromAXWithBaseInBX
  6138                              <2> %endif
  6139                              <2> 
  6140                              <2> 
  6141                              <2> ;--------------------------------------------------------------------
  6142                              <2> ; DisplayPrint_WordFromAXWithBaseInBX
  6143                              <2> ;	Parameters:
  6144                              <2> ;		AX:		Word to display
  6145                              <2> ;		BX:		Integer base (binary=2, octal=8, decimal=10, hexadecimal=16)
  6146                              <2> ;		DS:		BDA segment (zero)
  6147                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6148                              <2> ;	Returns:
  6149                              <2> ;		DI:		Updated offset to video RAM
  6150                              <2> ;	Corrupts registers:
  6151                              <2> ;		AX, DX
  6152                              <2> ;--------------------------------------------------------------------
  6153                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  6154                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6155                              <2> DisplayPrint_WordFromAXWithBaseInBX:
  6156                              <2> 	push	cx
  6157                              <2> 	push	bx
  6158                              <2> 
  6159                              <2> 	xor		cx, cx
  6160                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6161                              <2> .DivideLoop:
  6162                              <2> 	xor		dx, dx				; DX:AX now holds the integer
  6163                              <2> 	div		bx					; Divide DX:AX by base
  6164                              <2> 	push	dx					; Push remainder
  6165                              <2> 	inc		cx					; Increment character count
  6166                              <2> 	test	ax, ax				; All divided?
  6167                              <2> 	jnz		SHORT .DivideLoop	;  If not, loop
  6168                              <2> 
  6169                              <2> PrintAllPushedDigits:
  6170                              <2> 	mov		bx, g_rgcDigitToCharacter
  6171                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6172                              <2> .PrintNextDigit:
  6173                              <2> 	pop		ax					; Pop digit
  6174                              <2> 	cs xlatb
  6175                              <2> 	call	DisplayPrint_CharacterFromAL
  6176                              <2> 	loop	.PrintNextDigit
  6177                              <2> 
  6178                              <2> 	pop		bx
  6179                              <2> 	pop		cx
  6180                              <2> 	ret
  6181                              <2> 
  6182                              <2> g_rgcDigitToCharacter:	db	"0123456789ABCDEF"
  6183                              <2> 
  6184                              <2> %endif ; MODULE_STRINGS_COMPRESSED
  6185                              <2> 
  6186                              <2> ;--------------------------------------------------------------------
  6187                              <2> ; DisplayPrint_QWordFromSSBPwithBaseInBX
  6188                              <2> ;	Parameters:
  6189                              <2> ;		SS:BP:	QWord to display
  6190                              <2> ;		BX:		Integer base (binary=2, octal=8, decimal=10, hexadecimal=16)
  6191                              <2> ;		DS:		BDA segment (zero)
  6192                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6193                              <2> ;	Returns:
  6194                              <2> ;		DI:		Updated offset to video RAM
  6195                              <2> ;	Corrupts registers:
  6196                              <2> ;		AX, DX, [SS:BP]
  6197                              <2> ;--------------------------------------------------------------------
  6198                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  6199                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6200                              <2> DisplayPrint_QWordFromSSBPwithBaseInBX:
  6201                              <2> 	push	cx
  6202                              <2> 	push	bx
  6203                              <2> 
  6204                              <2> 	mov		cx, bx				; CX = Integer base
  6205                              <2> 	xor		bx, bx				; BX = Character count
  6206                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6207                              <2> .DivideLoop:
  6208                              <2> 	call	Math_DivQWatSSBPbyCX; Divide by base
  6209                              <2> 	push	dx					; Push remainder
  6210                              <2> 	inc		bx					; Increment character count
  6211                              <2> 	cmp		WORD [bp], BYTE 0	; All divided?
  6212                              <2> 	jne		SHORT .DivideLoop	;  If not, loop
  6213                              <2> 	mov		cx, bx				; Character count to CX
  6214                              <2> 	jmp		SHORT PrintAllPushedDigits
  6215                              <2> %endif
  6216                              <2> 
  6217                              <2> 
  6218                              <2> ;--------------------------------------------------------------------
  6219                              <2> ; DisplayPrint_CharacterBufferFromBXSIwithLengthInCX
  6220                              <2> ;	Parameters:
  6221                              <2> ;		CX:		Buffer length (characters)
  6222                              <2> ;		BX:SI:	Ptr to NULL terminated string
  6223                              <2> ;		DS:		BDA segment (zero)
  6224                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6225                              <2> ;	Returns:
  6226                              <2> ;		DI:		Updated offset to video RAM
  6227                              <2> ;	Corrupts registers:
  6228                              <2> ;		AX, DX
  6229                              <2> ;--------------------------------------------------------------------
  6230                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6231                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6232                              <2> DisplayPrint_CharacterBufferFromBXSIwithLengthInCX:
  6233                              <2> 	jcxz	.NothingToPrintSinceZeroLength
  6234                              <2> 	push	si
  6235                              <2> 	push	cx
  6236                              <2> 
  6237                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6238                              <2> .PrintNextCharacter:
  6239                              <2> 	mov		ds, bx
  6240                              <2> 	lodsb
  6241                              <2> 	LOAD_BDA_SEGMENT_TO	ds, dx
  6242                              <2> 	call	DisplayPrint_CharacterFromAL
  6243                              <2> 	loop	.PrintNextCharacter
  6244                              <2> 
  6245                              <2> 	pop		cx
  6246                              <2> 	pop		si
  6247                              <2> .NothingToPrintSinceZeroLength:
  6248                              <2> 	ret
  6249                              <2> %endif
  6250                              <2> 
  6251                              <2> 
  6252                              <2> ;--------------------------------------------------------------------
  6253                              <2> ; DisplayPrint_ClearScreenWithCharInALandAttributeInAH
  6254                              <2> ;	Parameters:
  6255                              <2> ;		AL:		Character to clear with
  6256                              <2> ;		AH:		Attribute to clear with
  6257                              <2> ;		DS:		BDA segment (zero)
  6258                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6259                              <2> ;	Returns:
  6260                              <2> ;		Nothing
  6261                              <2> ;	Corrupts registers:
  6262                              <2> ;		AX, DX
  6263                              <2> ;--------------------------------------------------------------------
  6264                              <2> %ifdef INCLUDE_MENU_LIBRARY
  6265                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6266                              <2> DisplayPrint_ClearScreenWithCharInALandAttributeInAH:
  6267                              <2> 	push	di
  6268                              <2> 	push	cx
  6269                              <2> 
  6270                              <2> 	xchg	cx, ax
  6271                              <2> 	xor		ax, ax
  6272                              <2> 	call	DisplayCursor_SetCoordinatesFromAX		; Updates DI
  6273                              <2> 	call	DisplayPage_GetColumnsToALandRowsToAH
  6274                              <2> 	mul		ah		; AX = AL*AH = Characters on screen
  6275                              <2> 	xchg	cx, ax	; AX = Char+Attr, CX = WORDs to store
  6276                              <2> 	rep stosw
  6277                              <2> 
  6278                              <2> 	pop		cx
  6279                              <2> 	pop		di
  6280                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], di
  6281                              <2> 	ret
  6282                              <2> %endif
  6283                              <2> 
  6284                              <2> 
  6285                              <2> ;--------------------------------------------------------------------
  6286                              <2> ; DisplayPrint_ClearAreaWithHeightInAHandWidthInAL
  6287                              <2> ;	Parameters:
  6288                              <2> ;		AH:		Area height
  6289                              <2> ;		AL:		Area width
  6290                              <2> ;		DS:		BDA segment (zero)
  6291                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6292                              <2> ;	Returns:
  6293                              <2> ;		DI:		Updated offset to video RAM
  6294                              <2> ;	Corrupts registers:
  6295                              <2> ;		AX, DX
  6296                              <2> ;--------------------------------------------------------------------
  6297                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6298                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6299                              <2> DisplayPrint_ClearAreaWithHeightInAHandWidthInAL:
  6300                              <2> 	push	si
  6301                              <2> 	push	cx
  6302                              <2> 	push	bx
  6303                              <2> 
  6304                              <2> 	xchg	bx, ax							; Area size to BX
  6305                              <2> 	call	DisplayCursor_GetSoftwareCoordinatesToAX
  6306                              <2> 	xchg	si, ax							; Software (Y,X) coordinates now in SI
  6307                              <2> 	xor		cx, cx
  6308                              <2> 
  6309                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6310                              <2> .ClearRowLoop:
  6311                              <2> 	mov		cl, bl							; Area width now in CX
  6312                              <2> 	mov		al, SCREEN_BACKGROUND_CHARACTER
  6313                              <2> 	call	DisplayPrint_RepeatCharacterFromALwithCountInCX
  6314                              <2> 
  6315                              <2> 	xchg	ax, si							; Coordinates to AX
  6316                              <2> 	inc		ah								; Increment row
  6317                              <2> 	mov		si, ax
  6318                              <2> 	call	DisplayCursor_SetCoordinatesFromAX
  6319                              <2> 	dec		bh								; Decrement rows left
  6320                              <2> 	jnz		SHORT .ClearRowLoop
  6321                              <2> 
  6322                              <2> 	pop		bx
  6323                              <2> 	pop		cx
  6324                              <2> 	pop		si
  6325                              <2> 	ret
  6326                              <2> %endif
  6327                              <2> 
  6328                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6329                              <2> 	%define EXCLUDE
  6330                              <2> 	%ifdef MODULE_HOTKEYS
  6331                              <2> 		%undef EXCLUDE
  6332                              <2> 	%endif
  6333                              <2> 	%ifdef MODULE_BOOT_MENU
  6334                              <2> 		%undef EXCLUDE
  6335                              <2> 	%endif
  6336                              <2> %endif
  6337                              <2> 
  6338                              <2> %ifndef EXCLUDE
  6339                              <2> ;--------------------------------------------------------------------
  6340                              <2> ; DisplayPrint_RepeatCharacterFromALwithCountInCX
  6341                              <2> ;	Parameters:
  6342                              <2> ;		AL:		Character to display
  6343                              <2> ;		CX:		Repeat count
  6344                              <2> ;		DS:		BDA segment (zero)
  6345                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6346                              <2> ;	Returns:
  6347                              <2> ;		DI:		Updated offset to video RAM
  6348                              <2> ;	Corrupts registers:
  6349                              <2> ;		DX
  6350                              <2> ;--------------------------------------------------------------------
  6351                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6352                              <2> DisplayPrint_RepeatCharacterFromALwithCountInCX:
  6353                              <2> 	jcxz	.NothingToRepeat
  6354                              <2> 	push	cx
  6355                              <2> 
  6356                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6357                              <2> .RepeatCharacter:
  6358                              <2> 	push	ax
  6359                              <2> 	call	DisplayPrint_CharacterFromAL
  6360                              <2> 	pop		ax
  6361                              <2> 	loop	.RepeatCharacter
  6362                              <2> 
  6363                              <2> 	pop		cx
  6364                              <2> .NothingToRepeat:
  6365                              <2> 	ret
  6366                              <2> %endif
  6367                              <2> %undef EXCLUDE
  6368                              <2> 
  6369                              <2> ;--------------------------------------------------------------------
  6370                              <2> ; DisplayPrint_NullTerminatedStringFromCSSI
  6371                              <2> ;	Parameters:
  6372                              <2> ;		CS:SI:	Ptr to NULL terminated string
  6373                              <2> ;		DS:		BDA segment (zero)
  6374                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6375                              <2> ;	Returns:
  6376                              <2> ;		DI:		Updated offset to video RAM
  6377                              <2> ;	Corrupts registers:
  6378                              <2> ;		AX, DX
  6379                              <2> ;--------------------------------------------------------------------
  6380                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  6381                              <2> ;;;
  6382                              <2> ;;; Take care when using this routine with compressed strings (which is why it is disabled).
  6383                              <2> ;;; All strings in CSSI should go through the DisplayFormatCompressed code to be decoded.
  6384                              <2> ;;;
  6385                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6386                              <2> DisplayPrint_NullTerminatedStringFromCSSI:
  6387                              <2> 	push	bx
  6388                              <2> 	mov		bx, cs
  6389                              <2> 	call	DisplayPrint_NullTerminatedStringFromBXSI
  6390                              <2> 	pop		bx
  6391                              <2> 	ret
  6392                              <2> %endif
  6393                              <2> 
  6394                              <2> 
  6395                              <2> ;;;
  6396                              <2> ;;; Note that the following routines need to be at the bottom of this file
  6397                              <2> ;;; to accomodate short jumps from the next file (DisplayFormat/DisplayFormatCompressed)
  6398                              <2> ;;;
  6399                              <2> 
  6400                              <2> ;--------------------------------------------------------------------
  6401                              <2> ; DisplayPrint_Newline
  6402                              <2> ;	Parameters:
  6403                              <2> ;		DS:		BDA segment (zero)
  6404                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6405                              <2> ;	Returns:
  6406                              <2> ;		DI:		Updated offset to video RAM
  6407                              <2> ;	Corrupts registers:
  6408                              <2> ;		AX, DX
  6409                              <2> ;--------------------------------------------------------------------
  6410                              <2> %ifdef MODULE_STRINGS_COMPRESSED
  6411                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6412                              <2> DisplayPrint_Newline_FormatAdjustBP:
  6413 00000232 45                  <2> 	inc		bp					; we didn't need a parameter after all, readjust BP
  6414 00000233 45                  <2> 	inc		bp
  6415                              <2> 	; fall through to DisplayPrint_Newline
  6416                              <2> %endif
  6417                              <2> 
  6418                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6419                              <2> DisplayPrint_Newline:
  6420 00000234 B00A                <2> 	mov		al, LF
  6421 00000236 E80200              <2> 	call	DisplayPrint_CharacterFromAL
  6422 00000239 B00D                <2> 	mov		al, CR
  6423                              <2> 	; Fall to DisplayPrint_CharacterFromAL
  6424                              <2> 
  6425                              <2> ;--------------------------------------------------------------------
  6426                              <2> ; DisplayPrint_CharacterFromAL
  6427                              <2> ;	Parameters:
  6428                              <2> ;		AL:		Character to display
  6429                              <2> ;               Zero value is ignored (no character is printed)
  6430                              <2> ;		DS:		BDA segment (zero)
  6431                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6432                              <2> ;	Returns:
  6433                              <2> ;		DI:		Updated offset to video RAM
  6434                              <2> ;	Corrupts registers:
  6435                              <2> ;		AX, DX
  6436                              <2> ;--------------------------------------------------------------------
  6437                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6438                              <2> DisplayPrint_CharacterFromAL:
  6439 0000023B 84C0                <2> 	test	al, al
  6440 0000023D 741C                <2> 	jz		DisplayPrint_Ret
  6441                              <2> 
  6442 0000023F 8A265E04            <2> 	mov		ah, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute]
  6443 00000243 FF265804            <2> 	jmp		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fnCharOut]
  6444                              <2> 
  6445                              <2> 
  6446                              <2> ;--------------------------------------------------------------------
  6447                              <2> ; DisplayPrint_NullTerminatedStringFromBXSI
  6448                              <2> ;	Parameters:
  6449                              <2> ;		DS:		BDA segment (zero)
  6450                              <2> ;		BX:SI:	Ptr to NULL terminated string
  6451                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6452                              <2> ;	Returns:
  6453                              <2> ;		DI:		Updated offset to video RAM
  6454                              <2> ;	Corrupts registers:
  6455                              <2> ;		AX, DX
  6456                              <2> ;--------------------------------------------------------------------
  6457                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6458                              <2> DisplayPrint_NullTerminatedStringFromBXSI:
  6459 00000247 56                  <2> 	push	si
  6460 00000248 51                  <2> 	push	cx
  6461                              <2> 
  6462 00000249 31C9                <2> 	xor		cx, cx
  6463                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6464                              <2> .PrintNextCharacter:
  6465 0000024B 8EDB                <2> 	mov		ds, bx				; String segment to DS
  6466 0000024D AC                  <2> 	lodsb
  6467 0000024E 8ED9                <2> 	mov		ds, cx				; BDA segment to DS
  6468 00000250 84C0                <2> 	test	al, al				; NULL?
  6469 00000252 7405                <2> 	jz		SHORT .EndOfString
  6470 00000254 E8E4FF              <2> 	call	DisplayPrint_CharacterFromAL
  6471 00000257 EBF2                <2> 	jmp		SHORT .PrintNextCharacter
  6472                              <2> 
  6473                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6474                              <2> .EndOfString:
  6475 00000259 59                  <2> 	pop		cx
  6476 0000025A 5E                  <2> 	pop		si
  6477                              <2> 
  6478                              <2> DisplayPrint_Ret:				; random ret to jump to
  6479 0000025B C3                  <2> 	ret
  6480                              <2> 
  6481                              <1> %ifdef MODULE_STRINGS_COMPRESSED
  6482                              <1> 	%include "DisplayFormatCompressed.asm"
  6483                              <2> ; Project name	:	Assembly Library
  6484                              <2> ; Description	:	Functions for displaying formatted strings.
  6485                              <2> ;					** Compressed Strings edition **
  6486                              <2> ;					This is a plug replacement for DisplayFormat.asm,
  6487                              <2> ;					working instead with precompiled and slightly compressed strings.
  6488                              <2> 
  6489                              <2> ;
  6490                              <2> ; XTIDE Universal BIOS and Associated Tools
  6491                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  6492                              <2> ;
  6493                              <2> ; This program is free software; you can redistribute it and/or modify
  6494                              <2> ; it under the terms of the GNU General Public License as published by
  6495                              <2> ; the Free Software Foundation; either version 2 of the License, or
  6496                              <2> ; (at your option) any later version.
  6497                              <2> ;
  6498                              <2> ; This program is distributed in the hope that it will be useful,
  6499                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6500                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6501                              <2> ; GNU General Public License for more details.
  6502                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  6503                              <2> ;
  6504                              <2> 
  6505                              <2> ;=============================================================================================
  6506                              <2> ;
  6507                              <2> ; Strings are compressed in a simple manner:
  6508                              <2> ;	1. The two most common characters, space and null, are removed
  6509                              <2> ;	2. Format specifiers are reduced to a single byte, including length information
  6510                              <2> ;
  6511                              <2> ; Format of bytes in the string are:
  6512                              <2> ;     01 xxxxxx     Character in x plus StringsCompressed_NormalBase
  6513                              <2> ;     10 xxxxxx     Character in x plus StringsCompressed_NormalBase, followed by a null (last character)
  6514                              <2> ;     11 xxxxxx     Character in x plus StringsCompressed_NormalBase, followed by a space
  6515                              <2> ;     00 1 yyyyy    Character/Format in lookup table StringsCopmressed_TranslatesAndFormats
  6516                              <2> ;     00 0 yyyyy    Character/Format in lookup table StringsCompressed_TranslatesAndFormats, followed by a null
  6517                              <2> ;
  6518                              <2> ; StringsCompressed_NormalBase is defined by the compressor, but is usually around 0x40,
  6519                              <2> ; which gives a range of 0x40 to 0x7f, or roughly the upper and lower case letters.
  6520                              <2> ;
  6521                              <2> ; StringsCompressed_TranslatesAndFormats is a lookup table with the first few bytes being translation
  6522                              <2> ; characters, and the last few bytes being format jump offsets from DisplayFormatCompressed_BaseFormatOffset.
  6523                              <2> ; The dividing line is defined by StringsCompressed_FormatsBegin
  6524                              <2> ;
  6525                              <2> ; The assignments of the first two bits above is not by accident.  The translates/format branch is 00
  6526                              <2> ; which is easy to test for.  The '01' for "normal" (no null or space) and '001' for translates/format "normal"
  6527                              <2> ; match, allowing the translates/format codes to be shifted left by 1 and then tested with the same instructions.
  6528                              <2> ;
  6529                              <2> ; It is always possible to say that a null character follows the current character - thus there is
  6530                              <2> ; no way (nor need) to specify a zero character.
  6531                              <2> ;
  6532                              <2> ; Note that this code is optimized for size, not speed.  Since this code is used only during initialization
  6533                              <2> ; and only for the user interface, small performance hits should not be noticed.  It will seem odd to do so
  6534                              <2> ; much "preload", just in case a branch is taken, but that is cheaper (in size) than adding additional branches.
  6535                              <2> ;
  6536                              <2> 
  6537                              <2> ; Section containing code
  6538                              <2> SECTION .text
  6539                              <2> 
  6540                              <2> ;--------------------------------------------------------------------
  6541                              <2> ; Format Handlers
  6542                              <2> ;
  6543                              <2> ; Names of format handlers are DisplayFormatCompressed_Format_* where * is
  6544                              <2> ; replaced with the format code after the '%' in the original string,
  6545                              <2> ; with '-' replaced with '_'.
  6546                              <2> ;
  6547                              <2> ;	Parameters:
  6548                              <2> ;		DS:		BDA segment (zero)
  6549                              <2> ;		AX:     Parameter to Format
  6550                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6551                              <2> ;	Returns:
  6552                              <2> ;		DI:		Updated offset to video RAM
  6553                              <2> ;	Corrupts registers:
  6554                              <2> ;		AX, BX, CX, DX, SI
  6555                              <2> ;--------------------------------------------------------------------
  6556                              <2> 
  6557                              <2> ;
  6558                              <2> ; The following routines do not need any pre or post processing and can be jumped to directly.
  6559                              <2> ; Note that they need to be within 256 bytes of DisplayFormatCompressed_BaseFormatOffset
  6560                              <2> ;
  6561                              <2> %define DisplayFormatCompressed_Format_c DisplayPrint_CharacterFromAL
  6562                              <2> %define DisplayFormatCompressed_Format_nl DisplayPrint_Newline_FormatAdjustBP
  6563                              <2> %define DisplayFormatCompressed_Format_s DisplayFormat_ParseCharacters_FromAX
  6564                              <2> 
  6565                              <2> DisplayFormatCompressed_Format_A:
  6566 0000025C A25E04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], al
  6567                              <2> DisplayFormatCompressed_ret:			; jump target for other routines who need a "ret"
  6568 0000025F C3                  <2> 	ret
  6569                              <2> 
  6570                              <2> DisplayFormatCompressed_Format_z:
  6571 00000260 31DB                <2> 	xor		bx, bx
  6572 00000262 96                  <2> 	xchg	si, ax
  6573 00000263 EBE2                <2> 	jmp		short DisplayPrint_NullTerminatedStringFromBXSI
  6574                              <2> 
  6575                              <2> DisplayFormatCompressed_Format_x:
  6576                              <2> DisplayFormatCompressed_Format_5_x:
  6577 00000265 BE1000              <2> 	mov		si,16						; hex output, change base to 16
  6578 00000268 BB6804              <2> 	mov		bx,(04<<8) + 'h'	        ; 4 bytes, with postfix character 'h' to emit
  6579                              <2> 										; (note that the count includes the 'h')
  6580 0000026B EB09                <2> 	jmp		DisplayFormatCompressed_Format_u
  6581                              <2> 
  6582                              <2> DisplayFormatCompressed_Format_2_I:
  6583 0000026D BE[AD00]            <2> 	mov		si,g_szDashForZero			; preload dash string in case we jump
  6584 00000270 85C0                <2> 	test	ax,ax						; if parameter equals zero, emit dash string instead
  6585 00000272 742C                <2> 	jz		DisplayFormat_ParseCharacters
  6586                              <2> 	; fall through
  6587                              <2> 
  6588                              <2> DisplayFormatCompressed_Format_2_u:
  6589 00000274 B702                <2> 	mov		bh,2						; only two characters (instead of the default 5)
  6590                              <2> 	; fall through
  6591                              <2> 
  6592                              <2> DisplayFormatCompressed_Format_u:
  6593                              <2> DisplayFormatCompressed_Format_5_u:
  6594 00000276 53                  <2> 	push	bx							; push postfix character - either a zero (default) or a 'h'
  6595 00000277 88FB                <2> 	mov		bl,bh						; preserve character count for .PrintLoop
  6596                              <2> 
  6597                              <2> .DivLoop:
  6598 00000279 31D2                <2> 	xor		dx, dx						; Zero DX for division
  6599 0000027B F7F6                <2> 	div		si							; DX:AX / 10 => AX=quot, DX=rem
  6600 0000027D 52                  <2>  	push	dx							; Push digit
  6601                              <2> 
  6602 0000027E FECF                <2> 	dec		bh
  6603 00000280 75F7                <2> 	jnz		.DivLoop
  6604                              <2> 
  6605                              <2> .PrintLoop:
  6606 00000282 58                  <2> 	pop		ax							; Pop digit, postfix character on last iteration
  6607                              <2> 
  6608 00000283 FECB                <2> 	dec		bl							; on second to last iteration, emit digit whether it is zero or not
  6609 00000285 740D                <2> 	jz		.PrintDigit
  6610                              <2> 
  6611 00000287 78B2                <2> 	js		short DisplayPrint_CharacterFromAL	; on last iteration, emit postfix character
  6612                              <2> 												; if it is zero, DisplayPrint_CharacterFromAL will not emit
  6613                              <2> 
  6614 00000289 08C7                <2> 	or		bh, al						; skip leading zeros, bh keeps track if we have emitted anything non-zero
  6615 0000028B 7507                <2> 	jnz		.PrintDigit					; note that bh starts at zero, from the loop above
  6616                              <2> 
  6617 0000028D F6C502              <2> 	test	ch,2						; are we padding with leading spaces?
  6618 00000290 75F0                <2> 	jnz		.PrintLoop					; test the even/odd of the format byte in the string
  6619                              <2> 
  6620 00000292 B089                <2> 	mov		al, 89h						; emit space
  6621                              <2> 
  6622                              <2> .PrintDigit:
  6623 00000294 3C0A                <2> 	cmp		al, 10						; Convert binary digit in AL to ASCII hex digit ('0'-'9' or 'A'-'F')
  6624 00000296 1C69                <2> 	sbb		al, 69h
  6625 00000298 2F                  <2> 	das
  6626                              <2> 
  6627 00000299 E89FFF              <2> 	call	DisplayPrint_CharacterFromAL
  6628                              <2> 
  6629 0000029C EBE4                <2> 	jmp		.PrintLoop
  6630                              <2> 
  6631                              <2> 
  6632                              <2> ;--------------------------------------------------------------------
  6633                              <2> ; DisplayFormat_ParseCharacters
  6634                              <2> ;	Parameters:
  6635                              <2> ;		DS:		BDA segment (zero)
  6636                              <2> ;		SS:BP:	Pointer to first format parameter (-=2 updates to next parameter)
  6637                              <2> ;		CS:SI:	Pointer to string to format
  6638                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6639                              <2> ;	Returns:
  6640                              <2> ;		CS:SI:	Ptr to end of format string (ptr to one past NULL)
  6641                              <2> ;		DI:		Updated offset to video RAM
  6642                              <2> ;	Corrupts registers:
  6643                              <2> ;		AX, BX, CX, DX, BP
  6644                              <2> ;--------------------------------------------------------------------
  6645                              <2> 
  6646                              <2> DisplayFormatCompressed_BaseFormatOffset:
  6647                              <2> 
  6648                              <2> DisplayFormat_ParseCharacters_FromAX:
  6649 0000029E 89C6                <2> 	mov		si,ax
  6650                              <2> 	; fall through to DisplayFormat_ParseCharacters
  6651                              <2> 
  6652                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6653                              <2> DisplayFormat_ParseCharacters:
  6654                              <2> ;
  6655                              <2> ; This routine is used to output all strings from the ROM.  The strings in ROMVARS are not compressed,
  6656                              <2> ; and must be handled differently.
  6657                              <2> ;
  6658 000002A0 83FE7F              <2> 	cmp		si,byte 07fh		; well within the boundaries of ROMVARS_size
  6659 000002A3 8CCB                <2> 	mov		bx,cs				; preload bx with cs in case we take the following jump
  6660 000002A5 72A0                <2> 	jb		short DisplayPrint_NullTerminatedStringFromBXSI
  6661                              <2> 
  6662                              <2> .decode:
  6663 000002A7 2EAC                <2> 	cs lodsb					; load next byte of the string
  6664                              <2> 
  6665 000002A9 88C5                <2> 	mov		ch,al				; save a copy for later processing of high order bits
  6666                              <2> 
  6667 000002AB A8C0                <2> 	test	al,0c0h				; check for translation/format character
  6668 000002AD 7414                <2> 	jz		DisplayFormatCompressed_TranslatesAndFormats
  6669                              <2> 
  6670 000002AF 243F                <2> 	and		al,03fh								; "Normal" character, mask off high order bits
  6671 000002B1 043A                <2> 	add		al,StringsCompressed_NormalBase		; and add character offset (usually around 0x40)
  6672                              <2> 
  6673                              <2> .output:
  6674 000002B3 E885FF              <2> 	call 	DisplayPrint_CharacterFromAL
  6675                              <2> 
  6676                              <2> .process_after_output:
  6677                              <2> 	eSHL_IM	ch,1								; check high order bits for end of string or space
  6678                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  6679                              <3> %ifdef USE_386
  6680                              <3>  %if %2 = 1
  6681                              <3>  add %1, %1
  6682                              <3>  %else
  6683                              <3>  eSHIFT_IM %1, %2, shl
  6684                              <3>  %endif
  6685                              <3> %else
  6686                              <3>  eSHIFT_IM %1, %2, shl
  6687                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  6688                              <4> %ifndef USE_186
  6689                              <4>  %ifidni %1, cl
  6690                              <4>  times %2 %3 %1, 1
  6691                              <4>  %elifidni %1, ch
  6692 000002B6 D0E5                <4>  times %2 %3 %1, 1
  6693                              <4>  %elifidni %1, cx
  6694                              <4>  times %2 %3 %1, 1
  6695                              <4>  %else
  6696                              <4>  %if %2 > 3
  6697                              <4>  push cx
  6698                              <4>  mov cl, %2
  6699                              <4>  %3 %1, cl
  6700                              <4>  pop cx
  6701                              <4>  %else
  6702                              <4>  times %2 %3 %1, 1
  6703                              <4>  %endif
  6704                              <4>  %endif
  6705                              <4> 
  6706                              <4> %else
  6707                              <4>  %3 %1, %2
  6708                              <4> %endif
  6709                              <4> %endif
  6710                              <3> %endif
  6711                              <3> %endif
  6712 000002B8 79A5                <2> 	jns		short DisplayFormatCompressed_ret
  6713 000002BA 73EB                <2> 	jnc		.decode
  6714 000002BC B020                <2> 	mov		al,' '
  6715 000002BE E87AFF              <2> 	call	DisplayPrint_CharacterFromAL
  6716 000002C1 EBE4                <2> 	jmp		.decode
  6717                              <2> 
  6718                              <2> 
  6719                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6720                              <2> DisplayFormatCompressed_TranslatesAndFormats:
  6721                              <2> ;
  6722                              <2> ; This routine is here (above DisplayFormat_ParseCharacters) to reduce the amount of code between
  6723                              <2> ; DisplayFormatCompressed_BaseFormatOffset and jump targets (must fit in 256 bytes)
  6724                              <2> ;
  6725                              <2> 	eSHL_IM	ch,1				; setup ch for later testing of null in .process_after_output
  6726                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  6727                              <3> %ifdef USE_386
  6728                              <3>  %if %2 = 1
  6729                              <3>  add %1, %1
  6730                              <3>  %else
  6731                              <3>  eSHIFT_IM %1, %2, shl
  6732                              <3>  %endif
  6733                              <3> %else
  6734                              <3>  eSHIFT_IM %1, %2, shl
  6735                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  6736                              <4> %ifndef USE_186
  6737                              <4>  %ifidni %1, cl
  6738                              <4>  times %2 %3 %1, 1
  6739                              <4>  %elifidni %1, ch
  6740 000002C3 D0E5                <4>  times %2 %3 %1, 1
  6741                              <4>  %elifidni %1, cx
  6742                              <4>  times %2 %3 %1, 1
  6743                              <4>  %else
  6744                              <4>  %if %2 > 3
  6745                              <4>  push cx
  6746                              <4>  mov cl, %2
  6747                              <4>  %3 %1, cl
  6748                              <4>  pop cx
  6749                              <4>  %else
  6750                              <4>  times %2 %3 %1, 1
  6751                              <4>  %endif
  6752                              <4>  %endif
  6753                              <4> 
  6754                              <4> %else
  6755                              <4>  %3 %1, %2
  6756                              <4> %endif
  6757                              <4> %endif
  6758                              <3> %endif
  6759                              <3> %endif
  6760 000002C5 83E01F              <2> 	and		ax,0001fh			; also clears AH for addition with BX and DX below
  6761                              <2> 
  6762 000002C8 BB[5103]            <2> 	mov		bx,StringsCompressed_TranslatesAndFormats	; calculate offset of translation/formats offset byte
  6763 000002CB 01C3                <2> 	add		bx,ax
  6764                              <2> 
  6765 000002CD 3C14                <2> 	cmp		al,StringsCompressed_FormatsBegin			; determine if this is a translation or a format
  6766                              <2> 
  6767 000002CF 2E8A07              <2> 	mov		al,[cs:bx]									; fetch translation/formats byte
  6768                              <2> 
  6769 000002D2 72DF                <2> 	jb		DisplayFormat_ParseCharacters.output		; check if this a translation or a format
  6770                              <2> 														; if it is translation, output and postprocess for eos
  6771                              <2> 														; note that the flags for this conditional jump were
  6772                              <2> 														; set with the cmp al,StringsCompressed_FormatsBegin
  6773                              <2> 
  6774 000002D4 BA[9E02]            <2> 	mov		dx,DisplayFormatCompressed_BaseFormatOffset   ; calculate address to jump to for format handler
  6775 000002D7 29C2                <2> 	sub		dx,ax
  6776                              <2> 
  6777 000002D9 8B4600              <2> 	mov		ax,[bp]				; preload ax with parameter
  6778 000002DC 4D                  <2> 	dec		bp					; if no parameter is needed (format 'nl' for example),
  6779 000002DD 4D                  <2> 	dec		bp					; the format handler can reincrement bp
  6780                              <2> 
  6781 000002DE BB0005              <2> 	mov		bx,0500h			; preload bh with 5 decimal places for numeric output
  6782                              <2> 								; bl is zero, indicating not to output a 'h' (default base 10)
  6783                              <2> 
  6784 000002E1 56                  <2> 	push	si					; preserve si and cx, in the case of outputing a string
  6785 000002E2 51                  <2> 	push	cx
  6786                              <2> 
  6787 000002E3 BE0A00              <2> 	mov		si,10				; preload si with 10 for numeric output (default base 10)
  6788                              <2> 
  6789 000002E6 FFD2                <2> 	call	dx					; call the format routine
  6790                              <2> 
  6791 000002E8 59                  <2> 	pop		cx					; restore cx and si
  6792 000002E9 5E                  <2> 	pop		si
  6793                              <2> 
  6794 000002EA EBCA                <2> 	jmp		DisplayFormat_ParseCharacters.process_after_output	; continue postprocessing, check for end of string
  6795                              <2> 
  6796                              <1> %else
  6797                              <1> 	%include "DisplayFormat.asm"
  6798                              <1> %endif
  6799                              <1> %endif
  6800                              <1> 
  6801                              <1> %ifdef INCLUDE_FILE_LIBRARY
  6802                              <1> 	%include "Directory.asm"
  6803                              <1> 	%include "DosCritical.asm"
  6804                              <1> 	%include "Drive.asm"
  6805                              <1> 	%include "FileIO.asm"
  6806                              <1> %endif
  6807                              <1> 
  6808                              <1> %ifdef INCLUDE_KEYBOARD_LIBRARY
  6809                              <1>   %ifndef KEYBOARD_JUMP_ALIGN
  6810                              <1> 	%define KEYBOARD_JUMP_ALIGN 1
  6811                              <1>   %endif
  6812                              <1> 	%include "Keyboard.asm"
  6813                              <2> ; Project name	:	Assembly Library
  6814                              <2> ; Description	:	Functions for managing keyboard.
  6815                              <2> 
  6816                              <2> ;
  6817                              <2> ; XTIDE Universal BIOS and Associated Tools
  6818                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  6819                              <2> ;
  6820                              <2> ; This program is free software; you can redistribute it and/or modify
  6821                              <2> ; it under the terms of the GNU General Public License as published by
  6822                              <2> ; the Free Software Foundation; either version 2 of the License, or
  6823                              <2> ; (at your option) any later version.
  6824                              <2> ;
  6825                              <2> ; This program is distributed in the hope that it will be useful,
  6826                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6827                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6828                              <2> ; GNU General Public License for more details.
  6829                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  6830                              <2> ;
  6831                              <2> 
  6832                              <2> 
  6833                              <2> BUFFER_SIZE_FOR_WORD_INPUT		EQU		6	; 5 chars + NULL
  6834                              <2> 
  6835                              <2> ; Section containing code
  6836                              <2> SECTION .text
  6837                              <2> 
  6838                              <2> ;--------------------------------------------------------------------
  6839                              <2> ; Reads user inputted word.
  6840                              <2> ; Function returns when ENTER or ESC will be pressed.
  6841                              <2> ;
  6842                              <2> ; Keyboard_ReadUserInputtedWordWhilePrinting
  6843                              <2> ;	Parameters
  6844                              <2> ;		BX:		Numeric base (10 or 16)
  6845                              <2> ;	Returns:
  6846                              <2> ;		AX:		User inputted word
  6847                              <2> ;		ZF:		Set if user cancellation
  6848                              <2> ;	Corrupts registers:
  6849                              <2> ;		DX
  6850                              <2> ;--------------------------------------------------------------------
  6851                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6852                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  6853                              <2> Keyboard_ReadUserInputtedWordWhilePrinting:
  6854                              <2> 	push	ds
  6855                              <2> 	push	si
  6856                              <2> 	push	cx
  6857                              <2> 
  6858                              <2> 	mov		cx, BUFFER_SIZE_FOR_WORD_INPUT
  6859                              <2> 	call	Memory_ReserveCXbytesFromStackToDSSI
  6860                              <2> 
  6861                              <2> 	call	Char_GetFilterFunctionToDXforNumericBaseInBX
  6862                              <2> 	call	Registers_ExchangeDSSIwithESDI
  6863                              <2> 	call	Keyboard_ReadUserInputtedStringToESDIWhilePrinting
  6864                              <2> 	call	Registers_ExchangeDSSIwithESDI	; Does not modify FLAGS
  6865                              <2> 	jz		SHORT .CancelledByUser
  6866                              <2> 
  6867                              <2> 	call	String_ConvertWordToAXfromStringInDSSIwithBaseInBX
  6868                              <2> .CancelledByUser:
  6869                              <2> 	add		sp, BYTE BUFFER_SIZE_FOR_WORD_INPUT
  6870                              <2> 	test	cx, cx							; Set ZF if string length is zero
  6871                              <2> 	pop		cx
  6872                              <2> 	pop		si
  6873                              <2> 	pop		ds
  6874                              <2> 	ret
  6875                              <2> %endif
  6876                              <2> 
  6877                              <2> 
  6878                              <2> ;--------------------------------------------------------------------
  6879                              <2> ; Reads user inputted string to buffer. Character filter is
  6880                              <2> ; supported to ignore unwanted characters.
  6881                              <2> ; Function returns when ENTER or ESC will be pressed.
  6882                              <2> ;
  6883                              <2> ; Keyboard_ReadUserInputtedStringToESDIWhilePrinting
  6884                              <2> ;	Parameters:
  6885                              <2> ;		CX:		Buffer size (with NULL)
  6886                              <2> ;		ES:DI:	Ptr to destination buffer
  6887                              <2> ;		CS:DX:	Ptr to character filter function:
  6888                              <2> ;					Parameters:
  6889                              <2> ;						AL:		Character inputted by user
  6890                              <2> ;					Returns:
  6891                              <2> ;						CF:		Set if character is accepted
  6892                              <2> ;								Cleared if character is rejected
  6893                              <2> ;					Corrupts registers:
  6894                              <2> ;						Nothing
  6895                              <2> ;	Returns:
  6896                              <2> ;		CX:		String length in characters (without NULL)
  6897                              <2> ;		ZF:		Set if user cancellation
  6898                              <2> ;	Corrupts registers:
  6899                              <2> ;		AX
  6900                              <2> ;--------------------------------------------------------------------
  6901                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6902                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  6903                              <2> Keyboard_ReadUserInputtedStringToESDIWhilePrinting:
  6904                              <2> 	push	di
  6905                              <2> 	push	si
  6906                              <2> 	push	bx
  6907                              <2> 	call	.PrepareDisplayContextForKeyboardInput
  6908                              <2> 	jcxz	.ReturnAfterUpdatingZF
  6909                              <2> 
  6910                              <2> 	xor		bx, bx								; Zero character counter
  6911                              <2> 	dec		cx									; Decrement buffer size for NULL
  6912                              <2> 	cld
  6913                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  6914                              <2> .GetCharacterFromUser:
  6915                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary	; Get ASCII to AL
  6916                              <2> 	call	.ProcessControlCharacter
  6917                              <2> 	jz		SHORT .TerminateStringWithNULL
  6918                              <2> 	jc		SHORT .PlayBellForRejectedCharacter
  6919                              <2> 	call	dx									; Filter character
  6920                              <2> 	jnc		SHORT .PlayBellForRejectedCharacter
  6921                              <2> 	inc		bx									; Increment number of characters stored
  6922                              <2> 	stosb										; Store from AL to ES:DI
  6923                              <2> 	call	Keyboard_PrintInputtedCharacter
  6924                              <2> 	loop	.GetCharacterFromUser
  6925                              <2> .PlayBellForRejectedCharacter:
  6926                              <2> 	cmp		al, BS								; No bell for backspace
  6927                              <2> 	je		SHORT .GetCharacterFromUser
  6928                              <2> 	call	Keyboard_PlayBellForUnwantedKeystroke
  6929                              <2> 	jmp		SHORT .GetCharacterFromUser
  6930                              <2> 
  6931                              <2> .TerminateStringWithNULL:
  6932                              <2> 	stosb										; Terminate string with NULL
  6933                              <2> 	mov		cx, bx								; String length now in CX
  6934                              <2> 
  6935                              <2> .ReturnAfterUpdatingZF:
  6936                              <2> 	CALL_DISPLAY_LIBRARY PopDisplayContext
  6937                              <2> 	test	cx, cx								; Clear or set ZF
  6938                              <2> 	pop		bx
  6939                              <2> 	pop		si
  6940                              <2> 	pop		di
  6941                              <2> 	ret
  6942                              <2> 
  6943                              <2> ;--------------------------------------------------------------------
  6944                              <2> ; .PrepareDisplayContextForKeyboardInput
  6945                              <2> ;	Parameters:
  6946                              <2> ;		Nothing
  6947                              <2> ;	Returns:
  6948                              <2> ;		Nothing (Display context pushed to stack)
  6949                              <2> ;	Corrupts registers:
  6950                              <2> ;		AX, BX, SI
  6951                              <2> ;--------------------------------------------------------------------
  6952                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  6953                              <2> .PrepareDisplayContextForKeyboardInput:
  6954                              <2> 	pop		bx					; Pop return address to BX
  6955                              <2> 	mov		si, di
  6956                              <2> 
  6957                              <2> 	CALL_DISPLAY_LIBRARY PushDisplayContext
  6958                              <2> 	call	DisplayCursor_GetDefaultCursorShapeToAX
  6959                              <2> 	CALL_DISPLAY_LIBRARY SetCursorShapeFromAX
  6960                              <2> 	CALL_DISPLAY_LIBRARY SynchronizeDisplayContextToHardware
  6961                              <2> 
  6962                              <2> 	mov		di, si
  6963                              <2> 	jmp		bx
  6964                              <2> 
  6965                              <2> 
  6966                              <2> ;--------------------------------------------------------------------
  6967                              <2> ; .ProcessControlCharacter
  6968                              <2> ;	Parameters:
  6969                              <2> ;		AL:		Character inputted by user
  6970                              <2> ;		CX:		Number of bytes left in buffer
  6971                              <2> ;		BX:		Total number of characters inputted
  6972                              <2> ;		ES:DI:	Ptr where to store next character
  6973                              <2> ;	Returns:
  6974                              <2> ;		AL:		Character inputted by user or NULL if end of input
  6975                              <2> ;		BX:		Cleared if user cancellation
  6976                              <2> ;		ZF:		Set if user has ended or cancelled key input
  6977                              <2> ;		CF:		Set if character is rejected
  6978                              <2> ;	Corrupts registers:
  6979                              <2> ;		AH
  6980                              <2> ;--------------------------------------------------------------------
  6981                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  6982                              <2> .ProcessControlCharacter:
  6983                              <2> 	cmp		al, CR								; ENTER to terminate string?
  6984                              <2> 	je		SHORT .EndCharacterInput
  6985                              <2> 	cmp		al, ESC								; Cancel input?
  6986                              <2> 	je		SHORT .CancelCharacterInput
  6987                              <2> 	cmp		al, BS								; Backspace?
  6988                              <2> 	je		SHORT .Backspace
  6989                              <2> 	jcxz	.RejectCharacter
  6990                              <2> 	clc											; Clear CF (ZF is already cleared)
  6991                              <2> 	ret
  6992                              <2> 
  6993                              <2> .Backspace:
  6994                              <2> 	test	bx, bx								; At the beginning?
  6995                              <2> 	jz		SHORT .RejectCharacter
  6996                              <2> 	inc		cx									; Increment bytes left
  6997                              <2> 	dec		bx									; Decrement characters inputted
  6998                              <2> 	dec		di
  6999                              <2> 	call	Keyboard_PrintBackspace
  7000                              <2> 	mov		al, BS								; Restore character
  7001                              <2> .RejectCharacter:
  7002                              <2> 	test	al, al								; Clear ZF...
  7003                              <2> 	stc											; ...and set CF
  7004                              <2> 	ret
  7005                              <2> 
  7006                              <2> .CancelCharacterInput:
  7007                              <2> 	xor		bx, bx
  7008                              <2> .EndCharacterInput:
  7009                              <2> 	xor		al, al								; Set ZF and clear CF
  7010                              <2> 	ret
  7011                              <2> %endif ; EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7012                              <2> 
  7013                              <2> 
  7014                              <2> ;--------------------------------------------------------------------
  7015                              <2> ; Keyboard_PrintBackspace
  7016                              <2> ;	Parameters:
  7017                              <2> ;		Nothing
  7018                              <2> ;	Returns:
  7019                              <2> ;		Nothing
  7020                              <2> ;	Corrupts registers:
  7021                              <2> ;		AX
  7022                              <2> ;--------------------------------------------------------------------
  7023                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7024                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7025                              <2> Keyboard_PrintBackspace:
  7026                              <2> 	mov		al, BS
  7027                              <2> 	call	Keyboard_PrintInputtedCharacter
  7028                              <2> 	mov		al, ' '
  7029                              <2> 	call	Keyboard_PrintInputtedCharacter
  7030                              <2> 	mov		al, BS
  7031                              <2> 	jmp		SHORT Keyboard_PrintInputtedCharacter
  7032                              <2> %endif
  7033                              <2> 
  7034                              <2> 
  7035                              <2> ;--------------------------------------------------------------------
  7036                              <2> ; Keyboard_PlayBellForUnwantedKeystroke
  7037                              <2> ;	Parameters:
  7038                              <2> ;		Nothing
  7039                              <2> ;	Returns:
  7040                              <2> ;		Nothing
  7041                              <2> ;	Corrupts registers:
  7042                              <2> ;		AX
  7043                              <2> ;--------------------------------------------------------------------
  7044                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7045                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7046                              <2> Keyboard_PlayBellForUnwantedKeystroke:
  7047                              <2> 	mov		al, BELL
  7048                              <2> 	; Fall to Keyboard_PrintInputtedCharacter
  7049                              <2> %endif
  7050                              <2> 
  7051                              <2> ;--------------------------------------------------------------------
  7052                              <2> ; Keyboard_PrintInputtedCharacter
  7053                              <2> ;	Parameters:
  7054                              <2> ;		AL:		Character inputted by user
  7055                              <2> ;	Returns:
  7056                              <2> ;		Nothing
  7057                              <2> ;	Corrupts registers:
  7058                              <2> ;		AX
  7059                              <2> ;--------------------------------------------------------------------
  7060                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7061                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7062                              <2> Keyboard_PrintInputtedCharacter:
  7063                              <2> 	push	di
  7064                              <2> 	CALL_DISPLAY_LIBRARY PrintCharacterFromAL
  7065                              <2> 	CALL_DISPLAY_LIBRARY SynchronizeDisplayContextToHardware	; Hardware cursor
  7066                              <2> 	pop		di
  7067                              <2> 	ret
  7068                              <2> %endif
  7069                              <2> 
  7070                              <2> 
  7071                              <2> ;--------------------------------------------------------------------
  7072                              <2> ; Keyboard_RemoveAllKeystrokesFromBuffer
  7073                              <2> ;	Parameters:
  7074                              <2> ;		Nothing
  7075                              <2> ;	Returns:
  7076                              <2> ;		Nothing
  7077                              <2> ;	Corrupts registers:
  7078                              <2> ;		AX
  7079                              <2> ;--------------------------------------------------------------------
  7080                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS	; Only used when debugging
  7081                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7082                              <2> Keyboard_RemoveAllKeystrokesFromBuffer:
  7083                              <2> 	call	Keyboard_GetKeystrokeToAX
  7084                              <2> 	jnz		SHORT Keyboard_RemoveAllKeystrokesFromBuffer
  7085                              <2> 	ret
  7086                              <2> %endif
  7087                              <2> 
  7088                              <2> 
  7089                              <2> ;--------------------------------------------------------------------
  7090                              <2> ; Keyboard_GetKeystrokeToAX
  7091                              <2> ; Keyboard_GetKeystrokeToAXandLeaveItToBuffer
  7092                              <2> ; Keyboard_GetKeystrokeToAXandWaitIfNecessary
  7093                              <2> ;	Parameters:
  7094                              <2> ;		Nothing
  7095                              <2> ;	Returns:
  7096                              <2> ;		AL:		ASCII character (if keystroke available)
  7097                              <2> ;		AH:		BIOS scan code (if keystroke available)
  7098                              <2> ;		ZF:		Set if no keystroke available
  7099                              <2> ;				Cleared if keystroke available
  7100                              <2> ;	Corrupts registers:
  7101                              <2> ;		Nothing
  7102                              <2> ;--------------------------------------------------------------------
  7103                              <2> 
  7104                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7105                              <2> 	%define EXCLUDE
  7106                              <2> 	%ifdef MODULE_HOTKEYS
  7107                              <2> 		%undef EXCLUDE
  7108                              <2> 	%endif
  7109                              <2> 	%ifdef MODULE_BOOT_MENU
  7110                              <2> 		%undef EXCLUDE
  7111                              <2> 	%endif
  7112                              <2> %endif
  7113                              <2> 
  7114                              <2> %ifndef EXCLUDE
  7115                              <2> 
  7116                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7117                              <2> Keyboard_GetKeystrokeToAXandLeaveItToBuffer:
  7118                              <2> 	mov		ah, CHECK_FOR_KEYSTROKE
  7119                              <2> 	int		BIOS_KEYBOARD_INTERRUPT_16h
  7120                              <2> 	ret
  7121                              <2> 
  7122                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7123                              <2> Keyboard_GetKeystrokeToAX:
  7124                              <2> 	call	Keyboard_GetKeystrokeToAXandLeaveItToBuffer
  7125                              <2> 	jz		SHORT Keyboard_GetKeystrokeToAXReturn
  7126                              <2> 	; Fall to Keyboard_GetKeystrokeToAXandWaitIfNecessary
  7127                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7128                              <2> Keyboard_GetKeystrokeToAXandWaitIfNecessary:
  7129                              <2> 	xor		ah, ah						; GET_KEYSTROKE
  7130                              <2> 	int		BIOS_KEYBOARD_INTERRUPT_16h
  7131                              <2> 	test	ax, ax						; Clear ZF
  7132                              <2> Keyboard_GetKeystrokeToAXReturn:
  7133                              <2> 	ret
  7134                              <2> 
  7135                              <2> %endif
  7136                              <2> %undef EXCLUDE
  7137                              <1> %endif
  7138                              <1> 
  7139                              <1> %ifdef INCLUDE_MENU_LIBRARY
  7140                              <1>   %ifndef MENU_JUMP_ALIGN
  7141                              <1> 	%define MENU_JUMP_ALIGN 1
  7142                              <1>   %endif
  7143                              <1> 	%include "CharOutLineSplitter.asm"
  7144                              <1> 	%include "Menu.asm"
  7145                              <1> 	%include "MenuAttributes.asm"
  7146                              <1> 	%include "MenuBorders.asm"
  7147                              <1> 	%include "MenuCharOut.asm"
  7148                              <1> 	%include "MenuEvent.asm"
  7149                              <1> 	%include "MenuInit.asm"
  7150                              <1> 	%include "MenuLocation.asm"
  7151                              <1> 	%include "MenuLoop.asm"
  7152                              <1> 	%include "MenuScrollbars.asm"
  7153                              <1> 	%include "MenuText.asm"
  7154                              <1> 	%include "MenuTime.asm"
  7155                              <1> 
  7156                              <1> 	%ifdef INCLUDE_MENU_DIALOGS
  7157                              <1> 		%include "Dialog.asm"
  7158                              <1> 		%include "DialogDrive.asm"
  7159                              <1> 		%include "DialogFile.asm"
  7160                              <1> 		%include "DialogMessage.asm"
  7161                              <1> 		%include "DialogProgress.asm"
  7162                              <1> 		%include "DialogSelection.asm"
  7163                              <1> 		%include "DialogString.asm"
  7164                              <1> 		%include "DialogWord.asm"
  7165                              <1> 		%include "ItemLineSplitter.asm"
  7166                              <1> 		%include "StringsForDialogs.asm"
  7167                              <1> 	%endif
  7168                              <1> %endif
  7169                              <1> 
  7170                              <1> %ifdef INCLUDE_STRING_LIBRARY
  7171                              <1>   %ifndef STRING_JUMP_ALIGN
  7172                              <1> 	%define STRING_JUMP_ALIGN 1
  7173                              <1>   %endif
  7174                              <1> 	%include "Char.asm"
  7175                              <2> ; Project name	:	Assembly Library
  7176                              <2> ; Description	:	Functions for handling characters.
  7177                              <2> 
  7178                              <2> ;
  7179                              <2> ; XTIDE Universal BIOS and Associated Tools
  7180                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  7181                              <2> ;
  7182                              <2> ; This program is free software; you can redistribute it and/or modify
  7183                              <2> ; it under the terms of the GNU General Public License as published by
  7184                              <2> ; the Free Software Foundation; either version 2 of the License, or
  7185                              <2> ; (at your option) any later version.
  7186                              <2> ;
  7187                              <2> ; This program is distributed in the hope that it will be useful,
  7188                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7189                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7190                              <2> ; GNU General Public License for more details.
  7191                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  7192                              <2> ;
  7193                              <2> 
  7194                              <2> ; Section containing code
  7195                              <2> SECTION .text
  7196                              <2> 
  7197                              <2> ;--------------------------------------------------------------------
  7198                              <2> ; This macro can only be used within this source file!!!
  7199                              <2> ; IS_BETWEEN_IMMEDIATES
  7200                              <2> ;	Parameters:
  7201                              <2> ;		%1:		Value to check
  7202                              <2> ;		%2:		First accepted value in range
  7203                              <2> ;		%3:		Last accepted value in range
  7204                              <2> ;	Returns:
  7205                              <2> ;		CF:		Set if character in range
  7206                              <2> ;				(Jumps to Char_CharIsNotValid if before range)
  7207                              <2> ;	Corrupts registers:
  7208                              <2> ;		Nothing
  7209                              <2> ;--------------------------------------------------------------------
  7210                              <2> %macro IS_BETWEEN_IMMEDIATES 3
  7211                              <2> 	cmp		%1, %2
  7212                              <2> 	jb		SHORT Char_CharIsNotValid
  7213                              <2> 	cmp		%1, (%3)+1				; Set CF if %1 is lesser
  7214                              <2> %endmacro
  7215                              <2> 
  7216                              <2> 
  7217                              <2> ;--------------------------------------------------------------------
  7218                              <2> ; Char_IsLowerCaseLetterInAL
  7219                              <2> ;	Parameters:
  7220                              <2> ;		AL:		Character to check
  7221                              <2> ;	Returns:
  7222                              <2> ;		CF:		Set if character is lower case letter ('a'...'z')
  7223                              <2> ;				Cleared if character is not lower case letter
  7224                              <2> ;	Corrupts registers:
  7225                              <2> ;		Nothing
  7226                              <2> ;--------------------------------------------------------------------
  7227                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7228                              <2> 	%ifndef MODULE_HOTKEYS
  7229                              <2> 		%define EXCLUDE
  7230                              <2> 	%endif
  7231                              <2> %endif
  7232                              <2> 
  7233                              <2> %ifndef EXCLUDE
  7234                              <2> ALIGN STRING_JUMP_ALIGN
  7235                              <2> Char_IsLowerCaseLetterInAL:
  7236                              <2> 	IS_BETWEEN_IMMEDIATES al, 'a', 'z'
  7237                              <2> 	ret
  7238                              <2> %endif
  7239                              <2> %undef EXCLUDE
  7240                              <2> 
  7241                              <2> 
  7242                              <2> ;--------------------------------------------------------------------
  7243                              <2> ; Char_IsUpperCaseLetterInAL
  7244                              <2> ;	Parameters:
  7245                              <2> ;		AL:		Character to check
  7246                              <2> ;	Returns:
  7247                              <2> ;		CF:		Set if character is upper case letter ('A'...'Z')
  7248                              <2> ;				Cleared if character is not upper case letter
  7249                              <2> ;	Corrupts registers:
  7250                              <2> ;		Nothing
  7251                              <2> ;--------------------------------------------------------------------
  7252                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7253                              <2> ALIGN STRING_JUMP_ALIGN
  7254                              <2> Char_IsUpperCaseLetterInAL:
  7255                              <2> 	IS_BETWEEN_IMMEDIATES al, 'A', 'Z'
  7256                              <2> 	ret
  7257                              <2> %endif
  7258                              <2> 
  7259                              <2> 
  7260                              <2> ;--------------------------------------------------------------------
  7261                              <2> ; Char_IsHexadecimalDigitInAL
  7262                              <2> ;	Parameters:
  7263                              <2> ;		AL:		Character to check
  7264                              <2> ;	Returns:
  7265                              <2> ;		AL:		Character converted to lower case
  7266                              <2> ;		CF:		Set if character is decimal digit ('0'...'F')
  7267                              <2> ;				Cleared if character is not decimal digit
  7268                              <2> ;	Corrupts registers:
  7269                              <2> ;		Nothing
  7270                              <2> ;--------------------------------------------------------------------
  7271                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7272                              <2> ALIGN STRING_JUMP_ALIGN
  7273                              <2> Char_IsHexadecimalDigitInAL:
  7274                              <2> 	call	Char_IsDecimalDigitInAL
  7275                              <2> 	jc		SHORT Char_CharIsValid
  7276                              <2> 	call	Char_ALtoLowerCaseLetter
  7277                              <2> 	IS_BETWEEN_IMMEDIATES al, 'a', 'f'
  7278                              <2> 	ret
  7279                              <2> %endif
  7280                              <2> 
  7281                              <2> 
  7282                              <2> ;--------------------------------------------------------------------
  7283                              <2> ; Char_IsDecimalDigitInAL
  7284                              <2> ;	Parameters:
  7285                              <2> ;		AL:		Character to check
  7286                              <2> ;	Returns:
  7287                              <2> ;		CF:		Set if character is decimal digit ('0'...'9')
  7288                              <2> ;				Cleared if character is not decimal digit
  7289                              <2> ;	Corrupts registers:
  7290                              <2> ;		Nothing
  7291                              <2> ;--------------------------------------------------------------------
  7292                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  7293                              <2> ALIGN STRING_JUMP_ALIGN
  7294                              <2> Char_IsDecimalDigitInAL:
  7295                              <2> 	IS_BETWEEN_IMMEDIATES al, '0', '9'
  7296                              <2> 	ret
  7297                              <2> %endif
  7298                              <2> 
  7299                              <2> 
  7300                              <2> ;--------------------------------------------------------------------
  7301                              <2> ; Char_ConvertIntegerToALfromDigitInALwithBaseInBX
  7302                              <2> ;	Parameters:
  7303                              <2> ;		AL:		Character to convert
  7304                              <2> ;		BX:		Numeric base (10 or 16)
  7305                              <2> ;	Returns:
  7306                              <2> ;		AL:		Character converted to integer
  7307                              <2> ;		CF:		Set if character was valid
  7308                              <2> ;				Cleared if character was invalid
  7309                              <2> ;	Corrupts registers:
  7310                              <2> ;		Nothing
  7311                              <2> ;--------------------------------------------------------------------
  7312                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7313                              <2> ALIGN STRING_JUMP_ALIGN
  7314                              <2> Char_ConvertIntegerToALfromDigitInALwithBaseInBX:
  7315                              <2> 	push	dx
  7316                              <2> 	call	Char_GetFilterFunctionToDXforNumericBaseInBX
  7317                              <2> 	call	dx						; Converts to lower case
  7318                              <2> 	pop		dx
  7319                              <2> 	jnc		SHORT Char_CharIsNotValid
  7320                              <2> 
  7321                              <2> 	cmp		al, '9'					; Decimal digit
  7322                              <2> 	jbe		SHORT .ConvertToDecimalDigit
  7323                              <2> 	sub		al, 'a'-'0'-10			; Convert to hexadecimal integer
  7324                              <2> ALIGN STRING_JUMP_ALIGN
  7325                              <2> .ConvertToDecimalDigit:
  7326                              <2> 	sub		al, '0'					; Convert to decimal integer
  7327                              <2> 	; Fall to Char_CharIsValid
  7328                              <2> %endif
  7329                              <2> 
  7330                              <2> 
  7331                              <2> ;--------------------------------------------------------------------
  7332                              <2> ; Char_CharIsValid
  7333                              <2> ; Char_CharIsNotValid
  7334                              <2> ;	Parameters:
  7335                              <2> ;		Nothing
  7336                              <2> ;	Returns:
  7337                              <2> ;		CF:		Set for Char_CharIsValid
  7338                              <2> ;				Cleared for Char_CharIsNotValid
  7339                              <2> ;	Corrupts registers:
  7340                              <2> ;		Nothing
  7341                              <2> ;--------------------------------------------------------------------
  7342                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7343                              <2> ALIGN STRING_JUMP_ALIGN
  7344                              <2> Char_CharIsValid:
  7345                              <2> 	stc
  7346                              <2> 	ret
  7347                              <2> %endif
  7348                              <2> 
  7349                              <2> 
  7350                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7351                              <2> 	%ifndef MODULE_HOTKEYS
  7352                              <2> 		%define EXCLUDE
  7353                              <2> 	%endif
  7354                              <2> 	%ifndef MODULE_STRINGS_COMPRESSED
  7355                              <2> 		%undef EXCLUDE
  7356                              <2> 	%endif
  7357                              <2> %endif
  7358                              <2> 
  7359                              <2> %ifndef EXCLUDE
  7360                              <2> ALIGN STRING_JUMP_ALIGN
  7361                              <2> Char_CharIsNotValid:
  7362                              <2> 	clc
  7363                              <2> 	ret
  7364                              <2> %endif
  7365                              <2> %undef EXCLUDE
  7366                              <2> 
  7367                              <2> 
  7368                              <2> ;--------------------------------------------------------------------
  7369                              <2> ; Char_ALtoLowerCaseLetter
  7370                              <2> ;	Parameters:
  7371                              <2> ;		AL:		Character to convert
  7372                              <2> ;	Returns:
  7373                              <2> ;		AL:		Character with possible conversion
  7374                              <2> ;	Corrupts registers:
  7375                              <2> ;		Nothing
  7376                              <2> ;--------------------------------------------------------------------
  7377                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7378                              <2> ALIGN STRING_JUMP_ALIGN
  7379                              <2> Char_ALtoLowerCaseLetter:
  7380                              <2> 	call	Char_IsUpperCaseLetterInAL	; Is upper case character?
  7381                              <2> 	jmp		SHORT Char_ALtoUpperCaseLetter.CheckCF
  7382                              <2> %endif
  7383                              <2> 
  7384                              <2> 
  7385                              <2> ;--------------------------------------------------------------------
  7386                              <2> ; Char_ALtoUpperCaseLetter
  7387                              <2> ;	Parameters:
  7388                              <2> ;		AL:		Character to convert
  7389                              <2> ;	Returns:
  7390                              <2> ;		AL:		Character with possible conversion
  7391                              <2> ;	Corrupts registers:
  7392                              <2> ;		Nothing
  7393                              <2> ;--------------------------------------------------------------------
  7394                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7395                              <2> ALIGN STRING_JUMP_ALIGN
  7396                              <2> Char_ALtoUpperCaseLetter:
  7397                              <2> 	call	Char_IsLowerCaseLetterInAL	; Is lower case character?
  7398                              <2> .CheckCF:
  7399                              <2> 	jnc		SHORT Char_ChangeCaseInAL.Return
  7400                              <2> 	; Fall to Char_ChangeCaseInAL
  7401                              <2> %endif
  7402                              <2> 
  7403                              <2> 
  7404                              <2> ;--------------------------------------------------------------------
  7405                              <2> ; Char_ChangeCaseInAL
  7406                              <2> ;	Parameters:
  7407                              <2> ;		AL:		Character to convert (must be A-Z or a-z)
  7408                              <2> ;	Returns:
  7409                              <2> ;		AL:		Character converted
  7410                              <2> ;	Corrupts registers:
  7411                              <2> ;		Nothing
  7412                              <2> ;--------------------------------------------------------------------
  7413                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7414                              <2> Char_ChangeCaseInAL:
  7415                              <2> 	xor		al, 32
  7416                              <2> .Return:
  7417                              <2> 	ret
  7418                              <2> %endif
  7419                              <2> 
  7420                              <2> 
  7421                              <2> ;--------------------------------------------------------------------
  7422                              <2> ; Char_GetFilterFunctionToDXforNumericBaseInBX
  7423                              <2> ;	Parameters
  7424                              <2> ;		BX:		Numeric base (10 or 16)
  7425                              <2> ;	Returns:
  7426                              <2> ;		CS:DX:	Ptr to character filter function
  7427                              <2> ;	Corrupts registers:
  7428                              <2> ;		Nothing
  7429                              <2> ;--------------------------------------------------------------------
  7430                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7431                              <2> ALIGN STRING_JUMP_ALIGN
  7432                              <2> Char_GetFilterFunctionToDXforNumericBaseInBX:
  7433                              <2> 	mov		dx, Char_IsDecimalDigitInAL
  7434                              <2> 	cmp		bl, 10
  7435                              <2> 	je		SHORT .Return
  7436                              <2> 	mov		dx, Char_IsHexadecimalDigitInAL
  7437                              <2> .Return:
  7438                              <2> 	ret
  7439                              <2> %endif
  7440                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7441                              <1> 		%include "String.asm"
  7442                              <1> 		%include "StringProcess.asm"
  7443                              <1> 	%endif
  7444                              <1> %endif
  7445                              <1> 
  7446                              <1> %ifdef INCLUDE_SERIAL_LIBRARY
  7447                              <1> 	%include "Serial.inc"
  7448                              <1> %endif
  7449                              <1> %ifdef INCLUDE_SERIALSERVER_LIBRARY
  7450                              <1> 	%include "SerialServer.asm"
  7451                              <1> 	%include "SerialServerScan.asm"
  7452                              <1> 	%define INCLUDE_TIME_LIBRARY
  7453                              <1> %endif
  7454                              <1> 
  7455                              <1> %ifdef INCLUDE_TIME_LIBRARY
  7456                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7457                              <1> 		%include "Delay.asm"
  7458                              <1> 		%ifndef EXCLUDE_FROM_XTIDECFG
  7459                              <1> 			%include "SystemTimer.asm"
  7460                              <1> 		%endif
  7461                              <1> 	%endif
  7462                              <1> 	%include "TimerTicks.asm"
  7463                              <2> ; Project name	:	Assembly Library
  7464                              <2> ; Description	:	Functions for system timer related operations.
  7465                              <2> 
  7466                              <2> ;
  7467                              <2> ; XTIDE Universal BIOS and Associated Tools
  7468                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  7469                              <2> ;
  7470                              <2> ; This program is free software; you can redistribute it and/or modify
  7471                              <2> ; it under the terms of the GNU General Public License as published by
  7472                              <2> ; the Free Software Foundation; either version 2 of the License, or
  7473                              <2> ; (at your option) any later version.
  7474                              <2> ;
  7475                              <2> ; This program is distributed in the hope that it will be useful,
  7476                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7477                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7478                              <2> ; GNU General Public License for more details.
  7479                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  7480                              <2> ;
  7481                              <2> 
  7482                              <2> ; With a PIT input clock of 1193181.6666... Hz and a maximum
  7483                              <2> ; 16 bit divisor of 65536 (if PIT programmed with 0) we get:
  7484                              <2> ;
  7485                              <2> ; Clock / Divisor = ~18.2065 ticks per second
  7486                              <2> ; Clock * SecondsPerMinute / Divisor = ~1092 ticks per minute
  7487                              <2> ; Clock * SecondsPerHour / Divisor = ~65543 ticks per hour
  7488                              <2> ;
  7489                              <2> ; Since 65543 can't fit in a 16 bit register we use the
  7490                              <2> ; maximum possible instead and disregard the last ~8 ticks.
  7491                              <2> 
  7492                              <2> TICKS_PER_HOUR			EQU		65535
  7493                              <2> TICKS_PER_MINUTE		EQU		1092
  7494                              <2> TICKS_PER_SECOND		EQU		18
  7495                              <2> 
  7496                              <2> 
  7497                              <2> ; Section containing code
  7498                              <2> SECTION .text
  7499                              <2> 
  7500                              <2> ;--------------------------------------------------------------------
  7501                              <2> ; TimerTicks_GetHoursToAXandRemainderTicksToDXfromTicksInDXAX
  7502                              <2> ; TimerTicks_GetMinutesToAXandRemainderTicksToDXfromTicksInDX
  7503                              <2> ; TimerTicks_GetSecondsToAXandRemainderTicksToDXfromTicksInDX
  7504                              <2> ;	Parameters
  7505                              <2> ;		DX(:AX):	Timer ticks to convert
  7506                              <2> ;	Returns:
  7507                              <2> ;		AX:			Hours, minutes or seconds
  7508                              <2> ;		DX:			Remainder ticks
  7509                              <2> ;	Corrupts registers:
  7510                              <2> ;		CX
  7511                              <2> ;--------------------------------------------------------------------
  7512                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7513                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  7514                              <2> ALIGN JUMP_ALIGN
  7515                              <2> TimerTicks_GetHoursToAXandRemainderTicksToDXfromTicksInDXAX:
  7516                              <2> 	mov		cx, TICKS_PER_HOUR
  7517                              <2> 	div		cx		; Divide DX:AX by CX, Hours to AX, remainder ticks to DX
  7518                              <2> 	ret
  7519                              <2> %endif ; EXCLUDE_FROM_XTIDECFG
  7520                              <2> 
  7521                              <2> ALIGN JUMP_ALIGN
  7522                              <2> TimerTicks_GetMinutesToAXandRemainderTicksToDXfromTicksInDX:
  7523                              <2> 	xor		ax, ax
  7524                              <2> 	xchg	ax, dx	; Ticks now in DX:AX
  7525                              <2> 	mov		cx, TICKS_PER_MINUTE
  7526                              <2> 	div		cx		; Divide DX:AX by CX, Minutes to AX, remainder ticks to DX
  7527                              <2> 	ret
  7528                              <2> %endif ; EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7529                              <2> 
  7530                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  7531                              <2> ALIGN JUMP_ALIGN
  7532                              <2> TimerTicks_GetSecondsToAXandRemainderTicksToDXfromTicksInDX:
  7533                              <2> 	; This procedure can handle at most 4607 ticks in DX (almost 256 seconds)
  7534                              <2> 	; More than 4607 ticks will generate a divide overflow exception!
  7535                              <2> 	xchg	ax, dx	; Ticks now in AX
  7536                              <2> 	mov		cl, TICKS_PER_SECOND
  7537                              <2> 	div		cl		; Divide AX by CL, Seconds to AL, remainder ticks to AH
  7538                              <2> 	xor		dx, dx
  7539                              <2> 	xchg	dl, ah	; Seconds in AX, remainder in DX
  7540                              <2> 	ret
  7541                              <2> %endif
  7542                              <2> 
  7543                              <2> 
  7544                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7545                              <2> 	%ifndef MODULE_BOOT_MENU
  7546                              <2> 		%define EXCLUDE
  7547                              <2> 	%endif
  7548                              <2> %endif
  7549                              <2> ;--------------------------------------------------------------------
  7550                              <2> ; TimerTicks_GetSecondsToAXfromTicksInDX
  7551                              <2> ;	Parameters
  7552                              <2> ;		DX:			Timer ticks to convert
  7553                              <2> ;	Returns:
  7554                              <2> ;		AX:			Seconds
  7555                              <2> ;	Corrupts registers:
  7556                              <2> ;		DX
  7557                              <2> ;--------------------------------------------------------------------
  7558                              <2> %ifndef EXCLUDE	; 1 of 3
  7559                              <2> ALIGN JUMP_ALIGN
  7560                              <2> TimerTicks_GetSecondsToAXfromTicksInDX:
  7561                              <2> 	mov		ax, 3600	; Approximately 65536 / (Clock / Divisor)
  7562                              <2> 	mul		dx
  7563                              <2> 	xchg	dx, ax
  7564                              <2> 	ret
  7565                              <2> %endif
  7566                              <2> 
  7567                              <2> 
  7568                              <2> ;--------------------------------------------------------------------
  7569                              <2> ; First tick might take 0...54.9 ms and remaining ticks
  7570                              <2> ; will occur at 54.9 ms intervals. Use delay of two (or more) ticks to
  7571                              <2> ; ensure at least 54.9 ms timeout.
  7572                              <2> ;
  7573                              <2> ; TimerTicks_InitializeTimeoutFromAX
  7574                              <2> ;	Parameters:
  7575                              <2> ;		AX:			Timeout ticks (54.9 ms) before timeout
  7576                              <2> ;		DS:BX:		Ptr to timeout variable WORD
  7577                              <2> ;	Returns:
  7578                              <2> ;		[DS:BX]:	Initialized for TimerTicks_SetCarryIfTimeoutFromDSBX
  7579                              <2> ;	Corrupts registers:
  7580                              <2> ;		AX
  7581                              <2> ;--------------------------------------------------------------------
  7582                              <2> %ifndef EXCLUDE	; 2 of 3
  7583                              <2> ALIGN JUMP_ALIGN
  7584                              <2> TimerTicks_InitializeTimeoutFromAX:
  7585                              <2> 	mov		[bx], ax					; Store timeout ticks
  7586                              <2> 	call	TimerTicks_ReadFromBdaToAX
  7587                              <2> 	add		[bx], ax					; [bx] now contains end time for timeout
  7588                              <2> 	ret
  7589                              <2> %endif
  7590                              <2> 
  7591                              <2> 
  7592                              <2> ;--------------------------------------------------------------------
  7593                              <2> ; TimerTicks_GetTimeoutTicksLeftToAXfromDSBX
  7594                              <2> ;	Parameters:
  7595                              <2> ;		DS:BX:		Ptr to timeout variable WORD
  7596                              <2> ;	Returns:
  7597                              <2> ;		AX:			Number of ticks left before timeout
  7598                              <2> ;		CF:			Set if timeout
  7599                              <2> ;					Cleared if time left
  7600                              <2> ;	Corrupts registers:
  7601                              <2> ;		Nothing
  7602                              <2> ;--------------------------------------------------------------------
  7603                              <2> %ifndef EXCLUDE	; 3 of 3
  7604                              <2> ALIGN JUMP_ALIGN
  7605                              <2> TimerTicks_GetTimeoutTicksLeftToAXfromDSBX:
  7606                              <2> 	push	dx
  7607                              <2> 	mov		dx, [bx]
  7608                              <2> 	call	TimerTicks_ReadFromBdaToAX
  7609                              <2> 	xchg	ax, dx
  7610                              <2> 	sub		ax, dx		; AX = End time - current time
  7611                              <2> 	pop		dx
  7612                              <2> 	ret
  7613                              <2> %endif
  7614                              <2> 
  7615                              <2> %undef EXCLUDE
  7616                              <2> 
  7617                              <2> 
  7618                              <2> ;--------------------------------------------------------------------
  7619                              <2> ; TimerTicks_GetElapsedToAXandResetDSBX
  7620                              <2> ;	Parameters
  7621                              <2> ;		DS:BX:		Ptr to WORD containing previous reset time
  7622                              <2> ;	Returns:
  7623                              <2> ;		AX:			54.9 ms ticks elapsed since last reset
  7624                              <2> ;		[DS:BX]:	Reset to latest time
  7625                              <2> ;	Corrupts registers:
  7626                              <2> ;		Nothing
  7627                              <2> ;--------------------------------------------------------------------
  7628                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7629                              <2> ALIGN JUMP_ALIGN
  7630                              <2> TimerTicks_GetElapsedToAXandResetDSBX:
  7631                              <2> 	call	TimerTicks_ReadFromBdaToAX
  7632                              <2> 	push	ax
  7633                              <2> 	sub		ax, [bx]
  7634                              <2> 	pop		WORD [bx]			; Latest time to [DS:BX]
  7635                              <2> 	ret
  7636                              <2> %endif
  7637                              <2> 
  7638                              <2> 
  7639                              <2> ;--------------------------------------------------------------------
  7640                              <2> ; TimerTicks_GetElapsedToAXfromDSBX
  7641                              <2> ;	Parameters
  7642                              <2> ;		DS:BX:		Ptr to WORD containing previous update time
  7643                              <2> ;	Returns:
  7644                              <2> ;		AX:			54.9 ms ticks elapsed since initializing [DS:BX]
  7645                              <2> ;	Corrupts registers:
  7646                              <2> ;		Nothing
  7647                              <2> ;--------------------------------------------------------------------
  7648                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7649                              <2> ALIGN JUMP_ALIGN
  7650                              <2> TimerTicks_GetElapsedToAXfromDSBX:
  7651                              <2> 	call	TimerTicks_ReadFromBdaToAX
  7652                              <2> 	sub		ax, [bx]
  7653                              <2> 	ret
  7654                              <2> %endif
  7655                              <2> 
  7656                              <2> 
  7657                              <2> ;--------------------------------------------------------------------
  7658                              <2> ; TimerTicks_ReadFromBdaToAX
  7659                              <2> ;	Parameters
  7660                              <2> ;		Nothing
  7661                              <2> ;	Returns:
  7662                              <2> ;		AX:		System time in 54.9 ms ticks
  7663                              <2> ;	Corrupts registers:
  7664                              <2> ;		Nothing
  7665                              <2> ;--------------------------------------------------------------------
  7666                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7667                              <2> 	%ifndef MODULE_BOOT_MENU OR MODULE_HOTKEYS
  7668                              <2> 		%define EXCLUDE
  7669                              <2> 	%endif
  7670                              <2> %endif
  7671                              <2> 
  7672                              <2> %ifndef EXCLUDE
  7673                              <2> ALIGN JUMP_ALIGN
  7674                              <2> TimerTicks_ReadFromBdaToAX:
  7675                              <2> 	push	ds
  7676                              <2> 
  7677                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax
  7678                              <2> 	mov		ax, [BDA.dwTimerTicks]	; Read low WORD only
  7679                              <2> 
  7680                              <2> 	pop		ds
  7681                              <2> 	ret
  7682                              <2> %endif
  7683                              <2> %undef EXCLUDE
  7684                              <1> %endif
  7685                              <1> 
  7686                              <1> %ifdef INCLUDE_UTIL_LIBRARY
  7687                              <1>   %ifndef UTIL_SIZE_JUMP_ALIGN
  7688                              <1> 	%define UTIL_SIZE_JUMP_ALIGN 1
  7689                              <1>   %endif
  7690                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7691                              <1> 		%include "Bit.asm"
  7692                              <1> 	%endif
  7693                              <1> 	%include "Math.asm"
  7694                              <2> ; Project name	:	Assembly Library
  7695                              <2> ; Description	:	Functions for register operations.
  7696                              <2> 
  7697                              <2> ;
  7698                              <2> ; XTIDE Universal BIOS and Associated Tools
  7699                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  7700                              <2> ;
  7701                              <2> ; This program is free software; you can redistribute it and/or modify
  7702                              <2> ; it under the terms of the GNU General Public License as published by
  7703                              <2> ; the Free Software Foundation; either version 2 of the License, or
  7704                              <2> ; (at your option) any later version.
  7705                              <2> ;
  7706                              <2> ; This program is distributed in the hope that it will be useful,
  7707                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7708                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7709                              <2> ; GNU General Public License for more details.
  7710                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  7711                              <2> ;
  7712                              <2> 
  7713                              <2> 
  7714                              <2> ; Section containing code
  7715                              <2> SECTION .text
  7716                              <2> 
  7717                              <2> ;--------------------------------------------------------------------
  7718                              <2> ; Math_DivQWatSSBPbyCX
  7719                              <2> ;	Parameters:
  7720                              <2> ;		[SS:BP]:	64-bit unsigned divident
  7721                              <2> ;		CX:			16-bit unsigned divisor
  7722                              <2> ;	Returns:
  7723                              <2> ;		[SS:BP]:	64-bit unsigned quotient
  7724                              <2> ;		DX:			16-bit unsigned remainder
  7725                              <2> ;	Corrupts registers:
  7726                              <2> ;		AX
  7727                              <2> ;--------------------------------------------------------------------
  7728                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  7729                              <2> ALIGN JUMP_ALIGN
  7730                              <2> Math_DivQWatSSBPbyCX:
  7731                              <2> 	xor		dx, dx
  7732                              <2> 	mov		ax, [bp+6]		; Load highest divident WORD to DX:AX
  7733                              <2> 	div		cx
  7734                              <2> 	mov		[bp+6], ax		; Store quotient
  7735                              <2> 
  7736                              <2> 	mov		ax, [bp+4]
  7737                              <2> 	div		cx
  7738                              <2> 	mov		[bp+4], ax
  7739                              <2> 
  7740                              <2> 	mov		ax, [bp+2]
  7741                              <2> 	div		cx
  7742                              <2> 	mov		[bp+2], ax
  7743                              <2> 
  7744                              <2> 	mov		ax, [bp]
  7745                              <2> 	div		cx
  7746                              <2> 	mov		[bp], ax
  7747                              <2> 	ret
  7748                              <2> %endif
  7749                              <2> 
  7750                              <2> 
  7751                              <2> ;--------------------------------------------------------------------
  7752                              <2> ; Math_DivDXAXbyCX
  7753                              <2> ;	Parameters:
  7754                              <2> ;		DX:AX:	32-bit unsigned divident
  7755                              <2> ;		CX:		16-bit unsigned divisor
  7756                              <2> ;	Returns:
  7757                              <2> ;		DX:AX:	32-bit unsigned quotient
  7758                              <2> ;		BX:		16-bit unsigned remainder
  7759                              <2> ;	Corrupts registers:
  7760                              <2> ;		Nothing
  7761                              <2> ;--------------------------------------------------------------------
  7762                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  7763                              <2> ALIGN JUMP_ALIGN
  7764                              <2> Math_DivDXAXbyCX:
  7765 000002EC 31DB                <2> 	xor		bx, bx
  7766 000002EE 93                  <2> 	xchg	bx, ax
  7767 000002EF 92                  <2> 	xchg	dx, ax
  7768 000002F0 F7F1                <2> 	div		cx
  7769 000002F2 93                  <2> 	xchg	ax, bx
  7770 000002F3 F7F1                <2> 	div		cx
  7771 000002F5 87D3                <2> 	xchg	dx, bx
  7772 000002F7 C3                  <2> 	ret
  7773                              <2> %endif
  7774                              <1> 	%include "Registers.asm"
  7775                              <2> ; Project name	:	Assembly Library
  7776                              <2> ; Description	:	Functions for register operations.
  7777                              <2> 
  7778                              <2> ;
  7779                              <2> ; XTIDE Universal BIOS and Associated Tools
  7780                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  7781                              <2> ;
  7782                              <2> ; This program is free software; you can redistribute it and/or modify
  7783                              <2> ; it under the terms of the GNU General Public License as published by
  7784                              <2> ; the Free Software Foundation; either version 2 of the License, or
  7785                              <2> ; (at your option) any later version.
  7786                              <2> ;
  7787                              <2> ; This program is distributed in the hope that it will be useful,
  7788                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7789                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7790                              <2> ; GNU General Public License for more details.
  7791                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  7792                              <2> ;
  7793                              <2> 
  7794                              <2> ; Section containing code
  7795                              <2> SECTION .text
  7796                              <2> 
  7797                              <2> ;--------------------------------------------------------------------
  7798                              <2> ; Registers_ExchangeDSSIwithESDI
  7799                              <2> ;	Parameters
  7800                              <2> ;		Nothing
  7801                              <2> ;	Returns:
  7802                              <2> ;		DS:SI and ES:DI are exchanged.
  7803                              <2> ;	Corrupts registers:
  7804                              <2> ;		Nothing
  7805                              <2> ;--------------------------------------------------------------------
  7806                              <2> ALIGN JUMP_ALIGN
  7807                              <2> Registers_ExchangeDSSIwithESDI:
  7808 000002F8 1E                  <2> 	push	ds
  7809 000002F9 06                  <2> 	push	es
  7810 000002FA 1F                  <2> 	pop		ds
  7811 000002FB 07                  <2> 	pop		es
  7812 000002FC 87F7                <2> 	xchg	si, di
  7813 000002FE C3                  <2> 	ret
  7814                              <2> 
  7815                              <2> 
  7816                              <2> ;--------------------------------------------------------------------
  7817                              <2> ; Registers_CopySSBPtoESDI
  7818                              <2> ; Registers_CopySSBPtoDSSI
  7819                              <2> ; Registers_CopyDSSItoESDI
  7820                              <2> ; Registers_CopyESDItoDSSI
  7821                              <2> ;	Parameters
  7822                              <2> ;		Nothing
  7823                              <2> ;	Returns:
  7824                              <2> ;		Copies farm pointer to different segment/pointer register pair
  7825                              <2> ;	Corrupts registers:
  7826                              <2> ;		Nothing
  7827                              <2> ;--------------------------------------------------------------------
  7828                              <2> %ifdef INCLUDE_MENU_LIBRARY
  7829                              <2> ALIGN JUMP_ALIGN
  7830                              <2> Registers_CopySSBPtoESDI:
  7831                              <2> 	COPY_SSBP_TO_ESDI
  7832                              <2> 	ret
  7833                              <2> %endif
  7834                              <2> 
  7835                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7836                              <2> ALIGN JUMP_ALIGN
  7837                              <2> Registers_CopySSBPtoDSSI:
  7838                              <2> 	COPY_SSBP_TO_DSSI
  7839                              <2> 	ret
  7840                              <2> 
  7841                              <2> ALIGN JUMP_ALIGN
  7842                              <2> Registers_CopyDSSItoESDI:
  7843                              <2> 	COPY_DSSI_TO_ESDI
  7844                              <2> 	ret
  7845                              <2> 
  7846                              <2> ALIGN JUMP_ALIGN
  7847                              <2> Registers_CopyESDItoDSSI:
  7848                              <2> 	COPY_ESDI_to_DSSI
  7849                              <2> 	ret
  7850                              <2> %endif
  7851                              <2> 
  7852                              <2> 
  7853                              <2> ;--------------------------------------------------------------------
  7854                              <2> ; Registers_NormalizeESSI
  7855                              <2> ; Registers_NormalizeESDI
  7856                              <2> ;	Parameters
  7857                              <2> ;		DS:SI or ES:DI:	Ptr to normalize
  7858                              <2> ;	Returns:
  7859                              <2> ;		DS:SI or ES:DI:	Normalized pointer
  7860                              <2> ;	Corrupts registers:
  7861                              <2> ;		AX, CX
  7862                              <2> ;
  7863                              <2> ; Inline of NORMALIZE_FAR_POINTER so that we can share the last 2/3 of the
  7864                              <2> ; routine with Registers_NormalizeFinish.
  7865                              <2> ;
  7866                              <2> ;--------------------------------------------------------------------
  7867                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  7868                              <2> ALIGN JUMP_ALIGN
  7869                              <2> Registers_NormalizeESSI:
  7870                              <2> 	mov			cx, si
  7871                              <2> 	and			si, byte 0fh
  7872                              <2> 	jmp			Registers_NormalizeFinish
  7873                              <2> 
  7874                              <2> ALIGN JUMP_ALIGN
  7875                              <2> Registers_NormalizeESDI:
  7876                              <2> 	mov			cx, di
  7877                              <2> 	and			di, byte 0fh
  7878                              <2> ;;; fall-through
  7879                              <2> 
  7880                              <2> ALIGN JUMP_ALIGN
  7881                              <2> Registers_NormalizeFinish:
  7882                              <2> 	eSHR_IM		cx, 4
  7883                              <2> 	mov			ax, es
  7884                              <2> 	add			ax, cx
  7885                              <2> 	mov			es, ax
  7886                              <2> 	ret
  7887                              <2> %endif
  7888                              <2> 
  7889                              <2> 
  7890                              <2> ;--------------------------------------------------------------------
  7891                              <2> ; Registers_SetZFifNullPointerInDSSI (commented to save bytes)
  7892                              <2> ;	Parameters
  7893                              <2> ;		DS:SI:	Far pointer
  7894                              <2> ;	Returns:
  7895                              <2> ;		ZF:		Set if NULL pointer in DS:SI
  7896                              <2> ;	Corrupts registers:
  7897                              <2> ;		Nothing
  7898                              <2> ;--------------------------------------------------------------------
  7899                              <2> ;ALIGN JUMP_ALIGN
  7900                              <2> ;Registers_SetZFifNullPointerInDSSI:
  7901                              <2> ;	push	ax
  7902                              <2> ;	mov		ax, ds
  7903                              <2> ;	or		ax, si
  7904                              <2> ;	pop		ax
  7905                              <2> ;	ret
  7906                              <1> 	%include "Reboot.asm"
  7907                              <2> ; Project name	:	Assembly Library
  7908                              <2> ; Description	:	Functions for rebooting computer.
  7909                              <2> 
  7910                              <2> ;
  7911                              <2> ; XTIDE Universal BIOS and Associated Tools
  7912                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  7913                              <2> ;
  7914                              <2> ; This program is free software; you can redistribute it and/or modify
  7915                              <2> ; it under the terms of the GNU General Public License as published by
  7916                              <2> ; the Free Software Foundation; either version 2 of the License, or
  7917                              <2> ; (at your option) any later version.
  7918                              <2> ;
  7919                              <2> ; This program is distributed in the hope that it will be useful,
  7920                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7921                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7922                              <2> ; GNU General Public License for more details.
  7923                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  7924                              <2> ;
  7925                              <2> 
  7926                              <2> ; Section containing code
  7927                              <2> SECTION .text
  7928                              <2> 
  7929                              <2> ;--------------------------------------------------------------------
  7930                              <2> ; Reboot_ComputerWithBootFlagInAX
  7931                              <2> ;	Parameters:
  7932                              <2> ; 		AX:		Boot Flag
  7933                              <2> ;	Returns:
  7934                              <2> ;		Nothing, function never returns
  7935                              <2> ;--------------------------------------------------------------------
  7936                              <2> Reboot_ComputerWithBootFlagInAX:
  7937                              <2> 	LOAD_BDA_SEGMENT_TO	ds, bx
  7938                              <3> %ifndef USE_186
  7939 000002FF 31DB                <3>  xor %2, %2
  7940 00000301 8EDB                <3>  mov %1, %2
  7941                              <3> %elifidn %3, !
  7942                              <3>  xor %2, %2
  7943                              <3>  mov %1, %2
  7944                              <3> %else
  7945                              <3>  push BYTE 0
  7946                              <3>  pop %1
  7947                              <3> %endif
  7948 00000303 A37204              <2> 	mov		[BDA.wBoot], ax			; Store boot flag
  7949                              <2> 	; Fall to Reboot_AT
  7950                              <2> 
  7951                              <2> 
  7952                              <2> ;--------------------------------------------------------------------
  7953                              <2> ; Reboot_AT
  7954                              <2> ;	Parameters:
  7955                              <2> ; 		Nothing
  7956                              <2> ;	Returns:
  7957                              <2> ;		Nothing, function never returns
  7958                              <2> ;--------------------------------------------------------------------
  7959                              <2> Reboot_AT:
  7960 00000306 B0FE                <2> 	mov		al, 0FEh				; System reset (AT+ keyboard controller)
  7961 00000308 E664                <2> 	out		64h, al					; Reset computer (AT+)
  7962                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7963                              <2> 	%ifdef INCLUDE_TIME_LIBRARY
  7964                              <2> 		mov		ax, 10
  7965                              <2> 		call	Delay_MicrosecondsFromAX
  7966                              <2> 	%else
  7967                              <2> 		JMP_DELAY
  7968                              <2> 	%endif
  7969                              <2> %else
  7970                              <2> 	JMP_DELAY
  7971 0000030A EB00                <3>  jmp SHORT %%NextInstruction
  7972                              <3> %%NextInstruction:
  7973                              <2> %endif
  7974                              <2> 	; Fall to Reboot_XT
  7975                              <2> 
  7976                              <2> 
  7977                              <2> ;--------------------------------------------------------------------
  7978                              <2> ; Reboot_XT
  7979                              <2> ;	Parameters:
  7980                              <2> ; 		Nothing
  7981                              <2> ;	Returns:
  7982                              <2> ;		Nothing, function never returns
  7983                              <2> ;--------------------------------------------------------------------
  7984                              <2> Reboot_XT:
  7985 0000030C 31C0                <2> 	xor		ax, ax
  7986 0000030E 50                  <2> 	push	ax
  7987 0000030F 9D                  <2> 	popf							; Clear FLAGS (disables interrupt)
  7988 00000310 8ED8                <2> 	mov		ds, ax
  7989 00000312 8EC0                <2> 	mov		es, ax
  7990 00000314 8ED0                <2> 	mov		ss, ax
  7991 00000316 EA0000FFFF          <2> 	jmp		0FFFFh:0				; XT reset
  7992                              <1> 	%include "Memory.asm"
  7993                              <2> ; Project name	:	Assembly Library
  7994                              <2> ; Description	:	Functions for memory access.
  7995                              <2> 
  7996                              <2> ;
  7997                              <2> ; XTIDE Universal BIOS and Associated Tools
  7998                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  7999                              <2> ;
  8000                              <2> ; This program is free software; you can redistribute it and/or modify
  8001                              <2> ; it under the terms of the GNU General Public License as published by
  8002                              <2> ; the Free Software Foundation; either version 2 of the License, or
  8003                              <2> ; (at your option) any later version.
  8004                              <2> ;
  8005                              <2> ; This program is distributed in the hope that it will be useful,
  8006                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8007                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8008                              <2> ; GNU General Public License for more details.
  8009                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  8010                              <2> ;
  8011                              <2> 
  8012                              <2> ; Section containing code
  8013                              <2> SECTION .text
  8014                              <2> 
  8015                              <2> ;--------------------------------------------------------------------
  8016                              <2> ; OPTIMIZE_STRING_OPERATION
  8017                              <2> ;	Parameters
  8018                              <2> ;		%1:		Repeat instruction
  8019                              <2> ;		%2:		String instruction without size (for example MOVS and not MOVSB or MOVSW)
  8020                              <2> ;		CX:		Number of BYTEs to operate
  8021                              <2> ;		DS:SI:	Ptr to source data
  8022                              <2> ;		ES:DI:	Ptr to destination
  8023                              <2> ;	Returns:
  8024                              <2> ;		SI, DI:	Updated by number of bytes operated
  8025                              <2> ;	Corrupts registers:
  8026                              <2> ;		Nothing
  8027                              <2> ;--------------------------------------------------------------------
  8028                              <2> %macro OPTIMIZE_STRING_OPERATION 2
  8029                              <2> 	push	cx
  8030                              <2> 
  8031                              <2> 	shr		cx, 1			; Operate with WORDs for performance
  8032                              <2> 	jz	%%HandleRemainingByte
  8033                              <2> 	%1		%2w
  8034                              <2> %%HandleRemainingByte:
  8035                              <2> 	jnc		SHORT %%OperationCompleted
  8036                              <2> 	%2b
  8037                              <2> 
  8038                              <2> ALIGN JUMP_ALIGN
  8039                              <2> %%OperationCompleted:
  8040                              <2> 	pop		cx
  8041                              <2> %endmacro
  8042                              <2> 
  8043                              <2> 
  8044                              <2> ;--------------------------------------------------------------------
  8045                              <2> ; Memory_CopyCXbytesFromDSSItoESDI
  8046                              <2> ;	Parameters
  8047                              <2> ;		CX:		Number of bytes to copy
  8048                              <2> ;		DS:SI:	Ptr to source data
  8049                              <2> ;		ES:DI:	Ptr to destination buffer
  8050                              <2> ;	Returns:
  8051                              <2> ;		SI, DI:	Updated by number of bytes copied
  8052                              <2> ;	Corrupts registers:
  8053                              <2> ;		Nothing
  8054                              <2> ;--------------------------------------------------------------------
  8055                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8056                              <2> ALIGN JUMP_ALIGN
  8057                              <2> Memory_CopyCXbytesFromDSSItoESDI:
  8058                              <2> 	OPTIMIZE_STRING_OPERATION rep, movs
  8059                              <2> 	ret
  8060                              <2> %endif
  8061                              <2> 
  8062                              <2> 
  8063                              <2> ;--------------------------------------------------------------------
  8064                              <2> ; Memory_ZeroSSBPwithSizeInCX
  8065                              <2> ;	Parameters
  8066                              <2> ;		CX:		Number of bytes to zero
  8067                              <2> ;		SS:BP:	Ptr to buffer to zero
  8068                              <2> ;	Returns:
  8069                              <2> ;		Nothing
  8070                              <2> ;	Corrupts registers:
  8071                              <2> ;		Nothing
  8072                              <2> ;--------------------------------------------------------------------
  8073                              <2> %ifdef INCLUDE_MENU_LIBRARY
  8074                              <2> ALIGN JUMP_ALIGN
  8075                              <2> Memory_ZeroSSBPwithSizeInCX:
  8076                              <2> 	push	es
  8077                              <2> 	push	di
  8078                              <2> 	push	ax
  8079                              <2> 	call	Registers_CopySSBPtoESDI
  8080                              <2> 	call	Memory_ZeroESDIwithSizeInCX
  8081                              <2> 	pop		ax
  8082                              <2> 	pop		di
  8083                              <2> 	pop		es
  8084                              <2> 	ret
  8085                              <2> %endif
  8086                              <2> 
  8087                              <2> 
  8088                              <2> ;--------------------------------------------------------------------
  8089                              <2> ; Memory_ZeroESDIwithSizeInCX
  8090                              <2> ;	Parameters
  8091                              <2> ;		CX:		Number of bytes to zero
  8092                              <2> ;		ES:DI:	Ptr to destination buffer
  8093                              <2> ;	Returns:
  8094                              <2> ;		DI:		Updated by number of BYTEs stored
  8095                              <2> ;	Corrupts registers:
  8096                              <2> ;		AX
  8097                              <2> ;--------------------------------------------------------------------
  8098                              <2> ALIGN JUMP_ALIGN
  8099                              <2> Memory_ZeroESDIwithSizeInCX:
  8100 0000031B 31C0                <2> 	xor		ax, ax
  8101                              <2> 	; Fall to Memory_StoreCXbytesFromAccumToESDI
  8102                              <2> 
  8103                              <2> ;--------------------------------------------------------------------
  8104                              <2> ; Memory_StoreCXbytesFromAccumToESDI
  8105                              <2> ;	Parameters
  8106                              <2> ;		AX:		Word to use to fill buffer
  8107                              <2> ;		CX:		Number of BYTEs to store
  8108                              <2> ;		ES:DI:	Ptr to destination buffer
  8109                              <2> ;	Returns:
  8110                              <2> ;		DI:		Updated by number of BYTEs stored
  8111                              <2> ;	Corrupts registers:
  8112                              <2> ;		Nothing
  8113                              <2> ;--------------------------------------------------------------------
  8114                              <2> ALIGN JUMP_ALIGN
  8115                              <2> Memory_StoreCXbytesFromAccumToESDI:
  8116                              <2> 	OPTIMIZE_STRING_OPERATION rep, stos
  8117 0000031D 51                  <3>  push cx
  8118                              <3> 
  8119 0000031E D1E9                <3>  shr cx, 1
  8120 00000320 7402                <3>  jz %%HandleRemainingByte
  8121 00000322 F3AB                <3>  %1 %2w
  8122                              <3> %%HandleRemainingByte:
  8123 00000324 7301                <3>  jnc SHORT %%OperationCompleted
  8124 00000326 AA                  <3>  %2b
  8125                              <3> 
  8126                              <3> ALIGN JUMP_ALIGN
  8127                              <3> %%OperationCompleted:
  8128 00000327 59                  <3>  pop cx
  8129 00000328 C3                  <2> 	ret
  8130                              <2> 
  8131                              <2> 
  8132                              <2> ;--------------------------------------------------------------------
  8133                              <2> ; Memory_ReserveCXbytesFromStackToDSSI
  8134                              <2> ;	Parameters
  8135                              <2> ;		CX:		Number of bytes to reserve
  8136                              <2> ;	Returns:
  8137                              <2> ;		DS:SI:	Ptr to reserved buffer
  8138                              <2> ;	Corrupts registers:
  8139                              <2> ;		AX
  8140                              <2> ;--------------------------------------------------------------------
  8141                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8142                              <2> ALIGN JUMP_ALIGN
  8143                              <2> Memory_ReserveCXbytesFromStackToDSSI:
  8144                              <2> 	pop		ax
  8145                              <2> 	push	ss
  8146                              <2> 	pop		ds
  8147                              <2> 	sub		sp, cx
  8148                              <2> 	mov		si, sp
  8149                              <2> 	jmp		ax
  8150                              <2> %endif
  8151                              <2> 
  8152                              <2> 
  8153                              <2> ;--------------------------------------------------------------------
  8154                              <2> ; Memory_SumCXbytesFromESSItoAL
  8155                              <2> ;	Parameters
  8156                              <2> ;		CX:		Number of bytes to sum (0=65536)
  8157                              <2> ;		ES:SI:	Ptr to buffer containing the bytes to sum
  8158                              <2> ;	Returns:
  8159                              <2> ;		AL:		Sum of bytes
  8160                              <2> ;		ZF:		Set if result is zero
  8161                              <2> ;				Cleared if result is non-zero
  8162                              <2> ;	Corrupts registers:
  8163                              <2> ;		CX
  8164                              <2> ;--------------------------------------------------------------------
  8165                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  8166                              <2> ALIGN JUMP_ALIGN
  8167                              <2> Memory_SumCXbytesFromESSItoAL:
  8168 00000329 56                  <2> 	push	si
  8169 0000032A 4E                  <2> 	dec		si
  8170 0000032B 30C0                <2> 	xor		al, al
  8171                              <2> ALIGN JUMP_ALIGN
  8172                              <2> .AddNextByteToAL:
  8173 0000032D 46                  <2> 	inc		si
  8174 0000032E 260204              <2> 	add		al, [es:si]
  8175 00000331 E2FA                <2> 	loop	.AddNextByteToAL
  8176 00000333 5E                  <2> 	pop		si
  8177 00000334 C3                  <2> 	ret
  8178                              <2> %endif
  8179                              <1> 	%include "Size.asm"
  8180                              <2> ; Project name	:	Assembly Library
  8181                              <2> ; Description	:	Functions for size calculations.
  8182                              <2> 
  8183                              <2> ;
  8184                              <2> ; XTIDE Universal BIOS and Associated Tools
  8185                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  8186                              <2> ;
  8187                              <2> ; This program is free software; you can redistribute it and/or modify
  8188                              <2> ; it under the terms of the GNU General Public License as published by
  8189                              <2> ; the Free Software Foundation; either version 2 of the License, or
  8190                              <2> ; (at your option) any later version.
  8191                              <2> ;
  8192                              <2> ; This program is distributed in the hope that it will be useful,
  8193                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8194                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8195                              <2> ; GNU General Public License for more details.
  8196                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  8197                              <2> ;
  8198                              <2> 
  8199                              <2> %ifdef INCLUDE_MENU_LIBRARY
  8200                              <2> struc BYTE_MULTIPLES
  8201                              <2> 	.B			resb	1
  8202                              <2> 	.kiB		resb	1
  8203                              <2> 	.MiB		resb	1
  8204                              <2> 	.GiB		resb	1
  8205                              <2> 	.TiB		resb	1
  8206                              <2> endstruc
  8207                              <2> 
  8208                              <2> ; Section containing code
  8209                              <2> SECTION .text
  8210                              <2> 
  8211                              <2> ;--------------------------------------------------------------------
  8212                              <2> ; Size_GetSizeToAXAndCharToDLfromBXDXAXwithMagnitudeInCX
  8213                              <2> ;	Parameters:
  8214                              <2> ;		BX:DX:AX:	Size in magnitude
  8215                              <2> ;		CX:			Magnitude in BYTE_MULTIPLES
  8216                              <2> ;	Returns:
  8217                              <2> ;		AX:			Size in magnitude
  8218                              <2> ;		CX:			Tenths
  8219                              <2> ;		DL:			Magnitude character:
  8220                              <2> ;						'k' = *1024   B = kiB
  8221                              <2> ;						'M' = *1024 kiB = MiB
  8222                              <2> ;						'G' = *1024 MiB = GiB
  8223                              <2> ;						'T' = *1024 GiB = TiB
  8224                              <2> ;						'P' = *1024 TiB = PiB
  8225                              <2> ;	Corrupts registers:
  8226                              <2> ;		BX, DH
  8227                              <2> ;--------------------------------------------------------------------
  8228                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8229                              <2> Size_GetSizeToAXAndCharToDLfromBXDXAXwithMagnitudeInCX:
  8230                              <2> %ifndef USE_186		; If 8086/8088
  8231                              <2> 	push	di
  8232                              <2> %endif
  8233                              <2> 	push	si
  8234                              <2> 
  8235                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8236                              <2> .MagnitudeConversionLoop:
  8237                              <2> 	ePUSH_T	di, .MagnitudeConversionLoop; DI corrupted only on 8086/8088 build
  8238                              <2> 	test	bx, bx						; Bits 32...47 in use?
  8239                              <2> 	jnz		SHORT Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
  8240                              <2> 	test	dx, dx						; Bits 16...31 in use?
  8241                              <2> 	jnz		SHORT Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
  8242                              <2> 	cmp		ax, 10000					; 5 digits needed?
  8243                              <2> 	jae		SHORT Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
  8244                              <2> 	add		sp, BYTE 2					; Clean return address from stack
  8245                              <2> 	xchg	si, cx						; CX = Remainder (0...1023), SI = Magnitude
  8246                              <2> 
  8247                              <2> 	; Convert remainder to tenths
  8248                              <2> 	xchg	bx, ax						; Store AX
  8249                              <2> 	mov		ax, 5
  8250                              <2> 	mul		cx							; DX:AX = remainder * (10 / 2)
  8251                              <2> %ifdef USE_186
  8252                              <2> 	shr		ax, 9						; Divide AX by (1024 / 2)
  8253                              <2> %else
  8254                              <2> 	shr		ax, 1
  8255                              <2> 	mov		al, ah
  8256                              <2> 	cbw
  8257                              <2> %endif
  8258                              <2> 	xchg	cx, ax						; CX = tenths
  8259                              <2> 	xchg	ax, bx
  8260                              <2> 
  8261                              <2> 	; Convert magnitude to character
  8262                              <2> 	mov		dl, [cs:si+.rgbMagnitudeToChar]
  8263                              <2> 
  8264                              <2> 	pop		si
  8265                              <2> %ifndef USE_186
  8266                              <2> 	pop		di
  8267                              <2> %endif
  8268                              <2> 	ret
  8269                              <2> .rgbMagnitudeToChar:	db	" kMGTP"
  8270                              <2> %endif
  8271                              <2> 
  8272                              <2> ;--------------------------------------------------------------------
  8273                              <2> ; Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
  8274                              <2> ;	Parameters:
  8275                              <2> ;		BX:DX:AX:	Size
  8276                              <2> ;		CX:			Magnitude in BYTE_MULTIPLES
  8277                              <2> ;	Returns:
  8278                              <2> ;		BX:DX:AX:	Size in magnitude
  8279                              <2> ;		SI:			Remainder (0...1023)
  8280                              <2> ;		CX:			Magnitude in BYTE_MULTIPLES
  8281                              <2> ;	Corrupts registers:
  8282                              <2> ;		Nothing
  8283                              <2> ;--------------------------------------------------------------------
  8284                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8285                              <2> Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX:
  8286 00000335 51                  <2> 	push	cx
  8287 00000336 31F6                <2> 	xor		si, si					; Zero remainder
  8288 00000338 B10A                <2> 	mov		cl, 10					; Divide by 1024
  8289                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8290                              <2> .ShiftLoop:
  8291 0000033A E80D00              <2> 	call	Size_DivideBXDXAXbyTwo
  8292 0000033D D1DE                <2> 	rcr		si, 1					; Update remainder
  8293 0000033F E2F9                <2> 	loop	.ShiftLoop
  8294                              <2> 	eSHR_IM	si, 6					; Remainder to SI beginning
  8295                              <3>  eSHIFT_IM %1, %2, shr
  8296                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  8297                              <4> %ifndef USE_186
  8298                              <4>  %ifidni %1, cl
  8299                              <4>  times %2 %3 %1, 1
  8300                              <4>  %elifidni %1, ch
  8301                              <4>  times %2 %3 %1, 1
  8302                              <4>  %elifidni %1, cx
  8303                              <4>  times %2 %3 %1, 1
  8304                              <4>  %else
  8305                              <4>  %if %2 > 3
  8306 00000341 51                  <4>  push cx
  8307 00000342 B106                <4>  mov cl, %2
  8308 00000344 D3EE                <4>  %3 %1, cl
  8309 00000346 59                  <4>  pop cx
  8310                              <4>  %else
  8311                              <4>  times %2 %3 %1, 1
  8312                              <4>  %endif
  8313                              <4>  %endif
  8314                              <4> 
  8315                              <4> %else
  8316                              <4>  %3 %1, %2
  8317                              <4> %endif
  8318                              <4> %endif
  8319 00000347 59                  <2> 	pop		cx
  8320 00000348 41                  <2> 	inc		cx						; Increment magnitude
  8321 00000349 C3                  <2> 	ret
  8322                              <2> 
  8323                              <2> ;--------------------------------------------------------------------
  8324                              <2> ; Size_ConvertSectorCountInBXDXAXtoKiB
  8325                              <2> ; Size_DivideBXDXAXbyTwo
  8326                              <2> ;	Parameters:
  8327                              <2> ;		BX:DX:AX:	Total sector count
  8328                              <2> ;	Returns:
  8329                              <2> ;		BX:DX:AX:	Total size in kiB
  8330                              <2> ;		CF:			Remainder from division
  8331                              <2> ;	Corrupts registers:
  8332                              <2> ;		Nothing
  8333                              <2> ;--------------------------------------------------------------------
  8334                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8335                              <2> Size_ConvertSectorCountInBXDXAXtoKiB:	; unused entrypoint ok
  8336                              <2> Size_DivideBXDXAXbyTwo:
  8337 0000034A D1EB                <2> 	shr		bx, 1					; Divide sector count by 2...
  8338 0000034C D1DA                <2> 	rcr		dx, 1					; ...to get disk size in...
  8339 0000034E D1D8                <2> 	rcr		ax, 1					; ...kiB
  8340 00000350 C3                  <2> 	ret
  8341                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8342                              <1> 		%include "Sort.asm"
  8343                              <1> 	%endif
  8344                              <1> %endif
  8345                              <1> 
  8346                                  
  8347                                  	; String compression tables need to come after the AssemblyLibrary (since they depend on addresses
  8348                                  	; established in the assembly library), and are unnecessary if strings are not compressed.
  8349                                  	;
  8350                                  %ifdef MODULE_STRINGS_COMPRESSED
  8351                                  	%undef  STRINGSCOMPRESSED_STRINGS
  8352                                  	%define STRINGSCOMPRESSED_TABLES
  8353                                  	%include "StringsCompressed.asm"
  8354                              <1> ;;;======================================================================
  8355                              <1> ;;;
  8356                              <1> ;;; This file is generated by StringsCompress.pl from source in Strings.asm
  8357                              <1> ;;; DO NOT EDIT DIRECTLY - See the makefile for how to rebuild this file.
  8358                              <1> ;;; This file only needs to be rebuilt if Strings.asm is changed.
  8359                              <1> ;;;
  8360                              <1> ;;;======================================================================
  8361                              <1> 
  8362                              <1> %ifdef STRINGSCOMPRESSED_STRINGS
  8363                              <1> 
  8364                              <1> ; Project name	:	XTIDE Universal BIOS
  8365                              <1> ; Description	:	Strings and equates for BIOS messages.
  8366                              <1> 
  8367                              <1> ;
  8368                              <1> ; XTIDE Universal BIOS and Associated Tools
  8369                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  8370                              <1> ;
  8371                              <1> ; This program is free software; you can redistribute it and/or modify
  8372                              <1> ; it under the terms of the GNU General Public License as published by
  8373                              <1> ; the Free Software Foundation; either version 2 of the License, or
  8374                              <1> ; (at your option) any later version.
  8375                              <1> ;
  8376                              <1> ; This program is distributed in the hope that it will be useful,
  8377                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8378                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8379                              <1> ; GNU General Public License for more details.
  8380                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  8381                              <1> ;
  8382                              <1> 
  8383                              <1> %ifdef MODULE_STRINGS_COMPRESSED_PRECOMPRESS
  8384                              <1> %include "Display.inc"
  8385                              <1> %endif
  8386                              <1> 
  8387                              <1> ; Section containing code
  8388                              <1> SECTION .text
  8389                              <1> 
  8390                              <1> ; The following strings are used by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
  8391                              <1> ; To support an optimization in that code, these strings must start on the same 256 byte page,
  8392                              <1> ; which is checked at assembly time below.
  8393                              <1> ;
  8394                              <1> g_szDetectStart:
  8395                              <1> g_szDetectMaster:		; db	"Master",NULL
  8396                              <1>                  		; db	 4dh,  61h,  73h,  74h,  65h,  72h,  00h    ; uncompressed
  8397                              <1>                  		  db	 53h,  67h,  79h,  7ah,  6bh, 0b8h          ; compressed
  8398                              <1> 
  8399                              <1> g_szDetectSlave:		; db	"Slave ",NULL
  8400                              <1>                 		; db	 53h,  6ch,  61h,  76h,  65h,  20h,  00h    ; uncompressed
  8401                              <1>                 		  db	 59h,  72h,  67h,  7ch,  6bh,  00h          ; compressed
  8402                              <1> 
  8403                              <1> g_szDetectOuter:		; db	"%s at %s: ",NULL
  8404                              <1>                 		; db	 25h,  73h,  20h,  61h,  74h,  20h,  25h,  73h,  3ah,  20h,  00h    ; uncompressed
  8405                              <1>                 		  db	 3dh,  20h,  67h, 0fah,  3dh,  40h,  00h                            ; compressed
  8406                              <1> 
  8407                              <1> %ifdef MODULE_SERIAL
  8408                              <1> g_szDetectCOM:			; db	"COM%c%s",NULL
  8409                              <1>               			; db	 43h,  4fh,  4dh,  25h,  63h,  25h,  73h,  00h    ; uncompressed
  8410                              <1>               			  db	 49h,  55h,  53h,  3ch,  1dh                      ; compressed
  8411                              <1> 
  8412                              <1> g_szDetectCOMAuto:		; db	" Detect",NULL
  8413                              <1>                   		; db	 20h,  44h,  65h,  74h,  65h,  63h,  74h,  00h    ; uncompressed
  8414                              <1>                   		  db	 20h,  4ah,  6bh,  7ah,  6bh,  69h, 0bah          ; compressed
  8415                              <1> 
  8416                              <1> g_szDetectCOMSmall:		; db	"/%u%u00",NULL					; IDE Master at COM1/9600:
  8417                              <1>                    		; db	 2fh,  25h,  75h,  25h,  75h,  30h,  30h,  00h    ; uncompressed
  8418                              <1>                    		  db	 2ah,  35h,  35h,  33h,  13h                      ; compressed
  8419                              <1> 
  8420                              <1> g_szDetectCOMLarge:		; db	"/%u.%uK",NULL					; IDE Master at COM1/19.2K:
  8421                              <1>                    		; db	 2fh,  25h,  75h,  2eh,  25h,  75h,  4bh,  00h    ; uncompressed
  8422                              <1>                    		  db	 2ah,  35h,  29h,  35h,  91h                      ; compressed
  8423                              <1> 
  8424                              <1> %endif
  8425                              <1> g_szDetectEnd:
  8426                              <1> g_szDetectPort:			; db	"%x",NULL						; IDE Master at 1F0h:
  8427                              <1>                			; db	 25h,  78h,  00h    ; uncompressed
  8428                              <1>                			  db	 17h                ; compressed
  8429                              <1> 
  8430                              <1> 
  8431                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  8432                              <1> %if ((g_szDetectEnd-$$) & 0xff00) <> ((g_szDetectStart-$$) & 0xff00)
  8433                              <1> %error "g_szDetect* strings must start on the same 256 byte page, required by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP.  Please move this block up or down within Strings.asm"
  8434                              <1> %endif
  8435                              <1> %endif
  8436                              <1> 
  8437                              <1> 
  8438                              <1> ; POST drive detection strings
  8439                              <1> g_szDashForZero:	; db	"- ",NULL	; Required by Display Library
  8440                              <1>                 	; db	 2dh,  20h,  00h    ; uncompressed
  8441                              <1>                 	  db	 28h,  00h          ; compressed
  8442                              <1> 
  8443                              <1> g_szRomAt:			; db	LF,CR
  8444                              <1>           			; db	 0ah,  0dh    ; uncompressed
  8445                              <1>           			  db	 39h          ; compressed
  8446                              <1> 
  8447                              <1> 	; db	"%s @ %x",LF,CR						; -=XTIDE ... =- @ Segment
  8448                              <1> 	; db	 25h,  73h,  20h,  40h,  20h,  25h,  78h,  0ah,  0dh    ; uncompressed
  8449                              <1> 	  db	 3dh,  20h, 0c6h,  37h,  39h                            ; compressed
  8450                              <1> 
  8451                              <1> 	; db	"%s",LF,CR							; version string
  8452                              <1> 	; db	 25h,  73h,  0ah,  0dh    ; uncompressed
  8453                              <1> 	  db	 3dh,  39h                ; compressed
  8454                              <1> 
  8455                              <1> 	; db	"Released under GNU GPL v2",LF,CR
  8456                              <1> 	; db	 52h,  65h,  6ch,  65h,  61h,  73h,  65h,  64h,  20h,  75h,  6eh,  64h,  65h,  72h,  20h,  47h,  4eh,  55h,  20h,  47h,  50h,  4ch,  20h,  76h,  32h,  0ah,  0dh    ; uncompressed
  8457                              <1> 	  db	 58h,  6bh,  72h,  6bh,  67h,  79h,  6bh, 0eah,  7bh,  74h,  6ah,  6bh, 0f8h,  4dh,  54h, 0dbh,  4dh,  56h, 0d2h,  7ch,  2ch,  39h                                  ; compressed
  8458                              <1> 
  8459                              <1> 	; db	LF,CR,NULL
  8460                              <1> 	; db	 0ah,  0dh,  00h    ; uncompressed
  8461                              <1> 	  db	 19h                ; compressed
  8462                              <1> 
  8463                              <1> %ifdef MODULE_BOOT_MENU
  8464                              <1> g_szBootMenuTitle:	; db	"%s%c",LF,CR						; -=XTIDE ... =- and null (eaten)
  8465                              <1>                   	; db	 25h,  73h,  25h,  63h,  0ah,  0dh    ; uncompressed
  8466                              <1>                   	  db	 3dh,  3ch,  39h                      ; compressed
  8467                              <1> 
  8468                              <1> 	; db	"%s",NULL							; version string
  8469                              <1> 	; db	 25h,  73h,  00h    ; uncompressed
  8470                              <1> 	  db	 1dh                ; compressed
  8471                              <1> 
  8472                              <1> %endif
  8473                              <1> g_szDriveName:		; db	"%z",LF,CR,NULL
  8474                              <1>               		; db	 25h,  7ah,  0ah,  0dh,  00h    ; uncompressed
  8475                              <1>               		  db	 3eh,  19h                      ; compressed
  8476                              <1> 
  8477                              <1> 
  8478                              <1> 
  8479                              <1> ; Boot loader strings
  8480                              <1> g_szTryToBoot:			; db	"Booting %c",ANGLE_QUOTE_RIGHT,"%c",LF,CR,NULL
  8481                              <1>               			; db	 42h,  6fh,  6fh,  74h,  69h,  6eh,  67h,  20h,  25h,  63h, 0afh,  25h,  63h,  0ah,  0dh,  00h    ; uncompressed
  8482                              <1>               			  db	 48h,  75h,  75h,  7ah,  6fh,  74h, 0edh,  3ch,  24h,  3ch,  19h                                  ; compressed
  8483                              <1> 
  8484                              <1> g_szBootSectorNotFound:	; db	"Boot sector " 			; String fall through...
  8485                              <1>                        	; db	 42h,  6fh,  6fh,  74h,  20h,  73h,  65h,  63h,  74h,  6fh,  72h,  20h    ; uncompressed
  8486                              <1>                        	  db	 48h,  75h,  75h, 0fah,  79h,  6bh,  69h,  7ah,  75h, 0f8h                ; compressed
  8487                              <1> 
  8488                              <1> g_szNotFound:			; db	"not found",LF,CR,NULL
  8489                              <1>              			; db	 6eh,  6fh,  74h,  20h,  66h,  6fh,  75h,  6eh,  64h,  0ah,  0dh,  00h    ; uncompressed
  8490                              <1>              			  db	 74h,  75h, 0fah,  6ch,  75h,  7bh,  74h,  6ah,  19h                      ; compressed
  8491                              <1> 
  8492                              <1> g_szReadError:			; db	"Error %x!",LF,CR,NULL
  8493                              <1>               			; db	 45h,  72h,  72h,  6fh,  72h,  20h,  25h,  78h,  21h,  0ah,  0dh,  00h    ; uncompressed
  8494                              <1>               			  db	 4bh,  78h,  78h,  75h, 0f8h,  37h,  25h,  19h                            ; compressed
  8495                              <1> 
  8496                              <1> 
  8497                              <1> 
  8498                              <1> %ifdef MODULE_HOTKEYS
  8499                              <1> ; Hotkey Bar strings
  8500                              <1> g_szFDD:				; db	"FDD [%c]",NULL			; "FDD [A]"
  8501                              <1>         				; db	 46h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
  8502                              <1>         				  db	 4ch,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
  8503                              <1> 
  8504                              <1> g_szHDD:				; db	"HDD [%c]",NULL			; "HDD [C]"
  8505                              <1>         				; db	 48h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
  8506                              <1>         				  db	 4eh,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
  8507                              <1> 
  8508                              <1> %ifdef MODULE_BOOT_MENU
  8509                              <1> g_szBootMenu:			; db	"BootMnu%c",NULL		; "BootMnu", location of %c doesn't matter
  8510                              <1>              			; db	 42h,  6fh,  6fh,  74h,  4dh,  6eh,  75h,  25h,  63h,  00h    ; uncompressed
  8511                              <1>              			  db	 48h,  75h,  75h,  7ah,  53h,  74h,  7bh,  1ch                ; compressed
  8512                              <1> 
  8513                              <1> %endif ; MODULE_BOOT_MENU
  8514                              <1> g_szHotkey:				; db	"%A%c%c%A%s%A ",NULL	; "CHDD [A] ", "F2BootMnu " or "F8RomBoot "
  8515                              <1>            				; db	 25h,  41h,  25h,  63h,  25h,  63h,  25h,  41h,  25h,  73h,  25h,  41h,  20h,  00h    ; uncompressed
  8516                              <1>            				  db	 3bh,  3ch,  3ch,  3bh,  3dh,  3bh,  00h                                              ; compressed
  8517                              <1> 
  8518                              <1> %ifdef MODULE_SERIAL
  8519                              <1> g_szHotComDetect:		; db	"ComDtct%c",NULL		; "ComDtct", location of %c doesn't matter
  8520                              <1>                  		; db	 43h,  6fh,  6dh,  44h,  74h,  63h,  74h,  25h,  63h,  00h    ; uncompressed
  8521                              <1>                  		  db	 49h,  75h,  73h,  4ah,  7ah,  69h,  7ah,  1ch                ; compressed
  8522                              <1> 
  8523                              <1> %endif ; MODULE_SERIAL
  8524                              <1> %endif ; MODULE_HOTKEYS
  8525                              <1> 
  8526                              <1> %ifdef MODULE_BOOT_MENU
  8527                              <1> g_szRomBootDash:		; db	" -  "					; String fall through to g_szRomBoot
  8528                              <1>                 		; db	 20h,  2dh,  20h,  20h    ; uncompressed
  8529                              <1>                 		  db	 20h,  28h,  20h,  20h    ; compressed
  8530                              <1> 
  8531                              <1> %endif
  8532                              <1> %ifdef MODULE_HOTKEYS OR MODULE_BOOT_MENU
  8533                              <1> g_szRomBoot:			; db	"Rom%cBoot",NULL		; "RomBoot" or "Rom Boot"
  8534                              <1>             			; db	 52h,  6fh,  6dh,  25h,  63h,  42h,  6fh,  6fh,  74h,  00h    ; uncompressed
  8535                              <1>             			  db	 58h,  75h,  73h,  3ch,  48h,  75h,  75h, 0bah                ; compressed
  8536                              <1> 
  8537                              <1> %endif
  8538                              <1> 
  8539                              <1> 
  8540                              <1> %ifdef MODULE_BOOT_MENU
  8541                              <1> ; Boot Menu Floppy Disk strings
  8542                              <1> ;
  8543                              <1> ; The following strings are used by BootMenuPrint_RefreshInformation
  8544                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
  8545                              <1> ; which is checked at assembly time below.
  8546                              <1> ;
  8547                              <1> g_szFddStart:
  8548                              <1> g_szFddUnknown:		; db	"Unknown",NULL
  8549                              <1>                		; db	 55h,  6eh,  6bh,  6eh,  6fh,  77h,  6eh,  00h    ; uncompressed
  8550                              <1>                		  db	 5bh,  74h,  71h,  74h,  75h,  7dh, 0b4h          ; compressed
  8551                              <1> 
  8552                              <1> g_szFddSizeOr:		; db	"5",ONE_QUARTER,QUOTATION_MARK," or 3",ONE_HALF,QUOTATION_MARK," DD",NULL
  8553                              <1>               		; db	 35h, 0ach,  22h,  20h,  6fh,  72h,  20h,  33h, 0abh,  22h,  20h,  44h,  44h,  00h    ; uncompressed
  8554                              <1>               		  db	 2eh,  21h,  26h,  20h,  75h, 0f8h,  2dh,  22h,  26h,  20h,  4ah,  8ah                ; compressed
  8555                              <1> 
  8556                              <1> g_szFddSize:		; db	"%s",QUOTATION_MARK,", %u kiB",NULL	; 3", 1440 kiB
  8557                              <1>             		; db	 25h,  73h,  22h,  2ch,  20h,  25h,  75h,  20h,  6bh,  69h,  42h,  00h    ; uncompressed
  8558                              <1>             		  db	 3dh,  26h,  27h,  20h,  35h,  20h,  71h,  6fh,  88h                      ; compressed
  8559                              <1> 
  8560                              <1> g_szFddThreeHalf:	; db	"3",ONE_HALF,NULL
  8561                              <1>                  	; db	 33h, 0abh,  00h    ; uncompressed
  8562                              <1>                  	  db	 2dh,  02h          ; compressed
  8563                              <1> 
  8564                              <1> g_szFddEnd:
  8565                              <1> g_szFddFiveQuarter:	; db	"5",ONE_QUARTER,NULL
  8566                              <1>                    	; db	 35h, 0ach,  00h    ; uncompressed
  8567                              <1>                    	  db	 2eh,  01h          ; compressed
  8568                              <1> 
  8569                              <1> 
  8570                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  8571                              <1> %if ((g_szFddStart-$$) & 0xff00) <> ((g_szFddEnd-$$) & 0xff00)
  8572                              <1> %error "g_szFdd* strings must start on the same 256 byte page, required by the BootMenuPrint_RefreshInformation routines for floppy drives.  Please move this block up or down within Strings.asm"
  8573                              <1> %endif
  8574                              <1> %endif
  8575                              <1> 
  8576                              <1> 
  8577                              <1> g_szAddressingModes:
  8578                              <1> g_szNORMAL:		; db	"NORMAL",NULL
  8579                              <1>            		; db	 4eh,  4fh,  52h,  4dh,  41h,  4ch,  00h    ; uncompressed
  8580                              <1>            		  db	 54h,  55h,  58h,  53h,  47h,  92h          ; compressed
  8581                              <1> 
  8582                              <1> g_szLARGE:		; db	"LARGE ",NULL
  8583                              <1>           		; db	 4ch,  41h,  52h,  47h,  45h,  20h,  00h    ; uncompressed
  8584                              <1>           		  db	 52h,  47h,  58h,  4dh,  4bh,  00h          ; compressed
  8585                              <1> 
  8586                              <1> g_szLBA:		; db	"LBA   ",NULL
  8587                              <1>         		; db	 4ch,  42h,  41h,  20h,  20h,  20h,  00h    ; uncompressed
  8588                              <1>         		  db	 52h,  48h, 0c7h,  20h,  00h                ; compressed
  8589                              <1> 
  8590                              <1> g_szAddressingModes_Displacement equ (g_szLARGE - g_szAddressingModes)
  8591                              <1> ;
  8592                              <1> ; Ensure that addressing modes are correctly spaced in memory
  8593                              <1> ;
  8594                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  8595                              <1> %if g_szNORMAL <> g_szAddressingModes
  8596                              <1> %error "g_szAddressingModes Displacement Incorrect 1"
  8597                              <1> %endif
  8598                              <1> %if g_szLARGE <> g_szNORMAL + g_szAddressingModes_Displacement
  8599                              <1> %error "g_szAddressingModes Displacement Incorrect 2"
  8600                              <1> %endif
  8601                              <1> %if g_szLBA <> g_szLARGE + g_szAddressingModes_Displacement
  8602                              <1> %error "g_szAddressingModes Displacement Incorrect 3"
  8603                              <1> %endif
  8604                              <1> %endif
  8605                              <1> 
  8606                              <1> 
  8607                              <1> g_szDeviceTypeValues:
  8608                              <1> g_szDeviceTypeValues_16bit:		; db	" 16",NULL
  8609                              <1>                            		; db	 20h,  31h,  36h,  00h    ; uncompressed
  8610                              <1>                            		  db	 20h,  2bh,  0fh          ; compressed
  8611                              <1> 
  8612                              <1> g_szDeviceTypeValues_32bit:		; db	" 32",NULL
  8613                              <1>                            		; db	 20h,  33h,  32h,  00h    ; uncompressed
  8614                              <1>                            		  db	 20h,  2dh,  0ch          ; compressed
  8615                              <1> 
  8616                              <1> g_szDeviceTypeValues_8bit:		; db	"  8",NULL
  8617                              <1>                           		; db	 20h,  20h,  38h,  00h    ; uncompressed
  8618                              <1>                           		  db	 20h,  20h,  10h          ; compressed
  8619                              <1> 
  8620                              <1> g_szDeviceTypeValues_XTIDEr1:	; db	"D8 ",NULL	; Dual 8-bit
  8621                              <1>                              	; db	 44h,  38h,  20h,  00h    ; uncompressed
  8622                              <1>                              	  db	 4ah,  30h,  00h          ; compressed
  8623                              <1> 
  8624                              <1> g_szDeviceTypeValues_XTIDEr2:	; db	"X8 ",NULL	; A0<->A3 swapped 8-bit
  8625                              <1>                              	; db	 58h,  38h,  20h,  00h    ; uncompressed
  8626                              <1>                              	  db	 5eh,  30h,  00h          ; compressed
  8627                              <1> 
  8628                              <1> g_szDeviceTypeValues_XTCFpio8:	; db	"T8 ",NULL	; True 8-bit
  8629                              <1>                               	; db	 54h,  38h,  20h,  00h    ; uncompressed
  8630                              <1>                               	  db	 5ah,  30h,  00h          ; compressed
  8631                              <1> 
  8632                              <1> g_szDeviceTypeValues_XTCFdma:	; db	"8MA",NULL	; DMA 8-bit
  8633                              <1>                              	; db	 38h,  4dh,  41h,  00h    ; uncompressed
  8634                              <1>                              	  db	 30h,  53h,  87h          ; compressed
  8635                              <1> 
  8636                              <1> g_szDeviceTypeValues_XTCFmem:	; db	"M8 ",NULL	; Memory Mapped 8-bit
  8637                              <1>                              	; db	 4dh,  38h,  20h,  00h    ; uncompressed
  8638                              <1>                              	  db	 53h,  30h,  00h          ; compressed
  8639                              <1> 
  8640                              <1> g_szDeviceTypeValues_JrIde:		; db	"M8 ",NULL
  8641                              <1>                            		; db	 4dh,  38h,  20h,  00h    ; uncompressed
  8642                              <1>                            		  db	 53h,  30h,  00h          ; compressed
  8643                              <1> 
  8644                              <1> g_szDeviceTypeValues_Serial:	; db	"SER",NULL
  8645                              <1>                             	; db	 53h,  45h,  52h,  00h    ; uncompressed
  8646                              <1>                             	  db	 59h,  4bh,  98h          ; compressed
  8647                              <1> 
  8648                              <1> 
  8649                              <1> g_szDeviceTypeValues_Displacement equ (g_szDeviceTypeValues_32bit - g_szDeviceTypeValues)
  8650                              <1> ;
  8651                              <1> ; Ensure that device type strings are correctly spaced in memory
  8652                              <1> ;
  8653                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  8654                              <1> %if g_szDeviceTypeValues_16bit <> g_szDeviceTypeValues
  8655                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 1"
  8656                              <1> %endif
  8657                              <1> %if g_szDeviceTypeValues_32bit <> g_szDeviceTypeValues_16bit + g_szDeviceTypeValues_Displacement
  8658                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
  8659                              <1> %endif
  8660                              <1> %if g_szDeviceTypeValues_8bit <> g_szDeviceTypeValues_32bit + g_szDeviceTypeValues_Displacement
  8661                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
  8662                              <1> %endif
  8663                              <1> %if g_szDeviceTypeValues_XTIDEr1 <> g_szDeviceTypeValues_8bit + g_szDeviceTypeValues_Displacement
  8664                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 3"
  8665                              <1> %endif
  8666                              <1> %if g_szDeviceTypeValues_XTIDEr2 <> g_szDeviceTypeValues_XTIDEr1 + g_szDeviceTypeValues_Displacement
  8667                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 4"
  8668                              <1> %endif
  8669                              <1> %if g_szDeviceTypeValues_XTCFpio8 <> g_szDeviceTypeValues_XTIDEr2 + g_szDeviceTypeValues_Displacement
  8670                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 5"
  8671                              <1> %endif
  8672                              <1> %if g_szDeviceTypeValues_XTCFdma <> g_szDeviceTypeValues_XTCFpio8 + g_szDeviceTypeValues_Displacement
  8673                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 6"
  8674                              <1> %endif
  8675                              <1> %if g_szDeviceTypeValues_XTCFmem <> g_szDeviceTypeValues_XTCFdma + g_szDeviceTypeValues_Displacement
  8676                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 7"
  8677                              <1> %endif
  8678                              <1> %if g_szDeviceTypeValues_JrIde <> g_szDeviceTypeValues_XTCFmem + g_szDeviceTypeValues_Displacement
  8679                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 8"
  8680                              <1> %endif
  8681                              <1> %if g_szDeviceTypeValues_Serial <> g_szDeviceTypeValues_JrIde + g_szDeviceTypeValues_Displacement
  8682                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 9"
  8683                              <1> %endif
  8684                              <1> %endif
  8685                              <1> 
  8686                              <1> 
  8687                              <1> g_szSelectionTimeout:	; db	DOUBLE_BOTTOM_LEFT_CORNER,DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL,"%ASelection in %2-u s",NULL
  8688                              <1>                      	; db	0c8h, 0b5h,  25h,  41h,  53h,  65h,  6ch,  65h,  63h,  74h,  69h,  6fh,  6eh,  20h,  69h,  6eh,  20h,  25h,  32h,  2dh,  75h,  20h,  73h,  00h    ; uncompressed
  8689                              <1>                      	  db	 31h,  32h,  3bh,  59h,  6bh,  72h,  6bh,  69h,  7ah,  6fh,  75h, 0f4h,  6fh, 0f4h,  3ah,  20h, 0b9h                                              ; compressed
  8690                              <1> 
  8691                              <1> 
  8692                              <1> 
  8693                              <1> ; Boot Menu information strings
  8694                              <1> g_szCapacity:			; db	"Capacity : %s",NULL
  8695                              <1>              			; db	 43h,  61h,  70h,  61h,  63h,  69h,  74h,  79h,  20h,  3ah,  20h,  25h,  73h,  00h    ; uncompressed
  8696                              <1>              			  db	 49h,  67h,  76h,  67h,  69h,  6fh,  7ah, 0ffh, 0c0h,  1dh                            ; compressed
  8697                              <1> 
  8698                              <1> g_szCapacityNum:		; db	"%5-u.%u %ciB",NULL
  8699                              <1>                 		; db	 25h,  35h,  2dh,  75h,  2eh,  25h,  75h,  20h,  25h,  63h,  69h,  42h,  00h    ; uncompressed
  8700                              <1>                 		  db	 36h,  29h,  35h,  20h,  3ch,  6fh,  88h                                        ; compressed
  8701                              <1> 
  8702                              <1> g_szInformation:		; db	"%s",LF,CR
  8703                              <1>                 		; db	 25h,  73h,  0ah,  0dh    ; uncompressed
  8704                              <1>                 		  db	 3dh,  39h                ; compressed
  8705                              <1> 
  8706                              <1> 	; db	"Addr. ",SINGLE_VERTICAL,"Block",SINGLE_VERTICAL,"Bus",SINGLE_VERTICAL,"IRQ",SINGLE_VERTICAL,"Reset",LF,CR
  8707                              <1> 	; db	 41h,  64h,  64h,  72h,  2eh,  20h, 0b3h,  42h,  6ch,  6fh,  63h,  6bh, 0b3h,  42h,  75h,  73h, 0b3h,  49h,  52h,  51h, 0b3h,  52h,  65h,  73h,  65h,  74h,  0ah,  0dh    ; uncompressed
  8708                              <1> 	  db	 47h,  6ah,  6ah,  78h,  29h,  20h,  23h,  48h,  72h,  75h,  69h,  71h,  23h,  48h,  7bh,  79h,  23h,  4fh,  58h,  57h,  23h,  58h,  6bh,  79h,  6bh,  7ah,  39h          ; compressed
  8709                              <1> 
  8710                              <1> 	; db	"%s",SINGLE_VERTICAL,"%5-u",SINGLE_VERTICAL,"%s",SINGLE_VERTICAL," %2-I",SINGLE_VERTICAL,"%5-x",NULL
  8711                              <1> 	; db	 25h,  73h, 0b3h,  25h,  35h,  2dh,  75h, 0b3h,  25h,  73h, 0b3h,  20h,  25h,  32h,  2dh,  49h, 0b3h,  25h,  35h,  2dh,  78h,  00h    ; uncompressed
  8712                              <1> 	  db	 3dh,  23h,  36h,  23h,  3dh,  23h,  20h,  34h,  23h,  18h                                                                            ; compressed
  8713                              <1> 
  8714                              <1> 
  8715                              <1> 
  8716                              <1> ; Boot Menu menuitem strings
  8717                              <1> ;
  8718                              <1> ; The following strings are used by BootMenuPrint_* routines.
  8719                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
  8720                              <1> ; which is checked at assembly time below.
  8721                              <1> ;
  8722                              <1> g_szDriveNumSpace:		; db	" "							; leading space, used if drive number is less than 0fh
  8723                              <1>                   		; db	 20h    ; uncompressed
  8724                              <1>                   		  db	 20h    ; compressed
  8725                              <1> 
  8726                              <1> ; must come immediately before g_szDriveNum!
  8727                              <1> g_szBootMenuPrintStart:
  8728                              <1> g_szDriveNum:			; db	"%x %s",NULL
  8729                              <1>              			; db	 25h,  78h,  20h,  25h,  73h,  00h    ; uncompressed
  8730                              <1>              			  db	 37h,  20h,  1dh                      ; compressed
  8731                              <1> 
  8732                              <1> g_szDriveNumBNSpace:	; db	" "							; leading space, used if drive number is less than 0fh
  8733                              <1>                     	; db	 20h    ; uncompressed
  8734                              <1>                     	  db	 20h    ; compressed
  8735                              <1> 
  8736                              <1> ; must come immediately before g_szDriveNumBOOTNFO!
  8737                              <1> g_szDriveNumBOOTNFO:	; db	"%x %z",NULL
  8738                              <1>                     	; db	 25h,  78h,  20h,  25h,  7ah,  00h    ; uncompressed
  8739                              <1>                     	  db	 37h,  20h,  1eh                      ; compressed
  8740                              <1> 
  8741                              <1> g_szFloppyDrv:			; db	"Floppy Drive %c",NULL
  8742                              <1>               			; db	 46h,  6ch,  6fh,  70h,  70h,  79h,  20h,  44h,  72h,  69h,  76h,  65h,  20h,  25h,  63h,  00h    ; uncompressed
  8743                              <1>               			  db	 4ch,  72h,  75h,  76h,  76h, 0ffh,  4ah,  78h,  6fh,  7ch, 0ebh,  1ch                            ; compressed
  8744                              <1> 
  8745                              <1> g_szBootMenuPrintEnd:
  8746                              <1> g_szForeignHD:			; db	"Foreign Hard Disk",NULL
  8747                              <1>               			; db	 46h,  6fh,  72h,  65h,  69h,  67h,  6eh,  20h,  48h,  61h,  72h,  64h,  20h,  44h,  69h,  73h,  6bh,  00h    ; uncompressed
  8748                              <1>               			  db	 4ch,  75h,  78h,  6bh,  6fh,  6dh, 0f4h,  4eh,  67h,  78h, 0eah,  4ah,  6fh,  79h, 0b1h                      ; compressed
  8749                              <1> 
  8750                              <1> 
  8751                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  8752                              <1> %if ((g_szBootMenuPrintStart-$$) & 0xff00) <> ((g_szBootMenuPrintEnd-$$) & 0xff00)
  8753                              <1> %error "g_szBootMenuPrint* strings must start on the same 256 byte page, required by the BootMenuPrint_* routines.  Please move this block up or down within Strings.asm"
  8754                              <1> %endif
  8755                              <1> %if g_szDriveNumSpace+1 != g_szDriveNum || g_szDriveNumBNSpace+1 != g_szDriveNumBOOTNFO
  8756                              <1> %error "g_szDriveNumSpace or g_szDriveNumBNSpace are out of position"
  8757                              <1> %endif
  8758                              <1> %endif
  8759                              <1> 
  8760                              <1> %endif ; MODULE_BOOT_MENU
  8761                              <1> 
  8762                              <1> 
  8763                              <1> ;------------------------------------------------------------------------------------------
  8764                              <1> ;
  8765                              <1> ; Tables for StringsCompress.pl
  8766                              <1> ;
  8767                              <1> ; Items can be added and removed from this table as needed, with the following rules:
  8768                              <1> ;  * Formats follow the special characters.  But other than that, order makes no difference.
  8769                              <1> ;  * Some of the formats require "even" and "odd" numbering.  Even tells the code that
  8770                              <1> ;    it is a "number-" format, otherwise it doesn't interpret a number first.  The easiest
  8771                              <1> ;    way to maintain this is to move one of the "n/a" items to/from the front of the format
  8772                              <1> ;    list to maintain the even/odd.
  8773                              <1> ;  * Values do not need to remain consistent across versions.  This table is only used
  8774                              <1> ;    internally to this file.
  8775                              <1> ;  * There can only be 32 of these (0-31).
  8776                              <1> ;  * Keeping the list short is good - this translates to a table in the compressed version.
  8777                              <1> ;    An error will be reported if a character or format is no longer being used by any
  8778                              <1> ;    strings above.
  8779                              <1> ;  * Please keep items sequential for ease of further editing.
  8780                              <1> ;
  8781                              <1> ;$translate{ord(' ')} = 0;    [StringsCompress Processed]
  8782                              <1> ;$translate{172}      = 1;     # ONE_QUARTER    [StringsCompress Processed]
  8783                              <1> ;$translate{171}      = 2;     # ONE_HALF    [StringsCompress Processed]
  8784                              <1> ;$translate{179}      = 3;     # SINGLE_VERTICAL    [StringsCompress Processed]
  8785                              <1> ;$translate{175}      = 4;     # ANGLE_QUOTE_RIGHT    [StringsCompress Processed]
  8786                              <1> ;$translate{ord('!')} = 5;    [StringsCompress Processed]
  8787                              <1> ;$translate{ord('"')} = 6;    [StringsCompress Processed]
  8788                              <1> ;$translate{ord(',')} = 7;    [StringsCompress Processed]
  8789                              <1> ;$translate{ord('-')} = 8;    [StringsCompress Processed]
  8790                              <1> ;$translate{ord('.')} = 9;    [StringsCompress Processed]
  8791                              <1> ;$translate{ord('/')} = 10;    [StringsCompress Processed]
  8792                              <1> ;$translate{ord('1')} = 11;    [StringsCompress Processed]
  8793                              <1> ;$translate{ord('2')} = 12;    [StringsCompress Processed]
  8794                              <1> ;$translate{ord('3')} = 13;    [StringsCompress Processed]
  8795                              <1> ;$translate{ord('5')} = 14;    [StringsCompress Processed]
  8796                              <1> ;$translate{ord('6')} = 15;    [StringsCompress Processed]
  8797                              <1> ;$translate{ord('8')} = 16;    [StringsCompress Processed]
  8798                              <1> ;$translate{200}      = 17;    # DOUBLE_BOTTOM_LEFT_CORNER    [StringsCompress Processed]
  8799                              <1> ;$translate{181}      = 18;    # DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL    [StringsCompress Processed]
  8800                              <1> ;$translate{ord('0')} = 19;    [StringsCompress Processed]
  8801                              <1> ;
  8802                              <1> ; Formats begin immediately after the last Translated character (they are in the same table)
  8803                              <1> ;
  8804                              <1> ;$format_begin = 20;    [StringsCompress Processed]
  8805                              <1> ;
  8806                              <1> ;$format{"2-I"} = 20;        # must be even    [StringsCompress Processed]
  8807                              <1> ;$format{"u"}   = 21;        # must be odd    [StringsCompress Processed]
  8808                              <1> ;$format{"5-u"} = 22;        # must be even    [StringsCompress Processed]
  8809                              <1> ;$format{"x"}   = 23;        # must be odd    [StringsCompress Processed]
  8810                              <1> ;$format{"5-x"} = 24;        # must be even    [StringsCompress Processed]
  8811                              <1> ;$format{"nl"}  = 25;        # n/a    [StringsCompress Processed]
  8812                              <1> ;$format{"2-u"} = 26;        # must be even    [StringsCompress Processed]
  8813                              <1> ;$format{"A"}   = 27;        # n/a    [StringsCompress Processed]
  8814                              <1> ;$format{"c"}   = 28;        # n/a    [StringsCompress Processed]
  8815                              <1> ;$format{"s"}   = 29;        # n/a, normal string from DS    [StringsCompress Processed]
  8816                              <1> ;$format{"z"}   = 30;        # n/a, boot string from BDA    [StringsCompress Processed]
  8817                              <1> ;
  8818                              <1> ; NOTE: The last $format cannot exceed 31 (stored in a 5-bit quantity).
  8819                              <1> ;
  8820                              <1> ; Starting point for the "normal" range, typically around 0x40 to cover upper and lower case
  8821                              <1> ; letters.  If lower case 'z' is not used, 0x3a can be a good choice as it adds ':' to the
  8822                              <1> ; front end.
  8823                              <1> ;
  8824                              <1> ;$normal_base = 0x3a;    [StringsCompress Processed]
  8825                              <1> ;
  8826                              <1> ; End of StringsCompress.pl information
  8827                              <1> ;
  8828                              <1> ;;; end of input stream
  8829                              <1> 
  8830                              <1> %endif ; STRINGSCOMPRESSED_STRINGS
  8831                              <1> 
  8832                              <1> %ifdef STRINGSCOMPRESSED_TABLES
  8833                              <1> 
  8834                              <1> StringsCompressed_NormalBase     equ   58
  8835                              <1> 
  8836                              <1> StringsCompressed_FormatsBegin   equ   20
  8837                              <1> 
  8838                              <1> StringsCompressed_TranslatesAndFormats:
  8839 00000351 20                  <1>         db     32  ; 0
  8840 00000352 AC                  <1>         db     172  ; 1
  8841 00000353 AB                  <1>         db     171  ; 2
  8842 00000354 B3                  <1>         db     179  ; 3
  8843 00000355 AF                  <1>         db     175  ; 4
  8844 00000356 21                  <1>         db     33  ; 5
  8845 00000357 22                  <1>         db     34  ; 6
  8846 00000358 2C                  <1>         db     44  ; 7
  8847 00000359 2D                  <1>         db     45  ; 8
  8848 0000035A 2E                  <1>         db     46  ; 9
  8849 0000035B 2F                  <1>         db     47  ; 10
  8850 0000035C 31                  <1>         db     49  ; 11
  8851 0000035D 32                  <1>         db     50  ; 12
  8852 0000035E 33                  <1>         db     51  ; 13
  8853 0000035F 35                  <1>         db     53  ; 14
  8854 00000360 36                  <1>         db     54  ; 15
  8855 00000361 38                  <1>         db     56  ; 16
  8856 00000362 C8                  <1>         db     200  ; 17
  8857 00000363 B5                  <1>         db     181  ; 18
  8858 00000364 30                  <1>         db     48  ; 19
  8859 00000365 31                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I)    ; 20
  8860 00000366 28                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u)    ; 21
  8861 00000367 28                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u)    ; 22
  8862 00000368 39                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x)    ; 23
  8863 00000369 39                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x)    ; 24
  8864 0000036A 6C                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl)    ; 25
  8865 0000036B 2A                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u)    ; 26
  8866 0000036C 42                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A)    ; 27
  8867 0000036D 63                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c)    ; 28
  8868 0000036E 00                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s)    ; 29
  8869 0000036F 3E                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z)    ; 30
  8870                              <1> 
  8871                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  8872                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_I || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I > 255
  8873                              <1> %error "DisplayFormatCompressed_Format_2_I is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8874                              <1> %endif
  8875                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u > 255
  8876                              <1> %error "DisplayFormatCompressed_Format_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8877                              <1> %endif
  8878                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u > 255
  8879                              <1> %error "DisplayFormatCompressed_Format_5_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8880                              <1> %endif
  8881                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x > 255
  8882                              <1> %error "DisplayFormatCompressed_Format_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8883                              <1> %endif
  8884                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x > 255
  8885                              <1> %error "DisplayFormatCompressed_Format_5_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8886                              <1> %endif
  8887                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_nl || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl > 255
  8888                              <1> %error "DisplayFormatCompressed_Format_nl is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8889                              <1> %endif
  8890                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u > 255
  8891                              <1> %error "DisplayFormatCompressed_Format_2_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8892                              <1> %endif
  8893                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_A || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A > 255
  8894                              <1> %error "DisplayFormatCompressed_Format_A is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8895                              <1> %endif
  8896                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_c || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c > 255
  8897                              <1> %error "DisplayFormatCompressed_Format_c is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8898                              <1> %endif
  8899                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_s || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s > 255
  8900                              <1> %error "DisplayFormatCompressed_Format_s is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8901                              <1> %endif
  8902                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_z || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z > 255
  8903                              <1> %error "DisplayFormatCompressed_Format_z is out of range of DisplayFormatCompressed_BaseFormatOffset"
  8904                              <1> %endif
  8905                              <1> %endif
  8906                              <1> 
  8907                              <1> ;; translated usage stats
  8908                              <1> ;; 33:1
  8909                              <1> ;; 32:34
  8910                              <1> ;; 181:1
  8911                              <1> ;; 53:2
  8912                              <1> ;; 48:2
  8913                              <1> ;; 200:1
  8914                              <1> ;; 46:3
  8915                              <1> ;; 179:8
  8916                              <1> ;; 44:1
  8917                              <1> ;; 50:2
  8918                              <1> ;; 51:3
  8919                              <1> ;; 47:2
  8920                              <1> ;; 172:2
  8921                              <1> ;; 34:3
  8922                              <1> ;; 49:1
  8923                              <1> ;; 56:7
  8924                              <1> ;; 45:2
  8925                              <1> ;; 175:1
  8926                              <1> ;; 171:2
  8927                              <1> ;; 54:1
  8928                              <1> ;; total translated: 20
  8929                              <1> 
  8930                              <1> ;; format usage stats
  8931                              <1> ;; A:4
  8932                              <1> ;; 2-u:1
  8933                              <1> ;; 5-u:2
  8934                              <1> ;; x:5
  8935                              <1> ;; s:14
  8936                              <1> ;; 5-x:1
  8937                              <1> ;; nl:12
  8938                              <1> ;; 2-I:1
  8939                              <1> ;; u:6
  8940                              <1> ;; c:13
  8941                              <1> ;; z:2
  8942                              <1> ;; total format: 11
  8943                              <1> 
  8944                              <1> ;; alphabet usage stats
  8945                              <1> ;; 58,::2
  8946                              <1> ;; 59,;:
  8947                              <1> ;; 60,<:
  8948                              <1> ;; 61,=:
  8949                              <1> ;; 62,>:
  8950                              <1> ;; 63,?:
  8951                              <1> ;; 64,@:1
  8952                              <1> ;; 65,A:5
  8953                              <1> ;; 66,B:9
  8954                              <1> ;; 67,C:3
  8955                              <1> ;; 68,D:11
  8956                              <1> ;; 69,E:3
  8957                              <1> ;; 70,F:3
  8958                              <1> ;; 71,G:3
  8959                              <1> ;; 72,H:2
  8960                              <1> ;; 73,I:1
  8961                              <1> ;; 74,J:
  8962                              <1> ;; 75,K:1
  8963                              <1> ;; 76,L:4
  8964                              <1> ;; 77,M:7
  8965                              <1> ;; 78,N:2
  8966                              <1> ;; 79,O:2
  8967                              <1> ;; 80,P:1
  8968                              <1> ;; 81,Q:1
  8969                              <1> ;; 82,R:7
  8970                              <1> ;; 83,S:3
  8971                              <1> ;; 84,T:1
  8972                              <1> ;; 85,U:2
  8973                              <1> ;; 86,V:
  8974                              <1> ;; 87,W:
  8975                              <1> ;; 88,X:1
  8976                              <1> ;; 89,Y:
  8977                              <1> ;; 90,Z:
  8978                              <1> ;; 91,[:2
  8979                              <1> ;; 92,\:
  8980                              <1> ;; 93,]:2
  8981                              <1> ;; 94,^:
  8982                              <1> ;; 95,_:
  8983                              <1> ;; 96,`:
  8984                              <1> ;; 97,a:7
  8985                              <1> ;; 98,b:
  8986                              <1> ;; 99,c:6
  8987                              <1> ;; 100,d:6
  8988                              <1> ;; 101,e:15
  8989                              <1> ;; 102,f:1
  8990                              <1> ;; 103,g:2
  8991                              <1> ;; 104,h:
  8992                              <1> ;; 105,i:9
  8993                              <1> ;; 106,j:
  8994                              <1> ;; 107,k:4
  8995                              <1> ;; 108,l:5
  8996                              <1> ;; 109,m:2
  8997                              <1> ;; 110,n:11
  8998                              <1> ;; 111,o:20
  8999                              <1> ;; 112,p:3
  9000                              <1> ;; 113,q:
  9001                              <1> ;; 114,r:11
  9002                              <1> ;; 115,s:7
  9003                              <1> ;; 116,t:15
  9004                              <1> ;; 117,u:4
  9005                              <1> ;; 118,v:3
  9006                              <1> ;; 119,w:1
  9007                              <1> ;; 120,x:
  9008                              <1> ;; 121,y:2
  9009                              <1> ;; alphabet used count: 45
  9010                              <1> %endif ; STRINGSCOMPRESSED_TABLES
  9011                              <1> 
  9012                                  %endif
  9013                                  
  9014                                  	%include "Initialize.asm"		; For BIOS initialization
  9015                              <1> ; Project name	:	XTIDE Universal BIOS
  9016                              <1> ; Description	:	Functions for initializing the BIOS.
  9017                              <1> 
  9018                              <1> ;
  9019                              <1> ; XTIDE Universal BIOS and Associated Tools
  9020                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  9021                              <1> ;
  9022                              <1> ; This program is free software; you can redistribute it and/or modify
  9023                              <1> ; it under the terms of the GNU General Public License as published by
  9024                              <1> ; the Free Software Foundation; either version 2 of the License, or
  9025                              <1> ; (at your option) any later version.
  9026                              <1> ;
  9027                              <1> ; This program is distributed in the hope that it will be useful,
  9028                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9029                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9030                              <1> ; GNU General Public License for more details.
  9031                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  9032                              <1> ;
  9033                              <1> 
  9034                              <1> ; Section containing code
  9035                              <1> SECTION .text
  9036                              <1> 
  9037                              <1> ;--------------------------------------------------------------------
  9038                              <1> ; Initializes the BIOS.
  9039                              <1> ; This function is called from main BIOS ROM search routine.
  9040                              <1> ;
  9041                              <1> ; Initialize_FromMainBiosRomSearch
  9042                              <1> ;	Parameters:
  9043                              <1> ;		Nothing
  9044                              <1> ;	Returns:
  9045                              <1> ;		Nothing
  9046                              <1> ;	Corrupts registers:
  9047                              <1> ;		Nothing
  9048                              <1> ;--------------------------------------------------------------------
  9049                              <1> Initialize_FromMainBiosRomSearch:		; unused entrypoint ok
  9050 00000370 9C                  <1> 	pushf								; To store IF
  9051 00000371 1E                  <1> 	push	ds
  9052                              <1> 
  9053                              <1> %ifndef USE_186
  9054 00000372 50                  <1> 	push	ax
  9055                              <1> 	LOAD_BDA_SEGMENT_TO	ds, ax
  9056                              <2> %ifndef USE_186
  9057 00000373 31C0                <2>  xor %2, %2
  9058 00000375 8ED8                <2>  mov %1, %2
  9059                              <2> %elifidn %3, !
  9060                              <2>  xor %2, %2
  9061                              <2>  mov %1, %2
  9062                              <2> %else
  9063                              <2>  push BYTE 0
  9064                              <2>  pop %1
  9065                              <2> %endif
  9066                              <1> %else
  9067                              <1> 	push	BYTE 0
  9068                              <1> 	pop		ds
  9069                              <1> %endif
  9070                              <1> 
  9071 00000377 FB                  <1> 	sti									; Enable interrupts for keystrokes
  9072 00000378 F606170404          <1> 	test	BYTE [BDA.bKBFlgs1], (1<<2)	; Clears ZF if CTRL is held down
  9073 0000037D 750A                <1> 	jnz		SHORT .SkipRomInitialization
  9074                              <1> 
  9075                              <1> 	; Install INT 19h handler (boot loader) where drives are detected
  9076 0000037F C7066400[5707]      <1> 	mov		WORD [BIOS_BOOT_LOADER_INTERRUPT_19h*4], Int19h_BootLoaderHandler
  9077 00000385 8C0E6600            <1> 	mov		[BIOS_BOOT_LOADER_INTERRUPT_19h*4+2], cs
  9078                              <1> 
  9079                              <1> .SkipRomInitialization:
  9080                              <1> %ifndef USE_186
  9081 00000389 58                  <1> 	pop		ax
  9082                              <1> %endif
  9083 0000038A 1F                  <1> 	pop		ds
  9084 0000038B 9D                  <1> 	popf
  9085 0000038C CB                  <1> 	retf
  9086                              <1> 
  9087                              <1> 
  9088                              <1> ;--------------------------------------------------------------------
  9089                              <1> ; Initializes the BIOS variables and detects IDE drives.
  9090                              <1> ;
  9091                              <1> ; Initialize_AndDetectDrives
  9092                              <1> ;	Parameters:
  9093                              <1> ;		ES:		BDA Segment
  9094                              <1> ;	Returns:
  9095                              <1> ;		DS:		RAMVARS segment
  9096                              <1> ;	Corrupts registers:
  9097                              <1> ;		All, except ES
  9098                              <1> ;--------------------------------------------------------------------
  9099                              <1> Initialize_AndDetectDrives:
  9100 0000038D E85503              <1> 	call	DetectPrint_InitializeDisplayContext
  9101 00000390 E87903              <1> 	call	DetectPrint_RomFoundAtSegment
  9102 00000393 E84300              <1> 	call	RamVars_Initialize
  9103 00000396 E8B600              <1> 	call	BootVars_Initialize
  9104 00000399 E8EE02              <1> 	call	DetectDrives_FromAllIDEControllers
  9105 0000039C E80A00              <1> 	call	Interrupts_InitializeInterruptVectors
  9106                              <1> 	; Fall to .ResetDetectedDrives
  9107                              <1> 
  9108                              <1> ;--------------------------------------------------------------------
  9109                              <1> ; .ResetDetectedDrives
  9110                              <1> ;	Parameters:
  9111                              <1> ;		DS:		RAMVARS segment
  9112                              <1> ;		ES:		BDA and interrupt vector segment (zero)
  9113                              <1> ;	Returns:
  9114                              <1> ;		Nothing
  9115                              <1> ;	Corrupts registers:
  9116                              <1> ;		All, except DS and ES
  9117                              <1> ;--------------------------------------------------------------------
  9118                              <1> .ResetDetectedDrives:
  9119 0000039F E86404              <1> 	call	Idepack_FakeToSSBP
  9120 000003A2 E8350A              <1> 	call	AH0h_ResetAllOurHardDisksAtTheEndOfDriveInitialization
  9121 000003A5 83C409              <1> 	add		sp, BYTE SIZE_OF_IDEPACK_WITHOUT_INTPACK
  9122 000003A8 C3                  <1> 	ret
  9123                                  	%include "Interrupts.asm"		; For Interrupt initialization
  9124                              <1> ; Project name	:	XTIDE Universal BIOS
  9125                              <1> ; Description	:	Functions for initializing the BIOS.
  9126                              <1> 
  9127                              <1> ;
  9128                              <1> ; XTIDE Universal BIOS and Associated Tools
  9129                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  9130                              <1> ;
  9131                              <1> ; This program is free software; you can redistribute it and/or modify
  9132                              <1> ; it under the terms of the GNU General Public License as published by
  9133                              <1> ; the Free Software Foundation; either version 2 of the License, or
  9134                              <1> ; (at your option) any later version.
  9135                              <1> ;
  9136                              <1> ; This program is distributed in the hope that it will be useful,
  9137                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9138                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9139                              <1> ; GNU General Public License for more details.
  9140                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  9141                              <1> ;
  9142                              <1> 
  9143                              <1> ; Section containing code
  9144                              <1> SECTION .text
  9145                              <1> 
  9146                              <1> ;--------------------------------------------------------------------
  9147                              <1> ; Drives must be detected before this function is called!
  9148                              <1> ;
  9149                              <1> ; Interrupts_InitializeInterruptVectors
  9150                              <1> ;	Parameters:
  9151                              <1> ;		DS:		RAMVARS segment
  9152                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9153                              <1> ;	Returns:
  9154                              <1> ;		Nothing
  9155                              <1> ;	Corrupts registers:
  9156                              <1> ;		All except segments
  9157                              <1> ;--------------------------------------------------------------------
  9158                              <1> Interrupts_InitializeInterruptVectors:
  9159                              <1> 	; Install INT 19h handler to properly reset the system
  9160 000003A9 B019                <1> 	mov		al, BIOS_BOOT_LOADER_INTERRUPT_19h	; INT 19h interrupt vector offset
  9161 000003AB BE[0008]            <1> 	mov		si, Int19hReset_Handler				; INT 19h handler to reboot the system
  9162 000003AE E81B00              <1> 	call	Interrupts_InstallHandlerToVectorInALFromCSSI
  9163                              <1> 
  9164                              <1> 	; If no drives detected, leave system INT 13h and 40h handlers
  9165                              <1> 	; in place. We need our INT 13h handler to swap drive letters.
  9166                              <1> %ifndef MODULE_DRIVEXLATE
  9167 000003B1 803E090000          <1> 	cmp		BYTE [RAMVARS.bDrvCnt], 0
  9168 000003B6 7420                <1> 	je		SHORT Interrupts_InstallHandlerToVectorInALFromCSSI.Interrupts_Return
  9169                              <1> %endif
  9170                              <1> 	; Fall to .InitializeInt13hAnd40h
  9171                              <1> 
  9172                              <1> ;--------------------------------------------------------------------
  9173                              <1> ; .InitializeInt13hAnd40h
  9174                              <1> ;	Parameters:
  9175                              <1> ;		DS:		RAMVARS segment
  9176                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9177                              <1> ;	Returns:
  9178                              <1> ;		Nothing
  9179                              <1> ;	Corrupts registers:
  9180                              <1> ;		AX, BX, CX, DX, SI, DI
  9181                              <1> ;--------------------------------------------------------------------
  9182                              <1> .InitializeInt13hAnd40h:
  9183 000003B8 26A14E00            <1> 	mov		ax, [es:BIOS_DISK_INTERRUPT_13h*4+2]; Load old INT 13h segment
  9184 000003BC A30200              <1> 	mov		[RAMVARS.fpOldI13h+2], ax			; Store old INT 13h segment
  9185 000003BF 92                  <1> 	xchg	dx, ax
  9186 000003C0 26A14C00            <1> 	mov		ax, [es:BIOS_DISK_INTERRUPT_13h*4]	; Load old INT 13h offset
  9187 000003C4 A30000              <1> 	mov		[RAMVARS.fpOldI13h], ax				; Store old INT 13h offset
  9188                              <1> 
  9189                              <1> %ifdef COPY_13H_HANDLER_TO_40H
  9190                              <1> 	; Only store INT 13h handler to 40h if 40h is not already installed.
  9191                              <1> 	; At least AMI BIOS for 286 stores 40h handler by itself and calls
  9192                              <1> 	; 40h from 13h. That system locks to infinite loop if we copy 13h to 40h.
  9193                              <1> 	call	FloppyDrive_IsInt40hInstalled
  9194                              <1> 	jc		SHORT .Int40hAlreadyInstalled
  9195                              <1> 	mov		[es:BIOS_DISKETTE_INTERRUPT_40h*4], ax		; Store old INT 13h offset
  9196                              <1> 	mov		[es:BIOS_DISKETTE_INTERRUPT_40h*4+2], dx	; Store old INT 13h segment
  9197                              <1> .Int40hAlreadyInstalled:
  9198                              <1> %endif ; COPY_13H_HANDLER_TO_40H
  9199                              <1> 
  9200 000003C7 B013                <1> 	mov		al, BIOS_DISK_INTERRUPT_13h			; INT 13h interrupt vector offset
  9201                              <1> %ifdef RELOCATE_INT13H_STACK
  9202                              <1> 	mov		si, Int13h_DiskFunctionsHandlerWithStackChange
  9203                              <1> %else
  9204 000003C9 BE[970C]            <1> 	mov		si, Int13h_DiskFunctionsHandler
  9205                              <1> %endif
  9206                              <1> 
  9207                              <1> %ifndef MODULE_IRQ
  9208                              <1> 	; Fall to Interrupts_InstallHandlerToVectorInALFromCSSI
  9209                              <1> %else
  9210                              <1> 	call	Interrupts_InstallHandlerToVectorInALFromCSSI
  9211                              <1> 	; Fall to .InitializeHardwareIrqHandlers
  9212                              <1> 
  9213                              <1> ;--------------------------------------------------------------------
  9214                              <1> ; .InitializeHardwareIrqHandlers
  9215                              <1> ;	Parameters:
  9216                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9217                              <1> ;	Returns:
  9218                              <1> ;		Nothing
  9219                              <1> ;	Corrupts registers:
  9220                              <1> ;		BX, CX, DX, SI, DI, AX
  9221                              <1> ;--------------------------------------------------------------------
  9222                              <1> .InitializeHardwareIrqHandlers:
  9223                              <1> 	call	RamVars_GetIdeControllerCountToCX
  9224                              <1> 	mov		di, ROMVARS.ideVars0+IDEVARS.bIRQ	; CS:SI points to first IDEVARS
  9225                              <1> .IdeControllerLoop:
  9226                              <1> 	mov		al, [cs:di]
  9227                              <1> 	add		di, BYTE IDEVARS_size			; Increment to next controller
  9228                              <1> 	call	.InstallLowOrHighIrqHandler
  9229                              <1> 	loop	.IdeControllerLoop
  9230                              <1> .Return:
  9231                              <1> 	ret		; This ret is shared with .InstallLowOrHighIrqHandler
  9232                              <1> 
  9233                              <1> ;--------------------------------------------------------------------
  9234                              <1> ; .InstallLowOrHighIrqHandler
  9235                              <1> ;	Parameters:
  9236                              <1> ;		AL:		IRQ number, 0 if IRQ disabled
  9237                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9238                              <1> ;	Returns:
  9239                              <1> ;		Nothing
  9240                              <1> ;	Corrupts registers:
  9241                              <1> ;		BX, SI
  9242                              <1> ;--------------------------------------------------------------------
  9243                              <1> .InstallLowOrHighIrqHandler:
  9244                              <1> 	test	al, al
  9245                              <1> 	jz		SHORT .Return	; IRQ not used
  9246                              <1> 	cmp		al, 8
  9247                              <1> 	jb		SHORT .InstallLowIrqHandler
  9248                              <1> 	; Fall to .InstallHighIrqHandler
  9249                              <1> 
  9250                              <1> ;--------------------------------------------------------------------
  9251                              <1> ; .InstallHighIrqHandler
  9252                              <1> ;	Parameters:
  9253                              <1> ;		BX:		IRQ number (8...15)
  9254                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9255                              <1> ;	Returns:
  9256                              <1> ;		Nothing
  9257                              <1> ;	Corrupts registers:
  9258                              <1> ;		AL, BX, SI
  9259                              <1> ;--------------------------------------------------------------------
  9260                              <1> .InstallHighIrqHandler:
  9261                              <1> 	add		al, BYTE HARDWARE_IRQ_8_INTERRUPT_70h - 8	; Interrupt vector number
  9262                              <1> 	mov		si, IdeIrq_InterruptServiceRoutineForIrqs8to15
  9263                              <1> 	jmp		SHORT Interrupts_InstallHandlerToVectorInALFromCSSI
  9264                              <1> 
  9265                              <1> ;--------------------------------------------------------------------
  9266                              <1> ; .InstallLowIrqHandler
  9267                              <1> ;	Parameters:
  9268                              <1> ;		AL:		IRQ number (0...7)
  9269                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9270                              <1> ;	Returns:
  9271                              <1> ;		Nothing
  9272                              <1> ;	Corrupts registers:
  9273                              <1> ;		AL, BX, SI
  9274                              <1> ;--------------------------------------------------------------------
  9275                              <1> .InstallLowIrqHandler:
  9276                              <1> 	add		al, BYTE HARDWARE_IRQ_0_INTERRUPT_08h		; Interrupt vector number
  9277                              <1> 	mov		si, IdeIrq_InterruptServiceRoutineForIrqs2to7
  9278                              <1> 	; Fall to Interrupts_InstallHandlerToVectorInALFromCSSI
  9279                              <1> %endif ; MODULE_IRQ
  9280                              <1> 
  9281                              <1> 
  9282                              <1> ;--------------------------------------------------------------------
  9283                              <1> ; Interrupts_InstallHandlerToVectorInALFromCSSI
  9284                              <1> ;	Parameters:
  9285                              <1> ;		AL:		Interrupt vector number (for example 13h)
  9286                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9287                              <1> ;		CS:SI:	Ptr to interrupt handler
  9288                              <1> ;	Returns:
  9289                              <1> ;		Nothing
  9290                              <1> ;	Corrupts registers:
  9291                              <1> ;		AX, BX
  9292                              <1> ;--------------------------------------------------------------------
  9293                              <1> Interrupts_InstallHandlerToVectorInALFromCSSI:
  9294 000003CC B304                <1> 	mov		bl, 4					; Shift for DWORD offset, MUL smaller than other alternatives
  9295 000003CE F6E3                <1> 	mul		bl
  9296 000003D0 93                  <1> 	xchg	ax, bx
  9297 000003D1 268937              <1> 	mov		[es:bx], si				; Store offset
  9298 000003D4 268C4F02            <1> 	mov		[es:bx+2], cs			; Store segment
  9299                              <1> .Interrupts_Return:
  9300 000003D8 C3                  <1> 	ret
  9301                              <1> 
  9302                              <1> 
  9303                              <1> %ifdef MODULE_IRQ
  9304                              <1> ;--------------------------------------------------------------------
  9305                              <1> ; Interrupts_UnmaskInterruptControllerForDriveInDSDI
  9306                              <1> ;	Parameters:
  9307                              <1> ;		DS:DI:	Ptr to DPT
  9308                              <1> ;	Returns:
  9309                              <1> ;		Nothing
  9310                              <1> ;	Corrupts registers:
  9311                              <1> ;		AX, BX, DX
  9312                              <1> ;--------------------------------------------------------------------
  9313                              <1> Interrupts_UnmaskInterruptControllerForDriveInDSDI:
  9314                              <1> 	eMOVZX	bx, [di+DPT.bIdevarsOffset]
  9315                              <1> 	mov		al, [cs:bx+IDEVARS.bIRQ]
  9316                              <1> 	test	al, al
  9317                              <1> 	jz		SHORT .Return	; Interrupts disabled
  9318                              <1> 	cmp		al, 8
  9319                              <1> 	jb		SHORT .UnmaskLowIrqController
  9320                              <1> 	; Fall to .UnmaskHighIrqController
  9321                              <1> 
  9322                              <1> ;--------------------------------------------------------------------
  9323                              <1> ; .UnmaskHighIrqController
  9324                              <1> ;	Parameters:
  9325                              <1> ;		AL:		IRQ number (8...15)
  9326                              <1> ;	Returns:
  9327                              <1> ;		Nothing
  9328                              <1> ;	Corrupts registers:
  9329                              <1> ;		AX, DX
  9330                              <1> ;--------------------------------------------------------------------
  9331                              <1> .UnmaskHighIrqController:
  9332                              <1> 	sub		al, 8				; Slave interrupt number
  9333                              <1> 	mov		dx, SLAVE_8259_IMR
  9334                              <1> 	call	.ClearBitFrom8259MaskRegister
  9335                              <1> 	mov		al, 2				; Master IRQ 2 to allow slave IRQs
  9336                              <1> 	; Fall to .UnmaskLowIrqController
  9337                              <1> 
  9338                              <1> ;--------------------------------------------------------------------
  9339                              <1> ; .UnmaskLowIrqController
  9340                              <1> ;	Parameters:
  9341                              <1> ;		AL:		IRQ number (0...7)
  9342                              <1> ;	Returns:
  9343                              <1> ;		Nothing
  9344                              <1> ;	Corrupts registers:
  9345                              <1> ;		AX, DX
  9346                              <1> ;--------------------------------------------------------------------
  9347                              <1> .UnmaskLowIrqController:
  9348                              <1> 	mov		dx, MASTER_8259_IMR
  9349                              <1> 	; Fall to .ClearBitFrom8259MaskRegister
  9350                              <1> 
  9351                              <1> ;--------------------------------------------------------------------
  9352                              <1> ; .ClearBitFrom8259MaskRegister
  9353                              <1> ;	Parameters:
  9354                              <1> ;		AL:		8259 interrupt index (0...7)
  9355                              <1> ;		DX:		Port address to Interrupt Mask Register
  9356                              <1> ;	Returns:
  9357                              <1> ;		Nothing
  9358                              <1> ;	Corrupts registers:
  9359                              <1> ;		AX
  9360                              <1> ;--------------------------------------------------------------------
  9361                              <1> .ClearBitFrom8259MaskRegister:
  9362                              <1> 	push	cx
  9363                              <1> 	xchg	ax, cx				; IRQ index to CL
  9364                              <1> 	mov		ch, 1				; Load 1 to be shifted
  9365                              <1> 	shl		ch, cl				; Shift bit to correct position
  9366                              <1> 	not		ch					; Invert to create bit mask for clearing
  9367                              <1> 	in		al, dx				; Read Interrupt Mask Register
  9368                              <1> 	and		al, ch				; Clear wanted bit
  9369                              <1> 	out		dx, al				; Write modified Interrupt Mask Register
  9370                              <1> 	pop		cx
  9371                              <1> .Return:
  9372                              <1> 	ret
  9373                              <1> 
  9374                              <1> %endif ; MODULE_IRQ
  9375                                  	%include "RamVars.asm"			; For RAMVARS initialization and access
  9376                              <1> ; Project name	:	XTIDE Universal BIOS
  9377                              <1> ; Description	:	Functions for accessings RAMVARS.
  9378                              <1> 
  9379                              <1> ;
  9380                              <1> ; XTIDE Universal BIOS and Associated Tools
  9381                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  9382                              <1> ;
  9383                              <1> ; This program is free software; you can redistribute it and/or modify
  9384                              <1> ; it under the terms of the GNU General Public License as published by
  9385                              <1> ; the Free Software Foundation; either version 2 of the License, or
  9386                              <1> ; (at your option) any later version.
  9387                              <1> ;
  9388                              <1> ; This program is distributed in the hope that it will be useful,
  9389                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9390                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9391                              <1> ; GNU General Public License for more details.
  9392                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  9393                              <1> ;
  9394                              <1> 
  9395                              <1> ; Section containing code
  9396                              <1> SECTION .text
  9397                              <1> 
  9398                              <1> ;--------------------------------------------------------------------
  9399                              <1> ; Initializes RAMVARS.
  9400                              <1> ; Drive detection can be started after this function returns.
  9401                              <1> ;
  9402                              <1> ; RamVars_Initialize
  9403                              <1> ;	Parameters:
  9404                              <1> ;		Nothing
  9405                              <1> ;	Returns:
  9406                              <1> ;		DS:		RAMVARS segment
  9407                              <1> ;	Corrupts registers:
  9408                              <1> ;		AX, CX, DI
  9409                              <1> ;--------------------------------------------------------------------
  9410                              <1> RamVars_Initialize:
  9411 000003D9 06                  <1> 	push	es
  9412                              <1> 	; Fall to .StealMemoryForRAMVARS
  9413                              <1> 
  9414                              <1> ;--------------------------------------------------------------------
  9415                              <1> ; .StealMemoryForRAMVARS
  9416                              <1> ;	Parameters:
  9417                              <1> ;		Nothing
  9418                              <1> ;	Returns:
  9419                              <1> ;		DS:		RAMVARS segment
  9420                              <1> ;	Corrupts registers:
  9421                              <1> ;		AX
  9422                              <1> ;--------------------------------------------------------------------
  9423                              <1> .StealMemoryForRAMVARS:
  9424                              <1> %ifndef USE_AT
  9425 000003DA B83000              <1> 	mov		ax, LITE_MODE_RAMVARS_SEGMENT
  9426 000003DD 2EF606460001        <1> 	test	BYTE [cs:ROMVARS.wFlags], FLG_ROMVARS_FULLMODE
  9427 000003E3 7415                <1> 	jz		SHORT .InitializeRamvars	; No need to steal RAM
  9428                              <1> %endif
  9429                              <1> 
  9430                              <1> 	LOAD_BDA_SEGMENT_TO	ds, ax, !		; Zero AX
  9431                              <2> %ifndef USE_186
  9432 000003E5 31C0                <2>  xor %2, %2
  9433 000003E7 8ED8                <2>  mov %1, %2
  9434                              <2> %elifidn %3, !
  9435                              <2>  xor %2, %2
  9436                              <2>  mov %1, %2
  9437                              <2> %else
  9438                              <2>  push BYTE 0
  9439                              <2>  pop %1
  9440                              <2> %endif
  9441 000003E9 2EA04F00            <1> 	mov		al, [cs:ROMVARS.bStealSize]
  9442 000003ED 29061304            <1> 	sub		[BDA.wBaseMem], ax
  9443 000003F1 A11304              <1> 	mov		ax, [BDA.wBaseMem]
  9444                              <1> 	eSHL_IM	ax, 6						; Segment to first stolen kB (*=40h)
  9445                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9446                              <2> %ifdef USE_386
  9447                              <2>  %if %2 = 1
  9448                              <2>  add %1, %1
  9449                              <2>  %else
  9450                              <2>  eSHIFT_IM %1, %2, shl
  9451                              <2>  %endif
  9452                              <2> %else
  9453                              <2>  eSHIFT_IM %1, %2, shl
  9454                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9455                              <3> %ifndef USE_186
  9456                              <3>  %ifidni %1, cl
  9457                              <3>  times %2 %3 %1, 1
  9458                              <3>  %elifidni %1, ch
  9459                              <3>  times %2 %3 %1, 1
  9460                              <3>  %elifidni %1, cx
  9461                              <3>  times %2 %3 %1, 1
  9462                              <3>  %else
  9463                              <3>  %if %2 > 3
  9464 000003F4 51                  <3>  push cx
  9465 000003F5 B106                <3>  mov cl, %2
  9466 000003F7 D3E0                <3>  %3 %1, cl
  9467 000003F9 59                  <3>  pop cx
  9468                              <3>  %else
  9469                              <3>  times %2 %3 %1, 1
  9470                              <3>  %endif
  9471                              <3>  %endif
  9472                              <3> 
  9473                              <3> %else
  9474                              <3>  %3 %1, %2
  9475                              <3> %endif
  9476                              <3> %endif
  9477                              <2> %endif
  9478                              <2> %endif
  9479                              <1> 	; Fall to .InitializeRamvars
  9480                              <1> 
  9481                              <1> ;--------------------------------------------------------------------
  9482                              <1> ; .InitializeRamvars
  9483                              <1> ;	Parameters:
  9484                              <1> ;		AX:		RAMVARS segment
  9485                              <1> ;	Returns:
  9486                              <1> ;		DS:		RAMVARS segment
  9487                              <1> ;	Corrupts registers:
  9488                              <1> ;		AX, CX, DI, ES
  9489                              <1> ;--------------------------------------------------------------------
  9490                              <1> .InitializeRamvars:
  9491 000003FA 8ED8                <1> 	mov		ds, ax
  9492 000003FC 8EC0                <1> 	mov		es, ax
  9493 000003FE B90A00              <1> 	mov		cx, RAMVARS_size
  9494 00000401 31FF                <1> 	xor		di, di
  9495 00000403 E815FF              <1> 	call	Memory_ZeroESDIwithSizeInCX
  9496 00000406 C70600005A5A        <1> 	mov		WORD [RAMVARS.wDrvDetectSignature], RAMVARS_DRV_DETECT_SIGNATURE
  9497 0000040C C70604005875        <1> 	mov		WORD [RAMVARS.wSignature], RAMVARS_RAM_SIGNATURE
  9498                              <1> ;; There used to be a DriveXlate_Reset call here.  It isn't necessary, as we reset
  9499                              <1> ;; when entering the boot menu and also before transferring control at boot time and
  9500                              <1> ;; for ROM boots (in int19h.asm).
  9501                              <1> 
  9502 00000412 07                  <1> 	pop		es
  9503 00000413 C3                  <1> 	ret
  9504                              <1> 
  9505                              <1> ;--------------------------------------------------------------------
  9506                              <1> ; Returns segment to RAMVARS.
  9507                              <1> ; RAMVARS might be located at the top of interrupt vectors (0030:0000h)
  9508                              <1> ; or at the top of system base RAM.
  9509                              <1> ;
  9510                              <1> ; RamVars_GetSegmentToDS
  9511                              <1> ;	Parameters:
  9512                              <1> ;		Nothing
  9513                              <1> ;	Returns:
  9514                              <1> ;		DS:		RAMVARS segment
  9515                              <1> ;	Corrupts registers:
  9516                              <1> ;		DI
  9517                              <1> ;--------------------------------------------------------------------
  9518                              <1> ALIGN JUMP_ALIGN
  9519                              <1> RamVars_GetSegmentToDS:
  9520                              <1> 
  9521                              <1> %ifndef USE_AT	; Always in Full Mode for AT builds
  9522 00000414 2EF606460001        <1> 	test	BYTE [cs:ROMVARS.wFlags], FLG_ROMVARS_FULLMODE
  9523 0000041A 7506                <1> 	jnz		SHORT .GetStolenSegmentToDS
  9524                              <1> 	%ifndef USE_186
  9525 0000041C BF3000              <1> 		mov		di, LITE_MODE_RAMVARS_SEGMENT
  9526 0000041F 8EDF                <1> 		mov		ds, di
  9527                              <1> 	%else
  9528                              <1> 		push	LITE_MODE_RAMVARS_SEGMENT
  9529                              <1> 		pop		ds
  9530                              <1> 	%endif
  9531 00000421 C3                  <1> 	ret
  9532                              <1> %endif
  9533                              <1> 
  9534                              <1> ALIGN JUMP_ALIGN
  9535                              <1> .GetStolenSegmentToDS:
  9536                              <1> 	LOAD_BDA_SEGMENT_TO	ds, di
  9537                              <2> %ifndef USE_186
  9538 00000422 31FF                <2>  xor %2, %2
  9539 00000424 8EDF                <2>  mov %1, %2
  9540                              <2> %elifidn %3, !
  9541                              <2>  xor %2, %2
  9542                              <2>  mov %1, %2
  9543                              <2> %else
  9544                              <2>  push BYTE 0
  9545                              <2>  pop %1
  9546                              <2> %endif
  9547 00000426 8B3E1304            <1> 	mov		di, [BDA.wBaseMem]		; Load available base memory size in kB
  9548                              <1> 	eSHL_IM	di, 6					; Segment to first stolen kB (*=40h)
  9549                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9550                              <2> %ifdef USE_386
  9551                              <2>  %if %2 = 1
  9552                              <2>  add %1, %1
  9553                              <2>  %else
  9554                              <2>  eSHIFT_IM %1, %2, shl
  9555                              <2>  %endif
  9556                              <2> %else
  9557                              <2>  eSHIFT_IM %1, %2, shl
  9558                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9559                              <3> %ifndef USE_186
  9560                              <3>  %ifidni %1, cl
  9561                              <3>  times %2 %3 %1, 1
  9562                              <3>  %elifidni %1, ch
  9563                              <3>  times %2 %3 %1, 1
  9564                              <3>  %elifidni %1, cx
  9565                              <3>  times %2 %3 %1, 1
  9566                              <3>  %else
  9567                              <3>  %if %2 > 3
  9568 0000042A 51                  <3>  push cx
  9569 0000042B B106                <3>  mov cl, %2
  9570 0000042D D3E7                <3>  %3 %1, cl
  9571 0000042F 59                  <3>  pop cx
  9572                              <3>  %else
  9573                              <3>  times %2 %3 %1, 1
  9574                              <3>  %endif
  9575                              <3>  %endif
  9576                              <3> 
  9577                              <3> %else
  9578                              <3>  %3 %1, %2
  9579                              <3> %endif
  9580                              <3> %endif
  9581                              <2> %endif
  9582                              <2> %endif
  9583                              <1> ALIGN JUMP_ALIGN
  9584                              <1> .LoopStolenKBs:
  9585 00000430 8EDF                <1> 	mov		ds, di					; EBDA segment to DS
  9586 00000432 83C740              <1> 	add		di, BYTE 64				; DI to next stolen kB
  9587 00000435 813E04005875        <1> 	cmp		WORD [RAMVARS.wSignature], RAMVARS_RAM_SIGNATURE
  9588 0000043B 75F3                <1> 	jne		SHORT .LoopStolenKBs	; Loop until sign found (always found eventually)
  9589 0000043D C3                  <1> 	ret
  9590                              <1> 
  9591                              <1> 
  9592                              <1> ;--------------------------------------------------------------------
  9593                              <1> ; RamVars_GetHardDiskCountFromBDAtoAX
  9594                              <1> ;	Parameters:
  9595                              <1> ;		DS:		RAMVARS segment
  9596                              <1> ;	Returns:
  9597                              <1> ;		AX:		Total hard disk count
  9598                              <1> ;	Corrupts registers:
  9599                              <1> ;		BX
  9600                              <1> ;--------------------------------------------------------------------
  9601                              <1> %ifdef MODULE_BOOT_MENU
  9602                              <1> RamVars_GetHardDiskCountFromBDAtoAX:
  9603                              <1> 	call	RamVars_GetCountOfKnownDrivesToAX
  9604                              <1> 	push	ds
  9605                              <1> 	LOAD_BDA_SEGMENT_TO	ds, bx
  9606                              <1> 	mov		bl, [BDA.bHDCount]
  9607                              <1> 	MAX_U	al, bl
  9608                              <1> 	pop		ds
  9609                              <1> 	ret
  9610                              <1> %endif
  9611                              <1> 
  9612                              <1> 
  9613                              <1> ;--------------------------------------------------------------------
  9614                              <1> ; RamVars_GetCountOfKnownDrivesToAX
  9615                              <1> ;	Parameters:
  9616                              <1> ;		DS:		RAMVARS segment
  9617                              <1> ;	Returns:
  9618                              <1> ;		AX:		Total hard disk count
  9619                              <1> ;	Corrupts registers:
  9620                              <1> ;		None
  9621                              <1> ;--------------------------------------------------------------------
  9622                              <1> ALIGN JUMP_ALIGN
  9623                              <1> RamVars_GetCountOfKnownDrivesToAX:
  9624 0000043E A10800              <1> 	mov		ax, [RAMVARS.wFirstDrvAndCount]
  9625 00000441 00E0                <1> 	add		al, ah
  9626 00000443 83E07F              <1> 	and		ax, BYTE 7fh
  9627 00000446 C3                  <1> 	ret
  9628                              <1> 
  9629                              <1> ;--------------------------------------------------------------------
  9630                              <1> ; RamVars_GetIdeControllerCountToCX
  9631                              <1> ;	Parameters:
  9632                              <1> ;		Nothing
  9633                              <1> ;	Returns:
  9634                              <1> ;		CX:		Number of IDE controllers to handle
  9635                              <1> ;	Corrupts registers:
  9636                              <1> ;		Nothing
  9637                              <1> ;--------------------------------------------------------------------
  9638                              <1> ALIGN JUMP_ALIGN
  9639                              <1> RamVars_GetIdeControllerCountToCX:
  9640                              <1> 	eMOVZX	cx, [cs:ROMVARS.bIdeCnt]
  9641                              <2> %ifndef USE_386
  9642                              <2>  %ifidni %1, ax
  9643                              <2>  mov al, %2
  9644                              <2>  xor ah, ah
  9645                              <2>  %elifidni %1, bx
  9646                              <2>  mov bl, %2
  9647                              <2>  xor bh, bh
  9648                              <2>  %elifidni %1, cx
  9649 00000447 2E8A0E4C00          <2>  mov cl, %2
  9650 0000044C 30ED                <2>  xor ch, ch
  9651                              <2>  %elifidni %1, dx
  9652                              <2>  mov dl, %2
  9653                              <2>  xor dh, dh
  9654                              <2>  %else
  9655                              <2>  push ax
  9656                              <2>  mov al, %2
  9657                              <2>  xor ah, ah
  9658                              <2>  xchg ax, %1
  9659                              <2>  pop ax
  9660                              <2>  %endif
  9661                              <2> 
  9662                              <2> %else
  9663                              <2>  movzx %1, %2
  9664                              <2> %endif
  9665 0000044E C3                  <1> 	ret
  9666                              <1> 
  9667                              <1> 
  9668                              <1> %ifdef MODULE_SERIAL_FLOPPY
  9669                              <1> ;--------------------------------------------------------------------
  9670                              <1> ; RamVars_UnpackFlopCntAndFirstToAL
  9671                              <1> ;	Parameters:
  9672                              <1> ;		DS:		RAMVARS segment
  9673                              <1> ;	Returns:
  9674                              <1> ;		AL:		First floppy drive number supported
  9675                              <1> ;       CF:		Number of floppy drives supported (clear = 1, set = 2)
  9676                              <1> ;		SF:		Emulating drives (clear = yes, set = no)
  9677                              <1> ;	Corrupts registers:
  9678                              <1> ;		Nothing
  9679                              <1> ;--------------------------------------------------------------------
  9680                              <1> ALIGN JUMP_ALIGN
  9681                              <1> RamVars_UnpackFlopCntAndFirstToAL:
  9682                              <1> 	mov		al, [RAMVARS.xlateVars+XLATEVARS.bFlopCntAndFirst]
  9683                              <1> 	sar		al, 1
  9684                              <1> 	ret
  9685                              <1> %endif
  9686                              <1> 
  9687                              <1> 
  9688                              <1> %if 0							; unused...
  9689                              <1> ;--------------------------------------------------------------------
  9690                              <1> ; RamVars_IsDriveDetectionInProgress
  9691                              <1> ;	Parameters:
  9692                              <1> ;		DS:		RAMVARS segment
  9693                              <1> ;	Returns:
  9694                              <1> ;		ZF:		Set if drive detection is in progress (ROM initialization)
  9695                              <1> ;	Corrupts registers:
  9696                              <1> ;		None
  9697                              <1> ;--------------------------------------------------------------------
  9698                              <1> RamVars_IsDriveDetectionInProgress:
  9699                              <1> 	cmp		WORD [RAMVARS.wSignature], RAMVARS_DRV_DETECT_SIGNATURE
  9700                              <1> 	ret
  9701                              <1> %endif
  9702                                  	%include "BootVars.asm"			; For initializing variables used during init and boot
  9703                              <1> ; Project name	:	XTIDE Universal BIOS
  9704                              <1> ; Description	:	Functions for accessings BOOTVARS.
  9705                              <1> 
  9706                              <1> ;
  9707                              <1> ; XTIDE Universal BIOS and Associated Tools
  9708                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  9709                              <1> ;
  9710                              <1> ; This program is free software; you can redistribute it and/or modify
  9711                              <1> ; it under the terms of the GNU General Public License as published by
  9712                              <1> ; the Free Software Foundation; either version 2 of the License, or
  9713                              <1> ; (at your option) any later version.
  9714                              <1> ;
  9715                              <1> ; This program is distributed in the hope that it will be useful,
  9716                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9717                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9718                              <1> ; GNU General Public License for more details.
  9719                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  9720                              <1> ;
  9721                              <1> 
  9722                              <1> ; Section containing code
  9723                              <1> SECTION .text
  9724                              <1> 
  9725                              <1> ;--------------------------------------------------------------------
  9726                              <1> ; BootVars_Initialize
  9727                              <1> ;	Parameters:
  9728                              <1> ;		DS:		RAMVARS Segment
  9729                              <1> ;		ES:		BDA Segment
  9730                              <1> ;	Returns:
  9731                              <1> ;		Nothing
  9732                              <1> ;	Corrupts registers:
  9733                              <1> ;		AX, CX, DX, DI
  9734                              <1> ;--------------------------------------------------------------------
  9735                              <1> BootVars_Initialize:
  9736                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
  9737                              <1> 	mov		WORD [es:BOOTVARS.wNextXTCFportToScan], XTCF_BASE_PORT_DETECTION_SEED
  9738                              <1> %endif
  9739                              <1> 
  9740                              <1> 	; Clear all DRVDETECTINFO structs to zero
  9741 0000044F B02A                <1> 	mov		al, DRVDETECTINFO_size
  9742 00000451 2EF6264C00          <1> 	mul		BYTE [cs:ROMVARS.bIdeCnt]
  9743 00000456 BF067F              <1> 	mov		di, BOOTVARS.rgDrvDetectInfo	; We must not initialize anything before this!
  9744 00000459 91                  <1> 	xchg	cx, ax
  9745                              <1> %ifndef MODULE_HOTKEYS
  9746 0000045A E9BEFE              <1> 	jmp		Memory_ZeroESDIwithSizeInCX
  9747                              <1> 
  9748                              <1> %else ; if MODULE_HOTKEYS
  9749                              <1> 	call	Memory_ZeroESDIwithSizeInCX
  9750                              <1> 
  9751                              <1> 	; Initialize HOTKEYVARS by storing default drives to boot from
  9752                              <1> 	call	BootVars_StoreDefaultDriveLettersToHotkeyVars
  9753                              <1> 	mov		dl, [cs:ROMVARS.bBootDrv]
  9754                              <1> 	jmp		HotkeyBar_StoreHotkeyToBootvarsForDriveNumberInDL
  9755                              <1> 
  9756                              <1> 
  9757                              <1> ;--------------------------------------------------------------------
  9758                              <1> ; BootVars_StoreDefaultDriveLettersToHotkeyVars
  9759                              <1> ;	Parameters:
  9760                              <1> ;		ES:		BDA Segment
  9761                              <1> ;	Returns:
  9762                              <1> ;		Nothing
  9763                              <1> ;	Corrupts registers:
  9764                              <1> ;		Nothing
  9765                              <1> ;--------------------------------------------------------------------
  9766                              <1> BootVars_StoreDefaultDriveLettersToHotkeyVars:
  9767                              <1> 	mov		WORD [es:BOOTVARS.hotkeyVars+HOTKEYVARS.wFddAndHddLetters], DEFAULT_FLOPPY_DRIVE_LETTER | (DEFAULT_HARD_DRIVE_LETTER<<8)
  9768                              <1> 	ret
  9769                              <1> 
  9770                              <1> %endif ; MODULE_HOTKEYS
  9771                                  	%include "FloppyDrive.asm"		; Floppy Drive related functions
  9772                              <1> ; Project name	:	XTIDE Universal BIOS
  9773                              <1> ; Description	:	Various floppy drive related functions that
  9774                              <1> ;					Boot Menu uses.
  9775                              <1> 
  9776                              <1> ;
  9777                              <1> ; XTIDE Universal BIOS and Associated Tools
  9778                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  9779                              <1> ;
  9780                              <1> ; This program is free software; you can redistribute it and/or modify
  9781                              <1> ; it under the terms of the GNU General Public License as published by
  9782                              <1> ; the Free Software Foundation; either version 2 of the License, or
  9783                              <1> ; (at your option) any later version.
  9784                              <1> ;
  9785                              <1> ; This program is distributed in the hope that it will be useful,
  9786                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9787                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9788                              <1> ; GNU General Public License for more details.
  9789                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  9790                              <1> ;
  9791                              <1> 
  9792                              <1> ; Section containing code
  9793                              <1> SECTION .text
  9794                              <1> 
  9795                              <1> %ifdef COPY_13H_HANDLER_TO_40H
  9796                              <1> ;--------------------------------------------------------------------
  9797                              <1> ; Checks is floppy drive handler installed to interrupt vector 40h.
  9798                              <1> ;
  9799                              <1> ; FloppyDrive_IsInt40hInstalled
  9800                              <1> ;	Parameters:
  9801                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9802                              <1> ;	Returns:
  9803                              <1> ;		CF:		Set if INT 40h is installed
  9804                              <1> ;				Cleared if INT 40h is not installed
  9805                              <1> ;	Corrupts registers:
  9806                              <1> ;		BX, CX, DI
  9807                              <1> ;--------------------------------------------------------------------
  9808                              <1> FloppyDrive_IsInt40hInstalled:
  9809                              <1> 	cmp		WORD [es:BIOS_DISKETTE_INTERRUPT_40h*4+2], 0C000h	; Any ROM segment?
  9810                              <1> %ifdef USE_AT	; No need to verify on XT systems.
  9811                              <1> 	jb		SHORT .Int40hHandlerIsNotInstalled
  9812                              <1> 	call	.VerifyInt40hHandlerSinceSomeBiosesSimplyReturnFromInt40h
  9813                              <1> .Int40hHandlerIsNotInstalled:
  9814                              <1> %endif
  9815                              <1> 	cmc
  9816                              <1> 	ret
  9817                              <1> 
  9818                              <1> ;--------------------------------------------------------------------
  9819                              <1> ; .VerifyInt40hHandlerSinceSomeBiosesSimplyReturnFromInt40h
  9820                              <1> ;	Parameters:
  9821                              <1> ;		Nothing
  9822                              <1> ;	Returns:
  9823                              <1> ;		CF:		Cleared if INT 40h is installed
  9824                              <1> ;				Set if INT 40h is not installed
  9825                              <1> ;	Corrupts registers:
  9826                              <1> ;		BX, CX, DI
  9827                              <1> ;--------------------------------------------------------------------
  9828                              <1> %ifdef USE_AT
  9829                              <1> .VerifyInt40hHandlerSinceSomeBiosesSimplyReturnFromInt40h:
  9830                              <1> 	push	es
  9831                              <1> 	push	dx
  9832                              <1> 	push	ax
  9833                              <1> 
  9834                              <1> 	call	.LoadInt40hVerifyParameters
  9835                              <1> 	int		BIOS_DISK_INTERRUPT_13h
  9836                              <1> 	jc		SHORT .Int40hIsInstalled	; Maybe there are not any floppy drives at all
  9837                              <1> 	push	es
  9838                              <1> 	push	di
  9839                              <1> 
  9840                              <1> 	call	.LoadInt40hVerifyParameters
  9841                              <1> 	int		BIOS_DISKETTE_INTERRUPT_40h
  9842                              <1> 
  9843                              <1> 	pop		dx
  9844                              <1> 	pop		cx
  9845                              <1> 	cmp		dx, di						; Difference in offsets?
  9846                              <1> 	jne		SHORT .Int40hNotInstalled
  9847                              <1> 	mov		dx, es
  9848                              <1> 	cmp		cx, dx						; Difference in segments?
  9849                              <1> 	je		SHORT .Int40hIsInstalled
  9850                              <1> .Int40hNotInstalled:
  9851                              <1> 	stc
  9852                              <1> .Int40hIsInstalled:
  9853                              <1> 	pop		ax
  9854                              <1> 	pop		dx
  9855                              <1> 	pop		es
  9856                              <1> 	ret
  9857                              <1> 
  9858                              <1> ;--------------------------------------------------------------------
  9859                              <1> ; .LoadInt40hVerifyParameters
  9860                              <1> ;	Parameters:
  9861                              <1> ;		Nothing
  9862                              <1> ;	Returns:
  9863                              <1> ;		AH:		08h (Get Drive Parameters)
  9864                              <1> ;		DL:		00h (floppy drive)
  9865                              <1> ;		ES:DI:	0:0h (to guard against BIOS bugs)
  9866                              <1> ;	Corrupts registers:
  9867                              <1> ;		DH
  9868                              <1> ;--------------------------------------------------------------------
  9869                              <1> .LoadInt40hVerifyParameters:
  9870                              <1> 	mov		ah, 08h				; Get Drive Parameters
  9871                              <1> 	cwd							; Floppy drive 0
  9872                              <1> 	mov		di, dx
  9873                              <1> 	mov		es, dx				; ES:DI = 0000:0000h to guard against BIOS bugs
  9874                              <1> 	ret
  9875                              <1> %endif
  9876                              <1> 
  9877                              <1> %endif ; COPY_13H_HANDLER_TO_40H
  9878                              <1> 
  9879                              <1> 
  9880                              <1> ;--------------------------------------------------------------------
  9881                              <1> ; Returns floppy drive type.
  9882                              <1> ; PC/XT system do not support AH=08h but FLOPPY_TYPE_525_OR_35_DD
  9883                              <1> ; is still returned for them.
  9884                              <1> ;
  9885                              <1> ; FloppyDrive_GetType
  9886                              <1> ;	Parameters:
  9887                              <1> ;		DL:		Floppy Drive number
  9888                              <1> ;	Returns:
  9889                              <1> ;		BX:		Floppy Drive Type:
  9890                              <1> ;					FLOPPY_TYPE_525_OR_35_DD
  9891                              <1> ;					FLOPPY_TYPE_525_DD
  9892                              <1> ;					FLOPPY_TYPE_525_HD
  9893                              <1> ;					FLOPPY_TYPE_35_DD
  9894                              <1> ;					FLOPPY_TYPE_35_HD
  9895                              <1> ;					FLOPPY_TYPE_35_ED
  9896                              <1> ;		CF:		Set if AH=08h not supported (XT systems) or error
  9897                              <1> ;				Cleared if type read correctly (AT systems)
  9898                              <1> ;	Corrupts registers:
  9899                              <1> ;		AX, CX, DX, DI, ES
  9900                              <1> ;--------------------------------------------------------------------
  9901                              <1> %ifdef MODULE_BOOT_MENU
  9902                              <1> FloppyDrive_GetType:
  9903                              <1> 	mov		ah, 08h			; Get Drive Parameters
  9904                              <1> 	xor		bx, bx			; FLOPPY_TYPE_525_OR_35_DD when function not supported
  9905                              <1> 	int		BIOS_DISKETTE_INTERRUPT_40h
  9906                              <1> 	ret
  9907                              <1> %endif
  9908                              <1> 
  9909                              <1> 
  9910                              <1> ;--------------------------------------------------------------------
  9911                              <1> ; Returns number of Floppy Drives in system.
  9912                              <1> ;
  9913                              <1> ; FloppyDrive_GetCountToAX
  9914                              <1> ;	Parameters:
  9915                              <1> ;		DS:		RAMVARS Segment
  9916                              <1> ;	Returns:
  9917                              <1> ;		AX:		Number of Floppy Drives
  9918                              <1> ;--------------------------------------------------------------------
  9919                              <1> FloppyDrive_GetCountToAX:
  9920                              <1> %ifdef MODULE_SERIAL_FLOPPY
  9921                              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
  9922                              <1> 	js		.UseBIOSorBDA				; We didn't add in any drives, counts here are not valid
  9923                              <1> 
  9924                              <1> 	adc		al,1						; adds in the drive count bit, and adds 1 for count vs. 0-index,
  9925                              <1> 	jmp		.FinishCalc					; need to clear AH on the way out, and add in minimum drive numbers
  9926                              <1> 
  9927                              <1> .UseBIOSorBDA:
  9928                              <1> %endif
  9929 0000045D E80D00              <1> 	call	FloppyDrive_GetCountFromBIOS_or_BDA
  9930                              <1> 
  9931                              <1> .FinishCalc:
  9932 00000460 2E8A264E00          <1> 	mov		ah, [cs:ROMVARS.bMinFddCnt]
  9933                              <1> 	MAX_U	al, ah
  9934 00000465 38E0                <2>  cmp %1, %2
  9935 00000467 7702                <2>  ja %%Return
  9936 00000469 88E0                <2>  mov %1, %2
  9937                              <2> ALIGN JUMP_ALIGN
  9938                              <2> %%Return:
  9939 0000046B 98                  <1> 	cbw
  9940                              <1> 
  9941 0000046C C3                  <1> 	ret
  9942                              <1> 
  9943                              <1> FloppyDrive_GetCountFromBIOS_or_BDA:
  9944 0000046D 06                  <1> 	push	es
  9945                              <1> 
  9946                              <1> ;--------------------------------------------------------------------
  9947                              <1> ; Reads Floppy Drive Count from BIOS.
  9948                              <1> ; Does not work on most XT systems. Call .GetCountFromBDA
  9949                              <1> ; if this function fails.
  9950                              <1> ;
  9951                              <1> ; .GetCountFromBIOS
  9952                              <1> ;	Parameters:
  9953                              <1> ;		Nothing
  9954                              <1> ;	Returns:
  9955                              <1> ;		AL:		Number of Floppy Drives
  9956                              <1> ;		CF:		Cleared if successful
  9957                              <1> ;				Set if BIOS function not supported
  9958                              <1> ;	Corrupts registers:
  9959                              <1> ;		ES
  9960                              <1> ;--------------------------------------------------------------------
  9961                              <1> %ifdef USE_AT
  9962                              <1> .GetCountFromBIOS:
  9963                              <1> 	push	di
  9964                              <1> 	push	bx
  9965                              <1> 	push	cx
  9966                              <1> 	push	dx
  9967                              <1> 
  9968                              <1> 	mov		ah, 08h					; Get Drive Parameters
  9969                              <1> 	cwd								; Floppy Drive 00h
  9970                              <1> 	int		BIOS_DISKETTE_INTERRUPT_40h
  9971                              <1> 	mov		al, dl					; Number of Floppy Drives to AL
  9972                              <1> 
  9973                              <1> 	pop		dx
  9974                              <1> 	pop		cx
  9975                              <1> 	pop		bx
  9976                              <1> 	pop		di
  9977                              <1> %endif
  9978                              <1> 
  9979                              <1> ;--------------------------------------------------------------------
  9980                              <1> ; Reads Floppy Drive Count (0...4) from BIOS Data Area.
  9981                              <1> ; This function should be used only if .GetCountFromBIOS fails.
  9982                              <1> ;
  9983                              <1> ; .GetCountFromBDA
  9984                              <1> ;	Parameters:
  9985                              <1> ;		Nothing
  9986                              <1> ;	Returns:
  9987                              <1> ;		AL:		Number of Floppy Drives
  9988                              <1> ;	Corrupts registers:
  9989                              <1> ;		AH, ES
  9990                              <1> ;--------------------------------------------------------------------
  9991                              <1> %ifndef USE_AT
  9992                              <1> .GetCountFromBDA:
  9993                              <1> 	LOAD_BDA_SEGMENT_TO	es, ax
  9994                              <2> %ifndef USE_186
  9995 0000046E 31C0                <2>  xor %2, %2
  9996 00000470 8EC0                <2>  mov %1, %2
  9997                              <2> %elifidn %3, !
  9998                              <2>  xor %2, %2
  9999                              <2>  mov %1, %2
 10000                              <2> %else
 10001                              <2>  push BYTE 0
 10002                              <2>  pop %1
 10003                              <2> %endif
 10004 00000472 26A01004            <1> 	mov		al, [es:BDA.wEquipment]			; Load Equipment WORD low byte
 10005 00000476 88C4                <1> 	mov		ah, al							; Copy it to AH
 10006 00000478 2501C0              <1> 	and		ax, 0C001h						; Leave bits 15..14 and 0
 10007                              <1> 	eROL_IM	ah, 2							; EW low byte bits 7..6 to 1..0
 10008                              <2>  eSHIFT_IM %1, %2, rol
 10009                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10010                              <3> %ifndef USE_186
 10011                              <3>  %ifidni %1, cl
 10012                              <3>  times %2 %3 %1, 1
 10013                              <3>  %elifidni %1, ch
 10014                              <3>  times %2 %3 %1, 1
 10015                              <3>  %elifidni %1, cx
 10016                              <3>  times %2 %3 %1, 1
 10017                              <3>  %else
 10018                              <3>  %if %2 > 3
 10019                              <3>  push cx
 10020                              <3>  mov cl, %2
 10021                              <3>  %3 %1, cl
 10022                              <3>  pop cx
 10023                              <3>  %else
 10024 0000047B D0C4<rept>          <3>  times %2 %3 %1, 1
 10025                              <3>  %endif
 10026                              <3>  %endif
 10027                              <3> 
 10028                              <3> %else
 10029                              <3>  %3 %1, %2
 10030                              <3> %endif
 10031                              <3> %endif
 10032 0000047F 00E0                <1> 	add		al, ah							; AL = Floppy Drive count
 10033                              <1> %endif
 10034                              <1> 
 10035 00000481 07                  <1> 	pop		es
 10036 00000482 C3                  <1> 	ret
 10037                                  	%include "CreateDPT.asm"		; For creating DPTs
 10038                              <1> ; Project name	:	XTIDE Universal BIOS
 10039                              <1> ; Description	:	Functions for creating Disk Parameter Table.
 10040                              <1> 
 10041                              <1> ;
 10042                              <1> ; XTIDE Universal BIOS and Associated Tools
 10043                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 10044                              <1> ;
 10045                              <1> ; This program is free software; you can redistribute it and/or modify
 10046                              <1> ; it under the terms of the GNU General Public License as published by
 10047                              <1> ; the Free Software Foundation; either version 2 of the License, or
 10048                              <1> ; (at your option) any later version.
 10049                              <1> ;
 10050                              <1> ; This program is distributed in the hope that it will be useful,
 10051                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10052                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10053                              <1> ; GNU General Public License for more details.
 10054                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 10055                              <1> ;
 10056                              <1> 
 10057                              <1> ; Section containing code
 10058                              <1> SECTION .text
 10059                              <1> 
 10060                              <1> ;--------------------------------------------------------------------
 10061                              <1> ; Creates new Disk Parameter Table for detected hard disk.
 10062                              <1> ; Drive is then fully accessible using any BIOS function.
 10063                              <1> ;
 10064                              <1> ; CreateDPT_FromAtaInformation
 10065                              <1> ;	Parameters:
 10066                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 10067                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 10068                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10069                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10070                              <1> ;		DS:		RAMVARS segment
 10071                              <1> ;		ES:		BDA Segment
 10072                              <1> ;	Returns:
 10073                              <1> ;		DS:DI:	Ptr to Disk Parameter Table (if successful)
 10074                              <1> ;		CF:		Cleared if DPT created successfully
 10075                              <1> ;				Set if any error
 10076                              <1> ;	Corrupts registers:
 10077                              <1> ;		AX, BX, CX, DH
 10078                              <1> ;--------------------------------------------------------------------
 10079                              <1> CreateDPT_FromAtaInformation:
 10080 00000483 E8A700              <1> 	call	FindDPT_ForNewDriveToDSDI
 10081                              <1> 	; Fall to .InitializeDPT
 10082                              <1> 
 10083                              <1> ;--------------------------------------------------------------------
 10084                              <1> ; .InitializeDPT
 10085                              <1> ;	Parameters:
 10086                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 10087                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 10088                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10089                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10090                              <1> ;	Returns:
 10091                              <1> ;		Nothing
 10092                              <1> ;	Corrupts registers:
 10093                              <1> ;		AX
 10094                              <1> ;--------------------------------------------------------------------
 10095                              <1> .InitializeDPT:
 10096 00000486 E84100              <1> 	call	CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI
 10097                              <1> 	; Fall to .StoreDriveSelectAndDriveControlByte
 10098                              <1> 
 10099                              <1> ;--------------------------------------------------------------------
 10100                              <1> ; .StoreDriveSelectAndDriveControlByte
 10101                              <1> ;	Parameters:
 10102                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 10103                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10104                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10105                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10106                              <1> ;	Returns:
 10107                              <1> ;		Nothing
 10108                              <1> ;	Corrupts registers:
 10109                              <1> ;		AX
 10110                              <1> ;--------------------------------------------------------------------
 10111                              <1> .StoreDriveSelectAndDriveControlByte:
 10112 00000489 88F8                <1> 	mov		al, bh
 10113 0000048B 83E010              <1> 	and		ax, BYTE FLG_DRVNHEAD_DRV		; AL now has Master/Slave bit
 10114                              <1> %ifdef MODULE_IRQ
 10115                              <1> 	cmp		[cs:bp+IDEVARS.bIRQ], ah		; Interrupts enabled?
 10116                              <1> 	jz		SHORT .StoreFlags				;  If not, do not set interrupt flag
 10117                              <1> 	or		al, FLGL_DPT_ENABLE_IRQ
 10118                              <1> .StoreFlags:
 10119                              <1> %endif
 10120 0000048E 8905                <1> 	mov		[di+DPT.wFlags], ax
 10121                              <1> 	; Fall to .StoreCHSparametersAndAddressingMode
 10122                              <1> 
 10123                              <1> ;--------------------------------------------------------------------
 10124                              <1> ; .StoreCHSparametersAndAddressingMode
 10125                              <1> ;	Parameters:
 10126                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10127                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10128                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10129                              <1> ;	Returns:
 10130                              <1> ;		Nothing
 10131                              <1> ;	Corrupts registers:
 10132                              <1> ;		AX, BX, CX, DX
 10133                              <1> ;--------------------------------------------------------------------
 10134                              <1> .StoreCHSparametersAndAddressingMode:
 10135                              <1> 	; Check if CHS defined in ROMVARS
 10136 00000490 E84200              <1> 	call	GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS
 10137 00000493 F6C120              <1> 	test	cl, FLG_DRVPARAMS_USERCHS
 10138 00000496 7405                <1> 	jz		SHORT .AutodetectPCHSvalues
 10139                              <1> 
 10140                              <1> 	; Translate P-CHS to L-CHS
 10141 00000498 E8FE00              <1> 	call	AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX
 10142 0000049B EB03                <1> 	jmp		SHORT .StoreLCHStoDPT
 10143                              <1> .AutodetectPCHSvalues:
 10144 0000049D E8F600              <1> 	call	AtaGeometry_GetLCHStoAXBLBHfromAtaInfoInESSIandTranslateModeInDX
 10145                              <1> 
 10146                              <1> .StoreLCHStoDPT:
 10147                              <1> 	eSHL_IM	dl, TRANSLATEMODE_FIELD_POSITION
 10148                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10149                              <2> %ifdef USE_386
 10150                              <2>  %if %2 = 1
 10151                              <2>  add %1, %1
 10152                              <2>  %else
 10153                              <2>  eSHIFT_IM %1, %2, shl
 10154                              <2>  %endif
 10155                              <2> %else
 10156                              <2>  eSHIFT_IM %1, %2, shl
 10157                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10158                              <3> %ifndef USE_186
 10159                              <3>  %ifidni %1, cl
 10160                              <3>  times %2 %3 %1, 1
 10161                              <3>  %elifidni %1, ch
 10162                              <3>  times %2 %3 %1, 1
 10163                              <3>  %elifidni %1, cx
 10164                              <3>  times %2 %3 %1, 1
 10165                              <3>  %else
 10166                              <3>  %if %2 > 3
 10167                              <3>  push cx
 10168                              <3>  mov cl, %2
 10169                              <3>  %3 %1, cl
 10170                              <3>  pop cx
 10171                              <3>  %else
 10172 000004A0 D0E2<rept>          <3>  times %2 %3 %1, 1
 10173                              <3>  %endif
 10174                              <3>  %endif
 10175                              <3> 
 10176                              <3> %else
 10177                              <3>  %3 %1, %2
 10178                              <3> %endif
 10179                              <3> %endif
 10180                              <2> %endif
 10181                              <2> %endif
 10182 000004A4 08D1                <1> 	or		cl, dl
 10183 000004A6 080D                <1> 	or		[di+DPT.bFlagsLow], cl		; Shift count and addressing mode
 10184 000004A8 894506              <1> 	mov		[di+DPT.wLchsCylinders], ax
 10185 000004AB 895D08              <1> 	mov		[di+DPT.wLchsHeadsAndSectors], bx
 10186                              <1> 
 10187                              <1> 	; Store P-CHS to DPT
 10188 000004AE E81001              <1> 	call	AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI
 10189 000004B1 885D0A              <1> 	mov		[di+DPT.bPchsHeads], bl
 10190                              <1> %ifdef MODULE_EBIOS
 10191                              <1> 	mov		[di+DPT.wPchsCylinders], ax
 10192                              <1> 	mov		[di+DPT.bPchsSectorsPerTrack], bh
 10193                              <1> 	; Fall to .StoreNumberOfLbaSectors
 10194                              <1> 
 10195                              <1> ;--------------------------------------------------------------------
 10196                              <1> ; .StoreNumberOfLbaSectors
 10197                              <1> ;	Parameters:
 10198                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10199                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10200                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10201                              <1> ;	Returns:
 10202                              <1> ;		Nothing
 10203                              <1> ;	Corrupts registers:
 10204                              <1> ;		AX, BX, CX, DX
 10205                              <1> ;--------------------------------------------------------------------
 10206                              <1> 	; Check if LBA supported
 10207                              <1> 	test	BYTE [es:si+ATA1.wCaps+1], A1_wCaps_LBA>>8
 10208                              <1> 	jz		SHORT .NoLbaSupportedSoNoEBIOS
 10209                              <1> 
 10210                              <1> 	; Store LBA 28/48 total sector count
 10211                              <1> 	call	AtaGeometry_GetLbaSectorCountToBXDXAXfromAtaInfoInESSI
 10212                              <1> 	call	StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX
 10213                              <1> 
 10214                              <1> 	; Load user defined LBA
 10215                              <1> 	call	GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS
 10216                              <1> 	test	cl, FLG_DRVPARAMS_USERLBA
 10217                              <1> 	jz		SHORT .KeepTotalSectorsFromAtaID
 10218                              <1> 
 10219                              <1> 	; Compare user defined and ATA-ID sector count and select smaller
 10220                              <1> 	mov		dx, bx
 10221                              <1> 	xor		bx, bx		; User defined LBA now in BX:DX:AX
 10222                              <1> 	cmp		bx, [di+DPT.twLbaSectors+4]
 10223                              <1> 	jb		SHORT .StoreUserDefinedSectorCountToDPT
 10224                              <1> 	cmp		dx, [di+DPT.twLbaSectors+2]
 10225                              <1> 	jb		SHORT .StoreUserDefinedSectorCountToDPT
 10226                              <1> 	ja		SHORT .KeepTotalSectorsFromAtaID
 10227                              <1> 	cmp		ax, [di+DPT.twLbaSectors]
 10228                              <1> 	jae		SHORT .KeepTotalSectorsFromAtaID
 10229                              <1> .StoreUserDefinedSectorCountToDPT:
 10230                              <1> 	; CL bit FLGL_DPT_LBA48 is clear at this point
 10231                              <1> 	call	StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX
 10232                              <1> 
 10233                              <1> .KeepTotalSectorsFromAtaID:
 10234                              <1> .NoLbaSupportedSoNoEBIOS:
 10235                              <1> %endif ; MODULE_EBIOS
 10236                              <1> 	; Fall to .StoreBlockMode
 10237                              <1> 
 10238                              <1> ;--------------------------------------------------------------------
 10239                              <1> ; .StoreBlockMode
 10240                              <1> ;	Parameters:
 10241                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10242                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10243                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10244                              <1> ;	Returns:
 10245                              <1> ;		Nothing
 10246                              <1> ;	Corrupts registers:
 10247                              <1> ;		Nothing
 10248                              <1> ;--------------------------------------------------------------------
 10249                              <1> .StoreBlockMode:
 10250 000004B4 26807C5E01          <1> 	cmp		BYTE [es:si+ATA1.bBlckSize], 1	; Max block size in sectors
 10251 000004B9 7604                <1> 	jbe		SHORT .BlockModeTransfersNotSupported
 10252 000004BB 804D0102            <1> 	or		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_BLOCK_MODE_SUPPORTED
 10253                              <1> .BlockModeTransfersNotSupported:
 10254                              <1> 	; Fall to .StoreDeviceSpecificParameters
 10255                              <1> 
 10256                              <1> ;--------------------------------------------------------------------
 10257                              <1> ; .StoreDeviceSpecificParameters
 10258                              <1> ;	Parameters:
 10259                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10260                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10261                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10262                              <1> ;	Returns:
 10263                              <1> ;		Nothing
 10264                              <1> ;	Corrupts registers:
 10265                              <1> ;		AX, BX, CX, DX
 10266                              <1> ;--------------------------------------------------------------------
 10267                              <1> .StoreDeviceSpecificParameters:
 10268 000004BF E83607              <1> 	call	Device_FinalizeDPT
 10269                              <1> 
 10270                              <1> ;----------------------------------------------------------------------
 10271                              <1> ; Update drive counts (hard and floppy)
 10272                              <1> ;----------------------------------------------------------------------
 10273                              <1> 
 10274                              <1> %ifdef MODULE_SERIAL_FLOPPY
 10275                              <1> ;
 10276                              <1> ; These two instructions serve two purposes:
 10277                              <1> ; 1. If the drive is a floppy drive (CF set), then we effectively increment the counter.
 10278                              <1> ; 2. If this is a hard disk, and there have been any floppy drives previously added, then the hard disk is
 10279                              <1> ;    effectively discarded.  This is more of a safety check then code that should ever normally be hit (see below).
 10280                              <1> ;    Since the floppy DPT's come after the hard disk DPT's, without expensive (code size) code to relocate a DPT,
 10281                              <1> ;    this was necessary.  Now, this situation shouldn't happen in normal operation, for a couple of reasons:
 10282                              <1> ; 		A. xtidecfg always puts configured serial ports at the end of the IDEVARS list
 10283                              <1> ;       B. the auto serial code is always executed last
 10284                              <1> ;       C. the serial server always returns floppy drives last
 10285                              <1> ;
 10286                              <1> 	adc		byte [RAMVARS.xlateVars+XLATEVARS.bFlopCreateCnt], 0
 10287                              <1> 	jnz		.AllDone
 10288                              <1> %else
 10289                              <1> ;
 10290                              <1> ; Even without floppy support enabled, we shouldn't try to mount a floppy image as a hard disk, which
 10291                              <1> ; could lead to unpredictable results since no MBR will be present, etc.  The server doesn't know that
 10292                              <1> ; floppies are supported, so it is important to still fail here if a floppy is seen during the drive scan.
 10293                              <1> ;
 10294 000004C2 7204                <1> 	jc		.AllDone
 10295                              <1> %endif
 10296                              <1> 
 10297 000004C4 FE060900            <1> 	inc		BYTE [RAMVARS.bDrvCnt]		; Increment drive count to RAMVARS
 10298                              <1> 
 10299                              <1> .AllDone:
 10300 000004C8 F8                  <1> 	clc
 10301 000004C9 C3                  <1> 	ret
 10302                              <1> 
 10303                              <1> 
 10304                              <1> ;--------------------------------------------------------------------
 10305                              <1> ; CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI
 10306                              <1> ;	Parameters:
 10307                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 10308                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10309                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10310                              <1> ;	Returns:
 10311                              <1> ;		Nothing
 10312                              <1> ;	Corrupts registers:
 10313                              <1> ;		AX
 10314                              <1> ;--------------------------------------------------------------------
 10315                              <1> CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI:
 10316 000004CA 896D02              <1> 	mov		[di+DPT.bIdevarsOffset], bp		; IDEVARS must start in first 256 bytes of ROM
 10317                              <1> 
 10318                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 10319                              <1> 	call	DetectDrives_DoesIdevarsInCSBPbelongToXTCF
 10320                              <1> 	jne		SHORT .DeviceUsesPortSpecifiedInIDEVARS
 10321                              <1> 	mov		[di+DPT.wBasePort], dx
 10322                              <1> 	ret
 10323                              <1> .DeviceUsesPortSpecifiedInIDEVARS:
 10324                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 10325                              <1> 
 10326 000004CD 2E8B4600            <1> 	mov		ax, [cs:bp+IDEVARS.wBasePort]
 10327 000004D1 894504              <1> 	mov		[di+DPT.wBasePort], ax
 10328 000004D4 C3                  <1> 	ret
 10329                              <1> 
 10330                              <1> 
 10331                              <1> ;--------------------------------------------------------------------
 10332                              <1> ; GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS
 10333                              <1> ;	Parameters:
 10334                              <1> ;		DS:DI:		Ptr to Disk Parameter Table
 10335                              <1> ;	Returns:
 10336                              <1> ;		AX:			User defined P-CHS Cylinders or LBA low word
 10337                              <1> ;		BX:			User defined P-CHS Heads and Sectors or LBA high word
 10338                              <1> ;		DX:			Translate mode or TRANSLATEMODE_AUTO
 10339                              <1> ;		CX:			FLG_DRVPARAMS_USERCHS if user defined CHS in BX:AX
 10340                              <1> ;					FLG_DRVPARAMS_USERLBA if user defined LBA in BX:AX
 10341                              <1> ;					Zero if user has not defined capacity
 10342                              <1> ;	Corrupts registers:
 10343                              <1> ;		Nothing
 10344                              <1> ;--------------------------------------------------------------------
 10345                              <1> GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS:
 10346 000004D5 E8A900              <1> 	call	AccessDPT_GetPointerToDRVPARAMStoCSBX
 10347                              <1> 
 10348                              <1> 	; Get settings
 10349 000004D8 2E8B0F              <1> 	mov		cx, [cs:bx+DRVPARAMS.wFlags]
 10350 000004DB 89CA                <1> 	mov		dx, cx
 10351 000004DD 83E160              <1> 	and		cx, BYTE FLG_DRVPARAMS_USERCHS | FLG_DRVPARAMS_USERLBA
 10352 000004E0 83E20C              <1> 	and		dx, BYTE MASK_DRVPARAMS_TRANSLATEMODE
 10353                              <1> 	eSHR_IM	dx, TRANSLATEMODE_FIELD_POSITION
 10354                              <2>  eSHIFT_IM %1, %2, shr
 10355                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10356                              <3> %ifndef USE_186
 10357                              <3>  %ifidni %1, cl
 10358                              <3>  times %2 %3 %1, 1
 10359                              <3>  %elifidni %1, ch
 10360                              <3>  times %2 %3 %1, 1
 10361                              <3>  %elifidni %1, cx
 10362                              <3>  times %2 %3 %1, 1
 10363                              <3>  %else
 10364                              <3>  %if %2 > 3
 10365                              <3>  push cx
 10366                              <3>  mov cl, %2
 10367                              <3>  %3 %1, cl
 10368                              <3>  pop cx
 10369                              <3>  %else
 10370 000004E3 D1EA<rept>          <3>  times %2 %3 %1, 1
 10371                              <3>  %endif
 10372                              <3>  %endif
 10373                              <3> 
 10374                              <3> %else
 10375                              <3>  %3 %1, %2
 10376                              <3> %endif
 10377                              <3> %endif
 10378                              <1> 
 10379                              <1> 	; Get capacity
 10380 000004E7 2E8B4702            <1> 	mov		ax, [cs:bx+DRVPARAMS.wCylinders]		; Or .dwMaximumLBA
 10381 000004EB 2E8B5F04            <1> 	mov		bx, [cs:bx+DRVPARAMS.wHeadsAndSectors]	; Or .dwMaximumLBA+2
 10382 000004EF C3                  <1> 	ret
 10383                              <1> 
 10384                              <1> 
 10385                              <1> %ifdef MODULE_EBIOS
 10386                              <1> ;--------------------------------------------------------------------
 10387                              <1> ; StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX
 10388                              <1> ;	Parameters:
 10389                              <1> ;		BX:DX:AX:	Total Sector Count
 10390                              <1> ;		CL:			FLGL_DPT_LBA48 if LBA48 supported
 10391                              <1> ;		DS:DI:		Ptr to Disk Parameter Table
 10392                              <1> ;	Returns:
 10393                              <1> ;		Nothing
 10394                              <1> ;	Corrupts registers:
 10395                              <1> ;		CL
 10396                              <1> ;--------------------------------------------------------------------
 10397                              <1> StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX:
 10398                              <1> 	or		cl, FLGL_DPT_LBA_AND_EBIOS_SUPPORTED
 10399                              <1> 	and		BYTE [di+DPT.bFlagsLow], ~FLGL_DPT_LBA48
 10400                              <1> 	or		[di+DPT.bFlagsLow], cl
 10401                              <1> 	mov		[di+DPT.twLbaSectors], ax
 10402                              <1> 	mov		[di+DPT.twLbaSectors+2], dx
 10403                              <1> 	mov		[di+DPT.twLbaSectors+4], bx
 10404                              <1> 	ret
 10405                              <1> %endif ; MODULE_EBIOS
 10406                                  	%include "FindDPT.asm"			; For finding DPTs
 10407                              <1> ; Project name	:	XTIDE Universal BIOS
 10408                              <1> ; Description	:	Functions for finding Disk Parameter Table.
 10409                              <1> 
 10410                              <1> ;
 10411                              <1> ; XTIDE Universal BIOS and Associated Tools
 10412                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 10413                              <1> ;
 10414                              <1> ; This program is free software; you can redistribute it and/or modify
 10415                              <1> ; it under the terms of the GNU General Public License as published by
 10416                              <1> ; the Free Software Foundation; either version 2 of the License, or
 10417                              <1> ; (at your option) any later version.
 10418                              <1> ;
 10419                              <1> ; This program is distributed in the hope that it will be useful,
 10420                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10421                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10422                              <1> ; GNU General Public License for more details.
 10423                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 10424                              <1> ;
 10425                              <1> 
 10426                              <1> ; Section containing code
 10427                              <1> SECTION .text
 10428                              <1> 
 10429                              <1> ;--------------------------------------------------------------------
 10430                              <1> ; Checks if drive is handled by this BIOS, and return DPT pointer.
 10431                              <1> ;
 10432                              <1> ; FindDPT_ForDriveNumberInDL
 10433                              <1> ;	Parameters:
 10434                              <1> ;		DL:		Drive number
 10435                              <1> ;		DS:		RAMVARS segment
 10436                              <1> ;	Returns:
 10437                              <1> ;		CF:		Cleared if drive is handled by this BIOS
 10438                              <1> ;				Set if drive belongs to some other BIOS
 10439                              <1> ;		DI:		DPT Pointer if drive is handled by this BIOS
 10440                              <1> ;				Zero if drive belongs to some other BIOS
 10441                              <1> ;	Corrupts registers:
 10442                              <1> ;		Nothing
 10443                              <1> ;--------------------------------------------------------------------
 10444                              <1> ALIGN JUMP_ALIGN
 10445                              <1> FindDPT_ForDriveNumberInDL:
 10446 000004F0 97                  <1> 	xchg	di, ax								; Save the contents of AX in DI
 10447                              <1> 
 10448                              <1> ;
 10449                              <1> ; Check Our Hard Disks
 10450                              <1> ;
 10451 000004F1 A10800              <1> 	mov		ax, [RAMVARS.wFirstDrvAndCount]		; Drive count to AH, First number to AL
 10452 000004F4 00C4                <1> 	add		ah, al								; One past last drive to AH
 10453                              <1> 
 10454                              <1> %ifdef MODULE_SERIAL_FLOPPY
 10455                              <1> 	cmp		dl, ah								; Above last supported?
 10456                              <1> 	jae		SHORT .HardDiskNotHandledByThisBIOS
 10457                              <1> 
 10458                              <1> 	cmp		dl, al								; Below first supported?
 10459                              <1> 	jae		SHORT .CalcDPTForDriveNumber
 10460                              <1> 
 10461                              <1> ALIGN JUMP_ALIGN
 10462                              <1> .HardDiskNotHandledByThisBIOS:
 10463                              <1> ;
 10464                              <1> ; Check Our Floppy Disks
 10465                              <1> ;
 10466                              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
 10467                              <1> 	js		SHORT .DiskIsNotHandledByThisBIOS
 10468                              <1> 
 10469                              <1> 	cbw											; Always 0h (no floppy drive covered above)
 10470                              <1> 	adc		ah, al								; Add in first drive number and number of drives
 10471                              <1> 
 10472                              <1> 	cmp		ah, dl								; Check second drive if two, first drive if only one
 10473                              <1> 	jz		SHORT .CalcDPTForDriveNumber
 10474                              <1> 	cmp		al, dl								; Check first drive in all cases, redundant but OK to repeat
 10475                              <1> 	jnz		SHORT .DiskIsNotHandledByThisBIOS
 10476                              <1> %else
 10477 000004F6 38E2                <1> 	cmp		dl, ah								; Above last supported?
 10478 000004F8 7313                <1> 	jae		SHORT .DiskIsNotHandledByThisBIOS
 10479                              <1> 
 10480 000004FA 38C2                <1> 	cmp		dl, al								; Below first supported?
 10481 000004FC 720F                <1> 	jb		SHORT .DiskIsNotHandledByThisBIOS
 10482                              <1> %endif
 10483                              <1> 	; fall-through to CalcDPTForDriveNumber
 10484                              <1> 
 10485                              <1> ;--------------------------------------------------------------------
 10486                              <1> ; Finds Disk Parameter Table for drive number.
 10487                              <1> ; Not intended to be called except by FindDPT_ForDriveNumberInDL
 10488                              <1> ;
 10489                              <1> ; CalcDPTForDriveNumber
 10490                              <1> ;	Parameters:
 10491                              <1> ;		DL:		Drive number
 10492                              <1> ;		DS:		RAMVARS segment
 10493                              <1> ;       DI:     Saved copy of AX from entry at FindDPT_ForDriveNumberInDL
 10494                              <1> ;	Returns:
 10495                              <1> ;		DS:DI:	Ptr to DPT
 10496                              <1> ;       CF:     Clear
 10497                              <1> ;	Corrupts registers:
 10498                              <1> ;		Nothing
 10499                              <1> ;--------------------------------------------------------------------
 10500                              <1> ALIGN JUMP_ALIGN
 10501                              <1> .CalcDPTForDriveNumber:
 10502 000004FE 52                  <1> 	push	dx
 10503                              <1> 
 10504                              <1> %ifdef MODULE_SERIAL_FLOPPY
 10505                              <1> 	mov		ax, [RAMVARS.wFirstDrvAndCount]
 10506                              <1> 
 10507                              <1> 	test	dl, dl
 10508                              <1> 	js		.harddisk
 10509                              <1> 
 10510                              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
 10511                              <1> 	add		dl, ah						; add in end of hard disk DPT list, floppies start immediately after
 10512                              <1> 
 10513                              <1> ALIGN JUMP_ALIGN
 10514                              <1> .harddisk:
 10515                              <1> 	sub		dl, al						; subtract off beginning of either hard disk or floppy list (as appropriate)
 10516                              <1> %else
 10517 000004FF 2A160800            <1> 	sub		dl, [RAMVARS.bFirstDrv]		; subtract off beginning of hard disk list
 10518                              <1> %endif
 10519                              <1> 
 10520                              <1> .CalcDPTForNewDrive:
 10521 00000503 B00E                <1> 	mov		al, LARGEST_DPT_SIZE
 10522                              <1> 
 10523 00000505 F6E2                <1> 	mul		dl
 10524 00000507 83C00A              <1> 	add		ax, RAMVARS_size			; Clears CF (will not overflow)
 10525                              <1> 
 10526 0000050A 5A                  <1> 	pop		dx
 10527                              <1> 
 10528 0000050B 97                  <1> 	xchg	di, ax						; Restore AX from entry at FindDPT_ForDriveNumber, put DPT pointer in DI
 10529 0000050C C3                  <1> 	ret
 10530                              <1> 
 10531                              <1> ALIGN JUMP_ALIGN
 10532                              <1> .DiskIsNotHandledByThisBIOS:
 10533                              <1> ;
 10534                              <1> ; Drive not found...
 10535                              <1> ;
 10536 0000050D 31C0                <1> 	xor		ax, ax								; Clear DPT pointer
 10537 0000050F F9                  <1> 	stc											; Is not supported by our BIOS
 10538                              <1> 
 10539 00000510 97                  <1> 	xchg	di, ax								; Restore AX from save at top
 10540 00000511 C3                  <1> 	ret
 10541                              <1> 
 10542                              <1> 
 10543                              <1> ;--------------------------------------------------------------------
 10544                              <1> ; FindDPT_MasterOrSingleForIdevarsOffsetInDL
 10545                              <1> ;	Parameters:
 10546                              <1> ;		DL:		Offset to IDEVARS to search for
 10547                              <1> ;		DS:		RAMVARS segment
 10548                              <1> ;	Returns:
 10549                              <1> ;		DS:DI:		Ptr to first DPT with same IDEVARS as in DL
 10550                              <1> ;		CF:			Clear if wanted DPT found
 10551                              <1> ;					Set if DPT not found, or no DPTs present
 10552                              <1> ;	Corrupts registers:
 10553                              <1> ;		SI
 10554                              <1> ;--------------------------------------------------------------------
 10555                              <1> FindDPT_MasterOrSingleForIdevarsOffsetInDL:
 10556 00000512 BE[2605]            <1> 	mov		si, IterateFindFirstDPTforIdevars			; iteration routine (see below)
 10557 00000515 EB27                <1> 	jmp		SHORT FindDPT_IterateAllDPTs				; look for the first drive on this controller, if any
 10558                              <1> 
 10559                              <1> ;--------------------------------------------------------------------
 10560                              <1> ; FindDPT_SlaveForIdevarsOffsetInDL
 10561                              <1> ;	Parameters:
 10562                              <1> ;		DL:		Offset to IDEVARS to search for
 10563                              <1> ;		DS:		RAMVARS segment
 10564                              <1> ;	Returns:
 10565                              <1> ;		DS:DI:		Ptr to second DPT with same IDEVARS as in DL
 10566                              <1> ;		CF:			Clear if wanted DPT found
 10567                              <1> ;					Set if DPT not found, or no DPTs present
 10568                              <1> ;	Corrupts registers:
 10569                              <1> ;		SI
 10570                              <1> ;--------------------------------------------------------------------
 10571                              <1> FindDPT_SlaveForIdevarsOffsetInDL:
 10572 00000517 BE[1C05]            <1> 	mov		si, IterateFindSecondDPTforIdevars			; iteration routine (see below)
 10573 0000051A EB22                <1> 	jmp		SHORT FindDPT_IterateAllDPTs				; look for the second drive on this controller, if any
 10574                              <1> 
 10575                              <1> ;--------------------------------------------------------------------
 10576                              <1> ; Iteration routines for FindDPT_MasterOrSingleForIdevarsOffsetInDL and
 10577                              <1> ; FindDPT_SlaveForIdevarsOffsetInDL, for use with IterateAllDPTs
 10578                              <1> ;
 10579                              <1> ; Returns when DPT is found on the controller with Idevars offset in DL
 10580                              <1> ;
 10581                              <1> ; IterateFindSecondDPTforIdevars
 10582                              <1> ; IterateFindFirstDPTforIdevars
 10583                              <1> ;       DL:		Offset to IDEVARS to search from DPTs
 10584                              <1> ;		SI:		Offset to this callback function
 10585                              <1> ;		DS:DI:	Ptr to DPT to examine
 10586                              <1> ;	Returns:
 10587                              <1> ;		CF:		Clear if wanted DPT found
 10588                              <1> ;				Set if wrong DPT
 10589                              <1> ;--------------------------------------------------------------------
 10590                              <1> IterateFindSecondDPTforIdevars:
 10591 0000051C E80700              <1> 	call	IterateFindFirstDPTforIdevars
 10592 0000051F 7203                <1> 	jc		SHORT .WrongController
 10593 00000521 BE[2605]            <1> 	mov		si, IterateFindFirstDPTforIdevars
 10594                              <1> .WrongController:
 10595 00000524 F9                  <1> 	stc
 10596 00000525 C3                  <1> 	ret
 10597                              <1> 
 10598                              <1> IterateFindFirstDPTforIdevars:
 10599 00000526 3A5502              <1> 	cmp		dl, [di+DPT.bIdevarsOffset]			; Clears CF if matched
 10600 00000529 7401                <1> 	je		.done
 10601 0000052B F9                  <1> 	stc											; Set CF for not found
 10602                              <1> .done:
 10603 0000052C C3                  <1> 	ret
 10604                              <1> 
 10605                              <1> 
 10606                              <1> ;--------------------------------------------------------------------
 10607                              <1> ; Finds pointer to first unused Disk Parameter Table.
 10608                              <1> ; Should only be used before DetectDrives is complete (not valid after this time).
 10609                              <1> ;
 10610                              <1> ; FindDPT_ForNewDriveToDSDI
 10611                              <1> ;	Parameters:
 10612                              <1> ;		DS:		RAMVARS segment
 10613                              <1> ;	Returns:
 10614                              <1> ;		DS:DI:	Ptr to first unused DPT
 10615                              <1> ;	Corrupts registers:
 10616                              <1> ;		AX
 10617                              <1> ;--------------------------------------------------------------------
 10618                              <1> ALIGN JUMP_ALIGN
 10619                              <1> FindDPT_ForNewDriveToDSDI:
 10620 0000052D 52                  <1> 	push	dx
 10621                              <1> 
 10622                              <1> %ifdef MODULE_SERIAL_FLOPPY
 10623                              <1> 	mov		dx, [RAMVARS.wDrvCntAndFlopCnt]
 10624                              <1> 	add		dl, dh
 10625                              <1> %else
 10626 0000052E 8A160900            <1> 	mov		dl, [RAMVARS.bDrvCnt]
 10627                              <1> %endif
 10628                              <1> 
 10629 00000532 EBCF                <1> 	jmp		short FindDPT_ForDriveNumberInDL.CalcDPTForNewDrive
 10630                              <1> 
 10631                              <1> ;--------------------------------------------------------------------
 10632                              <1> ; IterateToDptWithFlagsHighInBL
 10633                              <1> ;	Parameters:
 10634                              <1> ;		DS:DI:	Ptr to DPT to examine
 10635                              <1> ;       BL:		Bit(s) to test in DPT.bFlagsHigh
 10636                              <1> ;	Returns:
 10637                              <1> ;		CF:		Clear if wanted DPT found
 10638                              <1> ;				Set if wrong DPT
 10639                              <1> ;	Corrupts registers:
 10640                              <1> ;		Nothing
 10641                              <1> ;--------------------------------------------------------------------
 10642                              <1> ALIGN JUMP_ALIGN
 10643                              <1> IterateToDptWithFlagsHighInBL:
 10644 00000534 845D01              <1> 	test	[di+DPT.bFlagsHigh], bl				; Clears CF
 10645 00000537 7501                <1> 	jnz		SHORT .ReturnRightDPT
 10646 00000539 F9                  <1> 	stc
 10647                              <1> .ReturnRightDPT:
 10648 0000053A C3                  <1> 	ret
 10649                              <1> 
 10650                              <1> ;--------------------------------------------------------------------
 10651                              <1> ; FindDPT_ToDSDIforSerialDevice
 10652                              <1> ;	Parameters:
 10653                              <1> ;		DS:		RAMVARS segment
 10654                              <1> ;	Returns:
 10655                              <1> ;		DS:DI:	Ptr to DPT
 10656                              <1> ;		CF:		Set if wanted DPT found
 10657                              <1> ;				Cleared if DPT not found
 10658                              <1> ;	Corrupts registers:
 10659                              <1> ;		SI
 10660                              <1> ;--------------------------------------------------------------------
 10661                              <1> %ifdef MODULE_SERIAL
 10662                              <1> ALIGN JUMP_ALIGN
 10663                              <1> FindDPT_ToDSDIforSerialDevice:
 10664                              <1> 	mov		bl, FLGH_DPT_SERIAL_DEVICE
 10665                              <1> ; fall-through
 10666                              <1> %endif
 10667                              <1> 
 10668                              <1> ;--------------------------------------------------------------------
 10669                              <1> ; FindDPT_ToDSDIforFlagsHigh
 10670                              <1> ;	Parameters:
 10671                              <1> ;		DS:		RAMVARS segment
 10672                              <1> ;       BL:		Bit(s) to test in DPT.bFlagsHigh
 10673                              <1> ;	Returns:
 10674                              <1> ;		DS:DI:	Ptr to DPT
 10675                              <1> ;		CF:		Set if wanted DPT found
 10676                              <1> ;				Cleared if DPT not found
 10677                              <1> ;	Corrupts registers:
 10678                              <1> ;		SI
 10679                              <1> ;--------------------------------------------------------------------
 10680                              <1> %ifdef MODULE_IRQ
 10681                              <1> ALIGN JUMP_ALIGN
 10682                              <1> FindDPT_ToDSDIforFlagsHighInBL:
 10683                              <1> %endif
 10684 0000053B BE[3405]            <1> 	mov		si, IterateToDptWithFlagsHighInBL
 10685                              <1> 	; Fall to IterateAllDPTs
 10686                              <1> 
 10687                              <1> ;--------------------------------------------------------------------
 10688                              <1> ; Iterates all Disk Parameter Tables.
 10689                              <1> ;
 10690                              <1> ; FindDPT_IterateAllDPTs
 10691                              <1> ;	Parameters:
 10692                              <1> ;		AX,BX,DX:	Parameters to callback function
 10693                              <1> ;		CS:SI:		Ptr to callback function
 10694                              <1> ;                   Callback routine should return CF=clear if found
 10695                              <1> ;		DS:			RAMVARS segment
 10696                              <1> ;	Returns:
 10697                              <1> ;		DS:DI:		Ptr to wanted DPT (if found)
 10698                              <1> ;					If not found, points to first empty DPT
 10699                              <1> ;		CF:			Clear if wanted DPT found
 10700                              <1> ;					Set if DPT not found, or no DPTs present
 10701                              <1> ;	Corrupts registers:
 10702                              <1> ;		Nothing unless corrupted by callback function
 10703                              <1> ;--------------------------------------------------------------------
 10704                              <1> ALIGN JUMP_ALIGN
 10705                              <1> FindDPT_IterateAllDPTs:
 10706 0000053E 51                  <1> 	push	cx
 10707                              <1> 
 10708 0000053F BF0A00              <1> 	mov		di, RAMVARS_size			; Point DS:DI to first DPT
 10709                              <1> 	eMOVZX	cx, [RAMVARS.bDrvCnt]
 10710                              <2> %ifndef USE_386
 10711                              <2>  %ifidni %1, ax
 10712                              <2>  mov al, %2
 10713                              <2>  xor ah, ah
 10714                              <2>  %elifidni %1, bx
 10715                              <2>  mov bl, %2
 10716                              <2>  xor bh, bh
 10717                              <2>  %elifidni %1, cx
 10718 00000542 8A0E0900            <2>  mov cl, %2
 10719 00000546 30ED                <2>  xor ch, ch
 10720                              <2>  %elifidni %1, dx
 10721                              <2>  mov dl, %2
 10722                              <2>  xor dh, dh
 10723                              <2>  %else
 10724                              <2>  push ax
 10725                              <2>  mov al, %2
 10726                              <2>  xor ah, ah
 10727                              <2>  xchg ax, %1
 10728                              <2>  pop ax
 10729                              <2>  %endif
 10730                              <2> 
 10731                              <2> %else
 10732                              <2>  movzx %1, %2
 10733                              <2> %endif
 10734 00000548 E309                <1> 	jcxz	.NotFound					; Return if no drives
 10735                              <1> 
 10736                              <1> ALIGN JUMP_ALIGN
 10737                              <1> .LoopWhileDPTsLeft:
 10738 0000054A FFD6                <1> 	call	si							; Is wanted DPT?
 10739 0000054C 7306                <1> 	jnc		SHORT .Found				;  If so, return
 10740 0000054E 83C70E              <1> 	add		di, BYTE LARGEST_DPT_SIZE	; Point to next DPT
 10741 00000551 E2F7                <1> 	loop	.LoopWhileDPTsLeft
 10742                              <1> 
 10743                              <1> ALIGN JUMP_ALIGN
 10744                              <1> .NotFound:
 10745 00000553 F9                  <1> 	stc
 10746                              <1> 
 10747                              <1> ALIGN JUMP_ALIGN
 10748                              <1> .Found:
 10749 00000554 59                  <1> 	pop		cx
 10750 00000555 C3                  <1> 	ret
 10751                                  	%include "AccessDPT.asm"		; For accessing DPTs
 10752                              <1> ; Project name	:	XTIDE Universal BIOS
 10753                              <1> ; Description	:	Functions for accessing DPT data.
 10754                              <1> 
 10755                              <1> ;
 10756                              <1> ; XTIDE Universal BIOS and Associated Tools
 10757                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 10758                              <1> ;
 10759                              <1> ; This program is free software; you can redistribute it and/or modify
 10760                              <1> ; it under the terms of the GNU General Public License as published by
 10761                              <1> ; the Free Software Foundation; either version 2 of the License, or
 10762                              <1> ; (at your option) any later version.
 10763                              <1> ;
 10764                              <1> ; This program is distributed in the hope that it will be useful,
 10765                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10766                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10767                              <1> ; GNU General Public License for more details.
 10768                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 10769                              <1> ;
 10770                              <1> 
 10771                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 10772                              <1> 
 10773                              <1> ; Section containing code
 10774                              <1> SECTION .text
 10775                              <1> 
 10776                              <1> ;--------------------------------------------------------------------
 10777                              <1> ; AccessDPT_GetDriveSelectByteForOldInt13hToAL
 10778                              <1> ; AccessDPT_GetDriveSelectByteForEbiosToAL
 10779                              <1> ;	Parameters:
 10780                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10781                              <1> ;	Returns:
 10782                              <1> ;		AL:		Drive Select Byte
 10783                              <1> ;	Corrupts registers:
 10784                              <1> ;		Nothing
 10785                              <1> ;--------------------------------------------------------------------
 10786                              <1> ALIGN JUMP_ALIGN
 10787                              <1> AccessDPT_GetDriveSelectByteForOldInt13hToAL:
 10788 00000556 8A05                <1> 	mov		al, [di+DPT.bFlagsLow]
 10789 00000558 A808                <1> 	test	al, FLGL_DPT_ASSISTED_LBA
 10790 0000055A 7505                <1> 	jnz		SHORT GetDriveSelectByteForAssistedLBAtoAL
 10791                              <1> 
 10792 0000055C 2410                <1> 	and		al, FLG_DRVNHEAD_DRV	; Clear all but drive select bit
 10793 0000055E 0CA0                <1> 	or		al, MASK_DRVNHEAD_SET	; Bits set to 1 for old drives
 10794 00000560 C3                  <1> 	ret
 10795                              <1> 
 10796                              <1> %ifdef MODULE_EBIOS
 10797                              <1> ALIGN JUMP_ALIGN
 10798                              <1> AccessDPT_GetDriveSelectByteForEbiosToAL:
 10799                              <1> 	mov		al, [di+DPT.bFlagsLow]
 10800                              <1> 	; Fall to GetDriveSelectByteForAssistedLBAtoAL
 10801                              <1> %endif ; MODULE_EBIOS
 10802                              <1> 
 10803                              <1> ALIGN JUMP_ALIGN
 10804                              <1> GetDriveSelectByteForAssistedLBAtoAL:
 10805 00000561 2410                <1> 	and		al, FLG_DRVNHEAD_DRV	; Master / Slave select
 10806 00000563 0CE0                <1> 	or		al, FLG_DRVNHEAD_LBA | MASK_DRVNHEAD_SET
 10807 00000565 C3                  <1> 	ret
 10808                              <1> 
 10809                              <1> 
 10810                              <1> ;--------------------------------------------------------------------
 10811                              <1> ; AccessDPT_GetDeviceControlByteToAL
 10812                              <1> ;	Parameters:
 10813                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10814                              <1> ;	Returns:
 10815                              <1> ;		AL:		Device Control Byte
 10816                              <1> ;	Corrupts registers:
 10817                              <1> ;		Nothing
 10818                              <1> ;--------------------------------------------------------------------
 10819                              <1> ALIGN JUMP_ALIGN
 10820                              <1> AccessDPT_GetDeviceControlByteToAL:
 10821                              <1> %ifdef MODULE_IRQ
 10822                              <1> 
 10823                              <1> %ifndef USE_UNDOC_INTEL
 10824                              <1> 	xor		al, al
 10825                              <1> %endif
 10826                              <1> 
 10827                              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_ENABLE_IRQ	; Clears CF
 10828                              <1> 
 10829                              <1> %ifdef USE_UNDOC_INTEL
 10830                              <1> 	eSALC	; Clears AL using CF while preserving flags
 10831                              <1> %endif
 10832                              <1> 
 10833                              <1> 	jnz		SHORT .EnableDeviceIrq
 10834                              <1> 	or		al, FLG_DEVCONTROL_nIEN	; Disable IRQ
 10835                              <1> .EnableDeviceIrq:
 10836                              <1> %else
 10837 00000566 B002                <1> 	mov		al, FLG_DEVCONTROL_nIEN	; Disable IRQ
 10838                              <1> %endif ; MODULE_IRQ
 10839 00000568 C3                  <1> 	ret
 10840                              <1> 
 10841                              <1> 
 10842                              <1> ;--------------------------------------------------------------------
 10843                              <1> ; AccessDPT_GetLCHStoAXBLBH
 10844                              <1> ;	Parameters:
 10845                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10846                              <1> ;	Returns:
 10847                              <1> ;		AX:		Number of L-CHS cylinders
 10848                              <1> ;		BL:		Number of L-CHS heads
 10849                              <1> ;		BH:		Number of L-CHS sectors per track
 10850                              <1> ;	Corrupts registers:
 10851                              <1> ;		Nothing
 10852                              <1> ;--------------------------------------------------------------------
 10853                              <1> AccessDPT_GetLCHStoAXBLBH:
 10854 00000569 8B4506              <1> 	mov		ax, [di+DPT.wLchsCylinders]
 10855 0000056C 8B5D08              <1> 	mov		bx, [di+DPT.wLchsHeadsAndSectors]
 10856 0000056F C3                  <1> 	ret
 10857                              <1> 
 10858                              <1> 
 10859                              <1> %ifdef MODULE_8BIT_IDE
 10860                              <1> ;--------------------------------------------------------------------
 10861                              <1> ; AccessDPT_IsThisDeviceXTCF
 10862                              <1> ;	Parameters:
 10863                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10864                              <1> ;	Returns:
 10865                              <1> ;		AH:		Device Type
 10866                              <1> ;		ZF:		Set if XTCF
 10867                              <1> ;				Cleared if some other device
 10868                              <1> ;	Corrupts registers:
 10869                              <1> ;		Nothing
 10870                              <1> ;--------------------------------------------------------------------
 10871                              <1> AccessDPT_IsThisDeviceXTCF:
 10872 00000570 8A650C              <1> 	mov		ah, [di+DPT_ATA.bDevice]
 10873 00000573 80FC0A              <1> 	cmp		ah, DEVICE_8BIT_XTCF_PIO8
 10874 00000576 7408                <1> 	je		SHORT .DeviceIsXTCF
 10875 00000578 80FC0C              <1> 	cmp		ah, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
 10876 0000057B 7403                <1> 	je		SHORT .DeviceIsXTCF
 10877 0000057D 80FC0E              <1> 	cmp		ah, DEVICE_8BIT_XTCF_DMA
 10878                              <1> .DeviceIsXTCF:
 10879 00000580 C3                  <1> 	ret		; note also executed if device *not* XT-CF
 10880                              <1> %endif ; MODULE_8BIT_IDE
 10881                              <1> 
 10882                              <1> 
 10883                              <1> %ifdef MODULE_EBIOS
 10884                              <1> ;--------------------------------------------------------------------
 10885                              <1> ; AccessDPT_GetLbaSectorCountToBXDXAX
 10886                              <1> ;	Parameters:
 10887                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10888                              <1> ;	Returns:
 10889                              <1> ;		BX:DX:AX:	48-bit sector count
 10890                              <1> ;	Corrupts registers:
 10891                              <1> ;		Nothing
 10892                              <1> ;--------------------------------------------------------------------
 10893                              <1> AccessDPT_GetLbaSectorCountToBXDXAX:
 10894                              <1> 	mov		ax, [di+DPT.twLbaSectors]
 10895                              <1> 	mov		dx, [di+DPT.twLbaSectors+2]
 10896                              <1> 	mov		bx, [di+DPT.twLbaSectors+4]
 10897                              <1> 	ret
 10898                              <1> %endif ; MODULE_EBIOS
 10899                              <1> 
 10900                              <1> 
 10901                              <1> ;--------------------------------------------------------------------
 10902                              <1> ; Returns pointer to DRVPARAMS for master or slave drive.
 10903                              <1> ;
 10904                              <1> ; AccessDPT_GetPointerToDRVPARAMStoCSBX
 10905                              <1> ;	Parameters:
 10906                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10907                              <1> ;	Returns:
 10908                              <1> ;		CS:BX:	Ptr to DRVPARAMS
 10909                              <1> ;	Corrupts registers:
 10910                              <1> ;		Nothing
 10911                              <1> ;--------------------------------------------------------------------
 10912                              <1> AccessDPT_GetPointerToDRVPARAMStoCSBX:
 10913 00000581 E80C00              <1> 	call	AccessDPT_GetIdevarsToCSBX
 10914 00000584 83C306              <1> 	add		bx, BYTE IDEVARS.drvParamsMaster	; CS:BX points to Master Drive DRVPARAMS
 10915 00000587 F60510              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_SLAVE
 10916 0000058A 7403                <1> 	jz		SHORT .ReturnPointerToDRVPARAMS
 10917 0000058C 83C306              <1> 	add		bx, BYTE DRVPARAMS_size				; CS:BX points to Slave Drive DRVPARAMS
 10918                              <1> .ReturnPointerToDRVPARAMS:
 10919 0000058F C3                  <1> 	ret
 10920                              <1> 
 10921                              <1> 
 10922                              <1> ;--------------------------------------------------------------------
 10923                              <1> ; Needed many times during initialization so it is better to
 10924                              <1> ; make it as a function to save bytes.
 10925                              <1> ;
 10926                              <1> ; AccessDPT_GetIdevarsToCSBX
 10927                              <1> ;	Parameters:
 10928                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10929                              <1> ;	Returns:
 10930                              <1> ;		CS:BX:	Ptr to IDEVARS for the drive
 10931                              <1> ;	Corrupts registers:
 10932                              <1> ;		Nothing
 10933                              <1> ;--------------------------------------------------------------------
 10934                              <1> AccessDPT_GetIdevarsToCSBX:
 10935                              <1> 	eMOVZX	bx, BYTE [di+DPT.bIdevarsOffset]
 10936                              <2> %ifndef USE_386
 10937                              <2>  %ifidni %1, ax
 10938                              <2>  mov al, %2
 10939                              <2>  xor ah, ah
 10940                              <2>  %elifidni %1, bx
 10941 00000590 8A5D02              <2>  mov bl, %2
 10942 00000593 30FF                <2>  xor bh, bh
 10943                              <2>  %elifidni %1, cx
 10944                              <2>  mov cl, %2
 10945                              <2>  xor ch, ch
 10946                              <2>  %elifidni %1, dx
 10947                              <2>  mov dl, %2
 10948                              <2>  xor dh, dh
 10949                              <2>  %else
 10950                              <2>  push ax
 10951                              <2>  mov al, %2
 10952                              <2>  xor ah, ah
 10953                              <2>  xchg ax, %1
 10954                              <2>  pop ax
 10955                              <2>  %endif
 10956                              <2> 
 10957                              <2> %else
 10958                              <2>  movzx %1, %2
 10959                              <2> %endif
 10960 00000595 C3                  <1> 	ret
 10961                              <1> 
 10962                              <1> 
 10963                              <1> ;--------------------------------------------------------------------
 10964                              <1> ; ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF
 10965                              <1> ;	Parameters:
 10966                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10967                              <1> ;	Returns:
 10968                              <1> ;		AX:		Translate Mode (TRANSLATEMODE_NORMAL, TRANSLATEMODE_LARGE or TRANSLATEMODE_ASSISTED_LBA)
 10969                              <1> ;               unshifted (still shifted where it is in bFlagsLow)
 10970                              <1> ;       ZF:     Set based on value in AL
 10971                              <1> ;	Corrupts registers:
 10972                              <1> ;		Nothing
 10973                              <1> ;--------------------------------------------------------------------
 10974                              <1> ;
 10975                              <1> ; Converted to a macro since only called in two places, and the call/ret overhead
 10976                              <1> ; is not worth it for these two instructions (4 bytes total)
 10977                              <1> ;
 10978                              <1> %macro ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF 0
 10979                              <1> 	mov		al, [di+DPT.bFlagsLow]
 10980                              <1> 	and		ax, BYTE MASKL_DPT_TRANSLATEMODE
 10981                              <1> %endmacro
 10982                                  	%include "AtaGeometry.asm"		; For generating L-CHS parameters
 10983                              <1> ; Project name	:	XTIDE Universal BIOS
 10984                              <1> ; Description	:	Functions for generating L-CHS parameters for
 10985                              <1> ;					drives with more than 1024 cylinders.
 10986                              <1> ;
 10987                              <1> ; 					These algorithms are taken from: http://www.mossywell.com/boot-sequence
 10988                              <1> ; 					Take a look at it for more detailed information.
 10989                              <1> ;
 10990                              <1> ;					This file is shared with BIOS Drive Information Tool.
 10991                              <1> 
 10992                              <1> ;
 10993                              <1> ; XTIDE Universal BIOS and Associated Tools
 10994                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 10995                              <1> ;
 10996                              <1> ; This program is free software; you can redistribute it and/or modify
 10997                              <1> ; it under the terms of the GNU General Public License as published by
 10998                              <1> ; the Free Software Foundation; either version 2 of the License, or
 10999                              <1> ; (at your option) any later version.
 11000                              <1> ;
 11001                              <1> ; This program is distributed in the hope that it will be useful,
 11002                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 11003                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 11004                              <1> ; GNU General Public License for more details.
 11005                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 11006                              <1> ;
 11007                              <1> 
 11008                              <1> ; Section containing code
 11009                              <1> SECTION .text
 11010                              <1> 
 11011                              <1> %ifdef MODULE_EBIOS
 11012                              <1> ;--------------------------------------------------------------------
 11013                              <1> ; AtaGeometry_GetLbaSectorCountToBXDXAXfromAtaInfoInESSI
 11014                              <1> ;	Parameters:
 11015                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11016                              <1> ;	Returns:
 11017                              <1> ;		BX:DX:AX:	48-bit sector count
 11018                              <1> ;		CL:			FLGL_DPT_LBA48 if LBA48 supported
 11019                              <1> ;					Zero if only LBA28 is supported
 11020                              <1> ;	Corrupts registers:
 11021                              <1> ;		Nothing
 11022                              <1> ;--------------------------------------------------------------------
 11023                              <1> AtaGeometry_GetLbaSectorCountToBXDXAXfromAtaInfoInESSI:
 11024                              <1> 	mov		bx, Registers_ExchangeDSSIwithESDI
 11025                              <1> 	call	bx	; ATA info now in DS:DI
 11026                              <1> 	push	bx	; We will return via Registers_ExchangeDSSIwithESDI
 11027                              <1> 
 11028                              <1> 	; Check if LBA48 supported
 11029                              <1> 	test	BYTE [di+ATA6.wSetSup83+1], A6_wSetSup83_LBA48>>8
 11030                              <1> 	jz		SHORT .GetLba28SectorCount
 11031                              <1> 
 11032                              <1> 	; Get LBA48 sector count
 11033                              <1> 	mov		cl, FLGL_DPT_LBA48
 11034                              <1> 	mov		ax, [di+ATA6.qwLBACnt]
 11035                              <1> 	mov		dx, [di+ATA6.qwLBACnt+2]
 11036                              <1> 	mov		bx, [di+ATA6.qwLBACnt+4]
 11037                              <1> 	ret
 11038                              <1> 
 11039                              <1> .GetLba28SectorCount:
 11040                              <1> 	xor		cl, cl
 11041                              <1> 	xor		bx, bx
 11042                              <1> 	mov		ax, [di+ATA1.dwLBACnt]
 11043                              <1> 	mov		dx, [di+ATA1.dwLBACnt+2]
 11044                              <1> 	ret
 11045                              <1> %endif	; MODULE_EBIOS
 11046                              <1> 
 11047                              <1> 
 11048                              <1> ;--------------------------------------------------------------------
 11049                              <1> ; AtaGeometry_GetLCHStoAXBLBHfromAtaInfoInESSIandTranslateModeInDX
 11050                              <1> ; AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX
 11051                              <1> ;	Parameters:
 11052                              <1> ;		DX:		Wanted translate mode or TRANSLATEMODE_AUTO to autodetect
 11053                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11054                              <1> ;	Returns:
 11055                              <1> ;		AX:		Number of L-CHS cylinders (1...1027, yes 1027)
 11056                              <1> ;		BL:		Number of L-CHS heads (1...255)
 11057                              <1> ;		BH:		Number of L-CHS sectors per track (1...63)
 11058                              <1> ;		CX:		Number of bits shifted (0...3)
 11059                              <1> ;		DL:		CHS Translate Mode
 11060                              <1> ;	Corrupts registers:
 11061                              <1> ;		DH
 11062                              <1> ;--------------------------------------------------------------------
 11063                              <1> AtaGeometry_GetLCHStoAXBLBHfromAtaInfoInESSIandTranslateModeInDX:
 11064 00000596 E82800              <1> 	call	AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI
 11065                              <1> 	; Fall to AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX
 11066                              <1> 
 11067                              <1> AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX:
 11068                              <1> 	; Check if user defined translate mode
 11069 00000599 4A                  <1> 	dec		dx						; Set ZF if TRANSLATEMODE_LARGE, SF if TRANSLATEMODE_NORMAL
 11070 0000059A 7909                <1> 	jns		SHORT .CheckIfLargeTranslationWanted
 11071                              <1> 	MIN_U	ax, MAX_LCHS_CYLINDERS	; TRANSLATEMODE_NORMAL maximum cylinders
 11072 0000059C 3D0004              <2>  cmp %1, %2
 11073 0000059F 7203                <2>  jb %%Return
 11074 000005A1 B80004              <2>  mov %1, %2
 11075                              <2> ALIGN JUMP_ALIGN
 11076                              <2> %%Return:
 11077 000005A4 42                  <1> 	inc		dx
 11078                              <1> .CheckIfLargeTranslationWanted:
 11079 000005A5 742D                <1> 	jz		SHORT ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL
 11080 000005A7 4A                  <1> 	dec		dx						; Set ZF if TRANSLATEMODE_ASSISTED_LBA
 11081 000005A8 7405                <1> 	jz		SHORT .UseAssistedLBA
 11082                              <1> 	; TRANSLATEMODE_AUTO set
 11083                              <1> 
 11084                              <1> 	; Generate L-CHS using simple bit shift algorithm (ECHS) if
 11085                              <1> 	; 8192 or less cylinders.
 11086 000005AA 3D0020              <1> 	cmp		ax, 8192
 11087 000005AD 7639                <1> 	jbe		SHORT ConvertPCHfromAXBLtoEnhancedCHinAXBL
 11088                              <1> 
 11089                              <1> 	; We have 8193 or more cylinders so two algorithms are available:
 11090                              <1> 	; Revised ECHS or Assisted LBA. The Assisted LBA provides larger
 11091                              <1> 	; capacity but requires LBA support from drive (drives this large
 11092                              <1> 	; always support LBA but user might have unintentionally set LBA).
 11093                              <1> .UseAssistedLBA:
 11094 000005AF 26F6446302          <1> 	test	BYTE [es:si+ATA1.wCaps+1], A1_wCaps_LBA>>8
 11095 000005B4 741E                <1> 	jz		SHORT ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL
 11096                              <1> 
 11097                              <1> 	; Drive supports LBA
 11098 000005B6 E81500              <1> 	call	GetSectorCountToDXAXfromCHSinAXBLBH
 11099 000005B9 E83E00              <1> 	call	ConvertChsSectorCountFromDXAXtoLbaAssistedLCHSinAXBLBH
 11100 000005BC 31C9                <1> 	xor		cx, cx		; No bits to shift
 11101 000005BE B202                <1> 	mov		dl, TRANSLATEMODE_ASSISTED_LBA
 11102 000005C0 C3                  <1> 	ret
 11103                              <1> 
 11104                              <1> 
 11105                              <1> ;--------------------------------------------------------------------
 11106                              <1> ; AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI
 11107                              <1> ;	Parameters:
 11108                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11109                              <1> ;	Returns:
 11110                              <1> ;		AX:		Number of P-CHS cylinders (1...16383)
 11111                              <1> ;		BL:		Number of P-CHS heads (1...16)
 11112                              <1> ;		BH:		Number of P-CHS sectors per track (1...63)
 11113                              <1> ;	Corrupts registers:
 11114                              <1> ;		Nothing
 11115                              <1> ;--------------------------------------------------------------------
 11116                              <1> AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI:
 11117 000005C1 268B4402            <1> 	mov		ax, [es:si+ATA1.wCylCnt]	; Cylinders (1...16383)
 11118 000005C5 268A5C06            <1> 	mov		bl, [es:si+ATA1.wHeadCnt]	; Heads (1...16)
 11119 000005C9 268A7C0C            <1> 	mov		bh, [es:si+ATA1.wSPT]		; Sectors per Track (1...63)
 11120 000005CD C3                  <1> 	ret
 11121                              <1> 
 11122                              <1> 
 11123                              <1> ;--------------------------------------------------------------------
 11124                              <1> ; GetSectorCountToDXAXfromCHSinAXBLBH
 11125                              <1> ;	Parameters:
 11126                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11127                              <1> ;		AX:		Number of cylinders (1...16383)
 11128                              <1> ;		BL:		Number of heads (1...255)
 11129                              <1> ;		BH:		Number of sectors per track (1...63)
 11130                              <1> ;	Returns:
 11131                              <1> ;		DX:AX:	Total number of CHS addressable sectors
 11132                              <1> ;	Corrupts registers:
 11133                              <1> ;		BX
 11134                              <1> ;--------------------------------------------------------------------
 11135                              <1> GetSectorCountToDXAXfromCHSinAXBLBH:
 11136 000005CE 93                  <1> 	xchg	ax, bx
 11137 000005CF F6E4                <1> 	mul		ah			; AX = Heads * Sectors per track
 11138 000005D1 F7E3                <1> 	mul		bx
 11139 000005D3 C3                  <1> 	ret
 11140                              <1> 
 11141                              <1> 
 11142                              <1> ;--------------------------------------------------------------------
 11143                              <1> ; Revised Enhanced CHS calculation (Revised ECHS)
 11144                              <1> ;
 11145                              <1> ; This algorithm translates P-CHS sector count to L-CHS sector count
 11146                              <1> ; with bit shift algorithm. Since 256 heads are not allowed
 11147                              <1> ; (DOS limit), this algorithm makes translations so that maximum of
 11148                              <1> ; 240 L-CHS heads can be used. This makes the maximum addressable capacity
 11149                              <1> ; to 7,927,234,560 bytes ~ 7.38 GiB. LBA addressing needs to be used to
 11150                              <1> ; get more capacity.
 11151                              <1> ;
 11152                              <1> ; L-CHS parameters generated here require the drive to use CHS addressing.
 11153                              <1> ;
 11154                              <1> ; Here is the algorithm:
 11155                              <1> ; If cylinders > 8192 and heads = 16
 11156                              <1> ;  Heads = 15
 11157                              <1> ;  Cylinders = cylinders * 16 / 15 (losing the fraction component)
 11158                              <1> ;  Do a standard ECHS translation
 11159                              <1> ;
 11160                              <1> ; ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL:
 11161                              <1> ;	Parameters:
 11162                              <1> ;		AX:		Number of P-CHS cylinders (8193...16383)
 11163                              <1> ;		BL:		Number of P-CHS heads (1...16)
 11164                              <1> ;	Returns:
 11165                              <1> ;		AX:		Number of L-CHS cylinders (?...1024)
 11166                              <1> ;		BL:		Number of L-CHS heads (?...240)
 11167                              <1> ;		CX:		Number of bits shifted (0...3)
 11168                              <1> ;		DL:		ADDRESSING_MODE_NORMAL or ADDRESSING_MODE_LARGE
 11169                              <1> ;	Corrupts registers:
 11170                              <1> ;		Nothing
 11171                              <1> ;--------------------------------------------------------------------
 11172                              <1> ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL:
 11173                              <1> 	; Generate L-CHS using simple bit shift algorithm (ECHS) if
 11174                              <1> 	; 8192 or less cylinders
 11175 000005D4 3D0020              <1> 	cmp		ax, 8192
 11176 000005D7 760F                <1> 	jbe		SHORT ConvertPCHfromAXBLtoEnhancedCHinAXBL
 11177 000005D9 80FB10              <1> 	cmp		bl, 16	; Drives with 8193 or more cylinders can report 15 heads
 11178 000005DC 720A                <1> 	jb		SHORT ConvertPCHfromAXBLtoEnhancedCHinAXBL
 11179                              <1> 
 11180                              <1> 	eMOVZX	cx, bl	; CX = 16
 11181                              <2> %ifndef USE_386
 11182                              <2>  %ifidni %1, ax
 11183                              <2>  mov al, %2
 11184                              <2>  xor ah, ah
 11185                              <2>  %elifidni %1, bx
 11186                              <2>  mov bl, %2
 11187                              <2>  xor bh, bh
 11188                              <2>  %elifidni %1, cx
 11189 000005DE 88D9                <2>  mov cl, %2
 11190 000005E0 30ED                <2>  xor ch, ch
 11191                              <2>  %elifidni %1, dx
 11192                              <2>  mov dl, %2
 11193                              <2>  xor dh, dh
 11194                              <2>  %else
 11195                              <2>  push ax
 11196                              <2>  mov al, %2
 11197                              <2>  xor ah, ah
 11198                              <2>  xchg ax, %1
 11199                              <2>  pop ax
 11200                              <2>  %endif
 11201                              <2> 
 11202                              <2> %else
 11203                              <2>  movzx %1, %2
 11204                              <2> %endif
 11205 000005E2 4B                  <1> 	dec		bx		; Heads = 15
 11206 000005E3 F7E1                <1> 	mul		cx		; DX:AX = Cylinders * 16
 11207 000005E5 49                  <1> 	dec		cx		; CX = 15
 11208 000005E6 F7F1                <1> 	div		cx		; AX = (Cylinders * 16) / 15
 11209                              <1> 	; Fall to ConvertPCHfromAXBXtoEnhancedCHinAXBX
 11210                              <1> 
 11211                              <1> 
 11212                              <1> ;--------------------------------------------------------------------
 11213                              <1> ; Enhanced CHS calculation (ECHS)
 11214                              <1> ;
 11215                              <1> ; This algorithm translates P-CHS sector count to L-CHS sector count
 11216                              <1> ; with simple bit shift algorithm. Since 256 heads are not allowed
 11217                              <1> ; (DOS limit), this algorithm require that there are at most 8192
 11218                              <1> ; P-CHS cylinders. This makes the maximum addressable capacity
 11219                              <1> ; to 4,227,858,432 bytes ~ 3.94 GiB. Use Revised ECHS or Assisted LBA
 11220                              <1> ; algorithms if there are more than 8192 P-CHS cylinders.
 11221                              <1> ;
 11222                              <1> ; L-CHS parameters generated here require the drive to use CHS addressing.
 11223                              <1> ;
 11224                              <1> ; Here is the algorithm:
 11225                              <1> ;  Multiplier = 1
 11226                              <1> ;  Cylinder = Cylinder - 1
 11227                              <1> ;  Is Cylinder < 1024? If not:
 11228                              <1> ;  Do a right bitwise rotation on the cylinder (i.e., divide by 2)
 11229                              <1> ;  Do a left bitwise rotation on the multiplier (i.e., multiply by 2)
 11230                              <1> ;  Use the multiplier on the Cylinder and Head values to obtain the translated values.
 11231                              <1> ;
 11232                              <1> ; ConvertPCHfromAXBLtoEnhancedCHinAXBL:
 11233                              <1> ;	Parameters:
 11234                              <1> ;		AX:		Number of P-CHS cylinders (1...8192)
 11235                              <1> ;		BL:		Number of P-CHS heads (1...16)
 11236                              <1> ;	Returns:
 11237                              <1> ;		AX:		Number of L-CHS cylinders (?...1024)
 11238                              <1> ;		BL:		Number of L-CHS heads (?...128)
 11239                              <1> ;		CX:		Number of bits shifted (0...3)
 11240                              <1> ;		DL:		TRANSLATEMODE_NORMAL or TRANSLATEMODE_LARGE
 11241                              <1> ;	Corrupts registers:
 11242                              <1> ;		Nothing
 11243                              <1> ;--------------------------------------------------------------------
 11244                              <1> ConvertPCHfromAXBLtoEnhancedCHinAXBL:
 11245 000005E8 31C9                <1> 	xor		cx, cx		; No bits to shift initially
 11246 000005EA 30D2                <1> 	xor		dl, dl		; Assume TRANSLATEMODE_NORMAL
 11247                              <1> .ShiftIfMoreThan1024Cylinder:
 11248 000005EC 3D0004              <1> 	cmp		ax, MAX_LCHS_CYLINDERS
 11249 000005EF 7633                <1> 	jbe		SHORT ReturnLCHSinAXBLBH
 11250 000005F1 D1E8                <1> 	shr		ax, 1		; Halve cylinders
 11251                              <1> 	eSHL_IM	bl, 1		; Double heads
 11252                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 11253                              <2> %ifdef USE_386
 11254                              <2>  %if %2 = 1
 11255                              <2>  add %1, %1
 11256                              <2>  %else
 11257                              <2>  eSHIFT_IM %1, %2, shl
 11258                              <2>  %endif
 11259                              <2> %else
 11260                              <2>  eSHIFT_IM %1, %2, shl
 11261                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 11262                              <3> %ifndef USE_186
 11263                              <3>  %ifidni %1, cl
 11264                              <3>  times %2 %3 %1, 1
 11265                              <3>  %elifidni %1, ch
 11266                              <3>  times %2 %3 %1, 1
 11267                              <3>  %elifidni %1, cx
 11268                              <3>  times %2 %3 %1, 1
 11269                              <3>  %else
 11270                              <3>  %if %2 > 3
 11271                              <3>  push cx
 11272                              <3>  mov cl, %2
 11273                              <3>  %3 %1, cl
 11274                              <3>  pop cx
 11275                              <3>  %else
 11276 000005F3 D0E3                <3>  times %2 %3 %1, 1
 11277                              <3>  %endif
 11278                              <3>  %endif
 11279                              <3> 
 11280                              <3> %else
 11281                              <3>  %3 %1, %2
 11282                              <3> %endif
 11283                              <3> %endif
 11284                              <2> %endif
 11285                              <2> %endif
 11286 000005F5 41                  <1> 	inc		cx			; Increment bit shift count
 11287 000005F6 B201                <1> 	mov		dl, TRANSLATEMODE_LARGE
 11288 000005F8 EBF2                <1> 	jmp		SHORT .ShiftIfMoreThan1024Cylinder
 11289                              <1> 
 11290                              <1> 
 11291                              <1> ;--------------------------------------------------------------------
 11292                              <1> ; LBA assist calculation (or Assisted LBA)
 11293                              <1> ;
 11294                              <1> ; This algorithm translates P-CHS sector count up to largest possible
 11295                              <1> ; L-CHS sector count (1024, 255, 63). Note that INT 13h interface allows
 11296                              <1> ; 256 heads but DOS supports up to 255 head. That is why BIOSes never
 11297                              <1> ; use 256 heads.
 11298                              <1> ;
 11299                              <1> ; L-CHS parameters generated here require the drive to use LBA addressing.
 11300                              <1> ;
 11301                              <1> ; Here is the algorithm:
 11302                              <1> ; If cylinders > 8192
 11303                              <1> ;  Variable CH = Total CHS Sectors / 63
 11304                              <1> ;  Divide (CH  1) by 1024 and add 1
 11305                              <1> ;  Round the result up to the nearest of 16, 32, 64, 128 and 255. This is the value to be used for the number of heads.
 11306                              <1> ;  Divide CH by the number of heads. This is the value to be used for the number of cylinders.
 11307                              <1> ;
 11308                              <1> ; ConvertChsSectorCountFromDXAXtoLbaAssistedLCHSinAXBLBH:
 11309                              <1> ;	Parameters:
 11310                              <1> ;		DX:AX:	Total number of P-CHS sectors for CHS addressing
 11311                              <1> ;				(max = 16383 * 16 * 63 = 16,514,064)
 11312                              <1> ;	Returns:
 11313                              <1> ;		AX:		Number of cylinders (?...1027)
 11314                              <1> ;		BL:		Number of heads (16, 32, 64, 128 or 255)
 11315                              <1> ;		BH:		Number of sectors per track (always 63)
 11316                              <1> ;	Corrupts registers:
 11317                              <1> ;		CX, DX
 11318                              <1> ;--------------------------------------------------------------------
 11319                              <1> ConvertChsSectorCountFromDXAXtoLbaAssistedLCHSinAXBLBH:
 11320                              <1> 	; Value CH = Total sector count / 63
 11321                              <1> 	; Max = 16,514,064 / 63 = 262128
 11322 000005FA B93F00              <1> 	mov		cx, LBA_ASSIST_SPT			; CX = 63
 11323 000005FD E8ECFC              <1> 	call	Math_DivDXAXbyCX
 11324 00000600 52                  <1> 	push	dx
 11325 00000601 50                  <1> 	push	ax							; Value CH stored for later use
 11326                              <1> 
 11327                              <1> 	; BX:DX:AX = Value CH - 1
 11328                              <1> 	; Max = 262128 - 1 = 262127
 11329 00000602 31DB                <1> 	xor		bx, bx
 11330 00000604 83E801              <1> 	sub		ax, BYTE 1
 11331 00000607 19DA                <1> 	sbb		dx, bx
 11332                              <1> 
 11333                              <1> 	; AX = Number of heads = ((Value CH - 1) / 1024) + 1
 11334                              <1> 	; Max = (262127 / 1024) + 1 = 256
 11335 00000609 56                  <1> 	push	si
 11336 0000060A E828FD              <1> 	call	Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
 11337 0000060D 5E                  <1> 	pop		si
 11338 0000060E 40                  <1> 	inc		ax							; + 1
 11339                              <1> 
 11340                              <1> 	; Heads must be 16, 32, 64, 128 or 255 (round up to the nearest)
 11341                              <1> 	; Max = 255
 11342 0000060F B91000              <1> 	mov		cx, 16						; Min number of heads
 11343                              <1> .CompareNextValidNumberOfHeads:
 11344 00000612 39C8                <1> 	cmp		ax, cx
 11345 00000614 7606                <1> 	jbe		SHORT .NumberOfHeadsNowInCX
 11346                              <1> 	eSHL_IM	cl, 1						; Double number of heads
 11347                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 11348                              <2> %ifdef USE_386
 11349                              <2>  %if %2 = 1
 11350                              <2>  add %1, %1
 11351                              <2>  %else
 11352                              <2>  eSHIFT_IM %1, %2, shl
 11353                              <2>  %endif
 11354                              <2> %else
 11355                              <2>  eSHIFT_IM %1, %2, shl
 11356                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 11357                              <3> %ifndef USE_186
 11358                              <3>  %ifidni %1, cl
 11359 00000616 D0E1                <3>  times %2 %3 %1, 1
 11360                              <3>  %elifidni %1, ch
 11361                              <3>  times %2 %3 %1, 1
 11362                              <3>  %elifidni %1, cx
 11363                              <3>  times %2 %3 %1, 1
 11364                              <3>  %else
 11365                              <3>  %if %2 > 3
 11366                              <3>  push cx
 11367                              <3>  mov cl, %2
 11368                              <3>  %3 %1, cl
 11369                              <3>  pop cx
 11370                              <3>  %else
 11371                              <3>  times %2 %3 %1, 1
 11372                              <3>  %endif
 11373                              <3>  %endif
 11374                              <3> 
 11375                              <3> %else
 11376                              <3>  %3 %1, %2
 11377                              <3> %endif
 11378                              <3> %endif
 11379                              <2> %endif
 11380                              <2> %endif
 11381 00000618 75F8                <1> 	jnz		SHORT .CompareNextValidNumberOfHeads	; Reached 256 heads?
 11382 0000061A FEC9                <1> 	dec		cl							;  If so, limit heads to 255
 11383                              <1> .NumberOfHeadsNowInCX:
 11384 0000061C 89CB                <1> 	mov		bx, cx						; Number of heads are returned in BL
 11385 0000061E B73F                <1> 	mov		bh, LBA_ASSIST_SPT			; Sectors per Track
 11386                              <1> 
 11387                              <1> 	; DX:AX = Number of cylinders = Value CH (without - 1) / number of heads
 11388                              <1> 	; Max = 262128 / 255 = 1027
 11389 00000620 58                  <1> 	pop		ax
 11390 00000621 5A                  <1> 	pop		dx							; Value CH back to DX:AX
 11391 00000622 F7F1                <1> 	div		cx
 11392                              <1> 
 11393                              <1> 	; Return L-CHS
 11394                              <1> ReturnLCHSinAXBLBH:
 11395 00000624 C3                  <1> 	ret
 11396                                  	%include "DrvDetectInfo.asm"	; For creating DRVDETECTINFO structs
 11397                              <1> ; Project name	:	XTIDE Universal BIOS
 11398                              <1> ; Description	:	Functions for generating and accessing drive
 11399                              <1> ;					information to be displayed on boot menu.
 11400                              <1> 
 11401                              <1> ;
 11402                              <1> ; XTIDE Universal BIOS and Associated Tools
 11403                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 11404                              <1> ;
 11405                              <1> ; This program is free software; you can redistribute it and/or modify
 11406                              <1> ; it under the terms of the GNU General Public License as published by
 11407                              <1> ; the Free Software Foundation; either version 2 of the License, or
 11408                              <1> ; (at your option) any later version.
 11409                              <1> ;
 11410                              <1> ; This program is distributed in the hope that it will be useful,
 11411                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 11412                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 11413                              <1> ; GNU General Public License for more details.
 11414                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 11415                              <1> ;
 11416                              <1> 
 11417                              <1> ; Section containing code
 11418                              <1> SECTION .text
 11419                              <1> 
 11420                              <1> ;--------------------------------------------------------------------
 11421                              <1> ; Creates new DRVDETECTINFO struct for detected hard disk.
 11422                              <1> ;
 11423                              <1> ; DriveDetectInfo_CreateForHardDisk
 11424                              <1> ;	Parameters:
 11425                              <1> ;		DL:		Drive number
 11426                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11427                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11428                              <1> ;	Returns:
 11429                              <1> ;		ES:BX:	Ptr to DRVDETECTINFO (if successful)
 11430                              <1> ;	Corrupts registers:
 11431                              <1> ;		AX, BX, CX, DX, DI
 11432                              <1> ;--------------------------------------------------------------------
 11433                              <1> DriveDetectInfo_CreateForHardDisk:
 11434 00000625 E81700              <1> 	call	DriveDetectInfo_ConvertDPTtoBX		; ES:BX now points to new DRVDETECTINFO
 11435                              <1> 
 11436                              <1> 	; Store Drive Name
 11437 00000628 1E                  <1> 	push	ds									; Preserve RAMVARS
 11438 00000629 56                  <1> 	push	si
 11439                              <1> 
 11440 0000062A 06                  <1> 	push	es									; ES copied to DS
 11441 0000062B 1F                  <1> 	pop		ds
 11442                              <1> 
 11443 0000062C 83C636              <1> 	add		si, BYTE ATA1.strModel				; DS:SI now points drive name (Clears CF)
 11444 0000062F 8D3F                <1> 	lea		di, [bx+DRVDETECTINFO.szDrvName]	; ES:DI now points to name destination
 11445 00000631 B90F00              <1> 	mov		cx, MAX_HARD_DISK_NAME_LENGTH / 2	; Max number of WORDs allowed
 11446                              <1> .CopyNextWord:
 11447 00000634 AD                  <1> 	lodsw
 11448 00000635 86C4                <1> 	xchg	al, ah								; Change endianness
 11449 00000637 AB                  <1> 	stosw
 11450 00000638 E2FA                <1> 	loop	.CopyNextWord
 11451 0000063A 91                  <1> 	xchg	cx, ax								; Zero AX (CF already cleared from the ADD above)
 11452 0000063B AB                  <1> 	stosw										; Terminate with NULL
 11453                              <1> 
 11454 0000063C 5E                  <1> 	pop		si
 11455 0000063D 1F                  <1> 	pop		ds
 11456                              <1> 
 11457 0000063E C3                  <1> 	ret
 11458                              <1> 
 11459                              <1> 
 11460                              <1> ;--------------------------------------------------------------------
 11461                              <1> ; Returns offset to DRVDETECTINFO based on DPT pointer.
 11462                              <1> ;
 11463                              <1> ; DriveDetectInfo_ConvertDPTtoBX
 11464                              <1> ;	Parameters:
 11465                              <1> ;		DS:DI:	DPT Pointer
 11466                              <1> ;	Returns:
 11467                              <1> ;		BX:		Offset to DRVDETECTINFO struct
 11468                              <1> ;	Corrupts registers:
 11469                              <1> ;		AX
 11470                              <1> ;--------------------------------------------------------------------
 11471                              <1> DriveDetectInfo_ConvertDPTtoBX:
 11472 0000063F 8D45F6              <1> 	lea		ax, [di-RAMVARS_size]					; subtract off base of DPTs
 11473 00000642 B303                <1> 	mov		bl, DPT_DRVDETECTINFO_SIZE_MULTIPLIER	; DRVDETECTINFO are a whole number multiple of DPT size
 11474 00000644 F6E3                <1> 	mul		bl
 11475 00000646 05067F              <1> 	add		ax, BOOTVARS.rgDrvDetectInfo			; add base of DRVDETECTINFO
 11476 00000649 93                  <1> 	xchg	bx, ax
 11477 0000064A C3                  <1> 	ret
 11478                                  	%include "AtaID.asm"			; For ATA Identify Device information
 11479                              <1> ; Project name	:	XTIDE Universal BIOS
 11480                              <1> ; Description	:	Functions for accessing ATA information read with
 11481                              <1> ;					IDENTIFY DEVICE command.
 11482                              <1> 
 11483                              <1> ;
 11484                              <1> ; XTIDE Universal BIOS and Associated Tools
 11485                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 11486                              <1> ;
 11487                              <1> ; This program is free software; you can redistribute it and/or modify
 11488                              <1> ; it under the terms of the GNU General Public License as published by
 11489                              <1> ; the Free Software Foundation; either version 2 of the License, or
 11490                              <1> ; (at your option) any later version.
 11491                              <1> ;
 11492                              <1> ; This program is distributed in the hope that it will be useful,
 11493                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 11494                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 11495                              <1> ; GNU General Public License for more details.
 11496                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 11497                              <1> ;
 11498                              <1> 
 11499                              <1> ; Section containing code
 11500                              <1> SECTION .text
 11501                              <1> 
 11502                              <1> ;--------------------------------------------------------------------
 11503                              <1> ; AtaID_VerifyFromESSI
 11504                              <1> ;	Parameters:
 11505                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11506                              <1> ;	Returns:
 11507                              <1> ;		CF:		Set if failed to verify ATA-ID
 11508                              <1> ;				Cleared if ATA-ID verified successfully
 11509                              <1> ;	Corrupts registers:
 11510                              <1> ;		AX, BX, CX
 11511                              <1> ;--------------------------------------------------------------------
 11512                              <1> AtaID_VerifyFromESSI:
 11513                              <1> 	; We cannot start by reading ATA version since the ID might be
 11514                              <1> 	; corrupted. We start by making sure P-CHS values are valid.
 11515                              <1> 	; If they are, we assume the ATA ID to be valid. Fortunately we can do
 11516                              <1> 	; further checking for ATA-5 and later since they contain signature and
 11517                              <1> 	; checksum bytes. Those are not available for ATA-4 and older.
 11518                              <1> 
 11519                              <1> 	; Verify P-CHS cylinders
 11520 0000064B BB0200              <1> 	mov		bx, ATA1.wCylCnt
 11521 0000064E B9FF3F              <1> 	mov		cx, MAX_VALID_PCHS_CYLINDERS
 11522 00000651 E82600              <1> 	call	.CompareCHorSfromOffsetBXtoMaxValueInCX
 11523                              <1> 
 11524 00000654 B306                <1> 	mov		bl, ATA1.wHeadCnt & 0FFh
 11525 00000656 B91000              <1> 	mov		cx, MAX_VALID_PCHS_HEADS
 11526 00000659 E81E00              <1> 	call	.CompareCHorSfromOffsetBXtoMaxValueInCX
 11527                              <1> 
 11528 0000065C B30C                <1> 	mov		bl, ATA1.wSPT & 0FFh
 11529 0000065E B13F                <1> 	mov		cl, MAX_VALID_PCHS_SECTORS_PER_TRACK
 11530 00000660 E81700              <1> 	call	.CompareCHorSfromOffsetBXtoMaxValueInCX
 11531                              <1> 
 11532                              <1> 	; Check signature byte. It is only found on ATA-5 and later. It should be zero on
 11533                              <1> 	; ATA-4 and older.
 11534 00000663 268A84FE01          <1> 	mov		al, [es:si+ATA6.bSignature]
 11535 00000668 84C0                <1> 	test	al, al
 11536 0000066A 740C                <1> 	jz		SHORT .AtaIDverifiedSuccessfully	; Old ATA so Signature and Checksum is not available
 11537 0000066C 3CA5                <1> 	cmp		al, A6_wIntegrity_SIGNATURE
 11538 0000066E 7518                <1> 	jne		SHORT .FailedToVerifyAtaID
 11539                              <1> 
 11540                              <1> 	; Check checksum byte since signature was present
 11541 00000670 B90002              <1> 	mov		cx, ATA6_size
 11542 00000673 E8B3FC              <1> 	call	Memory_SumCXbytesFromESSItoAL		; Returns with ZF set according to result
 11543 00000676 7510                <1> 	jnz		SHORT .FailedToVerifyAtaID
 11544                              <1> 
 11545                              <1> 	; ATA-ID is now verified to be valid
 11546                              <1> .AtaIDverifiedSuccessfully:
 11547 00000678 F8                  <1> 	clc
 11548 00000679 C3                  <1> 	ret
 11549                              <1> 
 11550                              <1> ;--------------------------------------------------------------------
 11551                              <1> ; .CompareCHorSfromOffsetBXtoMaxValueInCX
 11552                              <1> ;	Parameters:
 11553                              <1> ;		BX:		C, H or S offset to ATA-ID
 11554                              <1> ;		CX:		Maximum valid C, H or S value
 11555                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11556                              <1> ;	Returns:
 11557                              <1> ;		Exits from AtaID_VerifyFromESSI with CF set if invalid value
 11558                              <1> ;	Corrupts registers:
 11559                              <1> ;		AX
 11560                              <1> ;--------------------------------------------------------------------
 11561                              <1> .CompareCHorSfromOffsetBXtoMaxValueInCX:
 11562 0000067A 268B00              <1> 	mov		ax, [es:bx+si]
 11563 0000067D 85C0                <1> 	test	ax, ax
 11564 0000067F 7404                <1> 	jz		SHORT .InvalidPCHorSinOffsetBX
 11565 00000681 39C8                <1> 	cmp		ax, cx			; Compare to max valid value
 11566 00000683 7604                <1> 	jbe		SHORT .ValidPCHorSinOffsetBX
 11567                              <1> .InvalidPCHorSinOffsetBX:
 11568 00000685 83C402              <1> 	add		sp, BYTE 2		; Clear return address for this function
 11569                              <1> .FailedToVerifyAtaID:
 11570 00000688 F9                  <1> 	stc						; Set carry to indicate invalid ATA-ID
 11571                              <1> .ValidPCHorSinOffsetBX:
 11572 00000689 C3                  <1> 	ret
 11573                              <1> 
 11574                              <1> 
 11575                              <1> %ifdef MODULE_ADVANCED_ATA
 11576                              <1> ;--------------------------------------------------------------------
 11577                              <1> ; AtaID_GetMaxPioModeToAXandMinCycleTimeToCX
 11578                              <1> ;	Parameters:
 11579                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11580                              <1> ;	Returns:
 11581                              <1> ;		AL:		Max supported PIO mode
 11582                              <1> ;		AH:		FLGH_DPT_IORDY if IORDY supported, zero otherwise
 11583                              <1> ;		CX:		Minimum Cycle Time in nanosecs
 11584                              <1> ;	Corrupts registers:
 11585                              <1> ;		BX
 11586                              <1> ;--------------------------------------------------------------------
 11587                              <1> AtaID_GetMaxPioModeToAXandMinCycleTimeToCX:
 11588                              <1> 	; Get PIO mode and cycle time for PIO 0...2
 11589                              <1> 	mov		bx, [es:si+ATA1.bPioMode]
 11590                              <1> 	mov		ax, bx					; AH = 0, AL = PIO mode 0, 1 or 2
 11591                              <1> 	eSHL_IM	bx, 1					; Shift for WORD lookup
 11592                              <1> 	mov		cx, [cs:bx+.rgwPio0to2CycleTimeInNanosecs]
 11593                              <1> 
 11594                              <1> 	; Check if IORDY is supported
 11595                              <1> 	test	BYTE [es:si+ATA2.wCaps+1], A2_wCaps_IORDY >> 8
 11596                              <1> 	jz		SHORT .ReturnPioTimings	; No PIO 3 or higher if no IORDY
 11597                              <1> 	mov		ah, FLGH_DPT_IORDY
 11598                              <1> 
 11599                              <1> 	; Check if Advanced PIO modes are supported (3 and above)
 11600                              <1> 	test	BYTE [es:si+ATA2.wFields], A2_wFields_64to70
 11601                              <1> 	jz		SHORT .ReturnPioTimings
 11602                              <1> 
 11603                              <1> 	; Get Advanced PIO mode
 11604                              <1> 	; (Hard Disks supports up to 4 but CF cards can support 5 and 6)
 11605                              <1> 	mov		bl, [es:si+ATA2.bPIOSupp]
 11606                              <1> .CheckNextFlag:
 11607                              <1> 	inc		ax
 11608                              <1> 	shr		bl, 1
 11609                              <1> 	jnz		SHORT .CheckNextFlag
 11610                              <1> 	MIN_U	al, 6						; Make sure not above lookup tables
 11611                              <1> 	mov		cx, [es:si+ATA2.wPIOMinCyF]	; Advanced modes use IORDY
 11612                              <1> .ReturnPioTimings:
 11613                              <1> 	ret
 11614                              <1> 
 11615                              <1> .rgwPio0to2CycleTimeInNanosecs:
 11616                              <1> 	dw		PIO_0_MIN_CYCLE_TIME_NS
 11617                              <1> 	dw		PIO_1_MIN_CYCLE_TIME_NS
 11618                              <1> 	dw		PIO_2_MIN_CYCLE_TIME_NS
 11619                              <1> 
 11620                              <1> 
 11621                              <1> ;--------------------------------------------------------------------
 11622                              <1> ; AtaID_GetRecoveryTimeToAXfromPioModeInBXandCycleTimeInCX
 11623                              <1> ;	Parameters:
 11624                              <1> ;		BX:		PIO Mode
 11625                              <1> ;		CX:		PIO Cycle Time in nanosecs
 11626                              <1> ;	Returns:
 11627                              <1> ;		AX:		Active Time in nanosecs
 11628                              <1> ;	Corrupts registers:
 11629                              <1> ;		BX, CX
 11630                              <1> ;--------------------------------------------------------------------
 11631                              <1> AtaID_GetRecoveryTimeToAXfromPioModeInBXandCycleTimeInCX:
 11632                              <1> 	call	AtaID_GetActiveTimeToAXfromPioModeInBX
 11633                              <1> 	mov		bl, [cs:bx+.rgbPioModeToAddressValidTimeNs]
 11634                              <1> 	sub		cx, bx	; Cycle Time (t0) - Address Valid Time (t1)
 11635                              <1> 	sub		cx, ax	; - Active Time (t2)
 11636                              <1> 	xchg	ax, cx	; AX = Recovery Time (t2i)
 11637                              <1> 	ret
 11638                              <1> 
 11639                              <1> .rgbPioModeToAddressValidTimeNs:
 11640                              <1> 	db		PIO_0_MIN_ADDRESS_VALID_NS
 11641                              <1> 	db		PIO_1_MIN_ADDRESS_VALID_NS
 11642                              <1> 	db		PIO_2_MIN_ADDRESS_VALID_NS
 11643                              <1> 	db		PIO_3_MIN_ADDRESS_VALID_NS
 11644                              <1> 	db		PIO_4_MIN_ADDRESS_VALID_NS
 11645                              <1> 	db		PIO_5_MIN_ADDRESS_VALID_NS
 11646                              <1> 	db		PIO_6_MIN_ADDRESS_VALID_NS
 11647                              <1> 
 11648                              <1> 
 11649                              <1> ;--------------------------------------------------------------------
 11650                              <1> ; AtaID_GetActiveTimeToAXfromPioModeInBX
 11651                              <1> ;	Parameters:
 11652                              <1> ;		BX:		PIO Mode
 11653                              <1> ;	Returns:
 11654                              <1> ;		AX:		Active Time in nanosecs
 11655                              <1> ;	Corrupts registers:
 11656                              <1> ;		Nothing
 11657                              <1> ;--------------------------------------------------------------------
 11658                              <1> AtaID_GetActiveTimeToAXfromPioModeInBX:
 11659                              <1> 	eMOVZX	ax, [cs:bx+.rgbPioModeToActiveTimeNs]
 11660                              <1> 	ret
 11661                              <1> 
 11662                              <1> .rgbPioModeToActiveTimeNs:
 11663                              <1> 	db		PIO_0_MIN_ACTIVE_TIME_NS
 11664                              <1> 	db		PIO_1_MIN_ACTIVE_TIME_NS
 11665                              <1> 	db		PIO_2_MIN_ACTIVE_TIME_NS
 11666                              <1> 	db		PIO_3_MIN_ACTIVE_TIME_NS
 11667                              <1> 	db		PIO_4_MIN_ACTIVE_TIME_NS
 11668                              <1> 	db		PIO_5_MIN_ACTIVE_TIME_NS
 11669                              <1> 	db		PIO_6_MIN_ACTIVE_TIME_NS
 11670                              <1> 
 11671                              <1> %endif ; MODULE_ADVANCED_ATA
 11672                                  	%include "DetectDrives.asm"		; For detecting IDE drives
 11673                              <1> ; Project name	:	XTIDE Universal BIOS
 11674                              <1> ; Description	:	Functions for detecting drive for the BIOS.
 11675                              <1> 
 11676                              <1> ;
 11677                              <1> ; XTIDE Universal BIOS and Associated Tools
 11678                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 11679                              <1> ;
 11680                              <1> ; This program is free software; you can redistribute it and/or modify
 11681                              <1> ; it under the terms of the GNU General Public License as published by
 11682                              <1> ; the Free Software Foundation; either version 2 of the License, or
 11683                              <1> ; (at your option) any later version.
 11684                              <1> ;
 11685                              <1> ; This program is distributed in the hope that it will be useful,
 11686                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 11687                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 11688                              <1> ; GNU General Public License for more details.
 11689                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 11690                              <1> ;
 11691                              <1> 
 11692                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 11693                              <1> 
 11694                              <1> ; Section containing code
 11695                              <1> SECTION .text
 11696                              <1> 
 11697                              <1> ;--------------------------------------------------------------------
 11698                              <1> ; Detects all IDE hard disks to be controlled by this BIOS.
 11699                              <1> ;
 11700                              <1> ; DetectDrives_FromAllIDEControllers
 11701                              <1> ;	Parameters:
 11702                              <1> ;		DS:		RAMVARS segment
 11703                              <1> ;		ES:		BDA segment (zero)
 11704                              <1> ;	Returns:
 11705                              <1> ;		Nothing
 11706                              <1> ;	Corrupts registers:
 11707                              <1> ;		All (not segments)
 11708                              <1> ;--------------------------------------------------------------------
 11709                              <1> DetectDrives_FromAllIDEControllers:
 11710 0000068A E8BAFD              <1> 	call	RamVars_GetIdeControllerCountToCX
 11711 0000068D BD5100              <1> 	mov		bp, ROMVARS.ideVars0			; CS:BP now points to first IDEVARS
 11712                              <1> 
 11713                              <1> .DriveDetectLoop:							; Loop through IDEVARS
 11714 00000690 51                  <1> 	push	cx
 11715                              <1> 
 11716 00000691 B9[9900]            <1> 	mov		cx, g_szDetectMaster
 11717 00000694 B7A0                <1> 	mov		bh, MASK_DRVNHEAD_SET								; Select Master drive
 11718 00000696 E82300              <1> 	call	StartDetectionWithDriveSelectByteInBHandStringInCX	; Detect and create DPT + BOOTNFO
 11719                              <1> 
 11720 00000699 B9[9F00]            <1> 	mov		cx, g_szDetectSlave
 11721 0000069C B7B0                <1> 	mov		bh, MASK_DRVNHEAD_SET | FLG_DRVNHEAD_DRV
 11722 0000069E E81B00              <1> 	call	StartDetectionWithDriveSelectByteInBHandStringInCX
 11723                              <1> 
 11724 000006A1 59                  <1> 	pop		cx
 11725                              <1> 
 11726 000006A2 83C512              <1> 	add		bp, BYTE IDEVARS_size			; Point to next IDEVARS
 11727                              <1> 
 11728                              <1> %ifdef MODULE_SERIAL
 11729                              <1> 	jcxz	.AddHardDisks					; Set to zero on .ideVarsSerialAuto iteration (if any)
 11730                              <1> %endif
 11731 000006A5 E2E9                <1> 	loop	.DriveDetectLoop
 11732                              <1> 
 11733                              <1> %ifdef MODULE_SERIAL
 11734                              <1> ;----------------------------------------------------------------------
 11735                              <1> ;
 11736                              <1> ; if serial drive detected, do not scan (avoids duplicate drives and isn't needed - we already have a connection)
 11737                              <1> ;
 11738                              <1> 	call	FindDPT_ToDSDIforSerialDevice   ; does not modify AX
 11739                              <1> 	jnc		.AddHardDisks
 11740                              <1> 
 11741                              <1> 	mov		bp, ROMVARS.ideVarsSerialAuto	; Point to our special IDEVARS structure, just for serial scans
 11742                              <1> 
 11743                              <1> %ifdef MODULE_HOTKEYS
 11744                              <1> 	cmp		al, COM_DETECT_HOTKEY_SCANCODE  ; Set by last call to HotkeyBar_UpdateDuringDriveDetection above
 11745                              <1> 	je		.DriveDetectLoop
 11746                              <1> %endif
 11747                              <1> 
 11748                              <1> 	mov		al,[cs:ROMVARS.wFlags]			; Configurator set to always scan?
 11749                              <1> 	or		al,[es:BDA.bKBFlgs1]			; Or, did the user hold down the ALT key?
 11750                              <1> 	and		al,8							; 8 = alt key depressed, same as FLG_ROMVARS_SERIAL_ALWAYSDETECT
 11751                              <1> 	jnz		.DriveDetectLoop
 11752                              <1> %endif
 11753                              <1> 
 11754                              <1> .AddHardDisks:
 11755                              <1> ;----------------------------------------------------------------------
 11756                              <1> ;
 11757                              <1> ; Add in hard disks to BDA, finalize our Count and First variables
 11758                              <1> ;
 11759                              <1> ; Note that we perform the add to bHDCount and store bFirstDrv even if the count is zero.
 11760                              <1> ; This is done because we use the value of .bFirstDrv to know how many drives were in the system
 11761                              <1> ; at the time of boot, and to return that number on int13h/8h calls.  Because the count is zero,
 11762                              <1> ; FindDPT_ForDriveNumber will not find any drives that are ours.
 11763                              <1> ;
 11764 000006A7 8B0E0900            <1> 	mov		cx, [RAMVARS.wDrvCntAndFlopCnt]		; Our count of hard disks
 11765                              <1> 
 11766 000006AB 26A07504            <1> 	mov		al, [es:BDA.bHDCount]
 11767 000006AF 00C1                <1> 	add		cl, al						; Add our drives to the system count
 11768 000006B1 26880E7504          <1> 	mov		[es:BDA.bHDCount], cl
 11769 000006B6 0C80                <1> 	or		al, 80h						; Or in hard disk flag
 11770 000006B8 A20800              <1> 	mov		[RAMVARS.bFirstDrv], al		; Store first drive number
 11771                              <1> 
 11772                              <1> .AddFloppies:
 11773                              <1> %ifdef MODULE_SERIAL_FLOPPY
 11774                              <1> ;----------------------------------------------------------------------
 11775                              <1> ;
 11776                              <1> ; Add in any emulated serial floppy drives, finalize our packed Count and First variables
 11777                              <1> ;
 11778                              <1> 	dec		ch
 11779                              <1> 	mov		al, ch
 11780                              <1> 	js		.NoFloppies						; if no drives are present, we store 0ffh
 11781                              <1> 
 11782                              <1> 	call	FloppyDrive_GetCountFromBIOS_or_BDA
 11783                              <1> 
 11784                              <1> 	push	ax
 11785                              <1> 
 11786                              <1> 	add		al, ch							; Add our drives to existing drive count
 11787                              <1> 	cmp		al, 3							; For BDA, max out at 4 drives (ours is zero based)
 11788                              <1> 	jb		.MaxBDAFloppiesExceeded
 11789                              <1> 	mov		al, 3
 11790                              <1> .MaxBDAFloppiesExceeded:
 11791                              <1> 	eROR_IM	al, 2							; move to bits 6-7
 11792                              <1> 	inc		ax								; low order bit, indicating floppy drive exists
 11793                              <1> 
 11794                              <1> 	mov		ah, [es:BDA.wEquipment]			; Load Equipment WORD low byte
 11795                              <1> 	and		ah, 03eh						; Mask off drive number and drives present bit
 11796                              <1> 	or		al, ah							; Or in new values
 11797                              <1> 	mov		[es:BDA.wEquipment], al			; and store
 11798                              <1> 
 11799                              <1> 	mov		al, 1eh							; BDA pointer to Floppy DPT
 11800                              <1> 	mov		si, AH8h_FloppyDPT
 11801                              <1> 	call	Interrupts_InstallHandlerToVectorInALFromCSSI
 11802                              <1> 
 11803                              <1> 	pop		ax
 11804                              <1> 
 11805                              <1> 	shr		ch, 1							; number of drives, 1 or 2 only, to CF flag (clear=1, set=2)
 11806                              <1> 	rcl		al, 1							; starting drive number in upper 7 bits, number of drives in low bit
 11807                              <1> .NoFloppies:
 11808                              <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bFlopCntAndFirst], al
 11809                              <1> %endif
 11810                              <1> 
 11811 000006BB C3                  <1> 	ret
 11812                              <1> 
 11813                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 11814                              <1> 	%if FLG_ROMVARS_SERIAL_SCANDETECT != 8
 11815                              <1> 		%error "DetectDrives is currently coded to assume that FLG_ROMVARS_SERIAL_SCANDETECT is the same bit as the ALT key code in the BDA.  Changes in the code will be needed if these values are no longer the same."
 11816                              <1> 	%endif
 11817                              <1> %endif
 11818                              <1> 
 11819                              <1> 
 11820                              <1> ;--------------------------------------------------------------------
 11821                              <1> ; StartDetectionWithDriveSelectByteInBHandStringInCX
 11822                              <1> ;	Parameters:
 11823                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 11824                              <1> ;		CX:		Offset to "Master" or "Slave" string
 11825                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
 11826                              <1> ;		DS:		RAMVARS segment
 11827                              <1> ;		ES:		Zero (BDA segment)
 11828                              <1> ;	Returns:
 11829                              <1> ;       None
 11830                              <1> ;	Corrupts registers:
 11831                              <1> ;		AX, BL, CX, DX, SI, DI
 11832                              <1> ;--------------------------------------------------------------------
 11833                              <1> StartDetectionWithDriveSelectByteInBHandStringInCX:
 11834                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 11835                              <1> 	; Autodetect port for XT-CF
 11836                              <1> 	call	DetectDrives_DoesIdevarsInCSBPbelongToXTCF
 11837                              <1> 	jne		SHORT .SkipXTCFportDetection
 11838                              <1> 
 11839                              <1> 	; XT-CF do not support slave drives so skip detection
 11840                              <1> 	test	bh, FLG_DRVNHEAD_DRV
 11841                              <1> 	jnz		SHORT NoSlaveDriveAvailable
 11842                              <1> 
 11843                              <1> 	; XT-CF do not support slave drives so we can safely update port
 11844                              <1> 	; for next drive (another XT-CF card on same system)
 11845                              <1> .DetectNextPort:
 11846                              <1> 	mov		dx, [es:BOOTVARS.wNextXTCFportToScan]
 11847                              <1> 	xor		dl, 40h
 11848                              <1> 	jnz		SHORT .StoreNextXTCFportToScan
 11849                              <1> 	inc		dh
 11850                              <1> 	cmp		dh, XTCF_BASE_PORT_4 >> 8
 11851                              <1> 	ja		SHORT .SkipXTCFportDetection		; XT-CF not found from any port
 11852                              <1> .StoreNextXTCFportToScan:
 11853                              <1> 	mov		[es:BOOTVARS.wNextXTCFportToScan], dx
 11854                              <1> 
 11855                              <1> 	call	AH1Eh_DetectXTCFwithBasePortInDX
 11856                              <1> 	jc		SHORT .DetectNextPort				; XT-CF not found from this port
 11857                              <1> 
 11858                              <1> 	; We now have autodetected port in DX
 11859                              <1> 	push	dx
 11860                              <1> 	xchg	ax, dx								; Port to print in AX
 11861                              <1> 	call	DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP
 11862                              <1> 	jmp		SHORT .DriveDetectionStringPrintedOnScreen
 11863                              <1> 
 11864                              <1> 	; Print detect string for devices that do not support autodetection
 11865                              <1> .SkipXTCFportDetection:
 11866                              <1> 	push	dx
 11867                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 11868                              <1> 
 11869 000006BC E82C00              <1> 	call	DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
 11870                              <1> .DriveDetectionStringPrintedOnScreen:
 11871                              <1> %ifdef MODULE_HOTKEYS
 11872                              <1> 	call	HotkeyBar_UpdateDuringDriveDetection
 11873                              <1> %endif
 11874                              <1> 
 11875                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 11876                              <1> 	pop		dx
 11877                              <1> %endif
 11878                              <1> 	; Fall to .ReadAtaInfoFromHardDisk
 11879                              <1> 
 11880                              <1> 
 11881                              <1> ;--------------------------------------------------------------------
 11882                              <1> ; .ReadAtaInfoFromHardDisk
 11883                              <1> ;	Parameters:
 11884                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 11885                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 11886                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
 11887                              <1> ;		DS:		RAMVARS segment
 11888                              <1> ;		ES:		Zero (BDA segment)
 11889                              <1> ;	Returns:
 11890                              <1> ;		CF:		Cleared if ATA-information read successfully
 11891                              <1> ;				Set if any error
 11892                              <1> ;	Corrupts registers:
 11893                              <1> ;		AX, BL, CX, DX, SI, DI
 11894                              <1> ;--------------------------------------------------------------------
 11895                              <1> .ReadAtaInfoFromHardDisk:
 11896 000006BF BE007C              <1> 	mov		si, BOOTVARS.rgbAtaInfo		; ES:SI now points to ATA info location
 11897 000006C2 06                  <1> 	push	es
 11898 000006C3 56                  <1> 	push	si
 11899 000006C4 52                  <1> 	push	dx
 11900 000006C5 53                  <1> 	push	bx
 11901 000006C6 E8E801              <1> 	call	Device_IdentifyToBufferInESSIwithDriveSelectByteInBH
 11902 000006C9 5B                  <1> 	pop		bx
 11903 000006CA 5A                  <1> 	pop		dx
 11904 000006CB 5E                  <1> 	pop		si
 11905 000006CC 07                  <1> 	pop		es
 11906 000006CD 7305                <1> 	jnc		SHORT CreateBiosTablesForHardDisk
 11907                              <1> 	; Fall to .ReadAtapiInfoFromDrive
 11908                              <1> 
 11909                              <1> .ReadAtapiInfoFromDrive:				; Not yet implemented
 11910                              <1> 	;call	ReadAtapiInfoFromDrive		; Assume CD-ROM
 11911                              <1> 	;jnc	SHORT _CreateBiosTablesForCDROM
 11912                              <1> 
 11913                              <1> 	;jmp	short DetectDrives_DriveNotFound
 11914                              <1> ;;; fall-through instead of previous jmp instruction
 11915                              <1> ;--------------------------------------------------------------------
 11916                              <1> ; DetectDrives_DriveNotFound
 11917                              <1> ;	Parameters:
 11918                              <1> ;		Nothing
 11919                              <1> ;	Returns:
 11920                              <1> ;		CF:     Set (from DetectPrint_NullTerminatedStringFromCSSIandSetCF)
 11921                              <1> ;	Corrupts registers:
 11922                              <1> ;		AX, SI
 11923                              <1> ;--------------------------------------------------------------------
 11924                              <1> DetectDrives_DriveNotFound:
 11925 000006CF BE[E500]            <1> 	mov		si, g_szNotFound
 11926 000006D2 EB77                <1> 	jmp		DetectPrint_NullTerminatedStringFromCSSIandSetCF
 11927                              <1> 
 11928                              <1> 
 11929                              <1> ;--------------------------------------------------------------------
 11930                              <1> ; CreateBiosTablesForHardDisk
 11931                              <1> ;	Parameters:
 11932                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 11933                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 11934                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
 11935                              <1> ;		ES:SI	Ptr to ATA information for the drive
 11936                              <1> ;		DS:		RAMVARS segment
 11937                              <1> ;		ES:		BDA segment
 11938                              <1> ;	Returns:
 11939                              <1> ;		Nothing
 11940                              <1> ;	Corrupts registers:
 11941                              <1> ;		AX, BX, CX, DX, SI, DI
 11942                              <1> ;--------------------------------------------------------------------
 11943                              <1> CreateBiosTablesForHardDisk:
 11944 000006D4 53                  <1> 	push	bx
 11945 000006D5 E873FF              <1> 	call	AtaID_VerifyFromESSI
 11946 000006D8 5B                  <1> 	pop		bx
 11947 000006D9 72F4                <1> 	jc		SHORT DetectDrives_DriveNotFound
 11948 000006DB E8A5FD              <1> 	call	CreateDPT_FromAtaInformation
 11949 000006DE 72EF                <1> 	jc		SHORT DetectDrives_DriveNotFound
 11950 000006E0 E842FF              <1> 	call	DriveDetectInfo_CreateForHardDisk
 11951 000006E3 EB1C                <1> 	jmp		SHORT DetectPrint_DriveNameFromDrvDetectInfoInESBX
 11952                              <1> 
 11953                              <1> 
 11954                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 11955                              <1> ;--------------------------------------------------------------------
 11956                              <1> ; DetectDrives_DoesIdevarsInCSBPbelongToXTCF
 11957                              <1> ;	Parameters:
 11958                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
 11959                              <1> ;	Returns:
 11960                              <1> ;		ZF:		Set if IDEVARS belongs to XT-CF device
 11961                              <1> ;				Cleared if some other device
 11962                              <1> ;	Corrupts registers:
 11963                              <1> ;		AL
 11964                              <1> ;--------------------------------------------------------------------
 11965                              <1> DetectDrives_DoesIdevarsInCSBPbelongToXTCF:
 11966                              <1> 	mov		al, [cs:bp+IDEVARS.bDevice]
 11967                              <1> 	cmp		al, DEVICE_8BIT_XTCF_PIO8
 11968                              <1> 	je		SHORT .DeviceIsXTCF
 11969                              <1> 	cmp		al, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
 11970                              <1> 	je		SHORT .DeviceIsXTCF
 11971                              <1> 	cmp		al, DEVICE_8BIT_XTCF_DMA
 11972                              <1> .DeviceIsXTCF:
 11973                              <1> NoSlaveDriveAvailable:
 11974                              <1> 	ret
 11975                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 11976                              <1> 
 11977                                  	%include "DetectPrint.asm"		; For printing drive detection strings
 11978                              <1> ; Project name	:	XTIDE Universal BIOS
 11979                              <1> ; Description	:	Functions for printing drive detection strings.
 11980                              <1> 
 11981                              <1> ;
 11982                              <1> ; XTIDE Universal BIOS and Associated Tools
 11983                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 11984                              <1> ;
 11985                              <1> ; This program is free software; you can redistribute it and/or modify
 11986                              <1> ; it under the terms of the GNU General Public License as published by
 11987                              <1> ; the Free Software Foundation; either version 2 of the License, or
 11988                              <1> ; (at your option) any later version.
 11989                              <1> ;
 11990                              <1> ; This program is distributed in the hope that it will be useful,
 11991                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 11992                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 11993                              <1> ; GNU General Public License for more details.
 11994                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 11995                              <1> ;
 11996                              <1> 
 11997                              <1> ; Section containing code
 11998                              <1> SECTION .text
 11999                              <1> 
 12000                              <1> ;--------------------------------------------------------------------
 12001                              <1> ; DetectPrint_InitializeDisplayContext
 12002                              <1> ;	Parameters:
 12003                              <1> ;		Nothing
 12004                              <1> ;	Returns:
 12005                              <1> ;		Nothing
 12006                              <1> ;	Corrupts registers:
 12007                              <1> ;		AX, DI
 12008                              <1> ;--------------------------------------------------------------------
 12009                              <1> DetectPrint_InitializeDisplayContext:
 12010                              <1> 	JMP_DISPLAY_LIBRARY InitializeDisplayContext
 12011                              <2>  %ifidn %1, PushDisplayContext
 12012                              <2>  jmp DisplayContext_Push
 12013                              <2>  %elifidn %1, PopDisplayContext
 12014                              <2>  call DisplayContext_Pop
 12015                              <2>  ret
 12016                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
 12017                              <2>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
 12018                              <2>  %elifidn %1, FormatNullTerminatedStringFromCSSI
 12019                              <2>  mov di, %1
 12020                              <2>  call Display_FunctionFromDI
 12021                              <2>  ret
 12022                              <2>  %else
 12023 000006E5 BF[6601]            <2>  mov di, %1
 12024 000006E8 E91EFA              <2>  jmp Display_FunctionFromDI
 12025                              <2>  %endif
 12026                              <1> 
 12027                              <1> 
 12028                              <1> %ifdef MODULE_HOTKEYS
 12029                              <1> ;--------------------------------------------------------------------
 12030                              <1> ; DetectPrint_GetSoftwareCoordinatesToAX
 12031                              <1> ;	Parameters:
 12032                              <1> ;		Nothing
 12033                              <1> ;	Returns:
 12034                              <1> ;		Nothing
 12035                              <1> ;	Corrupts registers:
 12036                              <1> ;		AX, DI
 12037                              <1> ;--------------------------------------------------------------------
 12038                              <1> DetectPrint_GetSoftwareCoordinatesToAX:
 12039                              <1> 	JMP_DISPLAY_LIBRARY GetSoftwareCoordinatesToAX
 12040                              <1> %endif
 12041                              <1> 
 12042                              <1> 
 12043                              <1> ;--------------------------------------------------------------------
 12044                              <1> ; DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
 12045                              <1> ;	Parameters:
 12046                              <1> ;		CS:CX:	Ptr to "Master" or "Slave" string
 12047                              <1> ;		CS:BP:	Ptr to IDEVARS
 12048                              <1> ;	Returns:
 12049                              <1> ;		Nothing
 12050                              <1> ;	Corrupts registers:
 12051                              <1> ;		AX, CX, DX, SI, DI
 12052                              <1> ;--------------------------------------------------------------------
 12053                              <1> DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP:
 12054 000006EB 2E8B4600            <1> 	mov		ax, [cs:bp+IDEVARS.wBasePort]   ; for IDE: AX=port address, DH=.bDevice
 12055                              <1> 	; fall through to DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP
 12056                              <1> 
 12057                              <1> ;--------------------------------------------------------------------
 12058                              <1> ; DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP
 12059                              <1> ;	Parameters:
 12060                              <1> ;		AX:		Base Port Address
 12061                              <1> ;		CS:CX:	Ptr to "Master" or "Slave" string
 12062                              <1> ;		CS:BP:	Ptr to IDEVARS
 12063                              <1> ;	Returns:
 12064                              <1> ;		Nothing
 12065                              <1> ;	Corrupts registers:
 12066                              <1> ;		AX, CX, DX, SI, DI
 12067                              <1> ;--------------------------------------------------------------------
 12068                              <1> DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP:
 12069 000006EF 2E8B5603            <1> 	mov		dx, [cs:bp+IDEVARS.bDevice-1]   ; for Serial: AL=port address>>2, AH=baud rate
 12070                              <1> 											;			  DL=COM number character, DH=.bDevice
 12071 000006F3 55                  <1> 	push	bp								; setup stack for call to
 12072 000006F4 89E5                <1> 	mov		bp, sp							; BootMenuPrint_FormatCSSIfromParamsInSSBP
 12073                              <1> 
 12074 000006F6 51                  <1> 	push 	cx								; Push "Master" or "Slave"
 12075                              <1> 
 12076 000006F7 B1AC                <1> 	mov		cl, (g_szDetectPort-$$) & 0xff	; Setup print string for standard IDE
 12077                              <1> 											; Note that we modify only the low order bits of CX a lot here,
 12078                              <1> 											; saving code space rather than reloading CX completely.
 12079                              <1> 											; This optimization requires that all the g_szDetect* strings are
 12080                              <1> 											; on the same 256 byte page, which is checked in strings.asm.
 12081                              <1> 
 12082                              <1> %ifdef MODULE_SERIAL
 12083                              <1> 	cmp		dh, DEVICE_SERIAL_PORT		  	; Check if this is a serial device
 12084                              <1> 
 12085                              <1> 	jnz		.pushAndPrint					; CX = string to print, AX = port address, DX won't be used
 12086                              <1> 
 12087                              <1> 	mov		cl, (g_szDetectCOM-$$) & 0xff	; Setup print string for COM ports
 12088                              <1> 	push	cx								; And push now.  We use the fact that format strings can contain
 12089                              <1> 											; themselves format strings.
 12090                              <1> 
 12091                              <1> 	push	dx								; Push COM number character
 12092                              <1> 											; If the string is going to be "Auto", we will push a NULL (zero)
 12093                              <1> 											; here for the COM port number, which will be eaten by the
 12094                              <1> 											; print routine (DisplayPrint_CharacterFromAL), resulting in
 12095                              <1> 											; just "COM" being printed without a character after it.
 12096                              <1> 
 12097                              <1>  	mov		cl, (g_szDetectCOMAuto-$$) & 0xff	; Setup secondary print string for "Auto"
 12098                              <1> 
 12099                              <1> 	test	dl, dl							; Check if serial port "Auto"
 12100                              <1> 	jz		.pushAndPrintSerial				; CX = string to print, AX and DX won't be used
 12101                              <1> 
 12102                              <1> 	mov		cl, (g_szDetectCOMLarge-$$) & 0xff	; Setup secondary print string for "COMn/xx.yK"
 12103                              <1> 
 12104                              <1> 	mov		al,ah							; baud rate divisor to AL
 12105                              <1> 	cbw										; clear AH, AL will always be less than 128
 12106                              <1> 	xchg	si,ax							; move AX to SI for divide
 12107                              <1> 	mov		ax,1152							; baud rate to display is 115200/divisor, the "00" is handled
 12108                              <1> 											; in the print strings
 12109                              <1> 	cwd										; clear top 16-bits of dividend
 12110                              <1> 	div		si								; and divide...  Now AX = baud rate/100, DX = 0 (always a clean divide)
 12111                              <1> 
 12112                              <1> 	mov		si,10							; Now separate the whole portion from the fractional for "K" display
 12113                              <1> 	div		si								; and divide...  Now AX = baud rate/1000, DX = low order digit
 12114                              <1> 
 12115                              <1> 	cmp		ax,si							; < 10: "2400", "9600", etc.; >= 10: "19.2K", "38.4K", etc.
 12116                              <1> 	jae		.pushAndPrintSerial
 12117                              <1> 
 12118                              <1> 	mov		cl, (g_szDetectCOMSmall-$$) & 0xff	; Setup secondary print string for "COMn/XXy00"
 12119                              <1> 
 12120                              <1> .pushAndPrintSerial:
 12121                              <1> .pushAndPrint:
 12122                              <1> %endif
 12123                              <1> 
 12124 000006F9 51                  <1> 	push	cx								; Push print string
 12125 000006FA 50                  <1> 	push	ax								; Push high order digits, or port address, or N/A
 12126 000006FB 52                  <1> 	push	dx								; Push low order digit, or N/A
 12127                              <1> 
 12128 000006FC BE[A500]            <1> 	mov		si, g_szDetectOuter				; Load SI with default wrapper string "IDE %s at %s: "
 12129                              <1> 
 12130 000006FF EB4D                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
 12131                              <1> 
 12132                              <1> 
 12133                              <1> ;--------------------------------------------------------------------
 12134                              <1> ; DetectPrint_DriveNameFromDrvDetectInfoInESBX
 12135                              <1> ;	Parameters:
 12136                              <1> ;		ES:BX:	Ptr to DRVDETECTINFO (if drive found)
 12137                              <1> ;	Returns:
 12138                              <1> ;		Nothing
 12139                              <1> ;	Corrupts registers:
 12140                              <1> ;		AX, SI, DI
 12141                              <1> ;--------------------------------------------------------------------
 12142                              <1> DetectPrint_DriveNameFromDrvDetectInfoInESBX:
 12143 00000701 55                  <1> 	push	bp
 12144 00000702 89E5                <1> 	mov		bp,sp
 12145 00000704 8D37                <1> 	lea		si,[bx+DRVDETECTINFO.szDrvName]
 12146 00000706 56                  <1> 	push	si
 12147 00000707 BE[CE00]            <1> 	mov		si,g_szDriveName
 12148 0000070A EB42                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
 12149                              <1> 
 12150                              <1> 
 12151                              <1> ;--------------------------------------------------------------------
 12152                              <1> ; Prints BIOS name and segment address where it is found.
 12153                              <1> ;
 12154                              <1> ; DetectPrint_RomFoundAtSegment
 12155                              <1> ;	Parameters:
 12156                              <1> ;		Nothing
 12157                              <1> ;	Returns:
 12158                              <1> ;		Nothing
 12159                              <1> ;	Corrupts registers:
 12160                              <1> ;		AX, SI, DI
 12161                              <1> ;--------------------------------------------------------------------
 12162                              <1> DetectPrint_RomFoundAtSegment:
 12163 0000070C BE[AF00]            <1> 	mov		si, g_szRomAt
 12164 0000070F 8CCF                <1> 	mov		di, cs						; BIOS segment address, for later inclusion in the output, parameterized
 12165                              <1> 										; so that it can be a different value when using .BootMenuEntry
 12166                              <1> 
 12167                              <1> .BootMenuEntry:
 12168 00000711 55                  <1> 	push	bp
 12169 00000712 89E5                <1> 	mov		bp, sp
 12170                              <1> 
 12171                              <1> %ifndef USE_186
 12172 00000714 B80E00              <1> 	mov		ax, ROMVARS.szTitle
 12173 00000717 50                  <1> 	push	ax
 12174 00000718 57                  <1> 	push	di							; BIOS segment
 12175 00000719 041F                <1> 	add		al, ROMVARS.szVersion - ROMVARS.szTitle
 12176 0000071B 50                  <1> 	push	ax
 12177                              <1> %else
 12178                              <1> 	; szTitle and szVersion have the high order byte of their addresses zero,
 12179                              <1> 	; so these push instructions are only 2 bytes
 12180                              <1> 	;
 12181                              <1> 	push	ROMVARS.szTitle
 12182                              <1> 	push	di							; BIOS segment
 12183                              <1> 	push	ROMVARS.szVersion
 12184                              <1> %endif
 12185                              <1> 
 12186 0000071C EB30                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
 12187                              <1> 
 12188                              <1> 
 12189                              <1> ;--------------------------------------------------------------------
 12190                              <1> ; DetectPrint_FailedToLoadFirstSector
 12191                              <1> ;	Parameters:
 12192                              <1> ;		AH:		INT 13h error code
 12193                              <1> ;	Returns:
 12194                              <1> ;		CF:		Set
 12195                              <1> ;	Corrupts registers:
 12196                              <1> ;		AX, CX, SI, DI
 12197                              <1> ;--------------------------------------------------------------------
 12198                              <1> DetectPrint_FailedToLoadFirstSector:
 12199 0000071E 55                  <1> 	push	bp
 12200 0000071F 89E5                <1> 	mov		bp, sp
 12201                              <1> 	eMOVZX	cx, ah
 12202                              <2> %ifndef USE_386
 12203                              <2>  %ifidni %1, ax
 12204                              <2>  mov al, %2
 12205                              <2>  xor ah, ah
 12206                              <2>  %elifidni %1, bx
 12207                              <2>  mov bl, %2
 12208                              <2>  xor bh, bh
 12209                              <2>  %elifidni %1, cx
 12210 00000721 88E1                <2>  mov cl, %2
 12211 00000723 30ED                <2>  xor ch, ch
 12212                              <2>  %elifidni %1, dx
 12213                              <2>  mov dl, %2
 12214                              <2>  xor dh, dh
 12215                              <2>  %else
 12216                              <2>  push ax
 12217                              <2>  mov al, %2
 12218                              <2>  xor ah, ah
 12219                              <2>  xchg ax, %1
 12220                              <2>  pop ax
 12221                              <2>  %endif
 12222                              <2> 
 12223                              <2> %else
 12224                              <2>  movzx %1, %2
 12225                              <2> %endif
 12226 00000725 51                  <1> 	push	cx					; Push INT 13h error code
 12227 00000726 BE[EE00]            <1> 	mov		si, g_szReadError
 12228 00000729 EB23                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP	; Sets CF
 12229                              <1> 
 12230                              <1> 
 12231                              <1> ;--------------------------------------------------------------------
 12232                              <1> ; DetectPrint_TryToBootFromDL
 12233                              <1> ;	Parameters:
 12234                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
 12235                              <1> ;		DS:		RAMVARS segment
 12236                              <1> ;	Returns:
 12237                              <1> ;		Nothing
 12238                              <1> ;	Corrupts registers:
 12239                              <1> ;		AX, DH, SI, DI
 12240                              <1> ;--------------------------------------------------------------------
 12241                              <1> DetectPrint_TryToBootFromDL:
 12242 0000072B 55                  <1> 	push	bp
 12243 0000072C 89E5                <1> 	mov		bp, sp
 12244                              <1> 
 12245                              <1> %ifdef MODULE_DRIVEXLATE
 12246                              <1> 
 12247                              <1> 	call	DriveXlate_ToOrBack	; DL = Untranslated Drive number
 12248                              <1> 	mov		dh, dl
 12249                              <1> 	call	DriveXlate_ToOrBack	; DL = Translated Drive number
 12250                              <1> 
 12251                              <1> 	call	DriveXlate_ConvertDriveNumberFromDLtoDriveLetter	; DL = Translated letter
 12252                              <1> 	xchg	dl, dh
 12253                              <1> 	call	DriveXlate_ConvertDriveNumberFromDLtoDriveLetter	; DL = Untranslated letter
 12254                              <1> 	push	dx
 12255                              <1> 	xchg	dl, dh
 12256                              <1> 	push	dx
 12257                              <1> 
 12258                              <1> 	call	DriveXlate_ConvertDriveLetterInDLtoDriveNumber	; Restore DL
 12259                              <1> 
 12260                              <1> %else
 12261                              <1> 	ePUSH_T	ax, ' '			; No drive translation so print space
 12262                              <2> %ifndef USE_186
 12263                              <2>  %ifidni %2, 0
 12264                              <2>  xor %1, %1
 12265                              <2>  %else
 12266 0000072E B82000              <2>  mov %1, %2
 12267                              <2>  %endif
 12268 00000731 50                  <2>  push %1
 12269                              <2> 
 12270                              <2> %else
 12271                              <2>  push %2
 12272                              <2> %endif
 12273                              <1> 
 12274                              <1> 	; Get boot drive letters
 12275 00000732 E828FD              <1> 	call	FloppyDrive_GetCountToAX
 12276 00000735 B441                <1> 	mov		ah, 'A'			; AH = First Floppy Drive letter (always 'A')
 12277 00000737 00E0                <1> 	add		al, ah
 12278                              <1> 	MAX_U	al, 'C'			; AL = First Hard Drive letter ('C', 'D', or 'E')
 12279 00000739 3C43                <2>  cmp %1, %2
 12280 0000073B 7702                <2>  ja %%Return
 12281 0000073D B043                <2>  mov %1, %2
 12282                              <2> ALIGN JUMP_ALIGN
 12283                              <2> %%Return:
 12284 0000073F 84D2                <1> 	test	dl, dl
 12285                              <1> 	eCMOVNS	al, ah
 12286 00000741 7802                <2>  js SHORT %%Return
 12287 00000743 88E0                <2>  mov %1, %2
 12288                              <2> %%Return:
 12289 00000745 50                  <1> 	push	ax
 12290                              <1> 
 12291                              <1> %endif ; MODULE_DRIVEXLATE
 12292                              <1> 
 12293 00000746 BE[D000]            <1> 	mov		si, g_szTryToBoot
 12294 00000749 EB03                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
 12295                              <1> 
 12296                              <1> 
 12297                              <1> ;--------------------------------------------------------------------
 12298                              <1> ; DetectPrint_NullTerminatedStringFromCSSI
 12299                              <1> ; DetectPrint_NullTerminatedStringFromCSSIandSetCF
 12300                              <1> ;	Parameters:
 12301                              <1> ;		CS:SI:	Ptr to NULL terminated string to print
 12302                              <1> ;	Returns:
 12303                              <1> ;		CF:		Set since menu event was handled successfully
 12304                              <1> ;	Corrupts registers:
 12305                              <1> ;		AX, DI
 12306                              <1> ;--------------------------------------------------------------------
 12307                              <1> DetectPrint_NullTerminatedStringFromCSSI:
 12308                              <1> DetectPrint_NullTerminatedStringFromCSSIandSetCF:
 12309                              <1> ;
 12310                              <1> ; We send all CSSI strings through the Format routine for the case of
 12311                              <1> ; compressed strings, but this doesn't hurt in the non-compressed case either
 12312                              <1> ; (perhaps a little slower, but shouldn't be noticeable to the user)
 12313                              <1> ; and results in smaller code size.
 12314                              <1> ;
 12315 0000074B 55                  <1> 	push	bp
 12316 0000074C 89E5                <1> 	mov		bp,sp
 12317                              <1> 	; Fall to DetectPrint_FormatCSSIfromParamsInSSBP
 12318                              <1> 
 12319                              <1> ;--------------------------------------------------------------------
 12320                              <1> ; DetectPrint_FormatCSSIfromParamsInSSBP
 12321                              <1> ;	Parameters:
 12322                              <1> ;		CS:SI:	Ptr to string to format
 12323                              <1> ;		BP:		SP before pushing parameters
 12324                              <1> ;	Returns:
 12325                              <1> ;		BP:		Popped from stack
 12326                              <1> ;		CF:		Set since menu event was handled successfully
 12327                              <1> ;	Corrupts registers:
 12328                              <1> ;		AX, DI
 12329                              <1> ;--------------------------------------------------------------------
 12330                              <1> DetectPrint_FormatCSSIfromParamsInSSBP:
 12331                              <1> 	CALL_DISPLAY_LIBRARY FormatNullTerminatedStringFromCSSI
 12332                              <2>  %ifidn %1, PushDisplayContext
 12333                              <2>  call DisplayContext_Push
 12334                              <2>  %elifidn %1, PopDisplayContext
 12335                              <2>  call DisplayContext_Pop
 12336                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
 12337                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
 12338                              <2>  %else
 12339 0000074E BF[2101]            <2>  mov di, %1
 12340 00000751 E8B5F9              <2>  call Display_FunctionFromDI
 12341                              <2>  %endif
 12342 00000754 F9                  <1> 	stc				; Successful return from menu event
 12343 00000755 5D                  <1> 	pop		bp
 12344 00000756 C3                  <1> 	ret
 12345                                  
 12346                                  	; Hotkey Bar
 12347                                  %ifdef MODULE_HOTKEYS
 12348                                  	%include "HotkeyBar.asm"		; For hotkeys during drive detection and boot menu
 12349                                  %endif
 12350                                  %ifdef MODULE_DRIVEXLATE
 12351                                  	%include "DriveXlate.asm"		; For swapping drive numbers, must come immediately after HotkeyBar.asm
 12352                                  %endif
 12353                                  
 12354                                  	; Boot menu
 12355                                  %ifdef MODULE_BOOT_MENU
 12356                                  	%include "BootMenu.asm"			; For Boot Menu operations
 12357                                  	%include "BootMenuEvent.asm"	; For menu library event handling
 12358                                  									; NOTE: BootMenuPrint needs to come immediately after BootMenuEvent
 12359                                  									;       so that jump table entries in BootMenuEvent stay within 8-bits
 12360                                  	%include "BootMenuPrint.asm"	; For printing Boot Menu strings, also includes "BootMenuPrintCfg.asm"
 12361                                  %endif
 12362                                  
 12363                                  	; Boot loader
 12364                                  	%include "Int19h.asm"			; For Int 19h, Boot Loader
 12365                              <1> ; Project name	:	XTIDE Universal BIOS
 12366                              <1> ; Description	:	Int 19h Handler (Boot Loader).
 12367                              <1> 
 12368                              <1> ;
 12369                              <1> ; XTIDE Universal BIOS and Associated Tools
 12370                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 12371                              <1> ;
 12372                              <1> ; This program is free software; you can redistribute it and/or modify
 12373                              <1> ; it under the terms of the GNU General Public License as published by
 12374                              <1> ; the Free Software Foundation; either version 2 of the License, or
 12375                              <1> ; (at your option) any later version.
 12376                              <1> ;
 12377                              <1> ; This program is distributed in the hope that it will be useful,
 12378                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 12379                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 12380                              <1> ; GNU General Public License for more details.
 12381                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 12382                              <1> ;
 12383                              <1> 
 12384                              <1> ; Section containing code
 12385                              <1> SECTION .text
 12386                              <1> 
 12387                              <1> ;--------------------------------------------------------------------
 12388                              <1> ; Int19h_BootLoaderHandler
 12389                              <1> ;	Parameters:
 12390                              <1> ;		Nothing
 12391                              <1> ;	Returns:
 12392                              <1> ;		Never returns (loads operating system)
 12393                              <1> ;--------------------------------------------------------------------
 12394                              <1> Int19h_BootLoaderHandler:
 12395 00000757 FB                  <1> 	sti									; Enable interrupts
 12396 00000758 FC                  <1> 	cld									; String instructions to increment pointers
 12397                              <1> 	LOAD_BDA_SEGMENT_TO	es, ax			; Load BDA segment (zero) to ES
 12398                              <2> %ifndef USE_186
 12399 00000759 31C0                <2>  xor %2, %2
 12400 0000075B 8EC0                <2>  mov %1, %2
 12401                              <2> %elifidn %3, !
 12402                              <2>  xor %2, %2
 12403                              <2>  mov %1, %2
 12404                              <2> %else
 12405                              <2>  push BYTE 0
 12406                              <2>  pop %1
 12407                              <2> %endif
 12408                              <1> 	; Fall to .PrepareBootLoaderStack
 12409                              <1> 
 12410                              <1> 
 12411                              <1> ;--------------------------------------------------------------------
 12412                              <1> ; Drive detection and boot menu use lots of stack so it is
 12413                              <1> ; wise to relocate stack. Otherwise something important from
 12414                              <1> ; interrupt vectors are likely corrupted, likely our own DPTs if
 12415                              <1> ; they are located to 30:0h.
 12416                              <1> ;
 12417                              <1> ; .PrepareBootLoaderStack
 12418                              <1> ;	Parameters:
 12419                              <1> ;		ES:		BDA and interrupt vector segment (zero)
 12420                              <1> ;	Returns:
 12421                              <1> ;		Never returns (loads operating system)
 12422                              <1> ;--------------------------------------------------------------------
 12423                              <1> .PrepareBootLoaderStack:
 12424                              <1> 	STORE_POST_STACK_POINTER
 12425 0000075D 268926007F          <2>  mov [es:BOOTVARS.dwPostStack], sp
 12426 00000762 268C16027F          <2>  mov [es:BOOTVARS.dwPostStack+2], ss
 12427                              <1> 	SWITCH_TO_BOOT_MENU_STACK
 12428                              <2> %ifndef USE_186
 12429 00000767 FA                  <2>  cli
 12430                              <2> %endif
 12431                              <2>  LOAD_BDA_SEGMENT_TO ss, sp
 12432                              <3> %ifndef USE_186
 12433 00000768 31E4                <3>  xor %2, %2
 12434 0000076A 8ED4                <3>  mov %1, %2
 12435                              <3> %elifidn %3, !
 12436                              <3>  xor %2, %2
 12437                              <3>  mov %1, %2
 12438                              <3> %else
 12439                              <3>  push BYTE 0
 12440                              <3>  pop %1
 12441                              <3> %endif
 12442 0000076C BC007F              <2>  mov sp, BOOTVARS.rgbMnuStack
 12443                              <2> %ifndef USE_186
 12444 0000076F FB                  <2>  sti
 12445                              <2> %endif
 12446                              <1> 	; Fall to .InitializeDisplay
 12447                              <1> 
 12448                              <1> 
 12449                              <1> ;--------------------------------------------------------------------
 12450                              <1> ; .InitializeDisplay
 12451                              <1> ;	Parameters:
 12452                              <1> ;		ES:		BDA and interrupt vector segment (zero)
 12453                              <1> ;	Returns:
 12454                              <1> ;		Never returns (loads operating system)
 12455                              <1> ;--------------------------------------------------------------------
 12456                              <1> .InitializeDisplay:
 12457                              <1> 	; Change display mode if necessary
 12458 00000770 2EA14800            <1> 	mov		ax, [cs:ROMVARS.wDisplayMode]	; AH 00h = Set Video Mode
 12459 00000774 3C04                <1> 	cmp		al, DEFAULT_TEXT_MODE
 12460 00000776 7402                <1> 	je		SHORT .InitializeDisplayLibrary
 12461 00000778 CD10                <1> 	int		BIOS_VIDEO_INTERRUPT_10h
 12462                              <1> .InitializeDisplayLibrary:
 12463 0000077A E868FF              <1> 	call	DetectPrint_InitializeDisplayContext
 12464                              <1> 	; Fall to .InitializeBiosAndDetectDrives
 12465                              <1> 
 12466                              <1> 
 12467                              <1> ;--------------------------------------------------------------------
 12468                              <1> ; .InitializeBiosAndDetectDrives
 12469                              <1> ;	Parameters:
 12470                              <1> ;		ES:		BDA and interrupt vector segment (zero)
 12471                              <1> ;	Returns:
 12472                              <1> ;		DS:		RAMVARS segment
 12473                              <1> ;--------------------------------------------------------------------
 12474                              <1> %ifdef MODULE_HOTKEYS
 12475                              <1> 	call	TimerTicks_ReadFromBdaToAX
 12476                              <1> 	mov		[es:BOOTVARS.hotkeyVars+HOTKEYVARS.wTimeWhenDisplayed], ax
 12477                              <1> %endif
 12478                              <1> 
 12479 0000077D E80DFC              <1> 	call	Initialize_AndDetectDrives
 12480                              <1> 
 12481                              <1> %ifdef MODULE_HOTKEYS
 12482                              <1> .WaitUntilTimeToCloseHotkeyBar:
 12483                              <1> 	call	TimerTicks_ReadFromBdaToAX
 12484                              <1> 	sub		ax, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.wTimeWhenDisplayed]
 12485                              <1> 	cmp		ax, MIN_TIME_TO_DISPLAY_HOTKEY_BAR
 12486                              <1> 	jb		SHORT .WaitUntilTimeToCloseHotkeyBar
 12487                              <1> %endif
 12488                              <1> 	; Fall to SelectDriveToBootFrom
 12489                              <1> 
 12490                              <1> 
 12491                              <1> ;--------------------------------------------------------------------
 12492                              <1> ; SelectDriveToBootFrom
 12493                              <1> ;	Parameters:
 12494                              <1> ;		DS:		RAMVARS segment
 12495                              <1> ;		ES:		BDA and interrupt vector segment (zero)
 12496                              <1> ;	Returns:
 12497                              <1> ;		Never returns (loads operating system)
 12498                              <1> ;--------------------------------------------------------------------
 12499                              <1> ; The following macro could be easily inlined below.  Why a macro?  Depending on the combination
 12500                              <1> ; of MODULE_HOTKEYS or MODULE_BOOT_MENU, this code needs to either come before or after the
 12501                              <1> ; call to the boot menu.
 12502                              <1> ;
 12503                              <1> %macro TRY_TO_BOOT_DL_AND_DH_DRIVES 0
 12504                              <1> 	push	dx									; it's OK if this is left on the stack, if we are
 12505                              <1> 												; successful, the following call does not return
 12506                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
 12507                              <1> 	pop		dx
 12508                              <1> 	mov		dl, dh
 12509                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
 12510                              <1> %endmacro
 12511                              <1> 
 12512                              <1> 
 12513                              <1> SelectDriveToBootFrom:		; Function starts here
 12514                              <1> %ifdef MODULE_HOTKEYS
 12515                              <1> 	call	HotkeyBar_UpdateDuringDriveDetection
 12516                              <1> 	mov		al, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bScancode]
 12517                              <1> 	cmp		al, ROM_BOOT_HOTKEY_SCANCODE
 12518                              <1> 	je		SHORT .RomBoot						; CF clear so ROM boot
 12519                              <1> %ifdef MODULE_BOOT_MENU
 12520                              <1> 	cmp		al, BOOT_MENU_HOTKEY_SCANCODE
 12521                              <1> 	je		SHORT .BootMenu
 12522                              <1> %endif ; MODULE_BOOT_MENU
 12523                              <1> 
 12524                              <1> .TryUsingHotKeysCode:
 12525                              <1> 	call	HotkeyBar_GetBootDriveNumbersToDX
 12526                              <1> 	call	DriveXlate_SetDriveToSwap			; Enable primary boot device translation
 12527                              <1> 	xchg	dl, dh
 12528                              <1> 	call	DriveXlate_SetDriveToSwap			; Enable secondary boot device translation
 12529                              <1> 	xchg	dl, dh
 12530                              <1> 	call	DriveXlate_ToOrBack					; Tranlate now so boot device will appear as 00h or 80h to OS
 12531                              <1> 	TRY_TO_BOOT_DL_AND_DH_DRIVES
 12532                              <1> 	;; falls through to boot menu, if it is present.  If not present, falls through to rom boot.
 12533                              <1> %endif ; MODULE_HOTKEYS
 12534                              <1> 
 12535                              <1> 
 12536                              <1> %ifdef MODULE_BOOT_MENU
 12537                              <1> .BootMenu:
 12538                              <1> 	call	BootMenu_DisplayAndReturnDriveInDLRomBootClearCF
 12539                              <1> 	jnc		SHORT .RomBoot						; CF clear so ROM boot
 12540                              <1> 
 12541                              <1> 	call	DriveXlate_Reset
 12542                              <1> %ifdef MODULE_HOTKEYS
 12543                              <1> 	jmp		SHORT .TryUsingHotKeysCode			; Selected drive stored as hotkey
 12544                              <1> %else ; Boot menu without hotkeys, secondary boot drive is always 00h or 80h
 12545                              <1> 	mov		dh, dl								; Setup for secondary drive
 12546                              <1> 	not		dh									; Floppy goes to HD, or vice versa
 12547                              <1> 	and		dh, 80h								; Go to first drive of the floppy or HD set
 12548                              <1> 	call	DriveXlate_SetDriveToSwap
 12549                              <1> 	call	DriveXlate_ToOrBack
 12550                              <1> 	TRY_TO_BOOT_DL_AND_DH_DRIVES
 12551                              <1> 	jmp		SHORT .BootMenu						; Show boot menu again
 12552                              <1> %endif ; MODULE_HOTKEYS
 12553                              <1> 
 12554                              <1> %endif ; MODULE_BOOT_MENU
 12555                              <1> 
 12556                              <1> ; No hotkeys and no boot menu means fixed "A then C" boot order
 12557                              <1> %ifndef MODULE_HOTKEYS OR MODULE_BOOT_MENU
 12558 00000780 30D2                <1> 	xor		dl, dl							; Try to boot from Floppy Drive A
 12559 00000782 E82400              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
 12560 00000785 B243                <1> 	mov		dl, DEFAULT_HARD_DRIVE_LETTER	; Try to boot from Hard Drive C
 12561 00000787 E81F00              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
 12562                              <1> %endif
 12563                              <1> 
 12564                              <1> .RomBoot:
 12565                              <1> %ifdef MODULE_DRIVEXLATE
 12566                              <1> 	call	DriveXlate_Reset					; Clean up any drive mappings before Rom Boot
 12567                              <1> %endif
 12568 0000078A F8                  <1> 	clc
 12569                              <1> 	;; fall through to Int19_JumpToBootSectorOrRomBoot
 12570                              <1> 
 12571                              <1> ;--------------------------------------------------------------------
 12572                              <1> ; Int19_JumpToBootSectorOrRomBoot
 12573                              <1> ;
 12574                              <1> ; Switches back to the POST stack, clears the DS and ES registers,
 12575                              <1> ; and either jumps to the MBR (Master Boot Record) that was just read,
 12576                              <1> ; or calls the ROM's boot routine on interrupt 18.
 12577                              <1> ;
 12578                              <1> ;	Parameters:
 12579                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
 12580                              <1> ;       CF:     Set for Boot Sector Boot
 12581                              <1> ;               Clear for ROM Boot
 12582                              <1> ;	   	ES:BX:	(if CF set) Ptr to boot sector
 12583                              <1> ;
 12584                              <1> ;	Returns:
 12585                              <1> ;		Never returns
 12586                              <1> ;--------------------------------------------------------------------
 12587                              <1> Int19_JumpToBootSectorOrRomBoot:
 12588 0000078B 8CC1                <1> 	mov		cx, es		; Preserve MBR segment (can't push because of stack change)
 12589 0000078D B80000              <1> 	mov		ax, 0		; NOTE: can't use XOR (LOAD_BDA_SEGMENT_TO) as it impacts CF
 12590                              <1> 	SWITCH_BACK_TO_POST_STACK
 12591                              <2> %ifndef USE_386
 12592 00000790 FA                  <2>  cli
 12593 00000791 8ED0                <2>  mov ss, ax
 12594 00000793 368B26007F          <2>  mov sp, [ss:BOOTVARS.dwPostStack]
 12595 00000798 368E16027F          <2>  mov ss, [ss:BOOTVARS.dwPostStack+2]
 12596 0000079D FB                  <2>  sti
 12597                              <2> %else
 12598                              <2>  mov ss, ax
 12599                              <2>  lss sp, [ss:BOOTVARS.dwPostStack]
 12600                              <2> %endif
 12601                              <1> 
 12602                              <1> ; clear segment registers before boot sector or rom call
 12603 0000079E 8ED8                <1> 	mov		ds, ax
 12604 000007A0 8EC0                <1> 	mov		es, ax
 12605                              <1> %ifdef USE_386
 12606                              <1> 	mov		fs, ax
 12607                              <1> 	mov		gs, ax
 12608                              <1> %endif
 12609 000007A2 7303                <1> 	jnc		SHORT .romboot
 12610                              <1> 
 12611                              <1> ; jump to boot sector
 12612 000007A4 51                  <1> 	push	cx			; sgment address for MBR
 12613 000007A5 53                  <1> 	push	bx			; offset address for MBR
 12614 000007A6 CB                  <1> 	retf				; NOTE:	DL is set to the drive number
 12615                              <1> 
 12616                              <1> ; Boot by calling INT 18h (ROM Basic of ROM DOS)
 12617                              <1> .romboot:
 12618 000007A7 CD18                <1> 	int		BIOS_BOOT_FAILURE_INTERRUPT_18h	; Never returns
 12619                                  	%include "BootSector.asm"		; For loading boot sector
 12620                              <1> ; Project name	:	XTIDE Universal BIOS
 12621                              <1> ; Description	:	Reading and jumping to boot sector.
 12622                              <1> 
 12623                              <1> ;
 12624                              <1> ; XTIDE Universal BIOS and Associated Tools
 12625                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 12626                              <1> ;
 12627                              <1> ; This program is free software; you can redistribute it and/or modify
 12628                              <1> ; it under the terms of the GNU General Public License as published by
 12629                              <1> ; the Free Software Foundation; either version 2 of the License, or
 12630                              <1> ; (at your option) any later version.
 12631                              <1> ;
 12632                              <1> ; This program is distributed in the hope that it will be useful,
 12633                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 12634                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 12635                              <1> ; GNU General Public License for more details.
 12636                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 12637                              <1> ;
 12638                              <1> 
 12639                              <1> ; Section containing code
 12640                              <1> SECTION .text
 12641                              <1> 
 12642                              <1> ;--------------------------------------------------------------------
 12643                              <1> ; BootSector_TryToLoadFromDriveDL_AndBoot
 12644                              <1> ;	Parameters:
 12645                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
 12646                              <1> ;		DS:		RAMVARS segment
 12647                              <1> ;	Returns:
 12648                              <1> ;		ES:BX:	Ptr to boot sector (if successful)
 12649                              <1> ;		CF:		Set if boot sector loaded successfully
 12650                              <1> ;				Cleared if failed to load boot sector
 12651                              <1> ;	Corrupts registers:
 12652                              <1> ;		AX, CX, DH, SI, DI, (DL if failed to read boot sector)
 12653                              <1> ;--------------------------------------------------------------------
 12654                              <1> BootSector_TryToLoadFromDriveDL_AndBoot:
 12655 000007A9 E87FFF              <1> 	call	DetectPrint_TryToBootFromDL
 12656 000007AC E82B00              <1> 	call	LoadFirstSectorFromDriveDL
 12657 000007AF 7311                <1> 	jnc		SHORT .FirstSectorLoadedToESBX
 12658                              <1> 
 12659                              <1> 	; Do not display timeout error (80h) for floppy drives since
 12660                              <1> 	; it most likely mean no diskette in drive. This way we do not
 12661                              <1> 	; display error code every time user intends to boot from hard disk
 12662                              <1> 	; when A then C boot order is used.
 12663 000007B1 780A                <1> 	js		SHORT .PrintFailedToLoadErrorCode	; Hard Drive
 12664 000007B3 80FC80              <1> 	cmp		ah, RET_HD_TIMEOUT
 12665 000007B6 7420                <1> 	je		SHORT .ReturnWithCFclearSinceFailedToLoadBootSector
 12666 000007B8 80FC31              <1> 	cmp		ah, RET_HD_NOMEDIA
 12667 000007BB 741B                <1> 	je		SHORT .ReturnWithCFclearSinceFailedToLoadBootSector
 12668                              <1> .PrintFailedToLoadErrorCode:
 12669                              <1> %ifdef USE_186
 12670                              <1> 	push	.ReturnWithCFclearSinceFailedToLoadBootSector
 12671                              <1> 	jmp		DetectPrint_FailedToLoadFirstSector
 12672                              <1> %else
 12673 000007BD E85EFF              <1> 	call	DetectPrint_FailedToLoadFirstSector
 12674 000007C0 EB16                <1> 	jmp		.ReturnWithCFclearSinceFailedToLoadBootSector
 12675                              <1> %endif
 12676                              <1> 
 12677                              <1> 
 12678                              <1> .FirstSectorLoadedToESBX:
 12679 000007C2 84D2                <1> 	test	dl, dl
 12680 000007C4 7909                <1> 	jns		SHORT .AlwaysBootFromFloppyDriveForBooterGames
 12681 000007C6 2681BFFE0155AA      <1> 	cmp		WORD [es:bx+510], 0AA55h		; Valid boot sector?
 12682 000007CD 7503                <1> 	jne		SHORT .FirstHardDiskSectorNotBootable
 12683                              <1> .AlwaysBootFromFloppyDriveForBooterGames:
 12684 000007CF F9                  <1> 	stc		; Boot Sector loaded succesfully
 12685 000007D0 EBB9                <1> 	jmp		SHORT Int19_JumpToBootSectorOrRomBoot
 12686                              <1> 
 12687                              <1> .FirstHardDiskSectorNotBootable:
 12688 000007D2 BE[DB00]            <1> 	mov		si, g_szBootSectorNotFound
 12689 000007D5 E873FF              <1> 	call	DetectPrint_NullTerminatedStringFromCSSI
 12690                              <1> .ReturnWithCFclearSinceFailedToLoadBootSector:
 12691 000007D8 F8                  <1> 	clc
 12692 000007D9 C3                  <1> 	ret
 12693                              <1> 
 12694                              <1> 
 12695                              <1> ;--------------------------------------------------------------------
 12696                              <1> ; LoadFirstSectorFromDriveDL
 12697                              <1> ;	Parameters:
 12698                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
 12699                              <1> ;	Returns:
 12700                              <1> ;		AH:		INT 13h error code
 12701                              <1> ;		ES:BX:	Ptr to boot sector (if successful)
 12702                              <1> ;		CF:		Cleared if read successful
 12703                              <1> ;				Set if any error
 12704                              <1> ;	Corrupts registers:
 12705                              <1> ;		AL, CX, DH, DI
 12706                              <1> ;--------------------------------------------------------------------
 12707                              <1> LoadFirstSectorFromDriveDL:
 12708                              <1> 	LOAD_BDA_SEGMENT_TO	es, bx				; ES:BX now points to...
 12709                              <2> %ifndef USE_186
 12710 000007DA 31DB                <2>  xor %2, %2
 12711 000007DC 8EC3                <2>  mov %1, %2
 12712                              <2> %elifidn %3, !
 12713                              <2>  xor %2, %2
 12714                              <2>  mov %1, %2
 12715                              <2> %else
 12716                              <2>  push BYTE 0
 12717                              <2>  pop %1
 12718                              <2> %endif
 12719 000007DE BB007C              <1> 	mov		bx, BOOTVARS.rgbBootSect		; ...boot sector location
 12720 000007E1 BF0300              <1> 	mov		di, BOOT_READ_RETRY_TIMES		; Initialize retry counter
 12721                              <1> 
 12722                              <1> .ReadRetryLoop:
 12723 000007E4 B80102              <1> 	mov		ax, 0201h						; Read 1 sector
 12724 000007E7 B90100              <1> 	mov		cx, 1							; Cylinder 0, Sector 1
 12725 000007EA 30F6                <1> 	xor		dh, dh							; Head 0
 12726 000007EC CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h
 12727 000007EE 7201                <1> 	jc		SHORT .FailedToLoadFirstSector
 12728                              <1> .Return:
 12729 000007F0 C3                  <1> 	ret
 12730                              <1> 
 12731                              <1> .FailedToLoadFirstSector:
 12732 000007F1 4F                  <1> 	dec		di								; Decrement retry counter (preserve CF)
 12733 000007F2 74FC                <1> 	jz		SHORT .Return					; Loop while retries left
 12734                              <1> 
 12735                              <1> 	; Reset drive and retry
 12736 000007F4 31C0                <1> 	xor		ax, ax							; AH=00h, Disk Controller Reset
 12737 000007F6 84D2                <1> 	test	dl, dl							; Floppy drive?
 12738                              <1> 	eCMOVS	ah, RESET_HARD_DISK				; AH=0Dh, Reset Hard Disk (Alternate reset)
 12739 000007F8 7902                <2>  jns SHORT %%Return
 12740 000007FA B40D                <2>  mov %1, %2
 12741                              <2> %%Return:
 12742 000007FC CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h
 12743 000007FE EBE4                <1> 	jmp		SHORT .ReadRetryLoop
 12744                              <1> 
 12745                                  	%include "Int19hReset.asm"		; INT 19h handler for proper system reset
 12746                              <1> ; Project name	:	XTIDE Universal BIOS
 12747                              <1> ; Description	:	Int 19h Handler (Boot Loader).
 12748                              <1> 
 12749                              <1> ;
 12750                              <1> ; XTIDE Universal BIOS and Associated Tools
 12751                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 12752                              <1> ;
 12753                              <1> ; This program is free software; you can redistribute it and/or modify
 12754                              <1> ; it under the terms of the GNU General Public License as published by
 12755                              <1> ; the Free Software Foundation; either version 2 of the License, or
 12756                              <1> ; (at your option) any later version.
 12757                              <1> ;
 12758                              <1> ; This program is distributed in the hope that it will be useful,
 12759                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 12760                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 12761                              <1> ; GNU General Public License for more details.
 12762                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 12763                              <1> ;
 12764                              <1> 
 12765                              <1> ; Section containing code
 12766                              <1> SECTION .text
 12767                              <1> 
 12768                              <1> ;--------------------------------------------------------------------
 12769                              <1> ; INT 19h handler that properly reboots the computer when
 12770                              <1> ; INT 19h is called.
 12771                              <1> ;
 12772                              <1> ; Int19hReset_Handler
 12773                              <1> ;	Parameters:
 12774                              <1> ;		Nothing
 12775                              <1> ;	Returns:
 12776                              <1> ;		Never returns (reboots computer)
 12777                              <1> ;--------------------------------------------------------------------
 12778                              <1> Int19hReset_Handler:
 12779 00000800 B83412              <1> 	mov		ax, BOOT_FLAG_WARM				; Skip memory tests
 12780 00000803 E9F9FA              <1> 	jmp		Reboot_ComputerWithBootFlagInAX
 12781                                  
 12782                                  	; For all device types
 12783                                  	%include "Idepack.asm"
 12784                              <1> ; Project name	:	XTIDE Universal BIOS
 12785                              <1> ; Description	:	Functions for managing IDEPACK struct.
 12786                              <1> 
 12787                              <1> ;
 12788                              <1> ; XTIDE Universal BIOS and Associated Tools
 12789                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 12790                              <1> ;
 12791                              <1> ; This program is free software; you can redistribute it and/or modify
 12792                              <1> ; it under the terms of the GNU General Public License as published by
 12793                              <1> ; the Free Software Foundation; either version 2 of the License, or
 12794                              <1> ; (at your option) any later version.
 12795                              <1> ;
 12796                              <1> ; This program is distributed in the hope that it will be useful,
 12797                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 12798                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 12799                              <1> ; GNU General Public License for more details.
 12800                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 12801                              <1> ;
 12802                              <1> 
 12803                              <1> ; Section containing code
 12804                              <1> SECTION .text
 12805                              <1> 
 12806                              <1> ;--------------------------------------------------------------------
 12807                              <1> ; Idepack_FakeToSSBP
 12808                              <1> ;	Parameters:
 12809                              <1> ;		Nothing
 12810                              <1> ;	Returns:
 12811                              <1> ;		SS:BP:	Ptr to IDEPACK
 12812                              <1> ;	Corrupts registers:
 12813                              <1> ;		AX
 12814                              <1> ;--------------------------------------------------------------------
 12815                              <1> Idepack_FakeToSSBP:
 12816 00000806 58                  <1> 	pop		ax
 12817 00000807 83EC09              <1> 	sub		sp, BYTE SIZE_OF_IDEPACK_WITHOUT_INTPACK
 12818 0000080A 89E5                <1> 	mov		bp, sp
 12819 0000080C FFE0                <1> 	jmp		ax
 12820                              <1> 
 12821                              <1> 
 12822                              <1> ;--------------------------------------------------------------------
 12823                              <1> ; Idepack_ConvertDapToIdepackAndIssueCommandFromAH
 12824                              <1> ;	Parameters:
 12825                              <1> ;		AH:		IDE command to issue
 12826                              <1> ;		BH:		Timeout ticks
 12827                              <1> ;		BL:		IDE Status Register flag to wait after command
 12828                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 12829                              <1> ;		ES:SI:	Ptr to DAP (EBIOS Disk Address Packet)
 12830                              <1> ;		SS:BP:	Ptr to IDEPACK
 12831                              <1> ;	Returns:
 12832                              <1> ;		AH:		INT 13h Error Code
 12833                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
 12834                              <1> ;		CF:		Cleared if success, Set if error
 12835                              <1> ;	Corrupts registers:
 12836                              <1> ;		AL, BX, (CX), DX, SI, ES
 12837                              <1> ;--------------------------------------------------------------------
 12838                              <1> %ifdef MODULE_EBIOS
 12839                              <1> ALIGN JUMP_ALIGN
 12840                              <1> Idepack_ConvertDapToIdepackAndIssueCommandFromAH:
 12841                              <1> 	mov		al, [es:si+DAP.wSectorCount]
 12842                              <1> 	mov		[bp+IDEPACK.bSectorCount], al
 12843                              <1> 	mov		[bp+IDEPACK.bCommand], ah
 12844                              <1> 
 12845                              <1> 	mov		al, [es:si+DAP.qwLBA]		; LBA byte 0
 12846                              <1> 	mov		[bp+IDEPACK.bLbaLow], al
 12847                              <1> 	mov		ax, [es:si+DAP.qwLBA+1]		; LBA bytes 1 and 2
 12848                              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHigh], ax
 12849                              <1> 	mov		ah, [es:si+DAP.qwLBA+3]		; LBA byte 3, LBA28 bits 24...27
 12850                              <1> 	mov		[bp+IDEPACK.bLbaLowExt], ah
 12851                              <1> 	mov		cx, [es:si+DAP.qwLBA+4]		; LBA bytes 4 and 5
 12852                              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHighExt], cx
 12853                              <1> 
 12854                              <1> 	and		ah, 0Fh						; Limit bits for LBA28
 12855                              <1> 	call	AccessDPT_GetDriveSelectByteForEbiosToAL
 12856                              <1> 	or		al, ah
 12857                              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
 12858                              <1> 
 12859                              <1> 	; Load data buffer pointer to ES:SI
 12860                              <1> 	les		si, [es:si+DAP.dwMemoryAddress]
 12861                              <1> 	jmp		SHORT GetDeviceControlByteToIdepackAndStartTransfer
 12862                              <1> %endif ; MODULE_EBIOS
 12863                              <1> 
 12864                              <1> 
 12865                              <1> ;--------------------------------------------------------------------
 12866                              <1> ; Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 12867                              <1> ;	Parameters:
 12868                              <1> ;		AH:		IDE command to issue
 12869                              <1> ;		AL:		Number of sectors to transfer (for xfer commands)
 12870                              <1> ;		BH:		Timeout ticks
 12871                              <1> ;		BL:		IDE Status Register flag to wait after command
 12872                              <1> ;		CH:		Cylinder number, bits 7...0
 12873                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 12874                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 12875                              <1> ;		DH:		Starting head number (0...255)
 12876                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 12877                              <1> ;		ES:SI:	Ptr to normalized data buffer (for xfer commands)
 12878                              <1> ;		SS:BP:	Ptr to IDEPACK (containing INTPACK)
 12879                              <1> ;	Returns:
 12880                              <1> ;		AH:		INT 13h Error Code
 12881                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
 12882                              <1> ;		CF:		Cleared if success, Set if error
 12883                              <1> ;	Corrupts registers:
 12884                              <1> ;		AL, BX, (CX), DX
 12885                              <1> ;--------------------------------------------------------------------
 12886                              <1> ALIGN JUMP_ALIGN
 12887                              <1> Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH:
 12888 0000080E 884602              <1> 	mov		[bp+IDEPACK.bSectorCount], al
 12889 00000811 886606              <1> 	mov		[bp+IDEPACK.bCommand], ah
 12890                              <1> 
 12891 00000814 53                  <1> 	push	bx
 12892 00000815 E8E807              <1> 	call	Address_OldInt13hAddressToIdeAddress
 12893 00000818 E83BFD              <1> 	call	AccessDPT_GetDriveSelectByteForOldInt13hToAL
 12894 0000081B 08F8                <1> 	or		al, bh			; AL now has Drive and Head Select Byte
 12895 0000081D 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
 12896 00000820 885E03              <1> 	mov		[bp+IDEPACK.bLbaLow], bl
 12897 00000823 894E04              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHigh], cx
 12898 00000826 5B                  <1> 	pop		bx
 12899                              <1> 
 12900                              <1> GetDeviceControlByteToIdepackAndStartTransfer:
 12901 00000827 E83CFD              <1> 	call	AccessDPT_GetDeviceControlByteToAL
 12902 0000082A 884607              <1> 	mov		[bp+IDEPACK.bDeviceControl], al
 12903 0000082D E9C100              <1> 	jmp		Device_OutputCommandWithParameters
 12904                              <1> 
 12905                              <1> 
 12906                              <1> ;--------------------------------------------------------------------
 12907                              <1> ; Idepack_StoreNonExtParametersAndIssueCommandFromAL
 12908                              <1> ;	Parameters:
 12909                              <1> ;		BH:		Timeout ticks
 12910                              <1> ;		BL:		IDE Status Register flag to wait after command
 12911                              <1> ;		AL:		IDE command to issue
 12912                              <1> ;		AH:		Parameter to Drive and Head Select Register (Head bits only)
 12913                              <1> ;		DL:		Parameter to Sector Count Register
 12914                              <1> ;		DH:		Parameter to LBA Low / Sector Number Register
 12915                              <1> ;		CL:		Parameter to LBA Middle / Cylinder Low Register
 12916                              <1> ;		CH:		Parameter to LBA High / Cylinder High Register
 12917                              <1> ;		SI:		Parameter to Features Register
 12918                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 12919                              <1> ;		SS:BP:	Ptr to IDEPACK
 12920                              <1> ;	Returns:
 12921                              <1> ;		AH:		INT 13h Error Code
 12922                              <1> ;		CF:		Cleared if success, Set if error
 12923                              <1> ;	Corrupts registers:
 12924                              <1> ;		AL, BX, CX, DX
 12925                              <1> ;--------------------------------------------------------------------
 12926                              <1> ALIGN JUMP_ALIGN
 12927                              <1> Idepack_StoreNonExtParametersAndIssueCommandFromAL:
 12928 00000830 897600              <1> 	mov		[bp+IDEPACK.bFeatures], si
 12929 00000833 884606              <1> 	mov		[bp+IDEPACK.bCommand], al
 12930 00000836 895602              <1> 	mov		[bp+IDEPACK.wSectorCountAndLbaLow], dx
 12931 00000839 894E04              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHigh], cx
 12932                              <1> 
 12933                              <1> 	; Drive and Head select byte
 12934 0000083C 80E40F              <1> 	and		ah, MASK_DRVNHEAD_HEAD		; Keep head bits only
 12935 0000083F E814FD              <1> 	call	AccessDPT_GetDriveSelectByteForOldInt13hToAL
 12936 00000842 08E0                <1> 	or		al, ah
 12937 00000844 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
 12938                              <1> 
 12939                              <1> 	; Device Control byte with interrupts disabled
 12940 00000847 C6460702            <1> 	mov		BYTE [bp+IDEPACK.bDeviceControl], FLG_DEVCONTROL_nIEN
 12941                              <1> 
 12942 0000084B E9A300              <1> 	jmp		Device_OutputCommandWithParameters
 12943                                  	%include "Device.asm"
 12944                              <1> ; Project name	:	XTIDE Universal BIOS
 12945                              <1> ; Description	:	Command and port direction functions for different device types.
 12946                              <1> 
 12947                              <1> ;
 12948                              <1> ; XTIDE Universal BIOS and Associated Tools
 12949                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 12950                              <1> ;
 12951                              <1> ; This program is free software; you can redistribute it and/or modify
 12952                              <1> ; it under the terms of the GNU General Public License as published by
 12953                              <1> ; the Free Software Foundation; either version 2 of the License, or
 12954                              <1> ; (at your option) any later version.
 12955                              <1> ;
 12956                              <1> ; This program is distributed in the hope that it will be useful,
 12957                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 12958                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 12959                              <1> ; GNU General Public License for more details.
 12960                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 12961                              <1> ;
 12962                              <1> 
 12963                              <1> ; Section containing code
 12964                              <1> SECTION .text
 12965                              <1> 
 12966                              <1> 
 12967                              <1> %macro TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE 1
 12968                              <1> 	test	BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE
 12969                              <1> 	jnz		SHORT %1
 12970                              <1> %endmacro
 12971                              <1> 
 12972                              <1> %macro CMP_USING_IDEVARS_IN_CSBP_AND_JUMP_IF 2
 12973                              <1> 	cmp		BYTE [cs:bp+IDEVARS.bDevice], %1
 12974                              <1> 	je		SHORT %2
 12975                              <1> %endmacro
 12976                              <1> 
 12977                              <1> 
 12978                              <1> 
 12979                              <1> ;--------------------------------------------------------------------
 12980                              <1> ; Device_FinalizeDPT
 12981                              <1> ;	Parameters:
 12982                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 12983                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 12984                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 12985                              <1> ;	Returns:
 12986                              <1> ;		Nothing
 12987                              <1> ;	Corrupts registers:
 12988                              <1> ;		AX, BX, CX, DX
 12989                              <1> ;--------------------------------------------------------------------
 12990                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 12991                              <1> Device_FinalizeDPT:
 12992                              <1> 	; needs to check IDEVARS vs. checking the DPT as the serial bit in the DPT is set in the Finalize routine
 12993                              <1> 	CMP_USING_IDEVARS_IN_CSBP_AND_JUMP_IF	DEVICE_SERIAL_PORT, .FinalizeDptForSerialPortDevice
 12994                              <1> 	jmp		IdeDPT_Finalize
 12995                              <1> .FinalizeDptForSerialPortDevice:
 12996                              <1> 	jmp		SerialDPT_Finalize
 12997                              <1> 
 12998                              <1> %else					; IDE
 12999                              <1> 	Device_FinalizeDPT		EQU		IdeDPT_Finalize
 13000                              <1> %endif
 13001                              <1> 
 13002                              <1> 
 13003                              <1> ;--------------------------------------------------------------------
 13004                              <1> ; Device_ResetMasterAndSlaveController
 13005                              <1> ;	Parameters:
 13006                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13007                              <1> ;	Returns:
 13008                              <1> ;		AH:		INT 13h Error Code
 13009                              <1> ;		CF:		Cleared if success, Set if error
 13010                              <1> ;	Corrupts registers:
 13011                              <1> ;		AL, BX, CX, DX
 13012                              <1> ;--------------------------------------------------------------------
 13013                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 13014                              <1> Device_ResetMasterAndSlaveController:
 13015                              <1> 	TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE	ReturnSuccessForSerialPort
 13016                              <1> 	jmp		IdeCommand_ResetMasterAndSlaveController
 13017                              <1> 
 13018                              <1> %else					; IDE
 13019                              <1> 	Device_ResetMasterAndSlaveController	EQU		IdeCommand_ResetMasterAndSlaveController
 13020                              <1> %endif
 13021                              <1> 
 13022                              <1> 
 13023                              <1> ;--------------------------------------------------------------------
 13024                              <1> ; Device_IdentifyToBufferInESSIwithDriveSelectByteInBH
 13025                              <1> ;	Parameters:
 13026                              <1> ;		BH:		Drive Select byte for Drive and Head Select Register
 13027                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 13028                              <1> ;		DS:		Segment to RAMVARS
 13029                              <1> ;		ES:SI:	Ptr to buffer to receive 512-byte IDE Information
 13030                              <1> ;		CS:BP:	Ptr to IDEVARS
 13031                              <1> ;	Returns:
 13032                              <1> ;		AH:		INT 13h Error Code
 13033                              <1> ;		CF:		Cleared if success, Set if error
 13034                              <1> ;	Corrupts registers:
 13035                              <1> ;		AL, BX, CX, DX, SI, DI, ES
 13036                              <1> ;--------------------------------------------------------------------
 13037                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 13038                              <1> Device_IdentifyToBufferInESSIwithDriveSelectByteInBH:
 13039                              <1> 	CMP_USING_IDEVARS_IN_CSBP_AND_JUMP_IF	DEVICE_SERIAL_PORT, .IdentifyDriveFromSerialPort
 13040                              <1> 	jmp		IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
 13041                              <1> .IdentifyDriveFromSerialPort:
 13042                              <1> 	jmp		SerialCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
 13043                              <1> 
 13044                              <1> %else					; IDE
 13045                              <1> 	Device_IdentifyToBufferInESSIwithDriveSelectByteInBH	EQU		IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
 13046                              <1> %endif
 13047                              <1> 
 13048                              <1> 
 13049                              <1> ;--------------------------------------------------------------------
 13050                              <1> ; Device_OutputCommandWithParameters
 13051                              <1> ;	Parameters:
 13052                              <1> ;		BH:		Default system timer ticks for timeout (can be ignored)
 13053                              <1> ;		BL:		IDE Status Register bit to poll after command
 13054                              <1> ;		ES:SI:	Ptr to buffer (for data transfer commands)
 13055                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13056                              <1> ;		SS:BP:	Ptr to IDEPACK
 13057                              <1> ;	Returns:
 13058                              <1> ;		AH:		INT 13h Error Code
 13059                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
 13060                              <1> ;		CF:		Cleared if success, Set if error
 13061                              <1> ;	Corrupts registers:
 13062                              <1> ;		AL, BX, (CX), DX, (ES:SI for data transfer commands)
 13063                              <1> ;--------------------------------------------------------------------
 13064                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 13065                              <1> ALIGN JUMP_ALIGN
 13066                              <1> Device_OutputCommandWithParameters:
 13067                              <1> 	TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE .OutputCommandToSerialPort
 13068                              <1> 	jmp		IdeCommand_OutputWithParameters
 13069                              <1> 
 13070                              <1> ALIGN JUMP_ALIGN
 13071                              <1> .OutputCommandToSerialPort:
 13072                              <1> 	jmp		SerialCommand_OutputWithParameters
 13073                              <1> 
 13074                              <1> %else					; IDE
 13075                              <1> 	Device_OutputCommandWithParameters		EQU		IdeCommand_OutputWithParameters
 13076                              <1> %endif
 13077                              <1> 
 13078                              <1> 
 13079                              <1> ;--------------------------------------------------------------------
 13080                              <1> ; Device_SelectDrive
 13081                              <1> ;	Parameters:
 13082                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13083                              <1> ;		SS:BP:	Ptr to IDEPACK
 13084                              <1> ;	Returns:
 13085                              <1> ;		AH:		INT 13h Error Code
 13086                              <1> ;		CF:		Cleared if success, Set if error
 13087                              <1> ;	Corrupts registers:
 13088                              <1> ;		AL, BX, CX, DX
 13089                              <1> ;--------------------------------------------------------------------
 13090                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 13091                              <1> Device_SelectDrive:
 13092                              <1> 	TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE	ReturnSuccessForSerialPort
 13093                              <1> 	jmp		IdeCommand_SelectDrive
 13094                              <1> 
 13095                              <1> %else					; IDE
 13096                              <1> 	Device_SelectDrive		EQU		IdeCommand_SelectDrive
 13097                              <1> %endif
 13098                              <1> 
 13099                              <1> 
 13100                              <1> %ifdef MODULE_SERIAL
 13101                              <1> ALIGN JUMP_ALIGN
 13102                              <1> ReturnSuccessForSerialPort:
 13103                              <1> 	xor		ax, ax
 13104                              <1> 	ret
 13105                              <1> %endif
 13106                                  	%include "Timer.asm"			; For timeout and delay
 13107                              <1> ; Project name	:	XTIDE Universal BIOS
 13108                              <1> ; Description	:	Timeout and delay functions for INT 13h services.
 13109                              <1> 
 13110                              <1> ;
 13111                              <1> ; XTIDE Universal BIOS and Associated Tools
 13112                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 13113                              <1> ;
 13114                              <1> ; This program is free software; you can redistribute it and/or modify
 13115                              <1> ; it under the terms of the GNU General Public License as published by
 13116                              <1> ; the Free Software Foundation; either version 2 of the License, or
 13117                              <1> ; (at your option) any later version.
 13118                              <1> ;
 13119                              <1> ; This program is distributed in the hope that it will be useful,
 13120                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 13121                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 13122                              <1> ; GNU General Public License for more details.
 13123                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 13124                              <1> ;
 13125                              <1> 
 13126                              <1> ; Section containing code
 13127                              <1> SECTION .text
 13128                              <1> 
 13129                              <1> ;--------------------------------------------------------------------
 13130                              <1> ; Timer_InitializeTimeoutWithTicksInCL
 13131                              <1> ;	Parameters:
 13132                              <1> ;		CL:		Timeout value in system timer ticks
 13133                              <1> ;		DS:		Segment to RAMVARS
 13134                              <1> ;	Returns:
 13135                              <1> ;		Nothing
 13136                              <1> ;	Corrupts registers:
 13137                              <1> ;		CX
 13138                              <1> ;--------------------------------------------------------------------
 13139                              <1> ALIGN JUMP_ALIGN
 13140                              <1> Timer_InitializeTimeoutWithTicksInCL:
 13141 0000084E 880E0600            <1> 	mov		[RAMVARS.bTimeoutTicksLeft], cl		; Ticks until timeout
 13142 00000852 E82900              <1> 	call	ReadTimeFromBdaToCX
 13143 00000855 880E0700            <1> 	mov		[RAMVARS.bLastTimeoutUpdate], cl	; Start time
 13144 00000859 C3                  <1> 	ret
 13145                              <1> 
 13146                              <1> 
 13147                              <1> ;--------------------------------------------------------------------
 13148                              <1> ; Timer_SetCFifTimeout
 13149                              <1> ;	Parameters:
 13150                              <1> ;		DS:		Segment to RAMVARS
 13151                              <1> ;	Returns:
 13152                              <1> ;		CF:		Set if timeout
 13153                              <1> ;				Cleared if time left
 13154                              <1> ;	Corrupts registers:
 13155                              <1> ;		CX
 13156                              <1> ;--------------------------------------------------------------------
 13157                              <1> ALIGN JUMP_ALIGN
 13158                              <1> Timer_SetCFifTimeout:
 13159 0000085A E82100              <1> 	call	ReadTimeFromBdaToCX
 13160 0000085D 3A0E0700            <1> 	cmp		cl, [RAMVARS.bLastTimeoutUpdate]
 13161 00000861 7409                <1> 	je		SHORT .StillPollingTheSameTick
 13162 00000863 880E0700            <1> 	mov		[RAMVARS.bLastTimeoutUpdate], cl
 13163 00000867 802E060001          <1> 	sub		BYTE [RAMVARS.bTimeoutTicksLeft], 1	; DEC does not update CF
 13164                              <1> .StillPollingTheSameTick:
 13165 0000086C C3                  <1> 	ret
 13166                              <1> 
 13167                              <1> 
 13168                              <1> ;--------------------------------------------------------------------
 13169                              <1> ; Delay is always at least one millisecond since
 13170                              <1> ; RTC resolution is 977 microsecs.
 13171                              <1> ;
 13172                              <1> ; Timer_DelayMicrosecondsFromAX
 13173                              <1> ;	Parameters:
 13174                              <1> ;		AX:		Number of microsecs to wait
 13175                              <1> ;	Returns:
 13176                              <1> ;		Nothing
 13177                              <1> ;	Corrupts registers:
 13178                              <1> ;		AX
 13179                              <1> ;--------------------------------------------------------------------
 13180                              <1> Timer_DelayMicrosecondsFromAX:
 13181                              <1> %ifndef USE_AT
 13182 0000086D B80200              <1> 	mov		ax, 2
 13183                              <1> 	; Fall to Timer_DelayTimerTicksFromAX
 13184                              <1> %else
 13185                              <1> 	push	dx
 13186                              <1> 	push	cx
 13187                              <1> 
 13188                              <1> 	xor		cx, cx
 13189                              <1> 	xchg	dx, ax						; Microsecs now in CX:DX
 13190                              <1> 	mov		ah, EVENT_WAIT
 13191                              <1> 	int		BIOS_SYSTEM_INTERRUPT_15h
 13192                              <1> 	sti									; XT BIOSes return with interrupts disabled. TODO: Maybe we can remove this since it's in an AT-only block?
 13193                              <1> 
 13194                              <1> 	pop		cx
 13195                              <1> 	pop		dx
 13196                              <1> 	mov		ax, 1								; Prepare to wait 1 timer tick
 13197                              <1> 	jc		SHORT Timer_DelayTimerTicksFromAX	; Event Wait was unsupported or busy
 13198                              <1> 	ret
 13199                              <1> %endif
 13200                              <1> 
 13201                              <1> 
 13202                              <1> ;--------------------------------------------------------------------
 13203                              <1> ; First tick might take 0...54.9 ms and remaining ticks
 13204                              <1> ; will occur at 54.9 ms intervals.
 13205                              <1> ;
 13206                              <1> ; Timer_DelayTimerTicksFromAX
 13207                              <1> ;	Parameters:
 13208                              <1> ;		AX:		Number of timer ticks to wait
 13209                              <1> ;	Returns:
 13210                              <1> ;		Nothing
 13211                              <1> ;	Corrupts registers:
 13212                              <1> ;		AX
 13213                              <1> ;--------------------------------------------------------------------
 13214                              <1> Timer_DelayTimerTicksFromAX:
 13215 00000870 FB                  <1> 	sti								; Make sure that interrupts are enabled
 13216 00000871 E80A00              <1> 	call	ReadTimeFromBdaToCX
 13217 00000874 01C8                <1> 	add		ax, cx					; AX = end time
 13218                              <1> .WaitLoop:
 13219 00000876 E80500              <1> 	call	ReadTimeFromBdaToCX
 13220 00000879 39C1                <1> 	cmp		cx, ax
 13221 0000087B 75F9                <1> 	jne		SHORT .WaitLoop			; Loop until end time is reached
 13222 0000087D C3                  <1> 	ret
 13223                              <1> 
 13224                              <1> 
 13225                              <1> ;--------------------------------------------------------------------
 13226                              <1> ; ReadTimeFromBdaToCX
 13227                              <1> ;	Parameters
 13228                              <1> ;		Nothing
 13229                              <1> ;	Returns:
 13230                              <1> ;		CX:		System time in 54.9 ms ticks
 13231                              <1> ;	Corrupts registers:
 13232                              <1> ;		Nothing
 13233                              <1> ;--------------------------------------------------------------------
 13234                              <1> ALIGN JUMP_ALIGN
 13235                              <1> ReadTimeFromBdaToCX:
 13236 0000087E 1E                  <1> 	push	ds
 13237                              <1> 	LOAD_BDA_SEGMENT_TO	ds, cx
 13238                              <2> %ifndef USE_186
 13239 0000087F 31C9                <2>  xor %2, %2
 13240 00000881 8ED9                <2>  mov %1, %2
 13241                              <2> %elifidn %3, !
 13242                              <2>  xor %2, %2
 13243                              <2>  mov %1, %2
 13244                              <2> %else
 13245                              <2>  push BYTE 0
 13246                              <2>  pop %1
 13247                              <2> %endif
 13248 00000883 8B0E6C04            <1> 	mov		cx, [BDA.dwTimerTicks]	; Read low WORD only
 13249 00000887 1F                  <1> 	pop		ds
 13250 00000888 C3                  <1> 	ret
 13251                                  
 13252                                  	; IDE Device support
 13253                                  %ifdef MODULE_ADVANCED_ATA
 13254                                  	%include "AdvAtaInit.asm"		; For initializing VLB and PCI controllers
 13255                                  	%include "Vision.asm"			; QDI Vision QD6500 and QD6580 support
 13256                                  %endif
 13257                                  	%include "IdeCommand.asm"
 13258                              <1> ; Project name	:	XTIDE Universal BIOS
 13259                              <1> ; Description	:	IDE Device Command functions.
 13260                              <1> 
 13261                              <1> ;
 13262                              <1> ; XTIDE Universal BIOS and Associated Tools
 13263                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 13264                              <1> ;
 13265                              <1> ; This program is free software; you can redistribute it and/or modify
 13266                              <1> ; it under the terms of the GNU General Public License as published by
 13267                              <1> ; the Free Software Foundation; either version 2 of the License, or
 13268                              <1> ; (at your option) any later version.
 13269                              <1> ;
 13270                              <1> ; This program is distributed in the hope that it will be useful,
 13271                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 13272                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 13273                              <1> ; GNU General Public License for more details.
 13274                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 13275                              <1> ;
 13276                              <1> 
 13277                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 13278                              <1> 
 13279                              <1> ; Section containing code
 13280                              <1> SECTION .text
 13281                              <1> 
 13282                              <1> ;--------------------------------------------------------------------
 13283                              <1> ; IdeCommand_ResetMasterAndSlaveController
 13284                              <1> ;	Parameters:
 13285                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13286                              <1> ;	Returns:
 13287                              <1> ;		AH:		INT 13h Error Code
 13288                              <1> ;		CF:		Cleared if success, Set if error
 13289                              <1> ;	Corrupts registers:
 13290                              <1> ;		AL, BX, CX, DX
 13291                              <1> ;--------------------------------------------------------------------
 13292                              <1> IdeCommand_ResetMasterAndSlaveController:
 13293                              <1> 	; HSR0: Set_SRST
 13294 00000889 E8DAFC              <1> 	call	AccessDPT_GetDeviceControlByteToAL
 13295 0000088C 0C06                <1> 	or		al, FLG_DEVCONTROL_SRST | FLG_DEVCONTROL_nIEN	; Set Reset bit
 13296                              <1> 	OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER		DEVICE_CONTROL_REGISTER_out
 13297                              <2> %ifndef MODULE_8BIT_IDE
 13298                              <2> 
 13299                              <2>  %ifnidni %1, dx
 13300                              <2>  mov dx, %1
 13301                              <2>  %endif
 13302                              <2>  eMOVZX bx, BYTE [di+DPT.bIdevarsOffset]
 13303                              <2>  add dx, [cs:bx+IDEVARS.wControlBlockPort]
 13304                              <2>  out dx, al
 13305                              <2> 
 13306                              <2> %else
 13307                              <2> 
 13308                              <2>  %ifnidni %1, dl
 13309 0000088E B206                <2>  mov dl, %1
 13310                              <2>  %endif
 13311 00000890 E8A003              <2>  call IdeIO_OutputALtoIdeControlBlockRegisterInDL
 13312                              <2> 
 13313                              <2> %endif
 13314 00000893 B80600              <1> 	mov		ax, HSR0_RESET_WAIT_US
 13315 00000896 E8D4FF              <1> 	call	Timer_DelayMicrosecondsFromAX
 13316                              <1> 
 13317                              <1> 	; HSR1: Clear_wait
 13318 00000899 E8CAFC              <1> 	call	AccessDPT_GetDeviceControlByteToAL
 13319 0000089C 0C02                <1> 	or		al, FLG_DEVCONTROL_nIEN
 13320 0000089E 24FB                <1> 	and		al, ~FLG_DEVCONTROL_SRST						; Clear reset bit
 13321                              <1> 	OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER		DEVICE_CONTROL_REGISTER_out
 13322                              <2> %ifndef MODULE_8BIT_IDE
 13323                              <2> 
 13324                              <2>  %ifnidni %1, dx
 13325                              <2>  mov dx, %1
 13326                              <2>  %endif
 13327                              <2>  eMOVZX bx, BYTE [di+DPT.bIdevarsOffset]
 13328                              <2>  add dx, [cs:bx+IDEVARS.wControlBlockPort]
 13329                              <2>  out dx, al
 13330                              <2> 
 13331                              <2> %else
 13332                              <2> 
 13333                              <2>  %ifnidni %1, dl
 13334 000008A0 B206                <2>  mov dl, %1
 13335                              <2>  %endif
 13336 000008A2 E88E03              <2>  call IdeIO_OutputALtoIdeControlBlockRegisterInDL
 13337                              <2> 
 13338                              <2> %endif
 13339 000008A5 B83408              <1> 	mov		ax, HSR1_RESET_WAIT_US
 13340 000008A8 E8C2FF              <1> 	call	Timer_DelayMicrosecondsFromAX
 13341                              <1> 
 13342                              <1> 	; HSR2: Check_status
 13343 000008AB BB80FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_MAXIMUM, FLG_STATUS_BSY)
 13344 000008AE E9CD02              <1> 	jmp		IdeWait_PollStatusFlagInBLwithTimeoutInBH
 13345                              <1> 
 13346                              <1> 
 13347                              <1> ;--------------------------------------------------------------------
 13348                              <1> ; IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
 13349                              <1> ;	Parameters:
 13350                              <1> ;		BH:		Drive Select byte for Drive and Head Select Register
 13351                              <1> ;		DX:		Autodetected port for XT-CF
 13352                              <1> ;		DS:		Segment to RAMVARS
 13353                              <1> ;		ES:SI:	Ptr to buffer to receive 512-byte IDE Information
 13354                              <1> ;		CS:BP:	Ptr to IDEVARS
 13355                              <1> ;	Returns:
 13356                              <1> ;		AH:		INT 13h Error Code
 13357                              <1> ;		CF:		Cleared if success, Set if error
 13358                              <1> ;	Corrupts registers:
 13359                              <1> ;		AL, BX, CX, DX, SI, DI, ES
 13360                              <1> ;--------------------------------------------------------------------
 13361                              <1> IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH:
 13362                              <1> 	; Create fake DPT to be able to use Device.asm functions
 13363 000008B1 E879FC              <1> 	call	FindDPT_ForNewDriveToDSDI
 13364                              <1> 	eMOVZX	ax, bh
 13365                              <2> %ifndef USE_386
 13366                              <2>  %ifidni %1, ax
 13367 000008B4 88F8                <2>  mov al, %2
 13368 000008B6 30E4                <2>  xor ah, ah
 13369                              <2>  %elifidni %1, bx
 13370                              <2>  mov bl, %2
 13371                              <2>  xor bh, bh
 13372                              <2>  %elifidni %1, cx
 13373                              <2>  mov cl, %2
 13374                              <2>  xor ch, ch
 13375                              <2>  %elifidni %1, dx
 13376                              <2>  mov dl, %2
 13377                              <2>  xor dh, dh
 13378                              <2>  %else
 13379                              <2>  push ax
 13380                              <2>  mov al, %2
 13381                              <2>  xor ah, ah
 13382                              <2>  xchg ax, %1
 13383                              <2>  pop ax
 13384                              <2>  %endif
 13385                              <2> 
 13386                              <2> %else
 13387                              <2>  movzx %1, %2
 13388                              <2> %endif
 13389 000008B8 8905                <1> 	mov		[di+DPT.wFlags], ax
 13390 000008BA E80DFC              <1> 	call	CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI
 13391 000008BD E84103              <1> 	call	IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP
 13392 000008C0 C6450D01            <1> 	mov		BYTE [di+DPT_ATA.bBlockSize], 1	; Block = 1 sector
 13393                              <1> 
 13394                              <1> 	; Wait until drive motors have reached full speed
 13395 000008C4 83FD51              <1> 	cmp		bp, BYTE ROMVARS.ideVars0	; First controller?
 13396 000008C7 750B                <1> 	jne		SHORT .SkipLongWaitSinceDriveIsNotPrimaryMaster
 13397 000008C9 F6C710              <1> 	test		bh, FLG_DRVNHEAD_DRV		; Wait already done for Master
 13398 000008CC 7506                <1> 	jnz		SHORT .SkipLongWaitSinceDriveIsNotPrimaryMaster
 13399 000008CE BB40B5              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_MOTOR_STARTUP, FLG_STATUS_DRDY)
 13400 000008D1 E8AA02              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
 13401                              <1> .SkipLongWaitSinceDriveIsNotPrimaryMaster:
 13402                              <1> 
 13403                              <1> 	; Create IDEPACK without INTPACK
 13404 000008D4 55                  <1> 	push		bp
 13405 000008D5 E82EFF              <1> 	call	Idepack_FakeToSSBP
 13406                              <1> 
 13407                              <1> %ifdef MODULE_8BIT_IDE
 13408                              <1> 	; Enable 8-bit PIO mode for 8-bit ATA and XT-CF
 13409 000008D8 56                  <1> 	push		si
 13410 000008D9 E86006              <1> 	call	AH9h_Enable8bitModeForDevice8bitAta
 13411 000008DC 30C0                <1> 	xor		al, al						; XTCF_8BIT_PIO_MODE
 13412                              <1> 	call	AH9h_SetModeFromALtoXTCF
 13413          ******************  <1>  error: symbol `AH9h_SetModeFromALtoXTCF' undefined
 13414 000008DE 5E                  <1> 	pop		si
 13415                              <1> %endif ; MODULE_8BIT_IDE
 13416                              <1> 
 13417                              <1> 	; Prepare to output Identify Device command
 13418 000008DF B201                <1> 	mov		dl, 1						; Sector count (required by IdeTransfer.asm)
 13419 000008E1 B0EC                <1> 	mov		al, COMMAND_IDENTIFY_DEVICE
 13420 000008E3 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 13421 000008E6 E847FF              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
 13422                              <1> 
 13423                              <1> 	; Clean stack and return
 13424                              <1> .FailedToSet8bitMode:
 13425 000008E9 8D6609              <1> 	lea		sp, [bp+SIZE_OF_IDEPACK_WITHOUT_INTPACK]	; This assumes BP hasn't changed between Idepack_FakeToSSBP and here
 13426 000008EC 5D                  <1> 	pop		bp
 13427 000008ED C3                  <1> 	ret
 13428                              <1> 
 13429                              <1> 
 13430                              <1> ;--------------------------------------------------------------------
 13431                              <1> ; IdeCommand_OutputWithParameters
 13432                              <1> ;	Parameters:
 13433                              <1> ;		BH:		System timer ticks for timeout
 13434                              <1> ;		BL:		IDE Status Register bit to poll after command
 13435                              <1> ;		ES:SI:	Ptr to buffer (for data transfer commands)
 13436                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13437                              <1> ;		SS:BP:	Ptr to IDEPACK
 13438                              <1> ;	Returns:
 13439                              <1> ;		AH:		INT 13h Error Code
 13440                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
 13441                              <1> ;		CF:		Cleared if success, Set if error
 13442                              <1> ;	Corrupts registers:
 13443                              <1> ;		AL, BX, (CX), DX, (ES:SI for data transfer commands)
 13444                              <1> ;--------------------------------------------------------------------
 13445                              <1> ALIGN JUMP_ALIGN
 13446                              <1> IdeCommand_OutputWithParameters:
 13447 000008EE 53                  <1> 	push	bx						; Store status register bits to poll
 13448                              <1> 
 13449                              <1> 	; Select Master or Slave drive and output head number or LBA28 top bits
 13450 000008EF E83300              <1> 	call	IdeCommand_SelectDrive
 13451 000008F2 722F                <1> 	jc		SHORT .DriveNotReady
 13452                              <1> 
 13453                              <1> 	; Output Device Control Byte to enable or disable interrupts
 13454 000008F4 8A4607              <1> 	mov		al, [bp+IDEPACK.bDeviceControl]
 13455                              <1> %ifdef MODULE_IRQ
 13456                              <1> 	test	al, FLG_DEVCONTROL_nIEN	; Interrupts disabled?
 13457                              <1> 	jnz		SHORT .DoNotSetInterruptInServiceFlag
 13458                              <1> 
 13459                              <1> 	; Clear Task Flag and set Interrupt In-Service Flag
 13460                              <1> 	or		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_INTERRUPT_IN_SERVICE
 13461                              <1> 	push	ds
 13462                              <1> 	LOAD_BDA_SEGMENT_TO	ds, dx, !	; Also zero DX
 13463                              <1> 	mov		[BDA.bHDTaskFlg], dl
 13464                              <1> 	pop		ds
 13465                              <1> .DoNotSetInterruptInServiceFlag:
 13466                              <1> %endif
 13467                              <1> 	OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER		DEVICE_CONTROL_REGISTER_out
 13468                              <2> %ifndef MODULE_8BIT_IDE
 13469                              <2> 
 13470                              <2>  %ifnidni %1, dx
 13471                              <2>  mov dx, %1
 13472                              <2>  %endif
 13473                              <2>  eMOVZX bx, BYTE [di+DPT.bIdevarsOffset]
 13474                              <2>  add dx, [cs:bx+IDEVARS.wControlBlockPort]
 13475                              <2>  out dx, al
 13476                              <2> 
 13477                              <2> %else
 13478                              <2> 
 13479                              <2>  %ifnidni %1, dl
 13480 000008F7 B206                <2>  mov dl, %1
 13481                              <2>  %endif
 13482 000008F9 E83703              <2>  call IdeIO_OutputALtoIdeControlBlockRegisterInDL
 13483                              <2> 
 13484                              <2> %endif
 13485                              <1> 
 13486                              <1> 	; Output Feature Number
 13487 000008FC 8A4600              <1> 	mov		al, [bp+IDEPACK.bFeatures]
 13488                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	FEATURES_REGISTER_out
 13489                              <2> %ifndef MODULE_8BIT_IDE
 13490                              <2> 
 13491                              <2>  %ifnidni %1, dx
 13492                              <2>  mov dx, %1
 13493                              <2>  %endif
 13494                              <2>  add dx, [di+DPT.wBasePort]
 13495                              <2>  out dx, al
 13496                              <2> 
 13497                              <2> %else
 13498                              <2> 
 13499                              <2>  %ifnidni %1, dl
 13500 000008FF B201                <2>  mov dl, %1
 13501                              <2>  %endif
 13502 00000901 E85E03              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 13503                              <2> 
 13504                              <2> %endif
 13505                              <1> 
 13506                              <1> 	; Output Sector Address High (only used by LBA48)
 13507                              <1> %ifdef MODULE_EBIOS
 13508                              <1> 	eMOVZX	ax, [bp+IDEPACK.bLbaLowExt]		; Zero sector count
 13509                              <1> 	mov		cx, [bp+IDEPACK.wLbaMiddleAndHighExt]
 13510                              <1> 	call	OutputSectorCountAndAddress
 13511                              <1> %endif
 13512                              <1> 
 13513                              <1> 	; Output Sector Address Low
 13514 00000904 8B4602              <1> 	mov		ax, [bp+IDEPACK.wSectorCountAndLbaLow]
 13515 00000907 8B4E04              <1> 	mov		cx, [bp+IDEPACK.wLbaMiddleAndHigh]
 13516 0000090A E83C00              <1> 	call	OutputSectorCountAndAddress
 13517                              <1> 
 13518                              <1> 	; Output command
 13519 0000090D 8A4606              <1> 	mov		al, [bp+IDEPACK.bCommand]
 13520                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	COMMAND_REGISTER_out
 13521                              <2> %ifndef MODULE_8BIT_IDE
 13522                              <2> 
 13523                              <2>  %ifnidni %1, dx
 13524                              <2>  mov dx, %1
 13525                              <2>  %endif
 13526                              <2>  add dx, [di+DPT.wBasePort]
 13527                              <2>  out dx, al
 13528                              <2> 
 13529                              <2> %else
 13530                              <2> 
 13531                              <2>  %ifnidni %1, dl
 13532 00000910 B207                <2>  mov dl, %1
 13533                              <2>  %endif
 13534 00000912 E84D03              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 13535                              <2> 
 13536                              <2> %endif
 13537                              <1> 
 13538                              <1> 	; Wait until command completed
 13539 00000915 5B                  <1> 	pop		bx						; Pop status and timeout for polling
 13540 00000916 80FB08              <1> 	cmp		bl, FLG_STATUS_DRQ				; Data transfer started?
 13541 00000919 7505                <1> 	jne		SHORT .WaitUntilNonTransferCommandCompletes
 13542                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 13543                              <1> 	cmp		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_JRIDE_ISA
 13544                              <1> 	jae		SHORT JrIdeTransfer_StartWithCommandInAL
 13545                              <1> %endif
 13546 0000091B EB47                <1> 	jmp		IdeTransfer_StartWithCommandInAL
 13547                              <1> 
 13548                              <1> .WaitUntilNonTransferCommandCompletes:
 13549                              <1> %ifdef MODULE_IRQ
 13550                              <1> 	test	BYTE [bp+IDEPACK.bDeviceControl], FLG_DEVCONTROL_nIEN
 13551                              <1> 	jz		SHORT .PollStatusFlagInsteadOfWaitIrq
 13552                              <1> 	jmp		IdeWait_IRQorStatusFlagInBLwithTimeoutInBH
 13553                              <1> .PollStatusFlagInsteadOfWaitIrq:
 13554                              <1> %endif
 13555 0000091D E95E02              <1> 	jmp		IdeWait_PollStatusFlagInBLwithTimeoutInBH
 13556                              <1> 
 13557                              <1> .DriveNotReady:
 13558 00000920 5B                  <1> 	pop		bx							; Clean stack
 13559 00000921 C3                  <1> 	ret
 13560                              <1> 
 13561                              <1> 
 13562                              <1> ;--------------------------------------------------------------------
 13563                              <1> ; IdeCommand_SelectDrive
 13564                              <1> ;	Parameters:
 13565                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13566                              <1> ;		SS:BP:	Ptr to IDEPACK
 13567                              <1> ;	Returns:
 13568                              <1> ;		AH:		INT 13h Error Code
 13569                              <1> ;		CF:		Cleared if success, Set if error
 13570                              <1> ;	Corrupts registers:
 13571                              <1> ;		AL, BX, CX, DX
 13572                              <1> ;--------------------------------------------------------------------
 13573                              <1> ALIGN JUMP_ALIGN
 13574                              <1> IdeCommand_SelectDrive:
 13575                              <1> 	; We use different timeout value when detecting drives.
 13576                              <1> 	; This prevents unnecessary long delays when drive is not present.
 13577 00000922 B9402F              <1> 	mov		cx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRDY, FLG_STATUS_DRDY)
 13578 00000925 813E00005A5A        <1> 	cmp		WORD [RAMVARS.wDrvDetectSignature], RAMVARS_DRV_DETECT_SIGNATURE
 13579                              <1> 	eCMOVE	ch, TIMEOUT_SELECT_DRIVE_DURING_DRIVE_DETECTION
 13580                              <2>  eCMOVZ %1, %2
 13581 0000092B 7505                <3>  jnz SHORT %%Return
 13582 0000092D B509                <3>  mov %1, %2
 13583                              <3> %%Return:
 13584                              <1> 
 13585                              <1> 	; Select Master or Slave Drive
 13586 0000092F 8A4601              <1> 	mov		al, [bp+IDEPACK.bDrvAndHead]
 13587                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	DRIVE_AND_HEAD_SELECT_REGISTER
 13588                              <2> %ifndef MODULE_8BIT_IDE
 13589                              <2> 
 13590                              <2>  %ifnidni %1, dx
 13591                              <2>  mov dx, %1
 13592                              <2>  %endif
 13593                              <2>  add dx, [di+DPT.wBasePort]
 13594                              <2>  out dx, al
 13595                              <2> 
 13596                              <2> %else
 13597                              <2> 
 13598                              <2>  %ifnidni %1, dl
 13599 00000932 B206                <2>  mov dl, %1
 13600                              <2>  %endif
 13601 00000934 E82B03              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 13602                              <2> 
 13603                              <2> %endif
 13604 00000937 89CB                <1> 	mov		bx, cx
 13605 00000939 E84202              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
 13606                              <1> 
 13607                              <1> 	; Ignore errors from IDE Error Register (set by previous command)
 13608 0000093C 80FC80              <1> 	cmp		ah, RET_HD_TIMEOUT
 13609 0000093F 7406                <1> 	je		SHORT .FailedToSelectDrive
 13610 00000941 31C0                <1> 	xor		ax, ax					; Always success unless timeout
 13611 00000943 C3                  <1> 	ret
 13612                              <1> .FailedToSelectDrive:
 13613 00000944 F9                  <1> 	stc
 13614 00000945 C3                  <1> 	ret
 13615                              <1> 
 13616                              <1> 
 13617                              <1> ;--------------------------------------------------------------------
 13618                              <1> ; OutputSectorCountAndAddress
 13619                              <1> ;	Parameters:
 13620                              <1> ;		AH:		LBA low bits (Sector Number)
 13621                              <1> ;		AL:		Sector Count
 13622                              <1> ;		CL:		LBA middle bits (Cylinder Number low)
 13623                              <1> ;		CH:		LBA high bits (Cylinder Number high)
 13624                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13625                              <1> ;	Returns:
 13626                              <1> ;		Nothing
 13627                              <1> ;	Corrupts registers:
 13628                              <1> ;		AL, BX, DX
 13629                              <1> ;--------------------------------------------------------------------
 13630                              <1> ALIGN JUMP_ALIGN
 13631                              <1> OutputSectorCountAndAddress:
 13632                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	SECTOR_COUNT_REGISTER
 13633                              <2> %ifndef MODULE_8BIT_IDE
 13634                              <2> 
 13635                              <2>  %ifnidni %1, dx
 13636                              <2>  mov dx, %1
 13637                              <2>  %endif
 13638                              <2>  add dx, [di+DPT.wBasePort]
 13639                              <2>  out dx, al
 13640                              <2> 
 13641                              <2> %else
 13642                              <2> 
 13643                              <2>  %ifnidni %1, dl
 13644 00000946 B202                <2>  mov dl, %1
 13645                              <2>  %endif
 13646 00000948 E81703              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 13647                              <2> 
 13648                              <2> %endif
 13649                              <1> 
 13650 0000094B 88E0                <1> 	mov		al, ah
 13651                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	LBA_LOW_REGISTER
 13652                              <2> %ifndef MODULE_8BIT_IDE
 13653                              <2> 
 13654                              <2>  %ifnidni %1, dx
 13655                              <2>  mov dx, %1
 13656                              <2>  %endif
 13657                              <2>  add dx, [di+DPT.wBasePort]
 13658                              <2>  out dx, al
 13659                              <2> 
 13660                              <2> %else
 13661                              <2> 
 13662                              <2>  %ifnidni %1, dl
 13663 0000094D B203                <2>  mov dl, %1
 13664                              <2>  %endif
 13665 0000094F E81003              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 13666                              <2> 
 13667                              <2> %endif
 13668                              <1> 
 13669 00000952 88C8                <1> 	mov		al, cl
 13670                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	LBA_MIDDLE_REGISTER
 13671                              <2> %ifndef MODULE_8BIT_IDE
 13672                              <2> 
 13673                              <2>  %ifnidni %1, dx
 13674                              <2>  mov dx, %1
 13675                              <2>  %endif
 13676                              <2>  add dx, [di+DPT.wBasePort]
 13677                              <2>  out dx, al
 13678                              <2> 
 13679                              <2> %else
 13680                              <2> 
 13681                              <2>  %ifnidni %1, dl
 13682 00000954 B204                <2>  mov dl, %1
 13683                              <2>  %endif
 13684 00000956 E80903              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 13685                              <2> 
 13686                              <2> %endif
 13687                              <1> 
 13688 00000959 88E8                <1> 	mov		al, ch
 13689                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	LBA_HIGH_REGISTER
 13690                              <2> %ifndef MODULE_8BIT_IDE
 13691                              <2> 
 13692                              <2>  %ifnidni %1, dx
 13693                              <2>  mov dx, %1
 13694                              <2>  %endif
 13695                              <2>  add dx, [di+DPT.wBasePort]
 13696                              <2>  out dx, al
 13697                              <2> 
 13698                              <2> %else
 13699                              <2> 
 13700                              <2>  %ifnidni %1, dl
 13701 0000095B B205                <2>  mov dl, %1
 13702                              <2>  %endif
 13703 0000095D E80203              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 13704                              <2> 
 13705                              <2> %endif
 13706 00000960 C3                  <1> 	ret
 13707                                  %ifdef MODULE_8BIT_IDE_ADVANCED
 13708                                  	%include "JrIdeTransfer.asm"	; Must be included after IdeCommand.asm
 13709                                  	%include "IdeDmaBlock.asm"
 13710                                  %endif
 13711                                  	%include "IdeTransfer.asm"
 13712                              <1> ; Project name	:	XTIDE Universal BIOS
 13713                              <1> ; Description	:	IDE Device transfer functions.
 13714                              <1> 
 13715                              <1> ;
 13716                              <1> ; XTIDE Universal BIOS and Associated Tools
 13717                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 13718                              <1> ;
 13719                              <1> ; This program is free software; you can redistribute it and/or modify
 13720                              <1> ; it under the terms of the GNU General Public License as published by
 13721                              <1> ; the Free Software Foundation; either version 2 of the License, or
 13722                              <1> ; (at your option) any later version.
 13723                              <1> ;
 13724                              <1> ; This program is distributed in the hope that it will be useful,
 13725                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 13726                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 13727                              <1> ; GNU General Public License for more details.
 13728                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 13729                              <1> ;
 13730                              <1> 
 13731                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 13732                              <1> 
 13733                              <1> ; Structure containing variables for PIO transfer functions.
 13734                              <1> ; This struct must not be larger than IDEPACK without INTPACK.
 13735                              <1> struc PIOVARS	; Must not be larger than 9 bytes! See IDEPACK in RamVars.inc.
 13736 00000000 <res 00000002>      <1> 	.wDataPort			resb	2	; 0-1, IDE Data Port
 13737 00000002 <res 00000002>      <1> 	.fnXfer				resb	2	; 2-3, Offset to transfer function
 13738 00000004 <res 00000002>      <1> 	.wSectorsInBlock		resb	2	; 4-5, Block size in sectors
 13739 00000006 <res 00000001>      <1> 	.bSectorsLeft			resb	1	; 6, Sectors left to transfer
 13740 00000007 <res 00000001>      <1> 					resb	1	; 7, IDEPACK.bDeviceControl
 13741 00000008 <res 00000001>      <1> 	.bSectorsDone			resb	1	; 8, Number of sectors xferred
 13742                              <1> endstruc
 13743                              <1> 
 13744                              <1> 
 13745                              <1> ; Section containing code
 13746                              <1> SECTION .text
 13747                              <1> 
 13748                              <1> ;--------------------------------------------------------------------
 13749                              <1> ; IdeTransfer_StartWithCommandInAL
 13750                              <1> ;	Parameters:
 13751                              <1> ;		AL:		IDE command that was used to start the transfer
 13752                              <1> ;				(all PIO read and write commands including Identify Device)
 13753                              <1> ;		ES:SI:	Ptr to data buffer
 13754                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13755                              <1> ;		SS:BP:	Ptr to IDEPACK
 13756                              <1> ;	Returns:
 13757                              <1> ;		AH:		INT 13h Error Code
 13758                              <1> ;		CX:		Number of successfully transferred sectors
 13759                              <1> ;		CF:		Cleared if success, Set if error
 13760                              <1> ;	Corrupts registers:
 13761                              <1> ;		AL, BX, DX, SI, ES
 13762                              <1> ;--------------------------------------------------------------------
 13763                              <1> ALIGN JUMP_ALIGN
 13764                              <1> IdeTransfer_StartWithCommandInAL:
 13765                              <1> 	; Are we reading or writing?
 13766 00000961 A810                <1> 	test	al, 16	; Bit 4 is cleared on all the read commands but set on 3 of the 4 write commands
 13767 00000963 8A6602              <1> 	mov		ah, [bp+IDEPACK.bSectorCount]
 13768 00000966 7552                <1> 	jnz		SHORT WriteToDrive
 13769 00000968 3CC5                <1> 	cmp		al, COMMAND_WRITE_MULTIPLE
 13770 0000096A 744E                <1> 	je		SHORT WriteToDrive
 13771                              <1> 	; Fall to ReadFromDrive
 13772                              <1> 
 13773                              <1> ;--------------------------------------------------------------------
 13774                              <1> ; ReadFromDrive
 13775                              <1> ;	Parameters:
 13776                              <1> ;		AH:		Number of sectors to transfer (1...128)
 13777                              <1> ;		ES:SI:		Ptr to buffer to receive data
 13778                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 13779                              <1> ;		SS:BP:		Ptr to PIOVARS
 13780                              <1> ;	Returns:
 13781                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 13782                              <1> ;		AH:		BIOS Error code
 13783                              <1> ;		CX:		Number of successfully transferred sectors
 13784                              <1> ;		CF:		0 if transfer successful
 13785                              <1> ;				1 if any error
 13786                              <1> ;	Corrupts registers:
 13787                              <1> ;		AL, BX, DX, SI, ES
 13788                              <1> ;--------------------------------------------------------------------
 13789                              <1> ReadFromDrive:
 13790                              <1> 	; Prepare to read data to ESSI
 13791 0000096C BB[210A]            <1> 	mov		bx, g_rgfnPioRead
 13792 0000096F E87D00              <1> 	call	InitializePiovarsInSSBPwithSectorCountInAH
 13793                              <1> 
 13794                              <1> 	; Wait until drive is ready to transfer
 13795 00000972 E80602              <1> 	call	IdeWait_IRQorDRQ					; Wait until ready to transfer
 13796 00000975 723D                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 13797 00000977 87F7                <1> 	xchg	si, di							; ES:DI now points buffer
 13798                              <1> 
 13799 00000979 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]		; Max 128
 13800                              <1> 
 13801                              <1> ALIGN JUMP_ALIGN
 13802                              <1> .ReadNextBlockFromDrive:
 13803 0000097C 8B5600              <1> 	mov		dx, [bp+PIOVARS.wDataPort]
 13804 0000097F 384E06              <1> 	cmp		[bp+PIOVARS.bSectorsLeft], cl
 13805 00000982 761A                <1> 	jbe		SHORT .ReadLastBlockFromDrive
 13806 00000984 FF5602              <1> 	call	[bp+PIOVARS.fnXfer]
 13807                              <1> 
 13808                              <1> 	; Wait until ready for next block and check for errors
 13809 00000987 87FE                <1> 	xchg		di, si						; DS:DI now points DPT
 13810 00000989 E8EF01              <1> 	call	IdeWait_IRQorDRQ					; Wait until ready to transfer
 13811 0000098C 7226                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 13812 0000098E 87F7                <1> 	xchg		si, di						; ES:DI now points buffer
 13813                              <1> 
 13814                              <1> 	; Increment number of successfully read sectors
 13815 00000990 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]
 13816 00000993 284E06              <1> 	sub		[bp+PIOVARS.bSectorsLeft], cl
 13817 00000996 004E08              <1> 	add		[bp+PIOVARS.bSectorsDone], cl
 13818 00000999 EBE1                <1> 	jmp		SHORT .ReadNextBlockFromDrive
 13819                              <1> 
 13820                              <1> ALIGN JUMP_ALIGN
 13821                              <1> .ReadLastBlockFromDrive:
 13822 0000099B 8A4E06              <1> 	mov		cl, [bp+PIOVARS.bSectorsLeft]			; CH is already zero
 13823 0000099E 51                  <1> 	push	cx
 13824 0000099F FF5602              <1> 	call	[bp+PIOVARS.fnXfer]					; Transfer possibly partial block
 13825                              <1> 
 13826                              <1> 	; Check for errors in last block
 13827 000009A2 89F7                <1> 	mov		di, si						; DS:DI now points DPT
 13828                              <1> CheckErrorsAfterTransferringLastBlock:
 13829 000009A4 BB80FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_BSY)
 13830 000009A7 E8D401              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
 13831 000009AA 59                  <1> 	pop		cx	; [bp+PIOVARS.bSectorsLeft]
 13832 000009AB 7207                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 13833                              <1> 
 13834                              <1> 	; All sectors successfully transferred
 13835 000009AD 034E08              <1> 	add		cx, [bp+PIOVARS.bSectorsDone]			; Never sets CF
 13836 000009B0 C3                  <1> 	ret
 13837                              <1> 
 13838                              <1> 	; Return number of successfully read sectors
 13839                              <1> ReturnWithTransferErrorInAH:
 13840                              <1> %ifdef USE_386
 13841                              <1> 	movzx	cx, [bp+PIOVARS.bSectorsDone]
 13842                              <1> %else
 13843 000009B1 8A4E08              <1> 	mov		cl, [bp+PIOVARS.bSectorsDone]
 13844 000009B4 B500                <1> 	mov		ch, 0						; Preserve CF
 13845                              <1> %endif
 13846 000009B6 C3                  <1> 	ret
 13847                              <1> 
 13848                              <1> 
 13849                              <1> ;--------------------------------------------------------------------
 13850                              <1> ; WriteToDrive
 13851                              <1> ;	Parameters:
 13852                              <1> ;		AH:		Number of sectors to transfer (1...128)
 13853                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13854                              <1> ;		ES:SI:	Ptr to buffer containing data
 13855                              <1> ;		SS:BP:	Ptr to PIOVARS
 13856                              <1> ;	Returns:
 13857                              <1> ;		AH:		BIOS Error code
 13858                              <1> ;		CX:		Number of successfully transferred sectors
 13859                              <1> ;		CF:		0 if transfer successful
 13860                              <1> ;				1 if any error
 13861                              <1> ;	Corrupts registers:
 13862                              <1> ;		AL, BX, DX, SI, ES
 13863                              <1> ;--------------------------------------------------------------------
 13864                              <1> ALIGN JUMP_ALIGN
 13865                              <1> WriteToDrive:
 13866                              <1> 	; Prepare to write data from ESSI
 13867 000009B7 BB[310A]            <1> 	mov		bx, g_rgfnPioWrite
 13868 000009BA E83200              <1> 	call	InitializePiovarsInSSBPwithSectorCountInAH
 13869                              <1> 
 13870                              <1> 	; Always poll when writing first block (IRQs are generated for following blocks)
 13871 000009BD BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 13872 000009C0 E8BB01              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
 13873 000009C3 72EC                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 13874                              <1> 
 13875 000009C5 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]		; Max 128
 13876                              <1> 
 13877                              <1> ALIGN JUMP_ALIGN
 13878                              <1> .WriteNextBlockToDrive:
 13879 000009C8 8B5600              <1> 	mov		dx, [bp+PIOVARS.wDataPort]
 13880 000009CB 384E06              <1> 	cmp		[bp+PIOVARS.bSectorsLeft], cl
 13881 000009CE 7616                <1> 	jbe		SHORT .WriteLastBlockToDrive
 13882 000009D0 FF5602              <1> 	call	[bp+PIOVARS.fnXfer]
 13883                              <1> 
 13884                              <1> 	; Wait until ready for next block and check for errors
 13885 000009D3 E8A501              <1> 	call	IdeWait_IRQorDRQ					; Wait until ready to transfer
 13886 000009D6 72D9                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 13887                              <1> 
 13888                              <1> 	; Increment number of successfully written sectors
 13889 000009D8 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]
 13890 000009DB 284E06              <1> 	sub		[bp+PIOVARS.bSectorsLeft], cl
 13891 000009DE 004E08              <1> 	add		[bp+PIOVARS.bSectorsDone], cl
 13892 000009E1 EBE5                <1> 	jmp		SHORT .WriteNextBlockToDrive
 13893                              <1> 
 13894                              <1> ALIGN JUMP_ALIGN
 13895                              <1> .WriteLastBlockToDrive:
 13896 000009E3 8A4E06              <1> 	mov		cl, [bp+PIOVARS.bSectorsLeft]			; CH is already zero
 13897 000009E6 51                  <1> 	push		cx
 13898                              <1> %ifdef USE_186
 13899                              <1> 	push		CheckErrorsAfterTransferringLastBlock
 13900                              <1> 	jmp		[bp+PIOVARS.fnXfer]				; Transfer possibly partial block
 13901                              <1> %else
 13902 000009E7 FF5602              <1> 	call		[bp+PIOVARS.fnXfer]				; Transfer possibly partial block
 13903 000009EA EBB8                <1> 	jmp		SHORT CheckErrorsAfterTransferringLastBlock
 13904                              <1> %endif
 13905                              <1> 
 13906                              <1> 
 13907                              <1> ;--------------------------------------------------------------------
 13908                              <1> ; InitializePiovarsInSSBPwithSectorCountInAH
 13909                              <1> ;	Parameters:
 13910                              <1> ;		AH:		Number of sectors to transfer (1...128)
 13911                              <1> ;		BX:		Offset to transfer function lookup table
 13912                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 13913                              <1> ;		ES:SI:	Ptr to data buffer
 13914                              <1> ;		SS:BP:	Ptr to PIOVARS
 13915                              <1> ;	Returns:
 13916                              <1> ;		Nothing
 13917                              <1> ;	Corrupts registers:
 13918                              <1> ;		AX, BX, DX
 13919                              <1> ;--------------------------------------------------------------------
 13920                              <1> ALIGN JUMP_ALIGN
 13921                              <1> InitializePiovarsInSSBPwithSectorCountInAH:
 13922                              <1> 	; Store sizes and Data Port
 13923 000009EC 886606              <1> 	mov		[bp+PIOVARS.bSectorsLeft], ah
 13924 000009EF 8B4504              <1> 	mov		ax, [di+DPT.wBasePort]
 13925 000009F2 894600              <1> 	mov		[bp+PIOVARS.wDataPort], ax
 13926                              <1> 	eMOVZX		ax, [di+DPT_ATA.bBlockSize]
 13927                              <2> %ifndef USE_386
 13928                              <2>  %ifidni %1, ax
 13929 000009F5 8A450D              <2>  mov al, %2
 13930 000009F8 30E4                <2>  xor ah, ah
 13931                              <2>  %elifidni %1, bx
 13932                              <2>  mov bl, %2
 13933                              <2>  xor bh, bh
 13934                              <2>  %elifidni %1, cx
 13935                              <2>  mov cl, %2
 13936                              <2>  xor ch, ch
 13937                              <2>  %elifidni %1, dx
 13938                              <2>  mov dl, %2
 13939                              <2>  xor dh, dh
 13940                              <2>  %else
 13941                              <2>  push ax
 13942                              <2>  mov al, %2
 13943                              <2>  xor ah, ah
 13944                              <2>  xchg ax, %1
 13945                              <2>  pop ax
 13946                              <2>  %endif
 13947                              <2> 
 13948                              <2> %else
 13949                              <2>  movzx %1, %2
 13950                              <2> %endif
 13951 000009FA 894604              <1> 	mov		[bp+PIOVARS.wSectorsInBlock], ax
 13952 000009FD 886608              <1> 	mov		[bp+PIOVARS.bSectorsDone], ah			; Zero
 13953                              <1> 
 13954                              <1> 	; Get transfer function based on bus type
 13955 00000A00 93                  <1> 	xchg		ax, bx						; Lookup table offset to AX
 13956 00000A01 8A5D0C              <1> 	mov		bl, [di+DPT_ATA.bDevice]			; get device type to BX
 13957                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 13958                              <1> 	mov		dl, bl
 13959                              <1> %endif
 13960 00000A04 01C3                <1> 	add		bx, ax						; add table offset to device type (index)
 13961 00000A06 2E8B07              <1> 	mov		ax, [cs:bx]					; Load offset to transfer function
 13962 00000A09 894602              <1> 	mov		[bp+PIOVARS.fnXfer], ax
 13963                              <1> 
 13964                              <1> 	; Normalize pointer for PIO-transfers and convert to physical address for DMA transfers
 13965                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 13966                              <1> 	cmp		dl, DEVICE_8BIT_XTCF_DMA
 13967                              <1> 	jb		SHORT IdeTransfer_NormalizePointerInESSI
 13968                              <1> 
 13969                              <1> 	; Convert ES:SI to physical address
 13970                              <1> %ifdef USE_186			; Bytes	EU Cycles(286)
 13971                              <1> 	mov		ax, es		; 2		2
 13972                              <1> 	rol		ax, 4		; 3		9
 13973                              <1> 	mov		dx, ax		; 2		2
 13974                              <1> 	and		ax, BYTE 0Fh	; 3		3
 13975                              <1> 	xor		dx, ax		; 2		2
 13976                              <1> 	add		si, dx		; 2		2
 13977                              <1> 	adc		al, ah		; 2		2
 13978                              <1> 	mov		es, ax		; 2		2
 13979                              <1> 	;------------------------------------
 13980                              <1> 						; 18	24
 13981                              <1> %else ; 808x
 13982                              <1> 
 13983                              <1> %if 0
 13984                              <1> 						; Bytes	EU Cycles(808x)
 13985                              <1> 	mov		al, 4		; 2		4
 13986                              <1> 	mov		dx, es		; 2		2
 13987                              <1> 	xchg	cx, ax		; 1		3
 13988                              <1> 	rol		dx, cl		; 2		24
 13989                              <1> 	mov		cx, dx		; 2		2
 13990                              <1> 	xchg	cx, ax		; 1		3
 13991                              <1> 	and		ax, BYTE 0Fh; 3		4
 13992                              <1> 	xor		dx, ax		; 2		3
 13993                              <1> 	add		si, dx		; 2		3
 13994                              <1> 	adc		al, ah		; 2		3
 13995                              <1> 	mov		es, ax		; 2		2
 13996                              <1> 	;------------------------------------
 13997                              <1> 						; 21	53
 13998                              <1> ;
 13999                              <1> ; Judging by the Execution Unit cycle count the above block of code is
 14000                              <1> ; apparently slower. However, the shifts and rotates in the block below
 14001                              <1> ; execute faster than the Bus Interface Unit on an 8088 can fetch them,
 14002                              <1> ; thus causing the EU to starve. The difference in true execution speed
 14003                              <1> ; (if any) might not be worth the extra 5 bytes.
 14004                              <1> ; In other words, we could use a real world test here.
 14005                              <1> ;
 14006                              <1> %endif ; 0
 14007                              <1> 						; Bytes	EU Cycles(808x/286)
 14008                              <1> 	xor		dx, dx		; 2		3/2
 14009                              <1> 	mov		ax, es		; 2		2/2
 14010                              <1> %rep 4
 14011                              <1> 	shl		ax, 1		; 8		8/8
 14012                              <1> 	rcl		dx, 1		; 8		8/8
 14013                              <1> %endrep
 14014                              <1> 	add		si, ax		; 2		3/2
 14015                              <1> 	adc		dl, dh		; 2		3/2
 14016                              <1> 	mov		es, dx		; 2		2/2
 14017                              <1> 	;------------------------------------
 14018                              <1> %endif					; 26	29/26
 14019                              <1> 	ret
 14020                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 14021                              <1> 	; Fall to IdeTransfer_NormalizePointerInESSI if no MODULE_8BIT_IDE
 14022                              <1> 
 14023                              <1> 
 14024                              <1> ;--------------------------------------------------------------------
 14025                              <1> ; IdeTransfer_NormalizePointerInESSI
 14026                              <1> ;	Parameters:
 14027                              <1> ;		ES:SI:	Ptr to be normalized
 14028                              <1> ;	Returns:
 14029                              <1> ;		ES:SI:	Normalized pointer (SI = 0...15)
 14030                              <1> ;	Corrupts registers:
 14031                              <1> ;		AX, DX
 14032                              <1> ;--------------------------------------------------------------------
 14033                              <1> IdeTransfer_NormalizePointerInESSI:
 14034                              <1> 	NORMALIZE_FAR_POINTER	es, si, ax, dx
 14035 00000A0C 89F2                <2>  mov %4, %2
 14036 00000A0E 83E60F              <2>  and %2, BYTE 0Fh
 14037                              <2>  eSHR_IM %4, 4
 14038                              <3>  eSHIFT_IM %1, %2, shr
 14039                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 14040                              <4> %ifndef USE_186
 14041                              <4>  %ifidni %1, cl
 14042                              <4>  times %2 %3 %1, 1
 14043                              <4>  %elifidni %1, ch
 14044                              <4>  times %2 %3 %1, 1
 14045                              <4>  %elifidni %1, cx
 14046                              <4>  times %2 %3 %1, 1
 14047                              <4>  %else
 14048                              <4>  %if %2 > 3
 14049 00000A11 51                  <4>  push cx
 14050 00000A12 B104                <4>  mov cl, %2
 14051 00000A14 D3EA                <4>  %3 %1, cl
 14052 00000A16 59                  <4>  pop cx
 14053                              <4>  %else
 14054                              <4>  times %2 %3 %1, 1
 14055                              <4>  %endif
 14056                              <4>  %endif
 14057                              <4> 
 14058                              <4> %else
 14059                              <4>  %3 %1, %2
 14060                              <4> %endif
 14061                              <4> %endif
 14062 00000A17 8CC0                <2>  mov %3, %1
 14063 00000A19 01D0                <2>  add %3, %4
 14064 00000A1B 8EC0                <2>  mov %1, %3
 14065 00000A1D C3                  <1> 	ret
 14066                              <1> 
 14067                              <1> 
 14068                              <1> ; Lookup tables to get transfer function based on bus type
 14069                              <1> ALIGN WORD_ALIGN
 14070                              <1> g_rgfnPioRead:
 14071 00000A1E [B50A]              <1> 		dw		IdePioBlock_ReadFrom16bitDataPort	; 0, DEVICE_16BIT_ATA
 14072 00000A20 [CE0A]              <1> 		dw		IdePioBlock_ReadFrom32bitDataPort	; 1, DEVICE_32BIT_ATA
 14073                              <1> %ifdef MODULE_8BIT_IDE
 14074 00000A22 [8C0A]              <1> 		dw		IdePioBlock_ReadFrom8bitDataPort	; 2, DEVICE_8BIT_ATA
 14075 00000A24 [410A]              <1> 		dw		IdePioBlock_ReadFromXtideRev1		; 3, DEVICE_8BIT_XTIDE_REV1
 14076 00000A26 [B50A]              <1> 		dw		IdePioBlock_ReadFrom16bitDataPort	; 4, DEVICE_8BIT_XTIDE_REV2
 14077 00000A28 [8C0A]              <1> 		dw		IdePioBlock_ReadFrom8bitDataPort	; 5, DEVICE_8BIT_XTCF_PIO8
 14078 00000A2A [B50A]              <1> 		dw		IdePioBlock_ReadFrom16bitDataPort	; 6, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
 14079                              <1> 		dw		IdeDmaBlock_ReadFromXTCF		; 7, DEVICE_8BIT_XTCF_DMA
 14080          ******************  <1>  error: symbol `IdeDmaBlock_ReadFromXTCF' undefined
 14081                              <1> %endif
 14082                              <1> 
 14083                              <1> 
 14084                              <1> g_rgfnPioWrite:
 14085 00000A2C [5E0B]              <1> 		dw		IdePioBlock_WriteTo16bitDataPort	; 0, DEVICE_16BIT_ATA
 14086 00000A2E [730B]              <1> 		dw		IdePioBlock_WriteTo32bitDataPort	; 1, DEVICE_32BIT_ATA
 14087                              <1> %ifdef MODULE_8BIT_IDE
 14088 00000A30 [410B]              <1> 		dw		IdePioBlock_WriteTo8bitDataPort		; 2, DEVICE_8BIT_ATA
 14089 00000A32 [D50A]              <1> 		dw		IdePioBlock_WriteToXtideRev1		; 3, DEVICE_8BIT_XTIDE_REV1
 14090 00000A34 [100B]              <1> 		dw		IdePioBlock_WriteToXtideRev2		; 4, DEVICE_8BIT_XTIDE_REV2
 14091 00000A36 [410B]              <1> 		dw		IdePioBlock_WriteTo8bitDataPort		; 5, DEVICE_8BIT_XTCF_PIO8
 14092 00000A38 [5E0B]              <1> 		dw		IdePioBlock_WriteTo16bitDataPort	; 6, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
 14093                              <1> 		dw		IdeDmaBlock_WriteToXTCF			; 7, DEVICE_8BIT_XTCF_DMA
 14094          ******************  <1>  error: symbol `IdeDmaBlock_WriteToXTCF' undefined
 14095                              <1> %endif
 14096                                  	%include "IdePioBlock.asm"
 14097                              <1> ; Project name	:	XTIDE Universal BIOS
 14098                              <1> ; Description	:	IDE Read/Write functions for transferring
 14099                              <1> ;					block using PIO modes.
 14100                              <1> ;					These functions should only be called from IdeTransfer.asm.
 14101                              <1> 
 14102                              <1> ;
 14103                              <1> ; XTIDE Universal BIOS and Associated Tools
 14104                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 14105                              <1> ;
 14106                              <1> ; This program is free software; you can redistribute it and/or modify
 14107                              <1> ; it under the terms of the GNU General Public License as published by
 14108                              <1> ; the Free Software Foundation; either version 2 of the License, or
 14109                              <1> ; (at your option) any later version.
 14110                              <1> ;
 14111                              <1> ; This program is distributed in the hope that it will be useful,
 14112                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 14113                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14114                              <1> ; GNU General Public License for more details.
 14115                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 14116                              <1> ;
 14117                              <1> 
 14118                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 14119                              <1> 
 14120                              <1> ; Section containing code
 14121                              <1> SECTION .text
 14122                              <1> 
 14123                              <1> 
 14124                              <1> ; --------------------------------------------------------------------------------------------------
 14125                              <1> ;
 14126                              <1> ; READ routines follow
 14127                              <1> ;
 14128                              <1> ; --------------------------------------------------------------------------------------------------
 14129                              <1> 
 14130                              <1> 
 14131                              <1> %ifdef MODULE_8BIT_IDE
 14132                              <1> 
 14133                              <1> ;--------------------------------------------------------------------
 14134                              <1> ; IdePioBlock_ReadFromXtideRev1
 14135                              <1> ;	Parameters:
 14136                              <1> ;		CX:		Block size in 512 byte sectors
 14137                              <1> ;		DX:		IDE Data port address
 14138                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data
 14139                              <1> ;	Returns:
 14140                              <1> ;		Nothing
 14141                              <1> ;	Corrupts registers:
 14142                              <1> ;		AX, BX, CX
 14143                              <1> ;--------------------------------------------------------------------
 14144                              <1> ALIGN JUMP_ALIGN
 14145                              <1> IdePioBlock_ReadFromXtideRev1:
 14146                              <1> 	UNROLL_SECTORS_IN_CX_TO_OWORDS
 14147                              <2> %ifdef USE_186
 14148                              <2>  shl cx, 5
 14149                              <2> %else
 14150                              <2> 
 14151                              <2> 
 14152 00000A3A 88CD                <2>  mov ch, cl
 14153 00000A3C B103                <2>  mov cl, 3
 14154 00000A3E D3E9                <2>  shr cx, cl
 14155                              <2> %endif
 14156 00000A40 B308                <1> 	mov		bl, 8		; Bit mask for toggling data low/high reg
 14157                              <1> ALIGN JUMP_ALIGN
 14158                              <1> .InswLoop:
 14159                              <1> 	%rep 8 ; WORDs
 14160                              <1> 		XTIDE_INSW
 14161                              <1> 	%endrep
 14162                              <2>  XTIDE_INSW
 14163                              <3> %ifdef USE_186
 14164                              <3>  insb
 14165                              <3>  xor dl, bl
 14166                              <3>  insb
 14167                              <3>  xor dl, bl
 14168                              <3> %else
 14169 00000A42 EC                  <3>  in al, dx
 14170 00000A43 30DA                <3>  xor dl, bl
 14171 00000A45 AA                  <3>  stosb
 14172 00000A46 EC                  <3>  in al, dx
 14173 00000A47 30DA                <3>  xor dl, bl
 14174 00000A49 AA                  <3>  stosb
 14175                              <3> %endif
 14176                              <2>  XTIDE_INSW
 14177                              <3> %ifdef USE_186
 14178                              <3>  insb
 14179                              <3>  xor dl, bl
 14180                              <3>  insb
 14181                              <3>  xor dl, bl
 14182                              <3> %else
 14183 00000A4A EC                  <3>  in al, dx
 14184 00000A4B 30DA                <3>  xor dl, bl
 14185 00000A4D AA                  <3>  stosb
 14186 00000A4E EC                  <3>  in al, dx
 14187 00000A4F 30DA                <3>  xor dl, bl
 14188 00000A51 AA                  <3>  stosb
 14189                              <3> %endif
 14190                              <2>  XTIDE_INSW
 14191                              <3> %ifdef USE_186
 14192                              <3>  insb
 14193                              <3>  xor dl, bl
 14194                              <3>  insb
 14195                              <3>  xor dl, bl
 14196                              <3> %else
 14197 00000A52 EC                  <3>  in al, dx
 14198 00000A53 30DA                <3>  xor dl, bl
 14199 00000A55 AA                  <3>  stosb
 14200 00000A56 EC                  <3>  in al, dx
 14201 00000A57 30DA                <3>  xor dl, bl
 14202 00000A59 AA                  <3>  stosb
 14203                              <3> %endif
 14204                              <2>  XTIDE_INSW
 14205                              <3> %ifdef USE_186
 14206                              <3>  insb
 14207                              <3>  xor dl, bl
 14208                              <3>  insb
 14209                              <3>  xor dl, bl
 14210                              <3> %else
 14211 00000A5A EC                  <3>  in al, dx
 14212 00000A5B 30DA                <3>  xor dl, bl
 14213 00000A5D AA                  <3>  stosb
 14214 00000A5E EC                  <3>  in al, dx
 14215 00000A5F 30DA                <3>  xor dl, bl
 14216 00000A61 AA                  <3>  stosb
 14217                              <3> %endif
 14218                              <2>  XTIDE_INSW
 14219                              <3> %ifdef USE_186
 14220                              <3>  insb
 14221                              <3>  xor dl, bl
 14222                              <3>  insb
 14223                              <3>  xor dl, bl
 14224                              <3> %else
 14225 00000A62 EC                  <3>  in al, dx
 14226 00000A63 30DA                <3>  xor dl, bl
 14227 00000A65 AA                  <3>  stosb
 14228 00000A66 EC                  <3>  in al, dx
 14229 00000A67 30DA                <3>  xor dl, bl
 14230 00000A69 AA                  <3>  stosb
 14231                              <3> %endif
 14232                              <2>  XTIDE_INSW
 14233                              <3> %ifdef USE_186
 14234                              <3>  insb
 14235                              <3>  xor dl, bl
 14236                              <3>  insb
 14237                              <3>  xor dl, bl
 14238                              <3> %else
 14239 00000A6A EC                  <3>  in al, dx
 14240 00000A6B 30DA                <3>  xor dl, bl
 14241 00000A6D AA                  <3>  stosb
 14242 00000A6E EC                  <3>  in al, dx
 14243 00000A6F 30DA                <3>  xor dl, bl
 14244 00000A71 AA                  <3>  stosb
 14245                              <3> %endif
 14246                              <2>  XTIDE_INSW
 14247                              <3> %ifdef USE_186
 14248                              <3>  insb
 14249                              <3>  xor dl, bl
 14250                              <3>  insb
 14251                              <3>  xor dl, bl
 14252                              <3> %else
 14253 00000A72 EC                  <3>  in al, dx
 14254 00000A73 30DA                <3>  xor dl, bl
 14255 00000A75 AA                  <3>  stosb
 14256 00000A76 EC                  <3>  in al, dx
 14257 00000A77 30DA                <3>  xor dl, bl
 14258 00000A79 AA                  <3>  stosb
 14259                              <3> %endif
 14260                              <2>  XTIDE_INSW
 14261                              <3> %ifdef USE_186
 14262                              <3>  insb
 14263                              <3>  xor dl, bl
 14264                              <3>  insb
 14265                              <3>  xor dl, bl
 14266                              <3> %else
 14267 00000A7A EC                  <3>  in al, dx
 14268 00000A7B 30DA                <3>  xor dl, bl
 14269 00000A7D AA                  <3>  stosb
 14270 00000A7E EC                  <3>  in al, dx
 14271 00000A7F 30DA                <3>  xor dl, bl
 14272 00000A81 AA                  <3>  stosb
 14273                              <3> %endif
 14274 00000A82 E2BE                <1> 	loop	.InswLoop
 14275 00000A84 C3                  <1> 	ret
 14276                              <1> 
 14277                              <1> 
 14278                              <1> ;--------------------------------------------------------------------
 14279                              <1> ; IdePioBlock_ReadFrom8bitDataPort
 14280                              <1> ;
 14281                              <1> ; 8-bit PIO from a single data port.
 14282                              <1> ;
 14283                              <1> ;	Parameters:
 14284                              <1> ;		CX:	Block size in 512 byte sectors
 14285                              <1> ;		DX:	IDE Data port address
 14286                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data
 14287                              <1> ;	Returns:
 14288                              <1> ;		Nothing
 14289                              <1> ;	Corrupts registers:
 14290                              <1> ;		AX, BX, CX
 14291                              <1> ;--------------------------------------------------------------------
 14292                              <1> ALIGN JUMP_ALIGN
 14293                              <1> IdePioBlock_ReadFrom8bitDataPort:
 14294                              <1> %ifdef USE_186
 14295                              <1> 	shl		cx, 9			; Sectors to BYTEs
 14296                              <1> 	rep insb
 14297                              <1> 	ret
 14298                              <1> %else ; If 8088/8086
 14299                              <1> 	UNROLL_SECTORS_IN_CX_TO_OWORDS
 14300                              <2> %ifdef USE_186
 14301                              <2>  shl cx, 5
 14302                              <2> %else
 14303                              <2> 
 14304                              <2> 
 14305 00000A85 88CD                <2>  mov ch, cl
 14306 00000A87 B103                <2>  mov cl, 3
 14307 00000A89 D3E9                <2>  shr cx, cl
 14308                              <2> %endif
 14309                              <1> ALIGN JUMP_ALIGN
 14310                              <1> .ReadNextOword:
 14311                              <1> 	%rep 16	; BYTEs
 14312                              <1> 		in		al, dx		; Read BYTE
 14313                              <1> 		stosb				; Store BYTE to [ES:DI]
 14314                              <1> 	%endrep
 14315 00000A8B EC                  <2>  in al, dx
 14316 00000A8C AA                  <2>  stosb
 14317 00000A8D EC                  <2>  in al, dx
 14318 00000A8E AA                  <2>  stosb
 14319 00000A8F EC                  <2>  in al, dx
 14320 00000A90 AA                  <2>  stosb
 14321 00000A91 EC                  <2>  in al, dx
 14322 00000A92 AA                  <2>  stosb
 14323 00000A93 EC                  <2>  in al, dx
 14324 00000A94 AA                  <2>  stosb
 14325 00000A95 EC                  <2>  in al, dx
 14326 00000A96 AA                  <2>  stosb
 14327 00000A97 EC                  <2>  in al, dx
 14328 00000A98 AA                  <2>  stosb
 14329 00000A99 EC                  <2>  in al, dx
 14330 00000A9A AA                  <2>  stosb
 14331 00000A9B EC                  <2>  in al, dx
 14332 00000A9C AA                  <2>  stosb
 14333 00000A9D EC                  <2>  in al, dx
 14334 00000A9E AA                  <2>  stosb
 14335 00000A9F EC                  <2>  in al, dx
 14336 00000AA0 AA                  <2>  stosb
 14337 00000AA1 EC                  <2>  in al, dx
 14338 00000AA2 AA                  <2>  stosb
 14339 00000AA3 EC                  <2>  in al, dx
 14340 00000AA4 AA                  <2>  stosb
 14341 00000AA5 EC                  <2>  in al, dx
 14342 00000AA6 AA                  <2>  stosb
 14343 00000AA7 EC                  <2>  in al, dx
 14344 00000AA8 AA                  <2>  stosb
 14345 00000AA9 EC                  <2>  in al, dx
 14346 00000AAA AA                  <2>  stosb
 14347 00000AAB E2DE                <1> 	loop	.ReadNextOword
 14348 00000AAD C3                  <1> 	ret
 14349                              <1> %endif
 14350                              <1> 
 14351                              <1> %endif	; MODULE_8BIT_IDE
 14352                              <1> 
 14353                              <1> 
 14354                              <1> ;--------------------------------------------------------------------
 14355                              <1> ; IdePioBlock_ReadFrom16bitDataPort
 14356                              <1> ;
 14357                              <1> ; 16-bit PIO from a single data port.
 14358                              <1> ;
 14359                              <1> ;	Parameters:
 14360                              <1> ;		CX:	Block size in 512 byte sectors
 14361                              <1> ;		DX:	IDE Data port address
 14362                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data
 14363                              <1> ;	Returns:
 14364                              <1> ;		Nothing
 14365                              <1> ;	Corrupts registers:
 14366                              <1> ;		AX, BX, CX
 14367                              <1> ;--------------------------------------------------------------------
 14368                              <1> ALIGN JUMP_ALIGN
 14369                              <1> IdePioBlock_ReadFrom16bitDataPort:
 14370                              <1> %ifdef USE_186
 14371                              <1> 	xhcg		cl, ch			; Sectors to WORDs
 14372                              <1> 	rep
 14373                              <1> 	db		6Dh			; INSW
 14374                              <1> 	ret
 14375                              <1> %else ; If 8088/8086
 14376                              <1> 	UNROLL_SECTORS_IN_CX_TO_OWORDS
 14377                              <2> %ifdef USE_186
 14378                              <2>  shl cx, 5
 14379                              <2> %else
 14380                              <2> 
 14381                              <2> 
 14382 00000AAE 88CD                <2>  mov ch, cl
 14383 00000AB0 B103                <2>  mov cl, 3
 14384 00000AB2 D3E9                <2>  shr cx, cl
 14385                              <2> %endif
 14386                              <1> ALIGN JUMP_ALIGN
 14387                              <1> .ReadNextOword:
 14388                              <1> 	%rep 8	; WORDs
 14389                              <1> 		in		ax, dx		; Read BYTE
 14390                              <1> 		stosw				; Store BYTE to [ES:DI]
 14391                              <1> 	%endrep
 14392 00000AB4 ED                  <2>  in ax, dx
 14393 00000AB5 AB                  <2>  stosw
 14394 00000AB6 ED                  <2>  in ax, dx
 14395 00000AB7 AB                  <2>  stosw
 14396 00000AB8 ED                  <2>  in ax, dx
 14397 00000AB9 AB                  <2>  stosw
 14398 00000ABA ED                  <2>  in ax, dx
 14399 00000ABB AB                  <2>  stosw
 14400 00000ABC ED                  <2>  in ax, dx
 14401 00000ABD AB                  <2>  stosw
 14402 00000ABE ED                  <2>  in ax, dx
 14403 00000ABF AB                  <2>  stosw
 14404 00000AC0 ED                  <2>  in ax, dx
 14405 00000AC1 AB                  <2>  stosw
 14406 00000AC2 ED                  <2>  in ax, dx
 14407 00000AC3 AB                  <2>  stosw
 14408 00000AC4 E2EE                <1> 	loop	.ReadNextOword
 14409 00000AC6 C3                  <1> 	ret
 14410                              <1> %endif
 14411                              <1> 
 14412                              <1> 
 14413                              <1> ;--------------------------------------------------------------------
 14414                              <1> ALIGN JUMP_ALIGN
 14415                              <1> IdePioBlock_ReadFrom32bitDataPort:
 14416 00000AC7 C1                  <1> 	db		0C1h			; SHL
 14417 00000AC8 E1                  <1> 	db		0E1h			; CX
 14418 00000AC9 07                  <1> 	db		7			; 7	(Sectors to DWORDs)
 14419 00000ACA F3                  <1> 	rep
 14420 00000ACB 66                  <1> 	db		66h			; Override operand size to 32-bit
 14421 00000ACC 6D                  <1> 	db		6Dh			; INSW/INSD
 14422 00000ACD C3                  <1> 	ret
 14423                              <1> 
 14424                              <1> 
 14425                              <1> 
 14426                              <1> ; --------------------------------------------------------------------------------------------------
 14427                              <1> ;
 14428                              <1> ; WRITE routines follow
 14429                              <1> ;
 14430                              <1> ; --------------------------------------------------------------------------------------------------
 14431                              <1> 
 14432                              <1> %ifdef MODULE_8BIT_IDE
 14433                              <1> 
 14434                              <1> ;--------------------------------------------------------------------
 14435                              <1> ; IdePioBlock_WriteToXtideRev1
 14436                              <1> ;	Parameters:
 14437                              <1> ;		CX:	Block size in 512-byte sectors
 14438                              <1> ;		DX:	IDE Data port address
 14439                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
 14440                              <1> ;	Returns:
 14441                              <1> ;		Nothing
 14442                              <1> ;	Corrupts registers:
 14443                              <1> ;		AX, BX, CX, DX
 14444                              <1> ;--------------------------------------------------------------------
 14445                              <1> ALIGN JUMP_ALIGN
 14446                              <1> IdePioBlock_WriteToXtideRev1:
 14447 00000ACE 1E                  <1> 	push	ds
 14448                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
 14449                              <2> %ifdef USE_186
 14450                              <2>  shl cx, 6
 14451                              <2> %else
 14452                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
 14453                              <3> %ifdef USE_186
 14454                              <3>  shl cx, 7
 14455                              <3> %else
 14456 00000ACF 86CD                <3>  xchg cl, ch
 14457 00000AD1 D1E9                <3>  shr cx, 1
 14458                              <3> %endif
 14459 00000AD3 D1E9                <2>  shr cx, 1
 14460                              <2> %endif
 14461 00000AD5 B308                <1> 	mov		bl, 8		; Bit mask for toggling data low/high reg
 14462 00000AD7 06                  <1> 	push		es		; Copy ES...
 14463 00000AD8 1F                  <1> 	pop		ds		; ...to DS
 14464                              <1> ALIGN JUMP_ALIGN
 14465                              <1> .OutswLoop:
 14466                              <1> 	%rep 4	; WORDs
 14467                              <1> 		XTIDE_OUTSW
 14468                              <1> 	%endrep
 14469                              <2>  XTIDE_OUTSW
 14470                              <3> %ifdef USE_186
 14471                              <3>  lodsb
 14472                              <3>  xor dl, bl
 14473                              <3>  outsb
 14474                              <3>  xor dl, bl
 14475                              <3>  out dx, al
 14476                              <3> %else
 14477 00000AD9 AD                  <3>  lodsw
 14478 00000ADA 30DA                <3>  xor dl, bl
 14479 00000ADC 86C4                <3>  xchg al, ah
 14480 00000ADE EE                  <3>  out dx, al
 14481 00000ADF 30DA                <3>  xor dl, bl
 14482 00000AE1 88E0                <3>  mov al, ah
 14483 00000AE3 EE                  <3>  out dx, al
 14484                              <3> %endif
 14485                              <2>  XTIDE_OUTSW
 14486                              <3> %ifdef USE_186
 14487                              <3>  lodsb
 14488                              <3>  xor dl, bl
 14489                              <3>  outsb
 14490                              <3>  xor dl, bl
 14491                              <3>  out dx, al
 14492                              <3> %else
 14493 00000AE4 AD                  <3>  lodsw
 14494 00000AE5 30DA                <3>  xor dl, bl
 14495 00000AE7 86C4                <3>  xchg al, ah
 14496 00000AE9 EE                  <3>  out dx, al
 14497 00000AEA 30DA                <3>  xor dl, bl
 14498 00000AEC 88E0                <3>  mov al, ah
 14499 00000AEE EE                  <3>  out dx, al
 14500                              <3> %endif
 14501                              <2>  XTIDE_OUTSW
 14502                              <3> %ifdef USE_186
 14503                              <3>  lodsb
 14504                              <3>  xor dl, bl
 14505                              <3>  outsb
 14506                              <3>  xor dl, bl
 14507                              <3>  out dx, al
 14508                              <3> %else
 14509 00000AEF AD                  <3>  lodsw
 14510 00000AF0 30DA                <3>  xor dl, bl
 14511 00000AF2 86C4                <3>  xchg al, ah
 14512 00000AF4 EE                  <3>  out dx, al
 14513 00000AF5 30DA                <3>  xor dl, bl
 14514 00000AF7 88E0                <3>  mov al, ah
 14515 00000AF9 EE                  <3>  out dx, al
 14516                              <3> %endif
 14517                              <2>  XTIDE_OUTSW
 14518                              <3> %ifdef USE_186
 14519                              <3>  lodsb
 14520                              <3>  xor dl, bl
 14521                              <3>  outsb
 14522                              <3>  xor dl, bl
 14523                              <3>  out dx, al
 14524                              <3> %else
 14525 00000AFA AD                  <3>  lodsw
 14526 00000AFB 30DA                <3>  xor dl, bl
 14527 00000AFD 86C4                <3>  xchg al, ah
 14528 00000AFF EE                  <3>  out dx, al
 14529 00000B00 30DA                <3>  xor dl, bl
 14530 00000B02 88E0                <3>  mov al, ah
 14531 00000B04 EE                  <3>  out dx, al
 14532                              <3> %endif
 14533 00000B05 E2D2                <1> 	loop	.OutswLoop
 14534 00000B07 1F                  <1> 	pop		ds
 14535 00000B08 C3                  <1> 	ret
 14536                              <1> 
 14537                              <1> 
 14538                              <1> ;--------------------------------------------------------------------
 14539                              <1> ; IdePioBlock_WriteToXtideRev2	or rev 1 with swapped A0 and A3 (chuck-mod)
 14540                              <1> ;	Parameters:
 14541                              <1> ;		CX:	Block size in 512-byte sectors
 14542                              <1> ;		DX:	IDE Data port address
 14543                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
 14544                              <1> ;	Returns:
 14545                              <1> ;		Nothing
 14546                              <1> ;	Corrupts registers:
 14547                              <1> ;		AX, BX, CX, DX
 14548                              <1> ;--------------------------------------------------------------------
 14549                              <1> ALIGN JUMP_ALIGN
 14550                              <1> IdePioBlock_WriteToXtideRev2:
 14551                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
 14552                              <2> %ifdef USE_186
 14553                              <2>  shl cx, 6
 14554                              <2> %else
 14555                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
 14556                              <3> %ifdef USE_186
 14557                              <3>  shl cx, 7
 14558                              <3> %else
 14559 00000B09 86CD                <3>  xchg cl, ch
 14560 00000B0B D1E9                <3>  shr cx, 1
 14561                              <3> %endif
 14562 00000B0D D1E9                <2>  shr cx, 1
 14563                              <2> %endif
 14564 00000B0F 1E                  <1> 	push		ds
 14565 00000B10 06                  <1> 	push		es			; Copy ES...
 14566 00000B11 1F                  <1> 	pop		ds			; ...to DS
 14567                              <1> ALIGN JUMP_ALIGN
 14568                              <1> .WriteNextQword:
 14569                              <1> 	%rep 4	; WORDs
 14570                              <1> 		XTIDE_MOD_OUTSW			; special macro
 14571                              <1> 	%endrep
 14572                              <2>  XTIDE_MOD_OUTSW
 14573                              <3> %ifdef USE_186
 14574                              <3>  lodsb
 14575                              <3>  inc dx
 14576                              <3>  outsb
 14577                              <3>  dec dx
 14578                              <3>  out dx, al
 14579                              <3> %else
 14580 00000B12 AD                  <3>  lodsw
 14581 00000B13 42                  <3>  inc dx
 14582 00000B14 86C4                <3>  xchg al, ah
 14583 00000B16 EE                  <3>  out dx, al
 14584 00000B17 4A                  <3>  dec dx
 14585 00000B18 88E0                <3>  mov al, ah
 14586 00000B1A EE                  <3>  out dx, al
 14587                              <3> %endif
 14588                              <2>  XTIDE_MOD_OUTSW
 14589                              <3> %ifdef USE_186
 14590                              <3>  lodsb
 14591                              <3>  inc dx
 14592                              <3>  outsb
 14593                              <3>  dec dx
 14594                              <3>  out dx, al
 14595                              <3> %else
 14596 00000B1B AD                  <3>  lodsw
 14597 00000B1C 42                  <3>  inc dx
 14598 00000B1D 86C4                <3>  xchg al, ah
 14599 00000B1F EE                  <3>  out dx, al
 14600 00000B20 4A                  <3>  dec dx
 14601 00000B21 88E0                <3>  mov al, ah
 14602 00000B23 EE                  <3>  out dx, al
 14603                              <3> %endif
 14604                              <2>  XTIDE_MOD_OUTSW
 14605                              <3> %ifdef USE_186
 14606                              <3>  lodsb
 14607                              <3>  inc dx
 14608                              <3>  outsb
 14609                              <3>  dec dx
 14610                              <3>  out dx, al
 14611                              <3> %else
 14612 00000B24 AD                  <3>  lodsw
 14613 00000B25 42                  <3>  inc dx
 14614 00000B26 86C4                <3>  xchg al, ah
 14615 00000B28 EE                  <3>  out dx, al
 14616 00000B29 4A                  <3>  dec dx
 14617 00000B2A 88E0                <3>  mov al, ah
 14618 00000B2C EE                  <3>  out dx, al
 14619                              <3> %endif
 14620                              <2>  XTIDE_MOD_OUTSW
 14621                              <3> %ifdef USE_186
 14622                              <3>  lodsb
 14623                              <3>  inc dx
 14624                              <3>  outsb
 14625                              <3>  dec dx
 14626                              <3>  out dx, al
 14627                              <3> %else
 14628 00000B2D AD                  <3>  lodsw
 14629 00000B2E 42                  <3>  inc dx
 14630 00000B2F 86C4                <3>  xchg al, ah
 14631 00000B31 EE                  <3>  out dx, al
 14632 00000B32 4A                  <3>  dec dx
 14633 00000B33 88E0                <3>  mov al, ah
 14634 00000B35 EE                  <3>  out dx, al
 14635                              <3> %endif
 14636 00000B36 E2DA                <1> 	loop	.WriteNextQword
 14637 00000B38 1F                  <1> 	pop		ds
 14638 00000B39 C3                  <1> 	ret
 14639                              <1> 
 14640                              <1> 
 14641                              <1> ;--------------------------------------------------------------------
 14642                              <1> ; IdePioBlock_WriteTo8bitDataPort
 14643                              <1> ;	Parameters:
 14644                              <1> ;		CX:	Block size in 512-byte sectors
 14645                              <1> ;		DX:	IDE Data port address
 14646                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
 14647                              <1> ;	Returns:
 14648                              <1> ;		Nothing
 14649                              <1> ;	Corrupts registers:
 14650                              <1> ;		AX, BX, CX, DX
 14651                              <1> ;--------------------------------------------------------------------
 14652                              <1> ALIGN JUMP_ALIGN
 14653                              <1> IdePioBlock_WriteTo8bitDataPort:
 14654                              <1> %ifdef USE_186
 14655                              <1> 	shl		cx, 9		; Sectors to BYTEs
 14656                              <1> 	es				; Source is ES segment
 14657                              <1> 	rep outsb
 14658                              <1> 	ret
 14659                              <1> %else ; If 8088/8086
 14660                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
 14661                              <2> %ifdef USE_186
 14662                              <2>  shl cx, 6
 14663                              <2> %else
 14664                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
 14665                              <3> %ifdef USE_186
 14666                              <3>  shl cx, 7
 14667                              <3> %else
 14668 00000B3A 86CD                <3>  xchg cl, ch
 14669 00000B3C D1E9                <3>  shr cx, 1
 14670                              <3> %endif
 14671 00000B3E D1E9                <2>  shr cx, 1
 14672                              <2> %endif
 14673 00000B40 1E                  <1> 	push		ds
 14674 00000B41 06                  <1> 	push		es
 14675 00000B42 1F                  <1> 	pop		ds
 14676                              <1> ALIGN JUMP_ALIGN
 14677                              <1> .WriteNextQword:
 14678                              <1> 	%rep 8	; BYTEs
 14679                              <1> 		lodsb			; Load BYTE from [DS:SI]
 14680                              <1> 		out	dx, al		; Write BYTE
 14681                              <1> 	%endrep
 14682 00000B43 AC                  <2>  lodsb
 14683 00000B44 EE                  <2>  out dx, al
 14684 00000B45 AC                  <2>  lodsb
 14685 00000B46 EE                  <2>  out dx, al
 14686 00000B47 AC                  <2>  lodsb
 14687 00000B48 EE                  <2>  out dx, al
 14688 00000B49 AC                  <2>  lodsb
 14689 00000B4A EE                  <2>  out dx, al
 14690 00000B4B AC                  <2>  lodsb
 14691 00000B4C EE                  <2>  out dx, al
 14692 00000B4D AC                  <2>  lodsb
 14693 00000B4E EE                  <2>  out dx, al
 14694 00000B4F AC                  <2>  lodsb
 14695 00000B50 EE                  <2>  out dx, al
 14696 00000B51 AC                  <2>  lodsb
 14697 00000B52 EE                  <2>  out dx, al
 14698 00000B53 E2EE                <1> 	loop	.WriteNextQword
 14699 00000B55 1F                  <1> 	pop		ds
 14700 00000B56 C3                  <1> 	ret
 14701                              <1> %endif
 14702                              <1> 
 14703                              <1> %endif ; MODULE_8BIT_IDE
 14704                              <1> 
 14705                              <1> 
 14706                              <1> ;--------------------------------------------------------------------
 14707                              <1> ; IdePioBlock_WriteTo16bitDataPort		Normal 16-bit IDE
 14708                              <1> ; IdePioBlock_WriteTo32bitDataPort		VLB/PCI 32-bit IDE
 14709                              <1> ;	Parameters:
 14710                              <1> ;		CX:	Block size in 512-byte sectors
 14711                              <1> ;		DX:	IDE Data port address
 14712                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
 14713                              <1> ;	Returns:
 14714                              <1> ;		Nothing
 14715                              <1> ;	Corrupts registers:
 14716                              <1> ;		AX, BX, CX, DX
 14717                              <1> ;--------------------------------------------------------------------
 14718                              <1> ALIGN JUMP_ALIGN
 14719                              <1> IdePioBlock_WriteTo16bitDataPort:
 14720                              <1> %ifdef USE_186
 14721                              <1> 	xchg		cl, ch		; Sectors to WORDs
 14722                              <1> 	es				; Source is ES segment
 14723                              <1> 	rep
 14724                              <1> 	db		6Fh		; OUTSW
 14725                              <1> 	ret
 14726                              <1> %else ; If 8088/8086
 14727                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
 14728                              <2> %ifdef USE_186
 14729                              <2>  shl cx, 6
 14730                              <2> %else
 14731                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
 14732                              <3> %ifdef USE_186
 14733                              <3>  shl cx, 7
 14734                              <3> %else
 14735 00000B57 86CD                <3>  xchg cl, ch
 14736 00000B59 D1E9                <3>  shr cx, 1
 14737                              <3> %endif
 14738 00000B5B D1E9                <2>  shr cx, 1
 14739                              <2> %endif
 14740 00000B5D 1E                  <1> 	push		ds
 14741 00000B5E 06                  <1> 	push		es
 14742 00000B5F 1F                  <1> 	pop		ds
 14743                              <1> ALIGN JUMP_ALIGN
 14744                              <1> .WriteNextQword:
 14745                              <1> 	%rep 4	; WORDs
 14746                              <1> 		lodsw			; Load BYTE from [DS:SI]
 14747                              <1> 		out	dx, ax		; Write BYTE
 14748                              <1> 	%endrep
 14749 00000B60 AD                  <2>  lodsw
 14750 00000B61 EF                  <2>  out dx, ax
 14751 00000B62 AD                  <2>  lodsw
 14752 00000B63 EF                  <2>  out dx, ax
 14753 00000B64 AD                  <2>  lodsw
 14754 00000B65 EF                  <2>  out dx, ax
 14755 00000B66 AD                  <2>  lodsw
 14756 00000B67 EF                  <2>  out dx, ax
 14757 00000B68 E2F6                <1> 	loop	.WriteNextQword
 14758 00000B6A 1F                  <1> 	pop		ds
 14759 00000B6B C3                  <1> 	ret
 14760                              <1> %endif	; if/else USE_186
 14761                              <1> 
 14762                              <1> ;--------------------------------------------------------------------
 14763                              <1> ALIGN JUMP_ALIGN
 14764                              <1> IdePioBlock_WriteTo32bitDataPort:
 14765 00000B6C C1                  <1> 	db		0C1h		; SHL
 14766 00000B6D E1                  <1> 	db		0E1h		; CX
 14767 00000B6E 07                  <1> 	db		7		; 7	(Sectors to DWORDs)
 14768 00000B6F 26                  <1> 	es				; Source is ES segment
 14769 00000B70 F3                  <1> 	rep
 14770 00000B71 66                  <1> 	db		66h		; Override operand size to 32-bit
 14771 00000B72 6F                  <1> 	db		6Fh		; OUTSW/OUTSD
 14772 00000B73 C3                  <1> 	ret
 14773                              <1> 
 14774                              <1> 
 14775                                  	%include "IdeWait.asm"
 14776                              <1> ; Project name	:	XTIDE Universal BIOS
 14777                              <1> ; Description	:	IDE Device wait functions.
 14778                              <1> 
 14779                              <1> ;
 14780                              <1> ; XTIDE Universal BIOS and Associated Tools
 14781                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 14782                              <1> ;
 14783                              <1> ; This program is free software; you can redistribute it and/or modify
 14784                              <1> ; it under the terms of the GNU General Public License as published by
 14785                              <1> ; the Free Software Foundation; either version 2 of the License, or
 14786                              <1> ; (at your option) any later version.
 14787                              <1> ;
 14788                              <1> ; This program is distributed in the hope that it will be useful,
 14789                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 14790                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14791                              <1> ; GNU General Public License for more details.
 14792                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 14793                              <1> ;
 14794                              <1> 
 14795                              <1> ; Section containing code
 14796                              <1> SECTION .text
 14797                              <1> 
 14798                              <1> ;--------------------------------------------------------------------
 14799                              <1> ; IdeWait_IRQorDRQ
 14800                              <1> ;	Parameters:
 14801                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14802                              <1> ;		SS:BP:	Ptr to IDEPACK, PIOVARS or MEMPIOVARS
 14803                              <1> ;	Returns:
 14804                              <1> ;		AH:		INT 13h Error Code
 14805                              <1> ;		CF:		Cleared if success, Set if error
 14806                              <1> ;	Corrupts registers:
 14807                              <1> ;		AL, BX, CX, DX
 14808                              <1> ;--------------------------------------------------------------------
 14809                              <1> IdeWait_IRQorDRQ:
 14810 00000B74 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 14811                              <1> 
 14812                              <1> %ifdef MODULE_IRQ
 14813                              <1> 	test	BYTE [bp+IDEPACK.bDeviceControl], FLG_DEVCONTROL_nIEN
 14814                              <1> 	jnz		SHORT IdeWait_PollStatusFlagInBLwithTimeoutInBH	; Interrupt disabled
 14815                              <1> %endif
 14816                              <1> 	; Fall to IdeWait_IRQorStatusFlagInBLwithTimeoutInBH
 14817                              <1> 
 14818                              <1> 
 14819                              <1> ;--------------------------------------------------------------------
 14820                              <1> ; IdeWait_IRQorStatusFlagInBLwithTimeoutInBH
 14821                              <1> ;	Parameters:
 14822                              <1> ;		BH:		Timeout ticks
 14823                              <1> ;		BL:		IDE Status Register bit to wait
 14824                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14825                              <1> ;	Returns:
 14826                              <1> ;		AH:		INT 13h Error Code
 14827                              <1> ;		CF:		Cleared if success, Set if error
 14828                              <1> ;	Corrupts registers:
 14829                              <1> ;		AL, BX, CX, DX
 14830                              <1> ;--------------------------------------------------------------------
 14831                              <1> IdeWait_IRQorStatusFlagInBLwithTimeoutInBH:
 14832                              <1> %ifdef MODULE_IRQ
 14833                              <1> 	call	IdeIrq_WaitForIRQ
 14834                              <1> %endif
 14835                              <1> 	; Always fall to IdeWait_PollStatusFlagInBLwithTimeoutInBH for error processing
 14836                              <1> 
 14837                              <1> 
 14838                              <1> ;--------------------------------------------------------------------
 14839                              <1> ; IdeWait_PollStatusFlagInBLwithTimeoutInBH
 14840                              <1> ;	Parameters:
 14841                              <1> ;		BH:		Timeout ticks
 14842                              <1> ;		BL:		IDE Status Register bit to poll
 14843                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14844                              <1> ;	Returns:
 14845                              <1> ;		AH:		INT 13h Error Code
 14846                              <1> ;		CF:		Cleared if success, Set if error
 14847                              <1> ;	Corrupts registers:
 14848                              <1> ;		AL, BX, CX, DX
 14849                              <1> ;--------------------------------------------------------------------
 14850                              <1> IdeWait_PollStatusFlagInBLwithTimeoutInBH:
 14851 00000B77 88DC                <1> 	mov		ah, bl
 14852 00000B79 88F9                <1> 	mov		cl, bh
 14853 00000B7B E8D0FC              <1> 	call	Timer_InitializeTimeoutWithTicksInCL
 14854 00000B7E 80E47F              <1> 	and		ah, ~FLG_STATUS_BSY
 14855 00000B81 7423                <1> 	jz		SHORT PollBsyOnly
 14856                              <1> 	; Fall to PollBsyAndFlgInAH
 14857                              <1> 
 14858                              <1> ;--------------------------------------------------------------------
 14859                              <1> ; PollBsyAndFlgInAH
 14860                              <1> ;	Parameters:
 14861                              <1> ;		AH:		Status Register Flag to poll (until set) when device not busy
 14862                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14863                              <1> ;	Returns:
 14864                              <1> ;		AH:		BIOS Error code
 14865                              <1> ;		CF:		Clear if wait completed successfully (no errors)
 14866                              <1> ;				Set if any error
 14867                              <1> ;	Corrupts registers:
 14868                              <1> ;		AL, BX, CX, DX
 14869                              <1> ;--------------------------------------------------------------------
 14870                              <1> PollBsyAndFlgInAH:
 14871 00000B83 E88300              <1> 	call	IdeIO_InputStatusRegisterToAL		; Discard contents of first read
 14872                              <1> 
 14873                              <1> .PollLoop:
 14874 00000B86 E88000              <1> 	call	IdeIO_InputStatusRegisterToAL
 14875 00000B89 A880                <1> 	test	al, FLG_STATUS_BSY					; Controller busy?
 14876 00000B8B 750B                <1> 	jnz		SHORT .UpdateTimeout				;  If so, jump to timeout update
 14877 00000B8D 84E0                <1> 	test	al, ah								; Test secondary flag
 14878 00000B8F 7526                <1> 	jnz		SHORT IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 14879                              <1> .UpdateTimeout:
 14880 00000B91 E8C6FC              <1> 	call	Timer_SetCFifTimeout
 14881 00000B94 73F0                <1> 	jnc		SHORT .PollLoop						; Loop if time left
 14882 00000B96 E81E00              <1> 	call	IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 14883 00000B99 720A                <1> 	jc		SHORT .ReturnErrorCodeInAH
 14884 00000B9B B480                <1> 	mov		ah, RET_HD_TIMEOUT					; Expected bit never got set
 14885 00000B9D F9                  <1> 	stc
 14886                              <1> .ReturnErrorCodeInAH:
 14887 00000B9E C3                  <1> 	ret
 14888                              <1> 
 14889                              <1> 
 14890                              <1> ;--------------------------------------------------------------------
 14891                              <1> ; PollBsyOnly
 14892                              <1> ;	Parameters:
 14893                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14894                              <1> ;	Returns:
 14895                              <1> ;		AH:		BIOS Error code
 14896                              <1> ;		CF:		Clear if wait completed successfully (no errors)
 14897                              <1> ;				Set if any error
 14898                              <1> ;	Corrupts registers:
 14899                              <1> ;		AL, BX, CX, DX
 14900                              <1> ;--------------------------------------------------------------------
 14901                              <1> PollBsyOnly:
 14902 00000B9F E86700              <1> 	call	IdeIO_InputStatusRegisterToAL		; Discard contents of first read
 14903                              <1> 
 14904                              <1> .PollLoop:
 14905 00000BA2 E86400              <1> 	call	IdeIO_InputStatusRegisterToAL
 14906 00000BA5 A880                <1> 	test	al, FLG_STATUS_BSY					; Controller busy?
 14907 00000BA7 740E                <1> 	jz		SHORT IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 14908 00000BA9 E8AEFC              <1> 	call	Timer_SetCFifTimeout				; Update timeout counter
 14909 00000BAC 73F4                <1> 	jnc		SHORT .PollLoop						; Loop if time left (sets CF on timeout)
 14910 00000BAE EB07                <1> 	jmp		SHORT IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 14911                                  	%include "IdeError.asm"			; Must be included after IdeWait.asm
 14912                              <1> ; Project name	:	XTIDE Universal BIOS
 14913                              <1> ; Description	:	IDE Device error functions.
 14914                              <1> 
 14915                              <1> ;
 14916                              <1> ; XTIDE Universal BIOS and Associated Tools
 14917                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 14918                              <1> ;
 14919                              <1> ; This program is free software; you can redistribute it and/or modify
 14920                              <1> ; it under the terms of the GNU General Public License as published by
 14921                              <1> ; the Free Software Foundation; either version 2 of the License, or
 14922                              <1> ; (at your option) any later version.
 14923                              <1> ;
 14924                              <1> ; This program is distributed in the hope that it will be useful,
 14925                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 14926                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14927                              <1> ; GNU General Public License for more details.
 14928                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 14929                              <1> ;
 14930                              <1> 
 14931                              <1> ; Section containing code
 14932                              <1> SECTION .text
 14933                              <1> 
 14934                              <1> ;--------------------------------------------------------------------
 14935                              <1> ; IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 14936                              <1> ;	Parameters:
 14937                              <1> ;		AL:		IDE Status Register contents
 14938                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14939                              <1> ;	Returns:
 14940                              <1> ;		AH:		BIOS error code
 14941                              <1> ;		CF:		Set if error
 14942                              <1> ;				Cleared if no error
 14943                              <1> ;	Corrupts registers:
 14944                              <1> ;		AL, BX, DX
 14945                              <1> ;--------------------------------------------------------------------
 14946                              <1> ALIGN JUMP_ALIGN
 14947                              <1> IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL:
 14948 00000BB0 88C4                <1> 	mov		ah, al			; IDE Status Register to AH
 14949                              <1> 	INPUT_TO_AL_FROM_IDE_REGISTER	ERROR_REGISTER_in
 14950                              <2> %ifndef MODULE_8BIT_IDE
 14951                              <2> 
 14952                              <2>  %ifnidni %1, dx
 14953                              <2>  mov dx, %1
 14954                              <2>  %endif
 14955                              <2>  add dx, [di+DPT.wBasePort]
 14956                              <2>  in al, dx
 14957                              <2> 
 14958                              <2> %else
 14959                              <2> 
 14960                              <2>  %ifnidni %1, dl
 14961 00000BB2 B201                <2>  mov dl, %1
 14962                              <2>  %endif
 14963 00000BB4 E85400              <2>  call IdeIO_InputToALfromIdeRegisterInDL
 14964                              <2> 
 14965                              <2> %endif
 14966 00000BB7 86C4                <1> 	xchg	al, ah			; Status Register now in AL, Error Register now in AH
 14967                              <1> 	; Fall to GetBiosErrorCodeToAHfromStatusAndErrorRegistersInAX
 14968                              <1> 
 14969                              <1> 
 14970                              <1> ;--------------------------------------------------------------------
 14971                              <1> ; GetBiosErrorCodeToAHfromStatusAndErrorRegistersInAX
 14972                              <1> ;	Parameters:
 14973                              <1> ;		AL:		IDE Status Register contents
 14974                              <1> ;		AH:		IDE Error Register contents
 14975                              <1> ;	Returns:
 14976                              <1> ;		AH:		BIOS INT 13h error code
 14977                              <1> ;		CF:		Set if error
 14978                              <1> ;				Cleared if no error
 14979                              <1> ;	Corrupts registers:
 14980                              <1> ;		BX
 14981                              <1> ;--------------------------------------------------------------------
 14982                              <1> ALIGN JUMP_ALIGN
 14983                              <1> GetBiosErrorCodeToAHfromStatusAndErrorRegistersInAX:
 14984 00000BB9 A880                <1> 	test	al, FLG_STATUS_BSY
 14985 00000BBB 740B                <1> 	jz		SHORT .CheckErrorBitsFromStatusRegisterInAL
 14986 00000BBD B480                <1> 	mov		ah, RET_HD_TIMEOUT
 14987 00000BBF EB2C                <1> 	jmp		SHORT .ReturnBiosErrorCodeInAH
 14988                              <1> 
 14989                              <1> ALIGN JUMP_ALIGN
 14990                              <1> .CheckErrorBitsFromStatusRegisterInAL:
 14991 00000BC1 A825                <1> 	test	al, FLG_STATUS_DF | FLG_STATUS_CORR | FLG_STATUS_ERR
 14992 00000BC3 750A                <1> 	jnz		SHORT .ProcessErrorFromStatusRegisterInAL
 14993 00000BC5 30E4                <1> 	xor		ah, ah					; No errors, zero AH and CF
 14994 00000BC7 C3                  <1> 	ret
 14995                              <1> 
 14996                              <1> .ProcessErrorFromStatusRegisterInAL:
 14997 00000BC8 A801                <1> 	test	al, FLG_STATUS_ERR		; Error specified in Error register?
 14998 00000BCA 7511                <1> 	jnz		SHORT .ConvertBiosErrorToAHfromErrorRegisterInAH
 14999 00000BCC B411                <1> 	mov		ah, RET_HD_ECC			; Assume ECC corrected error
 15000 00000BCE A804                <1> 	test	al, FLG_STATUS_CORR		; ECC corrected error?
 15001 00000BD0 751B                <1> 	jnz		SHORT .ReturnBiosErrorCodeInAH
 15002 00000BD2 B420                <1> 	mov		ah, RET_HD_CONTROLLER	; Must be Device Fault
 15003 00000BD4 EB17                <1> 	jmp		SHORT .ReturnBiosErrorCodeInAH
 15004                              <1> 
 15005                              <1> .ConvertBiosErrorToAHfromErrorRegisterInAH:
 15006 00000BD6 31DB                <1> 	xor		bx, bx					; Clear CF
 15007                              <1> .ErrorBitLoop:
 15008 00000BD8 D0DC                <1> 	rcr		ah, 1					; Set CF if error bit set
 15009 00000BDA 720C                <1> 	jc		SHORT .LookupErrorCode
 15010 00000BDC 43                  <1> 	inc		bx
 15011 00000BDD 84E4                <1> 	test	ah, ah					; Clear CF
 15012 00000BDF 75F7                <1> 	jnz		SHORT .ErrorBitLoop
 15013                              <1> .LookupErrorCode:
 15014 00000BE1 2E8AA7[EF0B]        <1> 	mov		ah, [cs:bx+.rgbRetCodeLookup]
 15015                              <1> .ReturnBiosErrorCodeInAH:
 15016 00000BE6 F9                  <1> 	stc								; Set CF since error
 15017 00000BE7 C3                  <1> 	ret
 15018                              <1> 
 15019                              <1> .rgbRetCodeLookup:
 15020 00000BE8 02                  <1> 	db	RET_HD_ADDRMARK		; Bit0=AMNF, Address Mark Not Found
 15021 00000BE9 40                  <1> 	db	RET_HD_SEEK_FAIL	; Bit1=TK0NF, Track 0 Not Found
 15022 00000BEA 01                  <1> 	db	RET_HD_INVALID		; Bit2=ABRT, Aborted Command
 15023 00000BEB B0                  <1> 	db	RET_HD_NOTLOCKED	; Bit3=MCR, Media Change Requested
 15024 00000BEC 04                  <1> 	db	RET_HD_NOT_FOUND	; Bit4=IDNF, ID Not Found
 15025 00000BED B1                  <1> 	db	RET_HD_LOCKED		; Bit5=MC, Media Changed
 15026 00000BEE 10                  <1> 	db	RET_HD_UNCORRECC	; Bit6=UNC, Uncorrectable Data Error
 15027 00000BEF 0A                  <1> 	db	RET_HD_BADSECTOR	; Bit7=BBK, Bad Block Detected
 15028 00000BF0 E0                  <1> 	db	RET_HD_STATUSERR	; When Error Register is zero
 15029                                  	%include "IdeDPT.asm"
 15030                              <1> ; Project name	:	XTIDE Universal BIOS
 15031                              <1> ; Description	:	Sets IDE Device specific parameters to DPT.
 15032                              <1> 
 15033                              <1> ;
 15034                              <1> ; XTIDE Universal BIOS and Associated Tools
 15035                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 15036                              <1> ;
 15037                              <1> ; This program is free software; you can redistribute it and/or modify
 15038                              <1> ; it under the terms of the GNU General Public License as published by
 15039                              <1> ; the Free Software Foundation; either version 2 of the License, or
 15040                              <1> ; (at your option) any later version.
 15041                              <1> ;
 15042                              <1> ; This program is distributed in the hope that it will be useful,
 15043                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 15044                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 15045                              <1> ; GNU General Public License for more details.
 15046                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 15047                              <1> ;
 15048                              <1> 
 15049                              <1> ; Section containing code
 15050                              <1> SECTION .text
 15051                              <1> 
 15052                              <1> ;--------------------------------------------------------------------
 15053                              <1> ; IdeDPT_Finalize
 15054                              <1> ;	Parameters:
 15055                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 15056                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 15057                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 15058                              <1> ;	Returns:
 15059                              <1> ;		CF:		Clear, IDE interface only supports hard disks
 15060                              <1> ;	Corrupts registers:
 15061                              <1> ;		AX, BX, CX, DX
 15062                              <1> ;--------------------------------------------------------------------
 15063                              <1> IdeDPT_Finalize:
 15064                              <1> 
 15065                              <1> %ifdef MODULE_FEATURE_SETS
 15066                              <1> ;--------------------------------------------------------------------
 15067                              <1> ; .DetectPowerManagementSupport
 15068                              <1> ;	Parameters:
 15069                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 15070                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 15071                              <1> ;	Returns:
 15072                              <1> ;		Nothing
 15073                              <1> ;	Corrupts registers:
 15074                              <1> ;		Nothing
 15075                              <1> ;--------------------------------------------------------------------
 15076                              <1> .DetectPowerManagementSupport:
 15077                              <1> 	test	BYTE [es:si+ATA6.wSetSup82], A6_wSetSup82_POWERMAN
 15078                              <1> 	jz		SHORT .NoPowerManagementSupport
 15079                              <1> 	or		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_POWER_MANAGEMENT_SUPPORTED
 15080                              <1> .NoPowerManagementSupport:
 15081                              <1> %endif ; MODULE_FEATURE_SETS
 15082                              <1> 
 15083                              <1> 
 15084                              <1> ;--------------------------------------------------------------------
 15085                              <1> ; .StoreDeviceType
 15086                              <1> ;	Parameters:
 15087                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 15088                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 15089                              <1> ;	Returns:
 15090                              <1> ;		Nothing
 15091                              <1> ;	Corrupts registers:
 15092                              <1> ;		AL
 15093                              <1> ;--------------------------------------------------------------------
 15094                              <1> .StoreDeviceType:
 15095 00000BF1 E80D00              <1> 	call	IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP
 15096                              <1> 
 15097                              <1> 
 15098                              <1> ;--------------------------------------------------------------------
 15099                              <1> ; .StoreBlockMode
 15100                              <1> ;	Parameters:
 15101                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 15102                              <1> ;	Returns:
 15103                              <1> ;		Nothing
 15104                              <1> ;	Corrupts registers:
 15105                              <1> ;		Nothing
 15106                              <1> ;--------------------------------------------------------------------
 15107                              <1> .StoreBlockMode:
 15108 00000BF4 C6450D01            <1> 	mov		BYTE [di+DPT_ATA.bBlockSize], 1
 15109                              <1> 
 15110                              <1> 
 15111                              <1> %ifdef MODULE_ADVANCED_ATA
 15112                              <1> ;--------------------------------------------------------------------
 15113                              <1> ; .StorePioModeAndTimings
 15114                              <1> ;	Parameters:
 15115                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 15116                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 15117                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 15118                              <1> ;	Returns:
 15119                              <1> ;		Nothing
 15120                              <1> ;	Corrupts registers:
 15121                              <1> ;		AX, BX, CX
 15122                              <1> ;--------------------------------------------------------------------
 15123                              <1> .StorePioMode:
 15124                              <1> 	call	AtaID_GetMaxPioModeToAXandMinCycleTimeToCX
 15125                              <1> 	mov		[di+DPT_ADVANCED_ATA.wMinPioCycleTime], cx
 15126                              <1> 	mov		[di+DPT_ADVANCED_ATA.bPioMode], al
 15127                              <1> 	or		[di+DPT.bFlagsHigh], ah
 15128                              <1> 
 15129                              <1> 
 15130                              <1> ;--------------------------------------------------------------------
 15131                              <1> ; .DetectAdvancedIdeController
 15132                              <1> ;	Parameters:
 15133                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 15134                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 15135                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 15136                              <1> ;	Returns:
 15137                              <1> ;		Nothing
 15138                              <1> ;	Corrupts registers:
 15139                              <1> ;		AX, BX, CX, DX
 15140                              <1> ;--------------------------------------------------------------------
 15141                              <1> .DetectAdvancedIdeController:
 15142                              <1> 	mov		bx, [di+DPT.wBasePort]
 15143                              <1> 	call	AdvAtaInit_DetectControllerForIdeBaseInBX
 15144                              <1> 	mov		[di+DPT_ADVANCED_ATA.wControllerID], ax	; Store zero if none detected
 15145                              <1> 	mov		[di+DPT_ADVANCED_ATA.wControllerBasePort], dx
 15146                              <1> 	jnc		SHORT .NoAdvancedControllerDetected
 15147                              <1> 
 15148                              <1> 	; Use highest common PIO mode from controller and drive.
 15149                              <1> 	; Many VLB controllers support PIO modes up to 2.
 15150                              <1> 	call	AdvAtaInit_GetControllerMaxPioModeToAL
 15151                              <1> 	jnc		SHORT .ChangeTo32bitDevice
 15152                              <1> 	and		BYTE [di+DPT.bFlagsHigh], ~FLGH_DPT_IORDY	; No IORDY supported if need to limit
 15153                              <1> 	MIN_U	[di+DPT_ADVANCED_ATA.bPioMode], al
 15154                              <1> 
 15155                              <1> 	; We have detected 32-bit controller so change Device Type since
 15156                              <1> 	; it might have been set to 16-bit on IDEVARS
 15157                              <1> .ChangeTo32bitDevice:
 15158                              <1> 	mov		BYTE [di+DPT_ATA.bDevice], DEVICE_32BIT_ATA
 15159                              <1> .NoAdvancedControllerDetected:
 15160                              <1> %endif	; MODULE_ADVANCED_ATA
 15161                              <1> 
 15162                              <1> 
 15163                              <1> ; End DPT
 15164 00000BF8 F8                  <1> 	clc
 15165 00000BF9 C3                  <1> 	ret
 15166                              <1> 
 15167                              <1> 
 15168                              <1> ;--------------------------------------------------------------------
 15169                              <1> ; IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP
 15170                              <1> ;	Parameters:
 15171                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 15172                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 15173                              <1> ;	Returns:
 15174                              <1> ;		Nothing
 15175                              <1> ;	Corrupts registers:
 15176                              <1> ;		AL
 15177                              <1> ;--------------------------------------------------------------------
 15178                              <1> IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP:
 15179 00000BFA 2E8A4604            <1> 	mov		al, [cs:bp+IDEVARS.bDevice]
 15180 00000BFE 88450C              <1> 	mov		[di+DPT_ATA.bDevice], al
 15181 00000C01 C3                  <1> 	ret
 15182                                  	%include "IdeIO.asm"
 15183                              <1> ; Project name	:	XTIDE Universal BIOS
 15184                              <1> ; Description	:	IDE Register I/O functions when supporting 8-bit
 15185                              <1> ;					devices that need address translations.
 15186                              <1> 
 15187                              <1> ;
 15188                              <1> ; XTIDE Universal BIOS and Associated Tools
 15189                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 15190                              <1> ;
 15191                              <1> ; This program is free software; you can redistribute it and/or modify
 15192                              <1> ; it under the terms of the GNU General Public License as published by
 15193                              <1> ; the Free Software Foundation; either version 2 of the License, or
 15194                              <1> ; (at your option) any later version.
 15195                              <1> ;
 15196                              <1> ; This program is distributed in the hope that it will be useful,
 15197                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 15198                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 15199                              <1> ; GNU General Public License for more details.
 15200                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 15201                              <1> ;
 15202                              <1> 
 15203                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 15204                              <1> 
 15205                              <1> ; Section containing code
 15206                              <1> SECTION .text
 15207                              <1> 
 15208                              <1> ;--------------------------------------------------------------------
 15209                              <1> ; IdeIO_InputStatusRegisterToAL
 15210                              <1> ;	Parameters:
 15211                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15212                              <1> ;	Returns:
 15213                              <1> ;		AL:		IDE Status Register contents
 15214                              <1> ;	Corrupts registers:
 15215                              <1> ;		BX, DX
 15216                              <1> ;--------------------------------------------------------------------
 15217                              <1> ALIGN JUMP_ALIGN
 15218                              <1> IdeIO_InputStatusRegisterToAL:
 15219                              <1> %ifndef MODULE_8BIT_IDE
 15220                              <1> 	INPUT_TO_AL_FROM_IDE_REGISTER STATUS_REGISTER_in
 15221                              <1> 	ret
 15222                              <1> 
 15223                              <1> %else
 15224 00000C02 B207                <1> 	mov		dl, STATUS_REGISTER_in
 15225                              <1> 	; Fall to IdeIO_InputToALfromIdeRegisterInDL
 15226                              <1> 
 15227                              <1> ;--------------------------------------------------------------------
 15228                              <1> ; IdeIO_InputToALfromIdeRegisterInDL
 15229                              <1> ;	Parameters:
 15230                              <1> ;		DL:		IDE Register
 15231                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15232                              <1> ;	Returns:
 15233                              <1> ;		AL:		Inputted byte
 15234                              <1> ;	Corrupts registers:
 15235                              <1> ;		BX, DX
 15236                              <1> ;--------------------------------------------------------------------
 15237                              <1> IdeIO_InputToALfromIdeRegisterInDL:
 15238 00000C04 30F6                <1> 	xor		dh, dh	; IDE Register index now in DX
 15239 00000C06 89D3                <1> 	mov		bx, dx	; and BX
 15240 00000C08 8A450C              <1> 	mov		al, [di+DPT_ATA.bDevice]
 15241 00000C0B 3C08                <1> 	cmp		al, DEVICE_8BIT_XTIDE_REV2
 15242 00000C0D 721F                <1> 	jb		SHORT .InputToALfromRegisterInDX	; Standard IDE controllers and XTIDE rev 1
 15243                              <1> 
 15244                              <1> %ifdef MODULE_8BIT_IDE
 15245 00000C0F 7415                <1> 	je		SHORT .ReverseA0andA3fromRegisterIndexInDX
 15246                              <1> 
 15247 00000C11 3C10                <1> 	cmp		al, DEVICE_8BIT_JRIDE_ISA
 15248 00000C13 7517                <1> 	jne		SHORT .ShlRegisterIndexInDX			; All XT-CF modes
 15249                              <1> 	; Fall to .InputToALfromMemoryMappedRegisterInDX
 15250                              <1> 
 15251                              <1> .InputToALfromMemoryMappedRegisterInDX:
 15252 00000C15 1E                  <1> 	push	ds
 15253 00000C16 8E5D04              <1> 	mov		ds, [di+DPT.wBasePort]	; Segment for JR-IDE/ISA
 15254                              <1> 	mov		al, [bx+JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET]
 15255          ******************  <1>  error: symbol `JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET' undefined
 15256 00000C19 1F                  <1> 	pop		ds
 15257 00000C1A C3                  <1> 	ret
 15258                              <1> %endif
 15259                              <1> 
 15260                              <1> .ReverseA0andA3fromRegisterIndexInDX:
 15261 00000C1B 2E8A97[8F0C]        <1> 	mov		dl, [cs:bx+g_rgbSwapA0andA3fromIdeRegisterIndex]
 15262                              <1> 	SKIP2B	bx	; Skip shl dx, 1
 15263                              <2>  %ifidni %1, f
 15264                              <2>  db 03Dh
 15265                              <2> 
 15266                              <2>  %elifidni %1, ax
 15267                              <2>  db 0B8h
 15268                              <2>  %elifidni %1, cx
 15269                              <2>  db 0B9h
 15270                              <2>  %elifidni %1, dx
 15271                              <2>  db 0BAh
 15272                              <2>  %elifidni %1, bx
 15273 00000C20 BB                  <2>  db 0BBh
 15274                              <2>  %elifidni %1, sp
 15275                              <2>  db 0BCh
 15276                              <2>  %elifidni %1, bp
 15277                              <2>  db 0BDh
 15278                              <2>  %elifidni %1, si
 15279                              <2>  db 0BEh
 15280                              <2>  %elifidni %1, di
 15281                              <2>  db 0BFh
 15282                              <2>  %else
 15283                              <2>  %error "Invalid parameter passed to SKIP2B"
 15284                              <2>  %endif
 15285                              <1> 
 15286                              <1> .ShlRegisterIndexInDX:
 15287                              <1> 	eSHL_IM	dx, 1
 15288                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15289                              <2> %ifdef USE_386
 15290                              <2>  %if %2 = 1
 15291                              <2>  add %1, %1
 15292                              <2>  %else
 15293                              <2>  eSHIFT_IM %1, %2, shl
 15294                              <2>  %endif
 15295                              <2> %else
 15296                              <2>  eSHIFT_IM %1, %2, shl
 15297                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15298                              <3> %ifndef USE_186
 15299                              <3>  %ifidni %1, cl
 15300                              <3>  times %2 %3 %1, 1
 15301                              <3>  %elifidni %1, ch
 15302                              <3>  times %2 %3 %1, 1
 15303                              <3>  %elifidni %1, cx
 15304                              <3>  times %2 %3 %1, 1
 15305                              <3>  %else
 15306                              <3>  %if %2 > 3
 15307                              <3>  push cx
 15308                              <3>  mov cl, %2
 15309                              <3>  %3 %1, cl
 15310                              <3>  pop cx
 15311                              <3>  %else
 15312 00000C21 D1E2                <3>  times %2 %3 %1, 1
 15313                              <3>  %endif
 15314                              <3>  %endif
 15315                              <3> 
 15316                              <3> %else
 15317                              <3>  %3 %1, %2
 15318                              <3> %endif
 15319                              <3> %endif
 15320                              <2> %endif
 15321                              <2> %endif
 15322                              <1> 	; Fall to .InputToALfromRegisterInDX
 15323                              <1> 
 15324                              <1> .InputToALfromRegisterInDX:
 15325 00000C23 035504              <1> 	add		dx, [di+DPT.wBasePort]
 15326 00000C26 EC                  <1> 	in		al, dx
 15327 00000C27 C3                  <1> 	ret
 15328                              <1> 
 15329                              <1> 
 15330                              <1> ;--------------------------------------------------------------------
 15331                              <1> ; IdeIO_OutputALtoIdeControlBlockRegisterInDL
 15332                              <1> ;	Parameters:
 15333                              <1> ;		AL:		Byte to output
 15334                              <1> ;		DL:		IDE Control Block Register
 15335                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15336                              <1> ;	Returns:
 15337                              <1> ;		Nothing
 15338                              <1> ;	Corrupts registers:
 15339                              <1> ;		BX, DX
 15340                              <1> ;--------------------------------------------------------------------
 15341                              <1> IdeIO_OutputALtoIdeControlBlockRegisterInDL:
 15342 00000C28 30F6                <1> 	xor		dh, dh	; IDE Register index now in DX
 15343                              <1> 
 15344 00000C2A 8A5D0C              <1> 	mov		bl, [di+DPT_ATA.bDevice]
 15345 00000C2D 80FB08              <1> 	cmp		bl, DEVICE_8BIT_XTIDE_REV2
 15346 00000C30 7227                <1> 	jb		SHORT .OutputALtoControlBlockRegisterInDX	; Standard IDE controllers and XTIDE rev 1
 15347                              <1> 
 15348                              <1> %ifdef MODULE_8BIT_IDE
 15349 00000C32 7415                <1> 	je		SHORT .ReverseA0andA3fromRegisterIndexInDX
 15350                              <1> 
 15351 00000C34 80FB10              <1> 	cmp		bl, DEVICE_8BIT_JRIDE_ISA
 15352 00000C37 7519                <1> 	jne		SHORT .ShlRegisterIndexInDX		; All XT-CF modes
 15353                              <1> 	; Fall to .OutputALtoMemoryMappedRegisterInDX
 15354                              <1> 
 15355                              <1> .OutputALtoMemoryMappedRegisterInDX:
 15356                              <1> 	mov		bx, JRIDE_CONTROL_BLOCK_REGISTER_WINDOW_OFFSET
 15357          ******************  <1>  error: symbol `JRIDE_CONTROL_BLOCK_REGISTER_WINDOW_OFFSET' undefined
 15358 00000C39 EB3B                <1> 	jmp 	SHORT IdeIO_OutputALtoIdeRegisterInDL.OutputALtoMemoryMappedRegisterInDXwithWindowOffsetInBX
 15359                              <1> %endif
 15360                              <1> 
 15361                              <1> .ReverseA0andA3fromRegisterIndexInDX:
 15362                              <1> 	; We cannot use lookup table since A3 will be always set because
 15363                              <1> 	; Control Block Registers start from Command Block + 8h. We can do
 15364                              <1> 	; a small trick since we only access Device Control Register at
 15365                              <1> 	; offset 6h: Always clear A3 and set A0.
 15366 00000C3B 2E035702            <1> 	add		dx, [cs:bx+IDEVARS.wControlBlockPort]
 15367 00000C3F 80F209              <1> 	xor		dl, 1001b						; Clear A3, Set A0
 15368 00000C42 EB49                <1> 	jmp		SHORT OutputALtoPortInDX
 15369                              <1> 
 15370                              <1> .ShlRegisterIndexInDX:
 15371                              <1> 	eSHL_IM	dx, 1
 15372                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15373                              <2> %ifdef USE_386
 15374                              <2>  %if %2 = 1
 15375                              <2>  add %1, %1
 15376                              <2>  %else
 15377                              <2>  eSHIFT_IM %1, %2, shl
 15378                              <2>  %endif
 15379                              <2> %else
 15380                              <2>  eSHIFT_IM %1, %2, shl
 15381                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15382                              <3> %ifndef USE_186
 15383                              <3>  %ifidni %1, cl
 15384                              <3>  times %2 %3 %1, 1
 15385                              <3>  %elifidni %1, ch
 15386                              <3>  times %2 %3 %1, 1
 15387                              <3>  %elifidni %1, cx
 15388                              <3>  times %2 %3 %1, 1
 15389                              <3>  %else
 15390                              <3>  %if %2 > 3
 15391                              <3>  push cx
 15392                              <3>  mov cl, %2
 15393                              <3>  %3 %1, cl
 15394                              <3>  pop cx
 15395                              <3>  %else
 15396 00000C44 D1E2                <3>  times %2 %3 %1, 1
 15397                              <3>  %endif
 15398                              <3>  %endif
 15399                              <3> 
 15400                              <3> %else
 15401                              <3>  %3 %1, %2
 15402                              <3> %endif
 15403                              <3> %endif
 15404                              <2> %endif
 15405                              <2> %endif
 15406 00000C46 83C210              <1> 	add		dx, BYTE XTCF_CONTROL_BLOCK_OFFSET
 15407 00000C49 EB3F                <1> 	jmp		SHORT OutputALtoRegisterInDX
 15408                              <1> 
 15409                              <1> .OutputALtoControlBlockRegisterInDX:
 15410 00000C4B E842F9              <1> 	call	AccessDPT_GetIdevarsToCSBX
 15411 00000C4E 2E035702            <1> 	add		dx, [cs:bx+IDEVARS.wControlBlockPort]
 15412 00000C52 EB39                <1> 	jmp		SHORT OutputALtoPortInDX
 15413                              <1> 
 15414                              <1> 
 15415                              <1> ;--------------------------------------------------------------------
 15416                              <1> ; IdeIO_OutputALtoIdeRegisterInDL
 15417                              <1> ;	Parameters:
 15418                              <1> ;		AL:		Byte to output
 15419                              <1> ;		DL:		IDE Command Block Register
 15420                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15421                              <1> ;	Returns:
 15422                              <1> ;		Nothing
 15423                              <1> ;	Corrupts registers:
 15424                              <1> ;		BX, DX
 15425                              <1> ;--------------------------------------------------------------------
 15426                              <1> ALIGN JUMP_ALIGN
 15427                              <1> IdeIO_OutputALtoIdeRegisterInDL:
 15428 00000C54 30F6                <1> 	xor		dh, dh	; IDE Register index now in DX
 15429                              <1> 
 15430 00000C56 8A5D0C              <1> 	mov		bl, [di+DPT_ATA.bDevice]
 15431 00000C59 80FB08              <1> 	cmp		bl, DEVICE_8BIT_XTIDE_REV2
 15432 00000C5C 722C                <1> 	jb		SHORT OutputALtoRegisterInDX	; Standard IDE controllers and XTIDE rev 1
 15433                              <1> 
 15434                              <1> %ifdef MODULE_8BIT_IDE
 15435 00000C5E 7420                <1> 	je		SHORT .ReverseA0andA3fromRegisterIndexInDX
 15436                              <1> 
 15437 00000C60 80FB10              <1> 	cmp		bl, DEVICE_8BIT_JRIDE_ISA
 15438 00000C63 7523                <1> 	jne		SHORT .ShlRegisterIndexInDX		; All XT-CF modes
 15439                              <1> 	; Fall to .OutputALtoMemoryMappedRegisterInDX
 15440                              <1> 
 15441                              <1> .OutputALtoMemoryMappedRegisterInDX:
 15442                              <1> 	mov		bx, JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET
 15443          ******************  <1>  error: symbol `JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET' undefined
 15444                              <1> .OutputALtoMemoryMappedRegisterInDXwithWindowOffsetInBX:
 15445 00000C65 01D3                <1> 	add		bx, dx
 15446 00000C67 1E                  <1> 	push	ds
 15447 00000C68 8E5D04              <1> 	mov		ds, [di+DPT.wBasePort]	; Segment for JR-IDE/ISA
 15448 00000C6B 8807                <1> 	mov		[bx], al
 15449 00000C6D 1F                  <1> 	pop		ds
 15450 00000C6E C3                  <1> 	ret
 15451                              <1> %endif
 15452                              <1> 
 15453                              <1> .ReverseA0andA3fromRegisterIndexInDX:
 15454 00000C6F 89D3                <1> 	mov		bx, dx
 15455 00000C71 2E8A97[8F0C]        <1> 	mov		dl, [cs:bx+g_rgbSwapA0andA3fromIdeRegisterIndex]
 15456                              <1> 	SKIP2B	bx	; Skip shl dx, 1
 15457                              <2>  %ifidni %1, f
 15458                              <2>  db 03Dh
 15459                              <2> 
 15460                              <2>  %elifidni %1, ax
 15461                              <2>  db 0B8h
 15462                              <2>  %elifidni %1, cx
 15463                              <2>  db 0B9h
 15464                              <2>  %elifidni %1, dx
 15465                              <2>  db 0BAh
 15466                              <2>  %elifidni %1, bx
 15467 00000C76 BB                  <2>  db 0BBh
 15468                              <2>  %elifidni %1, sp
 15469                              <2>  db 0BCh
 15470                              <2>  %elifidni %1, bp
 15471                              <2>  db 0BDh
 15472                              <2>  %elifidni %1, si
 15473                              <2>  db 0BEh
 15474                              <2>  %elifidni %1, di
 15475                              <2>  db 0BFh
 15476                              <2>  %else
 15477                              <2>  %error "Invalid parameter passed to SKIP2B"
 15478                              <2>  %endif
 15479                              <1> 
 15480                              <1> .ShlRegisterIndexInDX:
 15481                              <1> 	eSHL_IM	dx, 1
 15482                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15483                              <2> %ifdef USE_386
 15484                              <2>  %if %2 = 1
 15485                              <2>  add %1, %1
 15486                              <2>  %else
 15487                              <2>  eSHIFT_IM %1, %2, shl
 15488                              <2>  %endif
 15489                              <2> %else
 15490                              <2>  eSHIFT_IM %1, %2, shl
 15491                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15492                              <3> %ifndef USE_186
 15493                              <3>  %ifidni %1, cl
 15494                              <3>  times %2 %3 %1, 1
 15495                              <3>  %elifidni %1, ch
 15496                              <3>  times %2 %3 %1, 1
 15497                              <3>  %elifidni %1, cx
 15498                              <3>  times %2 %3 %1, 1
 15499                              <3>  %else
 15500                              <3>  %if %2 > 3
 15501                              <3>  push cx
 15502                              <3>  mov cl, %2
 15503                              <3>  %3 %1, cl
 15504                              <3>  pop cx
 15505                              <3>  %else
 15506 00000C77 D1E2                <3>  times %2 %3 %1, 1
 15507                              <3>  %endif
 15508                              <3>  %endif
 15509                              <3> 
 15510                              <3> %else
 15511                              <3>  %3 %1, %2
 15512                              <3> %endif
 15513                              <3> %endif
 15514                              <2> %endif
 15515                              <2> %endif
 15516                              <1> 	; Fall to OutputALtoRegisterInDX
 15517                              <1> 
 15518                              <1> ALIGN JUMP_ALIGN
 15519                              <1> OutputALtoRegisterInDX:
 15520 00000C79 035504              <1> 	add		dx, [di+DPT.wBasePort]
 15521                              <1> OutputALtoPortInDX:
 15522 00000C7C EE                  <1> 	out		dx, al
 15523 00000C7D C3                  <1> 	ret
 15524                              <1> 
 15525                              <1> 
 15526                              <1> 
 15527                              <1> ; A0 <-> A3 lookup table
 15528                              <1> g_rgbSwapA0andA3fromIdeRegisterIndex:
 15529 00000C7E 00                  <1> 	db	0000b	; <-> 0000b, 0
 15530 00000C7F 08                  <1> 	db	1000b	; <-> 0001b, 1
 15531 00000C80 02                  <1> 	db	0010b	; <-> 0010b, 2
 15532 00000C81 0A                  <1> 	db	1010b	; <-> 0011b, 3
 15533 00000C82 04                  <1> 	db	0100b	; <-> 0100b, 4
 15534 00000C83 0C                  <1> 	db	1100b	; <-> 0101b, 5
 15535 00000C84 06                  <1> 	db	0110b	; <-> 0110b, 6
 15536 00000C85 0E                  <1> 	db	1110b	; <-> 0111b, 7
 15537                              <1> 
 15538                              <1> %endif ; MODULE_8BIT_IDE
 15539                                  %ifdef MODULE_IRQ
 15540                                  	%include "IdeIrq.asm"
 15541                                  %endif
 15542                                  
 15543                                  	; Serial Device support
 15544                                  %ifdef MODULE_SERIAL				; Serial Port Device support
 15545                                  	%include "SerialCommand.asm"
 15546                                  	%include "SerialDPT.asm"
 15547                                  %endif
 15548                                  
 15549                                  	; INT 13h Hard Disk BIOS functions
 15550                                  	%include "Int13h.asm"			; For Int 13h, Disk functions
 15551                              <1> ; Project name	:	XTIDE Universal BIOS
 15552                              <1> ; Description	:	Int 13h BIOS functions (Floppy and Hard disk).
 15553                              <1> 
 15554                              <1> ;
 15555                              <1> ; XTIDE Universal BIOS and Associated Tools
 15556                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 15557                              <1> ;
 15558                              <1> ; This program is free software; you can redistribute it and/or modify
 15559                              <1> ; it under the terms of the GNU General Public License as published by
 15560                              <1> ; the Free Software Foundation; either version 2 of the License, or
 15561                              <1> ; (at your option) any later version.
 15562                              <1> ;
 15563                              <1> ; This program is distributed in the hope that it will be useful,
 15564                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 15565                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 15566                              <1> ; GNU General Public License for more details.
 15567                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 15568                              <1> ;
 15569                              <1> 
 15570                              <1> ; Section containing code
 15571                              <1> SECTION .text
 15572                              <1> 
 15573                              <1> ;--------------------------------------------------------------------
 15574                              <1> ; Int 13h software interrupt handler.
 15575                              <1> ; This handler changes stack to top of stolen conventional memory
 15576                              <1> ; and then calls the actual INT 13h handler (Int13h_DiskFunctionsHandler).
 15577                              <1> ;
 15578                              <1> ; Int13h_DiskFunctionsHandlerWithStackChange
 15579                              <1> ;	Parameters:
 15580                              <1> ;		AH:		Bios function
 15581                              <1> ;		DL:		Drive number
 15582                              <1> ;		Other:	Depends on function
 15583                              <1> ;	Returns:
 15584                              <1> ;		Depends on function
 15585                              <1> ;--------------------------------------------------------------------
 15586                              <1> %ifdef RELOCATE_INT13H_STACK
 15587                              <1> ALIGN JUMP_ALIGN
 15588                              <1> Int13h_DiskFunctionsHandlerWithStackChange:
 15589                              <1> 	sti			; Enable interrupts
 15590                              <1> 	; TODO: Maybe we need to save Flags (DF) as well?
 15591                              <1> 	push	ds	; Save DS:DI on the original stack
 15592                              <1> 	push	di
 15593                              <1> 	call	RamVars_GetSegmentToDS
 15594                              <1> 
 15595                              <1> 	; Store entry registers to RAMVARS
 15596                              <1> %ifdef USE_386
 15597                              <1> 	pop		DWORD [RAMVARS.dwStackChangeDSDI]
 15598                              <1> %else
 15599                              <1> 	pop		WORD [RAMVARS.wStackChangeDI]	; Pop DS:DI to the top of what
 15600                              <1> 	pop		WORD [RAMVARS.wStackChangeDS]	; is to become the new stack
 15601                              <1> %endif
 15602                              <1> 	mov		[RAMVARS.fpInt13hEntryStack], sp
 15603                              <1> 	mov		[RAMVARS.fpInt13hEntryStack+2], ss
 15604                              <1> 
 15605                              <1> 	; Load new stack and restore DS and DI
 15606                              <1> 	mov		di, ds		; We can save 2 bytes by using PUSH/POP but it's slower
 15607                              <1> 	mov		ss, di		; No need to wrap with CLI/STI since this is for AT only (286+)
 15608                              <1> 	mov		sp, RAMVARS.rgbTopOfStack-4
 15609                              <1> 	pop		di			; DI before stack change
 15610                              <1> 	pop		ds			; DS before stack change
 15611                              <1> 
 15612                              <1> 	; Call INT 13h
 15613                              <1> 	pushf
 15614                              <1> 	push	cs
 15615                              <1> 	call	Int13h_DiskFunctionsHandler
 15616                              <1> 
 15617                              <1> 	; Restore stack (we must not corrupt FLAGS!)
 15618                              <1> %ifdef USE_386
 15619                              <1> 	lss		sp, [ss:RAMVARS.fpInt13hEntryStack]
 15620                              <1> %else
 15621                              <1> 	cli
 15622                              <1> 	mov		sp, [ss:RAMVARS.fpInt13hEntryStack]
 15623                              <1> 	mov		ss, [ss:RAMVARS.fpInt13hEntryStack+2]
 15624                              <1> 	sti
 15625                              <1> %endif
 15626                              <1> 	retf	2			; Skip FLAGS from stack
 15627                              <1> %endif ; RELOCATE_INT13H_STACK
 15628                              <1> 
 15629                              <1> 
 15630                              <1> ;--------------------------------------------------------------------
 15631                              <1> ; Int 13h software interrupt handler.
 15632                              <1> ; Jumps to specific function defined in AH.
 15633                              <1> ;
 15634                              <1> ; Note to developers: Do not make recursive INT 13h calls!
 15635                              <1> ;
 15636                              <1> ; Int13h_DiskFunctionsHandler
 15637                              <1> ;	Parameters:
 15638                              <1> ;		AH:		Bios function
 15639                              <1> ;		DL:		Drive number
 15640                              <1> ;		Other:	Depends on function
 15641                              <1> ;	Returns:
 15642                              <1> ;		Depends on function
 15643                              <1> ;--------------------------------------------------------------------
 15644                              <1> ALIGN JUMP_ALIGN
 15645                              <1> Int13h_DiskFunctionsHandler:
 15646                              <1> %ifndef RELOCATE_INT13H_STACK
 15647 00000C86 FB                  <1> 	sti									; Enable interrupts
 15648                              <1> %endif
 15649 00000C87 FC                  <1> 	cld									; String instructions to increment pointers
 15650                              <1> 	CREATE_FRAME_INTPACK_TO_SSBP	SIZE_OF_IDEPACK_WITHOUT_INTPACK
 15651                              <2>  ePUSHA
 15652                              <3> %ifndef USE_186
 15653 00000C88 50                  <3>  push ax
 15654 00000C89 51                  <3>  push cx
 15655 00000C8A 52                  <3>  push dx
 15656 00000C8B 53                  <3>  push bx
 15657 00000C8C 54                  <3>  push sp
 15658 00000C8D 55                  <3>  push bp
 15659 00000C8E 56                  <3>  push si
 15660 00000C8F 57                  <3>  push di
 15661                              <3> 
 15662                              <3> %else
 15663                              <3>  pusha
 15664                              <3> %endif
 15665 00000C90 1E                  <2>  push ds
 15666 00000C91 06                  <2>  push es
 15667                              <2> %ifdef USE_386
 15668                              <2> 
 15669                              <2> 
 15670                              <2> %endif
 15671 00000C92 83EC09              <2>  sub sp, BYTE %1
 15672 00000C95 89E5                <2>  mov bp, sp
 15673 00000C97 E87AF7              <1> 	call	RamVars_GetSegmentToDS
 15674                              <1> 
 15675                              <1> %ifdef MODULE_DRIVEXLATE
 15676                              <1> 	call	DriveXlate_ToOrBack
 15677                              <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bXlatedDrv], dl
 15678                              <1> %endif
 15679 00000C9A E853F8              <1> 	call	FindDPT_ForDriveNumberInDL	; DS:DI points to our DPT, or NULL if not our drive
 15680 00000C9D 7221                <1> 	jc		SHORT .NotOurDrive			; DPT not found so this is not one of our drives
 15681                              <1> 
 15682                              <1> .OurFunction:
 15683                              <1> 	; Jump to correct BIOS function
 15684                              <1> 	eMOVZX	bx, ah
 15685                              <2> %ifndef USE_386
 15686                              <2>  %ifidni %1, ax
 15687                              <2>  mov al, %2
 15688                              <2>  xor ah, ah
 15689                              <2>  %elifidni %1, bx
 15690 00000C9F 88E3                <2>  mov bl, %2
 15691 00000CA1 30FF                <2>  xor bh, bh
 15692                              <2>  %elifidni %1, cx
 15693                              <2>  mov cl, %2
 15694                              <2>  xor ch, ch
 15695                              <2>  %elifidni %1, dx
 15696                              <2>  mov dl, %2
 15697                              <2>  xor dh, dh
 15698                              <2>  %else
 15699                              <2>  push ax
 15700                              <2>  mov al, %2
 15701                              <2>  xor ah, ah
 15702                              <2>  xchg ax, %1
 15703                              <2>  pop ax
 15704                              <2>  %endif
 15705                              <2> 
 15706                              <2> %else
 15707                              <2>  movzx %1, %2
 15708                              <2> %endif
 15709                              <1> 	eSHL_IM	bx, 1
 15710                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15711                              <2> %ifdef USE_386
 15712                              <2>  %if %2 = 1
 15713                              <2>  add %1, %1
 15714                              <2>  %else
 15715                              <2>  eSHIFT_IM %1, %2, shl
 15716                              <2>  %endif
 15717                              <2> %else
 15718                              <2>  eSHIFT_IM %1, %2, shl
 15719                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15720                              <3> %ifndef USE_186
 15721                              <3>  %ifidni %1, cl
 15722                              <3>  times %2 %3 %1, 1
 15723                              <3>  %elifidni %1, ch
 15724                              <3>  times %2 %3 %1, 1
 15725                              <3>  %elifidni %1, cx
 15726                              <3>  times %2 %3 %1, 1
 15727                              <3>  %else
 15728                              <3>  %if %2 > 3
 15729                              <3>  push cx
 15730                              <3>  mov cl, %2
 15731                              <3>  %3 %1, cl
 15732                              <3>  pop cx
 15733                              <3>  %else
 15734 00000CA3 D1E3                <3>  times %2 %3 %1, 1
 15735                              <3>  %endif
 15736                              <3>  %endif
 15737                              <3> 
 15738                              <3> %else
 15739                              <3>  %3 %1, %2
 15740                              <3> %endif
 15741                              <3> %endif
 15742                              <2> %endif
 15743                              <2> %endif
 15744 00000CA5 80FC25              <1> 	cmp		ah, 25h						; Possible EBIOS function?
 15745                              <1> %ifndef MODULE_EBIOS
 15746 00000CA8 7723                <1> 	ja		SHORT UnsupportedFunction
 15747 00000CAA 2EFFA7[660D]        <1> 	jmp		[cs:bx+g_rgw13hFuncJump]	; Jump to BIOS function
 15748                              <1> 
 15749                              <1> %else ; If using MODULE_EBIOS
 15750                              <1> 	ja		SHORT .JumpToEbiosFunction
 15751                              <1> 	jmp		[cs:bx+g_rgw13hFuncJump]	; Jump to BIOS function
 15752                              <1> 
 15753                              <1> ALIGN JUMP_ALIGN
 15754                              <1> .JumpToEbiosFunction:
 15755                              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_LBA_AND_EBIOS_SUPPORTED
 15756                              <1> 	jz		SHORT UnsupportedFunction	; No eINT 13h for CHS drives
 15757                              <1> 	sub		bl, 41h<<1					; BX = Offset to eINT 13h jump table
 15758                              <1> 	jb		SHORT UnsupportedFunction
 15759                              <1> 	cmp		ah, 48h
 15760                              <1> 	ja		SHORT UnsupportedFunction
 15761                              <1> 	jmp		[cs:bx+g_rgwEbiosFunctionJumpTable]
 15762                              <1> %endif	; MODULE_EBIOS
 15763                              <1> 
 15764                              <1> 
 15765                              <1> ALIGN JUMP_ALIGN
 15766                              <1> .NotOurDrive:
 15767 00000CAF 84E4                <1> 	test	ah, ah
 15768 00000CB1 74EC                <1> 	jz		SHORT .OurFunction			; We handle all function 0h requests (resets)
 15769                              <1> 
 15770                              <1> %ifndef MODULE_SERIAL_FLOPPY
 15771                              <1> ; Without floppy support, we handle only hard disk traffic for function 08h.
 15772 00000CB3 84D2                <1> 	test	dl, dl
 15773 00000CB5 7916                <1> 	jns		SHORT Int13h_DirectCallToAnotherBios
 15774                              <1> %endif
 15775                              <1> ; With floppy support, we handle all traffic for function 08h, as we need to wrap both hard disk and floppy drive counts.
 15776 00000CB7 80FC08              <1> 	cmp		ah, 8
 15777 00000CBA 74E3                <1> 	je		SHORT .OurFunction
 15778                              <1> 	; Fall to Int13h_DirectCallToAnotherBios
 15779                              <1> 
 15780                              <1> 
 15781                              <1> ;--------------------------------------------------------------------
 15782                              <1> ; UnsupportedFunction
 15783                              <1> ; Int13h_DirectCallToAnotherBios
 15784                              <1> ;	Parameters:
 15785                              <1> ;		DL:		Translated drive number
 15786                              <1> ;		DS:		RAMVARS segment
 15787                              <1> ;		SS:BP:	Ptr to IDEPACK
 15788                              <1> ;		BX, DI:	Corrupted on Int13h_DiskFunctionsHandler
 15789                              <1> ;		Other:	Function specific INT 13h parameters
 15790                              <1> ;	Returns:
 15791                              <1> ;		Depends on function
 15792                              <1> ;	Corrupts registers:
 15793                              <1> ;		Flags
 15794                              <1> ;--------------------------------------------------------------------
 15795                              <1> ALIGN JUMP_ALIGN
 15796                              <1> UnsupportedFunction:
 15797                              <1> Int13h_DirectCallToAnotherBios:
 15798 00000CBC E86800              <1> 	call	ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 15799 00000CBF 8B5E15              <1> 	mov		bx, [bp+IDEPACK.intpack+INTPACK.bx]
 15800 00000CC2 8B7E0D              <1> 	mov		di, [bp+IDEPACK.intpack+INTPACK.di]
 15801 00000CC5 8E5E0B              <1> 	mov		ds, [bp+IDEPACK.intpack+INTPACK.ds]
 15802 00000CC8 FF7621              <1> 	push	WORD [bp+IDEPACK.intpack+INTPACK.flags]
 15803 00000CCB 9D                  <1> 	popf
 15804 00000CCC 55                  <1> 	push	bp
 15805 00000CCD 8B6E11              <1> 	mov		bp, [bp+IDEPACK.intpack+INTPACK.bp]
 15806 00000CD0 CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h	; Can safely do as much recursion as it wants
 15807                              <1> 
 15808                              <1> 	; Store returned values to INTPACK
 15809 00000CD2 5D                  <1> 	pop		bp	; Standard INT 13h functions never uses BP as return register
 15810                              <1> %ifdef USE_386
 15811                              <1> ;	mov		[bp+IDEPACK.intpack+INTPACK.gs], gs
 15812                              <1> ;	mov		[bp+IDEPACK.intpack+INTPACK.fs], fs
 15813                              <1> %endif
 15814 00000CD3 8C4609              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.es], es
 15815 00000CD6 8C5E0B              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ds], ds
 15816 00000CD9 897E0D              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.di], di
 15817 00000CDC 89760F              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.si], si
 15818 00000CDF 895E15              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.bx], bx
 15819                              <1> %ifdef MODULE_DRIVEXLATE
 15820                              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dh], dh
 15821                              <1> %else
 15822 00000CE2 895617              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dx], dx
 15823                              <1> %endif
 15824 00000CE5 894E19              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.cx], cx
 15825 00000CE8 89461B              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ax], ax
 15826 00000CEB 9C                  <1> 	pushf
 15827 00000CEC 8F4621              <1> 	pop		WORD [bp+IDEPACK.intpack+INTPACK.flags]
 15828 00000CEF E822F7              <1> 	call	RamVars_GetSegmentToDS
 15829                              <1> 
 15830                              <1> %ifdef MODULE_DRIVEXLATE
 15831                              <1> 	cmp		dl, [RAMVARS.xlateVars+XLATEVARS.bXlatedDrv]	; DL is still drive number?
 15832                              <1> 	je		SHORT .ExchangeInt13hHandlers
 15833                              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dl], dl	; Something is returned in DL
 15834                              <1> ALIGN JUMP_ALIGN
 15835                              <1> .ExchangeInt13hHandlers:
 15836                              <1> %endif
 15837                              <1> 
 15838                              <1> %ifdef USE_186
 15839                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 15840                              <1> 	jmp		SHORT ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 15841                              <1> %else
 15842 00000CF2 E83200              <1> 	call	ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 15843 00000CF5 EB14                <1> 	jmp		SHORT Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 15844                              <1> %endif
 15845                              <1> 
 15846                              <1> 
 15847                              <1> %ifdef MODULE_SERIAL_FLOPPY
 15848                              <1> ;--------------------------------------------------------------------
 15849                              <1> ; Int13h_ReturnSuccessForFloppy
 15850                              <1> ;
 15851                              <1> ; Some operations, such as format of a floppy disk track, should just
 15852                              <1> ; return success, while for hard disks it should be treated as unsupported.
 15853                              <1> ;--------------------------------------------------------------------
 15854                              <1> ALIGN JUMP_ALIGN
 15855                              <1> Int13h_ReturnSuccessForFloppy:
 15856                              <1> 	test	dl, dl
 15857                              <1> 	js		SHORT UnsupportedFunction
 15858                              <1> 	xor		ah, ah
 15859                              <1> 	jmp		SHORT Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 15860                              <1> %endif
 15861                              <1> 
 15862                              <1> 
 15863                              <1> ;--------------------------------------------------------------------
 15864                              <1> ; Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 15865                              <1> ;	Parameters:
 15866                              <1> ;		AH:		BIOS Error code
 15867                              <1> ;		CL:		Number of sectors actually transferred
 15868                              <1> ;		SS:BP:	Ptr to IDEPACK
 15869                              <1> ;	Returns:
 15870                              <1> ;		All registers are loaded from INTPACK
 15871                              <1> ;--------------------------------------------------------------------
 15872                              <1> ALIGN JUMP_ALIGN
 15873                              <1> Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL:
 15874 00000CF7 884E1B              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.al], cl
 15875                              <1> 	; Fall to Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 15876                              <1> 
 15877                              <1> 
 15878                              <1> ;--------------------------------------------------------------------
 15879                              <1> ; Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 15880                              <1> ; Int13h_ReturnFromHandlerWithoutStoringErrorCode
 15881                              <1> ;	Parameters:
 15882                              <1> ;		AH:		BIOS Error code
 15883                              <1> ;		DS:		RAMVARS segment
 15884                              <1> ;		SS:BP:	Ptr to IDEPACK
 15885                              <1> ;	Returns:
 15886                              <1> ;		All registers are loaded from INTPACK
 15887                              <1> ;--------------------------------------------------------------------
 15888                              <1> ALIGN JUMP_ALIGN
 15889                              <1> Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH:
 15890                              <1> %ifdef MODULE_SERIAL_FLOPPY
 15891                              <1> 	mov		al, [bp+IDEPACK.intpack+INTPACK.dl]
 15892                              <1> Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH_ALHasDriveNumber:
 15893                              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH_ALHasDriveNumber
 15894                              <1> 
 15895                              <1> %else
 15896 00000CFA E85000              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH
 15897                              <1> %endif
 15898                              <1> 
 15899                              <1> Int13h_ReturnFromHandlerWithoutStoringErrorCode:
 15900                              <1> 	; Always return with interrupts enabled since there are programs that rely
 15901                              <1> 	; on INT 13h to enable interrupts.
 15902 00000CFD 804E2202            <1> 	or		BYTE [bp+IDEPACK.intpack+INTPACK.flags+1], (FLG_FLAGS_IF>>8)
 15903 00000D01 89EC                <1> 	mov		sp, bp	; This makes possible to exit anytime, no matter what is on stack
 15904                              <1> 	RESTORE_FRAME_INTPACK_FROM_SSBP		SIZE_OF_IDEPACK_WITHOUT_INTPACK
 15905 00000D03 83C409              <2>  add sp, BYTE %1
 15906                              <2> %ifdef USE_386
 15907                              <2> 
 15908                              <2> 
 15909                              <2> %endif
 15910 00000D06 07                  <2>  pop es
 15911 00000D07 1F                  <2>  pop ds
 15912                              <2>  ePOPA
 15913                              <3> %ifndef USE_186
 15914 00000D08 5F                  <3>  pop di
 15915 00000D09 5E                  <3>  pop si
 15916 00000D0A 5D                  <3>  pop bp
 15917 00000D0B 58                  <3>  pop ax
 15918 00000D0C 5B                  <3>  pop bx
 15919 00000D0D 5A                  <3>  pop dx
 15920 00000D0E 59                  <3>  pop cx
 15921 00000D0F 58                  <3>  pop ax
 15922                              <3> 
 15923                              <3> %else
 15924                              <3>  popa
 15925                              <3> %endif
 15926 00000D10 CF                  <2>  iret
 15927                              <1> 
 15928                              <1> 
 15929                              <1> ;--------------------------------------------------------------------
 15930                              <1> ; Int13h_CallPreviousInt13hHandler
 15931                              <1> ;	Parameters:
 15932                              <1> ;		AH:		INT 13h function to call
 15933                              <1> ;		DL:		Drive number
 15934                              <1> ;		DS:		RAMVARS segment
 15935                              <1> ;	Returns:
 15936                              <1> ;		Depends on function
 15937                              <1> ;       NOTE: ES:DI needs to be returned from the previous interrupt
 15938                              <1> ;		      handler, for floppy DPT in function 08h
 15939                              <1> ;	Corrupts registers:
 15940                              <1> ;		None
 15941                              <1> ;--------------------------------------------------------------------
 15942                              <1> ALIGN JUMP_ALIGN
 15943                              <1> Int13h_CallPreviousInt13hHandler:
 15944 00000D11 E81300              <1> 	call	ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 15945 00000D14 CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h
 15946                              <1> ;;;  fall-through to ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 15947                              <1> 
 15948                              <1> ;--------------------------------------------------------------------
 15949                              <1> ; ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 15950                              <1> ;	Parameters:
 15951                              <1> ;		DS:		RAMVARS segment
 15952                              <1> ;	Returns:
 15953                              <1> ;		Nothing
 15954                              <1> ;	Corrupts registers:
 15955                              <1> ;       Nothing
 15956                              <1> ;       Note: Flags are preserved
 15957                              <1> ;--------------------------------------------------------------------
 15958                              <1> ALIGN JUMP_ALIGN
 15959                              <1> ExchangeCurrentInt13hHandlerWithOldInt13hHandler:
 15960 00000D16 06                  <1> 	push	es
 15961 00000D17 56                  <1> 	push	si
 15962                              <1> 	LOAD_BDA_SEGMENT_PRESERVE_FLAGS_TO	es, si
 15963                              <2> %ifndef USE_186
 15964 00000D18 BE0000              <2>  mov %2, 0
 15965 00000D1B 8EC6                <2>  mov %1, %2
 15966                              <2> %elifidn %3, !
 15967                              <2>  mov %2, 0
 15968                              <2>  mov %1, %2
 15969                              <2> %else
 15970                              <2>  push BYTE 0
 15971                              <2>  pop %1
 15972                              <2> %endif
 15973 00000D1D 8B360000            <1> 	mov		si, [RAMVARS.fpOldI13h]
 15974 00000D21 FA                  <1> 	cli
 15975 00000D22 2687364C00          <1> 	xchg	si, [es:BIOS_DISK_INTERRUPT_13h*4]
 15976 00000D27 89360000            <1> 	mov		[RAMVARS.fpOldI13h], si
 15977 00000D2B 8B360200            <1> 	mov		si, [RAMVARS.fpOldI13h+2]
 15978 00000D2F 2687364E00          <1> 	xchg	si, [es:BIOS_DISK_INTERRUPT_13h*4+2]
 15979 00000D34 FB                  <1> 	sti
 15980 00000D35 89360200            <1> 	mov		[RAMVARS.fpOldI13h+2], si
 15981 00000D39 5E                  <1> 	pop		si
 15982 00000D3A 07                  <1> 	pop		es
 15983 00000D3B C3                  <1> 	ret
 15984                              <1> 
 15985                              <1> 
 15986                              <1> ;--------------------------------------------------------------------
 15987                              <1> ; Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH
 15988                              <1> ; Int13h_SetErrorCodeToIntpackInSSBPfromAH
 15989                              <1> ;	Parameters:
 15990                              <1> ;		AH:		BIOS error code (00h = no error)
 15991                              <1> ;		SS:BP:	Ptr to IDEPACK
 15992                              <1> ;	Returns:
 15993                              <1> ;		SS:BP:	Ptr to IDEPACK with error condition set
 15994                              <1> ;	Corrupts registers:
 15995                              <1> ;		DS, DI
 15996                              <1> ;--------------------------------------------------------------------
 15997                              <1> ALIGN JUMP_ALIGN
 15998                              <1> %ifdef MODULE_SERIAL_FLOPPY
 15999                              <1> Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH_ALHasDriveNumber:
 16000                              <1> 	; Store error code to BDA
 16001                              <1> 	mov		bx, BDA.bHDLastSt
 16002                              <1> 	test	al, al
 16003                              <1> 	js		SHORT .HardDisk
 16004                              <1> 	mov		bl, BDA.bFDRetST & 0xff
 16005                              <1> .HardDisk:
 16006                              <1> 	LOAD_BDA_SEGMENT_TO	ds, di
 16007                              <1> 	mov		[bx], ah
 16008                              <1> 	; Fall to Int13h_SetErrorCodeToIntpackInSSBPfromAH
 16009                              <1> 
 16010                              <1> %else
 16011                              <1> Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH:
 16012                              <1> 	; Store error code to BDA
 16013                              <1> 	LOAD_BDA_SEGMENT_TO	ds, di
 16014                              <2> %ifndef USE_186
 16015 00000D3C 31FF                <2>  xor %2, %2
 16016 00000D3E 8EDF                <2>  mov %1, %2
 16017                              <2> %elifidn %3, !
 16018                              <2>  xor %2, %2
 16019                              <2>  mov %1, %2
 16020                              <2> %else
 16021                              <2>  push BYTE 0
 16022                              <2>  pop %1
 16023                              <2> %endif
 16024 00000D40 88267404            <1> 	mov		[BDA.bHDLastSt], ah
 16025                              <1> 	; Fall to Int13h_SetErrorCodeToIntpackInSSBPfromAH
 16026                              <1> %endif
 16027                              <1> 
 16028                              <1> 	; Store error code to INTPACK
 16029                              <1> Int13h_SetErrorCodeToIntpackInSSBPfromAH:
 16030 00000D44 88661C              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ah], ah
 16031 00000D47 84E4                <1> 	test	ah, ah
 16032 00000D49 7516                <1> 	jnz		SHORT .SetCFtoIntpack
 16033 00000D4B 806621FE            <1> 	and		BYTE [bp+IDEPACK.intpack+INTPACK.flags], ~FLG_FLAGS_CF
 16034 00000D4F C3                  <1> 	ret
 16035                              <1> .SetCFtoIntpack:
 16036 00000D50 804E2101            <1> 	or		BYTE [bp+IDEPACK.intpack+INTPACK.flags], FLG_FLAGS_CF
 16037 00000D54 C3                  <1> 	ret
 16038                              <1> 
 16039                              <1> 
 16040                              <1> ; Jump table for correct BIOS function
 16041                              <1> ALIGN WORD_ALIGN
 16042                              <1> g_rgw13hFuncJump:
 16043 00000D55 [B20D]              <1> 	dw	AH0h_HandlerForDiskControllerReset			; 00h, Disk Controller Reset (All)
 16044 00000D57 [010E]              <1> 	dw	AH1h_HandlerForReadDiskStatus				; 01h, Read Disk Status (All)
 16045 00000D59 [0F0E]              <1> 	dw	AH2h_HandlerForReadDiskSectors				; 02h, Read Disk Sectors (All)
 16046 00000D5B [230E]              <1> 	dw	AH3h_HandlerForWriteDiskSectors				; 03h, Write Disk Sectors (All)
 16047 00000D5D [370E]              <1> 	dw	AH4h_HandlerForVerifyDiskSectors			; 04h, Verify Disk Sectors (All)
 16048                              <1> %ifdef MODULE_SERIAL_FLOPPY
 16049                              <1> 	dw	Int13h_ReturnSuccessForFloppy				; 05h, Format Disk Track (XT, AT, EISA)
 16050                              <1> %else
 16051 00000D5F [BC0C]              <1> 	dw	UnsupportedFunction							; 05h, Format Disk Track (XT, AT, EISA)
 16052                              <1> %endif
 16053 00000D61 [BC0C]              <1> 	dw	UnsupportedFunction							; 06h, Format Disk Track with Bad Sectors (XT)
 16054 00000D63 [BC0C]              <1> 	dw	UnsupportedFunction							; 07h, Format Multiple Cylinders (XT)
 16055 00000D65 [450E]              <1> 	dw	AH8h_HandlerForReadDiskDriveParameters		; 08h, Read Disk Drive Parameters (All)
 16056 00000D67 [8F0E]              <1> 	dw	AH9h_HandlerForInitializeDriveParameters	; 09h, Initialize Drive Parameters (All)
 16057 00000D69 [BC0C]              <1> 	dw	UnsupportedFunction							; 0Ah, Read Disk Sectors with ECC (XT, AT, EISA)
 16058 00000D6B [BC0C]              <1> 	dw	UnsupportedFunction							; 0Bh, Write Disk Sectors with ECC (XT, AT, EISA)
 16059 00000D6D [440F]              <1> 	dw	AHCh_HandlerForSeek							; 0Ch, Seek (All)
 16060 00000D6F [8F0E]              <1> 	dw	AH9h_HandlerForInitializeDriveParameters	; 0Dh, Alternate Disk Reset (All)
 16061 00000D71 [BC0C]              <1> 	dw	UnsupportedFunction							; 0Eh, Read Sector Buffer (XT, PS/1), ESDI Undocumented Diagnostic (PS/2)
 16062 00000D73 [BC0C]              <1> 	dw	UnsupportedFunction							; 0Fh, Write Sector Buffer (XT, PS/1), ESDI Undocumented Diagnostic (PS/2)
 16063 00000D75 [520F]              <1> 	dw	AH10h_HandlerForCheckDriveReady				; 10h, Check Drive Ready (All)
 16064 00000D77 [580F]              <1> 	dw	AH11h_HandlerForRecalibrate					; 11h, Recalibrate (All)
 16065 00000D79 [BC0C]              <1> 	dw	UnsupportedFunction							; 12h, Controller RAM Diagnostic (XT)
 16066 00000D7B [BC0C]              <1> 	dw	UnsupportedFunction							; 13h, Drive Diagnostic (XT)
 16067 00000D7D [BC0C]              <1> 	dw	UnsupportedFunction							; 14h, Controller Internal Diagnostic (All)
 16068 00000D7F [650F]              <1> 	dw	AH15h_HandlerForReadDiskDriveSize			; 15h, Read Disk Drive Size (AT+)
 16069 00000D81 [BC0C]              <1> 	dw	UnsupportedFunction							; 16h,
 16070 00000D83 [BC0C]              <1> 	dw	UnsupportedFunction							; 17h,
 16071 00000D85 [BC0C]              <1> 	dw	UnsupportedFunction							; 18h,
 16072 00000D87 [BC0C]              <1> 	dw	UnsupportedFunction							; 19h, Park Heads (PS/2)
 16073 00000D89 [BC0C]              <1> 	dw	UnsupportedFunction							; 1Ah, Format ESDI Drive (PS/2)
 16074 00000D8B [BC0C]              <1> 	dw	UnsupportedFunction							; 1Bh, Get ESDI Manufacturing Header (PS/2)
 16075 00000D8D [BC0C]              <1> 	dw	UnsupportedFunction							; 1Ch, ESDI Special Functions (PS/2)
 16076 00000D8F [BC0C]              <1> 	dw	UnsupportedFunction							; 1Dh,
 16077                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 16078                              <1> 	dw	AH1Eh_HandlerForXTCFfeatures				; 1Eh, Lo-tech XT-CF features (XTIDE Universal BIOS)
 16079                              <1> %else
 16080 00000D91 [BC0C]              <1> 	dw	UnsupportedFunction							; 1Eh,
 16081                              <1> %endif
 16082 00000D93 [BC0C]              <1> 	dw	UnsupportedFunction							; 1Fh,
 16083 00000D95 [BC0C]              <1> 	dw	UnsupportedFunction							; 20h,
 16084 00000D97 [BC0C]              <1> 	dw	UnsupportedFunction							; 21h, Read Disk Sectors, Multiple Blocks (PS/1)
 16085 00000D99 [BC0C]              <1> 	dw	UnsupportedFunction							; 22h, Write Disk Sectors, Multiple Blocks (PS/1)
 16086 00000D9B [8B0F]              <1> 	dw	AH23h_HandlerForSetControllerFeatures		; 23h, Set Controller Features Register (PS/1)
 16087 00000D9D [A20F]              <1> 	dw	AH24h_HandlerForSetMultipleBlocks			; 24h, Set Multiple Blocks (PS/1)
 16088 00000D9F [C90F]              <1> 	dw	AH25h_HandlerForGetDriveInformation			; 25h, Get Drive Information (PS/1)
 16089                              <1> 
 16090                              <1> %ifdef MODULE_EBIOS
 16091                              <1> g_rgwEbiosFunctionJumpTable:
 16092                              <1> 	dw	AH41h_HandlerForCheckIfExtensionsPresent	; 41h, Check if Extensions Present (EBIOS)*
 16093                              <1> 	dw	AH42h_HandlerForExtendedReadSectors			; 42h, Extended Read Sectors (EBIOS)*
 16094                              <1> 	dw	AH43h_HandlerForExtendedWriteSectors		; 43h, Extended Write Sectors (EBIOS)*
 16095                              <1> 	dw	AH44h_HandlerForExtendedVerifySectors		; 44h, Extended Verify Sectors (EBIOS)*
 16096                              <1> 	dw	UnsupportedFunction							; 45h, Lock and Unlock Drive (EBIOS)***
 16097                              <1> 	dw	UnsupportedFunction							; 46h, Eject Media Request (EBIOS)***
 16098                              <1> 	dw	AH47h_HandlerForExtendedSeek				; 47h, Extended Seek (EBIOS)*
 16099                              <1> 	dw	AH48h_HandlerForGetExtendedDriveParameters	; 48h, Get Extended Drive Parameters (EBIOS)*
 16100                              <1> ;	dw	UnsupportedFunction							; 49h, Get Extended Disk Change Status (EBIOS)***
 16101                              <1> ;	dw	UnsupportedFunction							; 4Ah, Initiate Disk Emulation (Bootable CD-ROM)
 16102                              <1> ;	dw	UnsupportedFunction							; 4Bh, Terminate Disk Emulation (Bootable CD-ROM)
 16103                              <1> ;	dw	UnsupportedFunction							; 4Ch, Initiate Disk Emulation and Boot (Bootable CD-ROM)
 16104                              <1> ;	dw	UnsupportedFunction							; 4Dh, Return Boot Catalog (Bootable CD-ROM)
 16105                              <1> ;	dw	UnsupportedFunction							; 4Eh, Set Hardware Configuration (EBIOS)**
 16106                              <1> ;
 16107                              <1> ;   * = Enhanced Drive Access Support (minimum required EBIOS functions)
 16108                              <1> ;  ** = Enhanced Disk Drive (EDD) Support
 16109                              <1> ; *** = Drive Locking and Ejecting Support
 16110                              <1> %endif
 16111                                  	%include "AH0h_HReset.asm"		; Required by Int13h_Jump.asm
 16112                              <1> ; Project name	:	XTIDE Universal BIOS
 16113                              <1> ; Description	:	Int 13h function AH=0h, Disk Controller Reset.
 16114                              <1> 
 16115                              <1> ;
 16116                              <1> ; XTIDE Universal BIOS and Associated Tools
 16117                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16118                              <1> ;
 16119                              <1> ; This program is free software; you can redistribute it and/or modify
 16120                              <1> ; it under the terms of the GNU General Public License as published by
 16121                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16122                              <1> ; (at your option) any later version.
 16123                              <1> ;
 16124                              <1> ; This program is distributed in the hope that it will be useful,
 16125                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16126                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16127                              <1> ; GNU General Public License for more details.
 16128                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16129                              <1> ;
 16130                              <1> 
 16131                              <1> ; Section containing code
 16132                              <1> SECTION .text
 16133                              <1> 
 16134                              <1> ;--------------------------------------------------------------------
 16135                              <1> ; Int 13h function AH=0h, Disk Controller Reset.
 16136                              <1> ;
 16137                              <1> ; Note: We handle all AH=0h calls, even for drives handled by other
 16138                              <1> ; BIOSes!
 16139                              <1> ;
 16140                              <1> ; AH0h_HandlerForDiskControllerReset
 16141                              <1> ;	Parameters:
 16142                              <1> ;		DL:		Translated Drive number (ignored so all drives are reset)
 16143                              <1> ;				If bit 7 is set all hard disks and floppy disks reset.
 16144                              <1> ;		DS:DI:	Ptr to DPT (or Null if foreign drive)
 16145                              <1> ;		SS:BP:	Ptr to IDEPACK
 16146                              <1> ;	Returns with INTPACK:
 16147                              <1> ;		AH:		Int 13h return status (from drive requested in DL)
 16148                              <1> ;		CF:		0 if successful, 1 if error
 16149                              <1> ;--------------------------------------------------------------------
 16150                              <1> AH0h_HandlerForDiskControllerReset:
 16151                              <1> 	; Reset foreign Floppy and Hard Drives (those handled by other BIOSes)
 16152                              <1> 	eMOVZX	bx, dl										; Copy requested drive to BL and zero BH to assume no errors
 16153                              <2> %ifndef USE_386
 16154                              <2>  %ifidni %1, ax
 16155                              <2>  mov al, %2
 16156                              <2>  xor ah, ah
 16157                              <2>  %elifidni %1, bx
 16158 00000DA1 88D3                <2>  mov bl, %2
 16159 00000DA3 30FF                <2>  xor bh, bh
 16160                              <2>  %elifidni %1, cx
 16161                              <2>  mov cl, %2
 16162                              <2>  xor ch, ch
 16163                              <2>  %elifidni %1, dx
 16164                              <2>  mov dl, %2
 16165                              <2>  xor dh, dh
 16166                              <2>  %else
 16167                              <2>  push ax
 16168                              <2>  mov al, %2
 16169                              <2>  xor ah, ah
 16170                              <2>  xchg ax, %1
 16171                              <2>  pop ax
 16172                              <2>  %endif
 16173                              <2> 
 16174                              <2> %else
 16175                              <2>  movzx %1, %2
 16176                              <2> %endif
 16177                              <1> 
 16178 00000DA5 30E4                <1> 	xor		ah, ah										; Disk Controller Reset
 16179 00000DA7 E867FF              <1> 	call	Int13h_CallPreviousInt13hHandler			; Reset floppy drives only or floppy drives and foreign hard disks
 16180 00000DAA E81D00              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH
 16181                              <1> 
 16182                              <1> %ifdef MODULE_SERIAL_FLOPPY
 16183                              <1> ;
 16184                              <1> ; "Reset" emulated serial floppy drives, if any.  There is nothing to actually do for this reset,
 16185                              <1> ; but record the proper error return code if one of these floppy drives is the drive requested.
 16186                              <1> ;
 16187                              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
 16188                              <1> 	cbw													; Clears AH (there are flop drives) or ffh (there are not)
 16189                              <1> 														; Either AH has success code (flop drives are present)
 16190                              <1> 														; or it doesn't matter because we won't match drive ffh
 16191                              <1> 
 16192                              <1> 	cwd													; clears DX (there are flop drives) or ffffh (there are not)
 16193                              <1> 
 16194                              <1> 	adc		dl, al										; second drive (CF set) if present
 16195                              <1> 														; If no drive is present, this will result in ffh which
 16196                              <1> 														; won't match a drive
 16197                              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH
 16198                              <1> 	mov		dl, al										; We may end up doing the first drive twice (if there is
 16199                              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH	; only one drive), but doing it again is not harmful.
 16200                              <1> %endif
 16201 00000DAD 84DB                <1> 	test	bl, bl										; If we were called with a floppy disk, then we are done,
 16202 00000DAF 7914                <1> 	jns		SHORT .SkipHardDiskReset					; don't do hard disks.
 16203                              <1> 
 16204                              <1> 	; Resetting our hard disks will modify dl and bl to be idevars offset based instead of drive number based,
 16205                              <1> 	; such that this call must be the last in the list of reset routines called.
 16206                              <1> 	;
 16207                              <1> 	; This needs to happen after ResetForeignDrives, as that call may have set the error code for 80h,
 16208                              <1> 	; and we need to override that value if we are xlate'd into 80h with one of our drives.
 16209                              <1> 	;
 16210 00000DB1 E81D00              <1> 	call	ResetHardDisksHandledByOurBIOS
 16211                              <1> 
 16212                              <1> .SkipHardDiskReset:
 16213 00000DB4 88FC                <1> 	mov		ah, bh
 16214 00000DB6 E941FF              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 16215                              <1> 
 16216                              <1> 
 16217                              <1> ;--------------------------------------------------------------------
 16218                              <1> ; BackupErrorCodeFromTheRequestedDriveToBH
 16219                              <1> ;	Parameters:
 16220                              <1> ;		AH:		Error code from the last resetted drive
 16221                              <1> ;		DL:		Drive last resetted
 16222                              <1> ;		BL:		Requested drive (DL when entering AH=00h)
 16223                              <1> ;	Returns:
 16224                              <1> ;		BH:		Backuped error code
 16225                              <1> ;	Corrupts registers:
 16226                              <1> ;		Nothing
 16227                              <1> ;--------------------------------------------------------------------
 16228                              <1> BackupErrorCodeFromTheRequestedDriveToBH:
 16229 00000DB9 38DA                <1> 	cmp		dl, bl				; Requested drive?
 16230                              <1> 	eCMOVE	bh, ah
 16231                              <2>  eCMOVZ %1, %2
 16232 00000DBB 7513                <3>  jnz SHORT %%Return
 16233 00000DBD 88E7                <3>  mov %1, %2
 16234                              <3> %%Return:
 16235 00000DBF C3                  <1> 	ret
 16236                              <1> 
 16237                              <1> 
 16238                              <1> 
 16239                              <1> ; This defines what is called when resetting our drives at the end of drive detection.
 16240                              <1> AH0h_ResetAllOurHardDisksAtTheEndOfDriveInitialization equ ResetHardDisksHandledByOurBIOS.ErrorCodeNotUsed
 16241                              <1> 
 16242                              <1> ;--------------------------------------------------------------------
 16243                              <1> ; ResetHardDisksHandledByOurBIOS
 16244                              <1> ;	Parameters:
 16245                              <1> ;		BL:		Requested drive (DL when entering AH=00h)
 16246                              <1> ;		DS:DI:	Ptr to DPT for requested drive
 16247                              <1> ;				If DPT pointer is not available, or error result in BH won't be used anyway,
 16248                              <1> ;				enter through .ErrorCodeNotUsed.
 16249                              <1> ;		SS:BP:	Ptr to IDEPACK
 16250                              <1> ;	Returns:
 16251                              <1> ;		BH:		Error code from requested drive (if available)
 16252                              <1> ;	Corrupts registers:
 16253                              <1> ;		AX, BX, CX, DX, SI, DI
 16254                              <1> ;--------------------------------------------------------------------
 16255                              <1> ResetHardDisksHandledByOurBIOS:
 16256 00000DC0 30DB                <1> 	xor		bl, bl										; Assume Null IdevarsOffset for now, assuming foreign drive
 16257 00000DC2 85FF                <1> 	test	di, di
 16258 00000DC4 7414                <1> 	jz		SHORT .ErrorCodeNotUsed
 16259 00000DC6 8A5D02              <1> 	mov		bl, [di+DPT.bIdevarsOffset]					; replace drive number with Idevars pointer for cmp with dl
 16260                              <1> .ErrorCodeNotUsed:										; BH will be garbage on exit if this entry point is used,
 16261                              <1> 														; but reset of all drives will still happen
 16262 00000DC9 B251                <1> 	mov		dl, ROMVARS.ideVars0						; starting Idevars offset
 16263                              <1> 
 16264                              <1>     ; Get count of ALL Idevars structures, not just the ones that are configured.  This may seem odd,
 16265                              <1>     ; but it catches the .ideVarsSerialAuto structure, which would not be scanned if the count from
 16266                              <1> 	; RamVars_GetIdeControllerCountToCX was used.  Unused controllers won't make a difference, since no DPT
 16267                              <1> 	; will point to them.  Performance isn't an issue, as this is a reset operation.
 16268                              <1>     ;
 16269 00000DCB B90400              <1> 	mov		cx, NUMBER_OF_IDEVARS
 16270                              <1> 
 16271                              <1> .loop:
 16272 00000DCE E841F7              <1> 	call	FindDPT_MasterOrSingleForIdevarsOffsetInDL
 16273 00000DD1 7228                <1> 	jc		SHORT .ControllerNotAvailable
 16274                              <1> 
 16275                              <1> 	; Reset controller (both Master and Slave Drive). We ignore error codes
 16276                              <1> 	; here since initialization is the one that matters.
 16277 00000DD3 51                  <1> 	push	cx
 16278 00000DD4 52                  <1> 	push	dx
 16279 00000DD5 53                  <1> 	push	bx
 16280                              <1> %ifdef MODULE_IRQ
 16281                              <1> 	call	Interrupts_UnmaskInterruptControllerForDriveInDSDI
 16282                              <1> %endif
 16283 00000DD6 E8B0FA              <1> 	call	Device_ResetMasterAndSlaveController
 16284                              <1> %ifdef MODULE_ADVANCED_ATA
 16285                              <1> 	call	AdvAtaInit_InitializeControllerForDPTinDSDI
 16286                              <1> %endif
 16287 00000DD9 5B                  <1> 	pop		bx
 16288 00000DDA 5A                  <1> 	pop		dx
 16289                              <1> 
 16290                              <1> 	; Initialize Master Drive
 16291 00000DDB E8B700              <1> 	call	AH9h_InitializeDriveForUse					; Initialize Master drive
 16292 00000DDE E8D8FF              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH
 16293                              <1> 
 16294                              <1> 	; Initialize Slave Drive
 16295 00000DE1 E833F7              <1> 	call	FindDPT_SlaveForIdevarsOffsetInDL
 16296 00000DE4 7214                <1> 	jc		SHORT .SlaveDriveNotAvailable
 16297 00000DE6 E8AC00              <1> 	call	AH9h_InitializeDriveForUse
 16298                              <1> 	; Here we have a small problem. Since DL now has offset to IDEVARS, it will be the same
 16299                              <1> 	; for both Master and Slave Drive. We simply ignore error from slave drive reset since most
 16300                              <1> 	; systems do not have slave drives at all and it is unlikely that AH=00h would be called for
 16301                              <1> 	; specific drive anyway. AH=Dh is for that.
 16302                              <1> 
 16303                              <1> .SlaveDriveNotAvailable:
 16304 00000DE9 59                  <1> 	pop		cx
 16305                              <1> .ControllerNotAvailable:
 16306 00000DEA 80C212              <1> 	add		dl, IDEVARS_size							; move Idevars pointer forward
 16307 00000DED E2DF                <1> 	loop	.loop
 16308 00000DEF C3                  <1> 	ret
 16309                                  	%include "AH1h_HStatus.asm"		; Required by Int13h_Jump.asm
 16310                              <1> ; Project name	:	XTIDE Universal BIOS
 16311                              <1> ; Description	:	Int 13h function AH=1h, Read Disk Status.
 16312                              <1> 
 16313                              <1> ;
 16314                              <1> ; XTIDE Universal BIOS and Associated Tools
 16315                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16316                              <1> ;
 16317                              <1> ; This program is free software; you can redistribute it and/or modify
 16318                              <1> ; it under the terms of the GNU General Public License as published by
 16319                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16320                              <1> ; (at your option) any later version.
 16321                              <1> ;
 16322                              <1> ; This program is distributed in the hope that it will be useful,
 16323                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16324                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16325                              <1> ; GNU General Public License for more details.
 16326                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16327                              <1> ;
 16328                              <1> 
 16329                              <1> ; Section containing code
 16330                              <1> SECTION .text
 16331                              <1> 
 16332                              <1> ;--------------------------------------------------------------------
 16333                              <1> ; Int 13h function AH=1h, Read Disk Status.
 16334                              <1> ;
 16335                              <1> ; AH1h_HandlerForReadDiskStatus
 16336                              <1> ;	Parameters:
 16337                              <1> ;		DL:		Translated Drive number
 16338                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16339                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 16340                              <1> ;	Returns with INTPACK:
 16341                              <1> ;		AH:		Int 13h floppy return status
 16342                              <1> ;		CF:		0 if AH = RET_HD_SUCCESS, 1 otherwise (error)
 16343                              <1> ;--------------------------------------------------------------------
 16344                              <1> ALIGN JUMP_ALIGN
 16345                              <1> AH1h_HandlerForReadDiskStatus:
 16346                              <1> 	LOAD_BDA_SEGMENT_TO	ds, ax, !
 16347                              <2> %ifndef USE_186
 16348 00000DF0 31C0                <2>  xor %2, %2
 16349 00000DF2 8ED8                <2>  mov %1, %2
 16350                              <2> %elifidn %3, !
 16351                              <2>  xor %2, %2
 16352                              <2>  mov %1, %2
 16353                              <2> %else
 16354                              <2>  push BYTE 0
 16355                              <2>  pop %1
 16356                              <2> %endif
 16357                              <1> 
 16358                              <1> %ifdef MODULE_SERIAL_FLOPPY
 16359                              <1> 	test	dl, dl
 16360                              <1> 	js		.HardDisk
 16361                              <1> 	mov		ah, [BDA.bFDRetST]	; Unlike for hard disks below, floppy version does not clear the status
 16362                              <1> 	jmp		.done
 16363                              <1> .HardDisk:
 16364                              <1> %endif
 16365                              <1> 
 16366 00000DF4 86267404            <1> 	xchg	ah, [BDA.bHDLastSt]	; Load and clear last error (AH is cleared with the LOAD_BDA_SEGMENT_TO above)
 16367                              <1> 
 16368                              <1> .done:
 16369                              <1> %ifndef USE_186
 16370 00000DF8 E849FF              <1> 	call	Int13h_SetErrorCodeToIntpackInSSBPfromAH
 16371 00000DFB E9FFFE              <1> 	jmp		Int13h_ReturnFromHandlerWithoutStoringErrorCode
 16372                              <1> %else
 16373                              <1> 	push	Int13h_ReturnFromHandlerWithoutStoringErrorCode
 16374                              <1> 	jmp		Int13h_SetErrorCodeToIntpackInSSBPfromAH
 16375                              <1> %endif
 16376                                  	%include "AH2h_HRead.asm"		; Required by Int13h_Jump.asm
 16377                              <1> ; Project name	:	XTIDE Universal BIOS
 16378                              <1> ; Description	:	Int 13h function AH=2h, Read Disk Sectors.
 16379                              <1> 
 16380                              <1> ;
 16381                              <1> ; XTIDE Universal BIOS and Associated Tools
 16382                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16383                              <1> ;
 16384                              <1> ; This program is free software; you can redistribute it and/or modify
 16385                              <1> ; it under the terms of the GNU General Public License as published by
 16386                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16387                              <1> ; (at your option) any later version.
 16388                              <1> ;
 16389                              <1> ; This program is distributed in the hope that it will be useful,
 16390                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16391                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16392                              <1> ; GNU General Public License for more details.
 16393                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16394                              <1> ;
 16395                              <1> 
 16396                              <1> ; Section containing code
 16397                              <1> SECTION .text
 16398                              <1> 
 16399                              <1> ;--------------------------------------------------------------------
 16400                              <1> ; Int 13h function AH=2h, Read Disk Sectors.
 16401                              <1> ;
 16402                              <1> ; AH2h_HandlerForReadDiskSectors
 16403                              <1> ;	Parameters:
 16404                              <1> ;		AL, CX, DH, ES:	Same as in INTPACK
 16405                              <1> ;		DL:		Translated Drive number
 16406                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16407                              <1> ;		SS:BP:	Ptr to IDEPACK
 16408                              <1> ;	Parameters on INTPACK:
 16409                              <1> ;		AL:		Number of sectors to read (1...128)
 16410                              <1> ;		CH:		Cylinder number, bits 7...0
 16411                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 16412                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 16413                              <1> ;		DH:		Starting head number (0...255)
 16414                              <1> ;		ES:BX:	Pointer to buffer receiving data
 16415                              <1> ;	Returns with INTPACK:
 16416                              <1> ;		AH:		Int 13h/40h floppy return status
 16417                              <1> ;		AL:		Burst error length if AH returns 11h (we never return error code 11h)
 16418                              <1> ;				Number of sectors actually read (only valid if CF set for someBIOSes)
 16419                              <1> ;		CF:		0 if successful, 1 if error
 16420                              <1> ;--------------------------------------------------------------------
 16421                              <1> ALIGN JUMP_ALIGN
 16422                              <1> AH2h_HandlerForReadDiskSectors:
 16423 00000DFE E83D02              <1> 	call	Prepare_BufferToESSIforOldInt13hTransfer
 16424 00000E01 E83302              <1> 	call	Prepare_GetOldInt13hCommandIndexToBX
 16425 00000E04 2E8AA7[5C10]        <1> 	mov		ah, [cs:bx+g_rgbReadCommandLookup]
 16426 00000E09 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 16427                              <1> %ifdef USE_186
 16428                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 16429                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 16430                              <1> %else
 16431 00000E0C E8FFF9              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 16432 00000E0F E9E5FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 16433                              <1> %endif
 16434                              <1> 
 16435                                  	%include "AH3h_HWrite.asm"		; Required by Int13h_Jump.asm
 16436                              <1> ; Project name	:	XTIDE Universal BIOS
 16437                              <1> ; Description	:	Int 13h function AH=3h, Write Disk Sectors.
 16438                              <1> 
 16439                              <1> ;
 16440                              <1> ; XTIDE Universal BIOS and Associated Tools
 16441                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16442                              <1> ;
 16443                              <1> ; This program is free software; you can redistribute it and/or modify
 16444                              <1> ; it under the terms of the GNU General Public License as published by
 16445                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16446                              <1> ; (at your option) any later version.
 16447                              <1> ;
 16448                              <1> ; This program is distributed in the hope that it will be useful,
 16449                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16450                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16451                              <1> ; GNU General Public License for more details.
 16452                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16453                              <1> ;
 16454                              <1> 
 16455                              <1> ; Section containing code
 16456                              <1> SECTION .text
 16457                              <1> 
 16458                              <1> ;--------------------------------------------------------------------
 16459                              <1> ; Int 13h function AH=3h, Write Disk Sectors.
 16460                              <1> ;
 16461                              <1> ; AH3h_HandlerForWriteDiskSectors
 16462                              <1> ;	Parameters:
 16463                              <1> ;		AL, CX, DH, ES:	Same as in INTPACK
 16464                              <1> ;		DL:		Translated Drive number
 16465                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16466                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 16467                              <1> ;	Parameters on INTPACK:
 16468                              <1> ;		AL:		Number of sectors to write (1...128)
 16469                              <1> ;		CH:		Cylinder number, bits 7...0
 16470                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 16471                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 16472                              <1> ;		DH:		Starting head number (0...255)
 16473                              <1> ;		ES:BX:	Pointer to source data
 16474                              <1> ;	Returns with INTPACK:
 16475                              <1> ;		AH:		Int 13h/40h floppy return status
 16476                              <1> ;		AL:		Number of sectors actually written (only valid if CF set for someBIOSes)
 16477                              <1> ;		CF:		0 if successful, 1 if error
 16478                              <1> ;--------------------------------------------------------------------
 16479                              <1> ALIGN JUMP_ALIGN
 16480                              <1> AH3h_HandlerForWriteDiskSectors:
 16481 00000E12 E82902              <1> 	call	Prepare_BufferToESSIforOldInt13hTransfer
 16482 00000E15 E81F02              <1> 	call	Prepare_GetOldInt13hCommandIndexToBX
 16483 00000E18 2E8AA7[5F10]        <1> 	mov		ah, [cs:bx+g_rgbWriteCommandLookup]
 16484 00000E1D BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 16485                              <1> %ifdef USE_186
 16486                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 16487                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 16488                              <1> %else
 16489 00000E20 E8EBF9              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 16490 00000E23 E9D1FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 16491                              <1> %endif
 16492                                  	%include "AH4h_HVerify.asm"		; Required by Int13h_Jump.asm
 16493                              <1> ; Project name	:	XTIDE Universal BIOS
 16494                              <1> ; Description	:	Int 13h function AH=4h, Verify Disk Sectors.
 16495                              <1> 
 16496                              <1> ;
 16497                              <1> ; XTIDE Universal BIOS and Associated Tools
 16498                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16499                              <1> ;
 16500                              <1> ; This program is free software; you can redistribute it and/or modify
 16501                              <1> ; it under the terms of the GNU General Public License as published by
 16502                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16503                              <1> ; (at your option) any later version.
 16504                              <1> ;
 16505                              <1> ; This program is distributed in the hope that it will be useful,
 16506                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16507                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16508                              <1> ; GNU General Public License for more details.
 16509                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16510                              <1> ;
 16511                              <1> 
 16512                              <1> ; Section containing code
 16513                              <1> SECTION .text
 16514                              <1> 
 16515                              <1> ;--------------------------------------------------------------------
 16516                              <1> ; Int 13h function AH=4h, Verify Disk Sectors.
 16517                              <1> ;
 16518                              <1> ; AH4h_HandlerForVerifyDiskSectors
 16519                              <1> ;	Parameters:
 16520                              <1> ;		AL, CX, DH:	Same as in INTPACK
 16521                              <1> ;		DL:		Translated Drive number
 16522                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16523                              <1> ;		SS:BP:	Ptr to INTPACK
 16524                              <1> ;	Parameters on INTPACK in SS:BP:
 16525                              <1> ;		AL:		Number of sectors to verify (1...128)
 16526                              <1> ;		CH:		Cylinder number, bits 7...0
 16527                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 16528                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 16529                              <1> ;		DH:		Starting head number (0...255)
 16530                              <1> ;	Returns with INTPACK in SS:BP:
 16531                              <1> ;		AH:		Int 13h/40h floppy return status
 16532                              <1> ;		AL:		Number of sectors actually verified (only valid if CF set for someBIOSes)
 16533                              <1> ;		CF:		0 if successful, 1 if error
 16534                              <1> ;--------------------------------------------------------------------
 16535                              <1> ALIGN JUMP_ALIGN
 16536                              <1> AH4h_HandlerForVerifyDiskSectors:
 16537 00000E26 B440                <1> 	mov		ah, COMMAND_VERIFY_SECTORS
 16538 00000E28 E81902              <1> 	call	Prepare_ByValidatingSectorsInALforOldInt13h	; Preserves AX
 16539 00000E2B BB40FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRDY)
 16540                              <1> %ifdef USE_186
 16541                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 16542                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 16543                              <1> %else
 16544 00000E2E E8DDF9              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 16545 00000E31 E9C3FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 16546                              <1> %endif
 16547                                  	%include "AH8h_HParams.asm"		; Required by Int13h_Jump.asm
 16548                              <1> ; Project name	:	XTIDE Universal BIOS
 16549                              <1> ; Description	:	Int 13h function AH=8h, Read Disk Drive Parameters.
 16550                              <1> 
 16551                              <1> ;
 16552                              <1> ; XTIDE Universal BIOS and Associated Tools
 16553                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16554                              <1> ;
 16555                              <1> ; This program is free software; you can redistribute it and/or modify
 16556                              <1> ; it under the terms of the GNU General Public License as published by
 16557                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16558                              <1> ; (at your option) any later version.
 16559                              <1> ;
 16560                              <1> ; This program is distributed in the hope that it will be useful,
 16561                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16562                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16563                              <1> ; GNU General Public License for more details.
 16564                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16565                              <1> ;
 16566                              <1> 
 16567                              <1> ; Section containing code
 16568                              <1> SECTION .text
 16569                              <1> 
 16570                              <1> ;--------------------------------------------------------------------
 16571                              <1> ; Int 13h function AH=8h, Read Disk Drive Parameters.
 16572                              <1> ;
 16573                              <1> ; AH8h_HandlerForReadDiskDriveParameters
 16574                              <1> ;	Parameters:
 16575                              <1> ;		DL:		Translated Drive number
 16576                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16577                              <1> ;		SS:BP:	Ptr to IDEPACK
 16578                              <1> ;	Returns with INTPACK:
 16579                              <1> ;       BL:     Drive Type (for floppies only)
 16580                              <1> ;		CH:		Maximum cylinder number, bits 7...0
 16581                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9...8
 16582                              <1> ;				Bits 5...0:	Maximum sector number (1...63)
 16583                              <1> ;		DH:		Maximum head number (0...254)
 16584                              <1> ;		DL:		Number of drives!!!
 16585                              <1> ;       ES:DI:  Floppy DPT (for floppies only)
 16586                              <1> ;		AH:		Int 13h/40h floppy return status
 16587                              <1> ;		CF:		0 if successful, 1 if error
 16588                              <1> ;--------------------------------------------------------------------
 16589                              <1> AH8h_HandlerForReadDiskDriveParameters:
 16590 00000E34 85FF                <1> 	test	di, di
 16591 00000E36 7436                <1> 	jz		SHORT .NotOurDrive
 16592                              <1> 
 16593 00000E38 E83B00              <1> 	call	AH8h_GetDriveParameters
 16594                              <1> 
 16595                              <1> %ifdef MODULE_SERIAL_FLOPPY
 16596                              <1> 	push	cs							; setup registers if we are a floppy drive, in all cases
 16597                              <1> 	pop		es							; if it is not a floppy drive, these values will not be put in INTPACK
 16598                              <1> 	mov		di, AH8h_FloppyDPT
 16599                              <1> %endif
 16600                              <1> 	;; fall-through
 16601                              <1> 
 16602                              <1> .MidGame:
 16603 00000E3B E800F6              <1> 	call	RamVars_GetCountOfKnownDrivesToAX		; assume hard disk for now, will discard if for floppies
 16604                              <1> 
 16605 00000E3E F6461780            <1> 	test	byte [bp+IDEPACK.intpack+INTPACK.dl], 080h
 16606 00000E42 751D                <1> 	jnz		.Done
 16607                              <1> 
 16608 00000E44 885E15              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.bl], bl
 16609                              <1> 
 16610 00000E47 8C4609              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.es], es
 16611 00000E4A 897E0D              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.di], di
 16612                              <1> 
 16613 00000E4D E80DF6              <1> 	call	FloppyDrive_GetCountToAX
 16614                              <1> 
 16615                              <1> .Done:
 16616 00000E50 88F4                <1> 	mov		ah, dh
 16617                              <1> 
 16618 00000E52 894E19              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.cx], cx
 16619 00000E55 874617              <1> 	xchg	[bp+IDEPACK.intpack+INTPACK.dx], ax		; recover DL for BDA last status byte determination
 16620                              <1> 
 16621 00000E58 30E4                <1> 	xor		ah, ah
 16622                              <1> %ifdef MODULE_SERIAL_FLOPPY
 16623                              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH_ALHasDriveNumber
 16624                              <1> %else
 16625 00000E5A E99DFE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 16626                              <1> %endif
 16627                              <1> 
 16628                              <1> .NotOurDrive:
 16629 00000E5D E8B1FE              <1> 	call	Int13h_CallPreviousInt13hHandler
 16630 00000E60 73D9                <1> 	jnc		SHORT .MidGame
 16631 00000E62 E995FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 16632                              <1> 
 16633                              <1> 
 16634                              <1> ;--------------------------------------------------------------------
 16635                              <1> ; Returns L-CHS parameters for drive and total hard disk count.
 16636                              <1> ;
 16637                              <1> ; AH8h_GetDriveParameters
 16638                              <1> ;	Parameters:
 16639                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16640                              <1> ;	Returns:
 16641                              <1> ;		CH:		Maximum cylinder number, bits 7...0
 16642                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9...8
 16643                              <1> ;				Bits 5...0:	Maximum sector number (1...63)
 16644                              <1> ;		DH:		Maximum head number (0...254)
 16645                              <1> ;	Corrupts registers:
 16646                              <1> ;		AX, BX
 16647                              <1> ;--------------------------------------------------------------------
 16648                              <1> AH8h_GetDriveParameters:
 16649 00000E65 E801F7              <1> 	call	AccessDPT_GetLCHStoAXBLBH
 16650                              <1> %ifdef RESERVE_DIAGNOSTIC_CYLINDER
 16651                              <1> 	dec		ax
 16652                              <1> %endif
 16653                              <1> 	MIN_U	ax, MAX_LCHS_CYLINDERS
 16654 00000E68 3D0004              <2>  cmp %1, %2
 16655 00000E6B 7214                <2>  jb %%Return
 16656 00000E6D B80004              <2>  mov %1, %2
 16657                              <2> ALIGN JUMP_ALIGN
 16658                              <2> %%Return:
 16659                              <1> 	; Fall to .PackReturnValues
 16660                              <1> 
 16661                              <1> ;--------------------------------------------------------------------
 16662                              <1> ; Packs L-CHS values to INT 13h, AH=08h return values.
 16663                              <1> ;
 16664                              <1> ; .PackReturnValues
 16665                              <1> ;	Parameters:
 16666                              <1> ;		AX:		Number of L-CHS cylinders available (1...1024)
 16667                              <1> ;		BL:		Number of L-CHS heads (1...255)
 16668                              <1> ;		BH:		Number of L-CHS sectors per track (1...63)
 16669                              <1> ;		DS:		RAMVARS segment
 16670                              <1> ;	Returns:
 16671                              <1> ;		CH:		Maximum cylinder number, bits 7...0
 16672                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9...8
 16673                              <1> ;				Bits 5...0:	Maximum sector number (1...63)
 16674                              <1> ;		DH:		Maximum head number (0...254)
 16675                              <1> ;	Corrupts registers:
 16676                              <1> ;		AX, BX
 16677                              <1> ;--------------------------------------------------------------------
 16678                              <1> .PackReturnValues:
 16679 00000E70 48                  <1> 	dec		ax						; AX = Number of last cylinder
 16680 00000E71 4B                  <1> 	dec		bx						; BL = Number of last head
 16681 00000E72 91                  <1> 	xchg	cx, ax
 16682 00000E73 86CD                <1> 	xchg	cl, ch					; CH = Last cylinder bits 0...7
 16683                              <1> 	eROR_IM	cl, 2					; CL bits 6...7 = Last cylinder bits 8...9
 16684                              <2>  eSHIFT_IM %1, %2, ror
 16685                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 16686                              <3> %ifndef USE_186
 16687                              <3>  %ifidni %1, cl
 16688 00000E75 D0C9<rept>          <3>  times %2 %3 %1, 1
 16689                              <3>  %elifidni %1, ch
 16690                              <3>  times %2 %3 %1, 1
 16691                              <3>  %elifidni %1, cx
 16692                              <3>  times %2 %3 %1, 1
 16693                              <3>  %else
 16694                              <3>  %if %2 > 3
 16695                              <3>  push cx
 16696                              <3>  mov cl, %2
 16697                              <3>  %3 %1, cl
 16698                              <3>  pop cx
 16699                              <3>  %else
 16700                              <3>  times %2 %3 %1, 1
 16701                              <3>  %endif
 16702                              <3>  %endif
 16703                              <3> 
 16704                              <3> %else
 16705                              <3>  %3 %1, %2
 16706                              <3> %endif
 16707                              <3> %endif
 16708 00000E79 08F9                <1> 	or		cl, bh					; CL bits 0...5 = Sectors per track
 16709 00000E7B 88DE                <1> 	mov		dh, bl					; DH = Maximum head number
 16710                              <1> 
 16711                              <1> %ifdef MODULE_SERIAL_FLOPPY
 16712                              <1> 	mov		bl, [di+DPT.bFlagsHigh]
 16713                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS             ; not sure why this is needed for preprocessor-only
 16714                              <1> 	eSHR_IM	bl, FLGH_DPT_SERIAL_FLOPPY_TYPE_FIELD_POSITION
 16715                              <1> %endif
 16716                              <1> %endif
 16717 00000E7D C3                  <1> 	ret
 16718                              <1> 
 16719                              <1> %ifdef MODULE_SERIAL_FLOPPY
 16720                              <1> ;
 16721                              <1> ; Floppy Disk Parameter Table.  There is no way to specify more than one of these
 16722                              <1> ; for any given system, so no way to make this drive or media specific.
 16723                              <1> ; So we return fixed values out of the ROM for callers who might be expecting this information.
 16724                              <1> ;
 16725                              <1> ; On AT systems, we return the information for a 1.44 MB disk,
 16726                              <1> ; and on XT systems, we return the information for a 360 KB disk.
 16727                              <1> ;
 16728                              <1> AH8h_FloppyDPT:
 16729                              <1> %ifdef USE_AT
 16730                              <1> 	db		0ah << 4 | 0fh			; Offset 0: Drive timings, 1.44MB values
 16731                              <1> %else
 16732                              <1> 	db		0dh << 4 | 0fh			; Offset 0: Drive timings, 360KB values
 16733                              <1> %endif
 16734                              <1> 
 16735                              <1> 	db		1h << 1 | 0				; Offset 1: Typical values of 1 for head load time
 16736                              <1> 									;           DMA used (although it actually is not, but is more restrictive)
 16737                              <1> 	db		25h						; Offset 2: Inactivity motor turn-off delay,
 16738                              <1> 									; 			Typical value of 25h for 2 second delay
 16739                              <1> 	db		02h						; Offset 3: Sector size, always 512
 16740                              <1> 
 16741                              <1> %ifdef USE_AT
 16742                              <1> 	db		12h						; Offset 4: Sectors per track, 1.44MB value
 16743                              <1> 	db		1bh						; Offset 5: Sector gap, 1.44MB value
 16744                              <1> %else
 16745                              <1> 	db		09h						; Offset 4: Sectors per track, 360KB value
 16746                              <1> 	db		2ah						; Offset 5: Sector gap, 360KB value
 16747                              <1> %endif
 16748                              <1> 
 16749                              <1> 	db		0ffh					; Offset 6: Data length
 16750                              <1> 
 16751                              <1> %ifdef USE_AT
 16752                              <1> 	db		6ch						; Offset 7: Format gap length, 1.44MB value
 16753                              <1> %else
 16754                              <1> 	db		50h						; Offset 7: Format gap length, 360KB value
 16755                              <1> %endif
 16756                              <1> 
 16757                              <1> 	db		0f6h					; Offset 8: Fill byte for format
 16758                              <1> 	db		0fh						; Offset 9: Head setting time
 16759                              <1> 	db		08h						; Offset A: Wait for motor startup time
 16760                              <1> 
 16761                              <1> %ifdef USE_AT
 16762                              <1> 	db		79						; Offset B: Maximum track number, 1.44MB value
 16763                              <1> 	db		0						; Offset C: Data transfer rate, 1.44MB value
 16764                              <1> 	db		4						; Offset D: Diskette CMOS drive type, 1.44MB value
 16765                              <1> %else
 16766                              <1> 	db		39						; Offset B: Maximum track number, 360KB value
 16767                              <1> 	db		80h						; Offset C: Data transfer rate, 360KB value
 16768                              <1> 	db		1						; Offset D: Diskette CMOS drive type, 360KB value
 16769                              <1> %endif
 16770                              <1> %endif
 16771                                  	%include "AH9h_HInit.asm"		; Required by Int13h_Jump.asm
 16772                              <1> ; Project name	:	XTIDE Universal BIOS
 16773                              <1> ; Description	:	Int 13h function AH=9h, Initialize Drive Parameters.
 16774                              <1> 
 16775                              <1> ;
 16776                              <1> ; XTIDE Universal BIOS and Associated Tools
 16777                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16778                              <1> ;
 16779                              <1> ; This program is free software; you can redistribute it and/or modify
 16780                              <1> ; it under the terms of the GNU General Public License as published by
 16781                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16782                              <1> ; (at your option) any later version.
 16783                              <1> ;
 16784                              <1> ; This program is distributed in the hope that it will be useful,
 16785                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16786                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16787                              <1> ; GNU General Public License for more details.
 16788                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16789                              <1> ;
 16790                              <1> 
 16791                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 16792                              <1> 
 16793                              <1> ; Section containing code
 16794                              <1> SECTION .text
 16795                              <1> 
 16796                              <1> ;--------------------------------------------------------------------
 16797                              <1> ; STORE_ERROR_FLAG_TO_DPT
 16798                              <1> ;	Parameters:
 16799                              <1> ;		%1:		Error flag to set
 16800                              <1> ;		AH:		BIOS Error Code
 16801                              <1> ;		DS:DI:	Ptr to DPT
 16802                              <1> ;		CF:		Set if error code in AH
 16803                              <1> ;	Returns:
 16804                              <1> ;		CF:		Clear if no error
 16805                              <1> ;				Set if error flag was set
 16806                              <1> ;	Corrupts registers:
 16807                              <1> ;		Nothing
 16808                              <1> ;--------------------------------------------------------------------
 16809                              <1> %macro STORE_ERROR_FLAG_TO_DPT 1
 16810                              <1> 	mov		al, %1
 16811                              <1> 	call	SetErrorFlagFromALwithErrorCodeInAH
 16812                              <1> %endmacro
 16813                              <1> 
 16814                              <1> 
 16815                              <1> ;--------------------------------------------------------------------
 16816                              <1> ; Int 13h function AH=9h, Initialize Drive Parameters.
 16817                              <1> ;
 16818                              <1> ; AH9h_HandlerForInitializeDriveParameters
 16819                              <1> ;	Parameters:
 16820                              <1> ;		DL:		Translated Drive number
 16821                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16822                              <1> ;		SS:BP:	Ptr to IDEPACK
 16823                              <1> ;	Returns with INTPACK:
 16824                              <1> ;		AH:		Int 13h return status
 16825                              <1> ;		CF:		0 if successful, 1 if error
 16826                              <1> ;--------------------------------------------------------------------
 16827                              <1> AH9h_HandlerForInitializeDriveParameters:
 16828                              <1> %ifndef USE_186
 16829                              <1> 	; why is this different for 186+?
 16830 00000E7E E81400              <1> 	call	AH9h_InitializeDriveForUse
 16831 00000E81 E976FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 16832                              <1> %else
 16833                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 16834                              <1> 	; Fall to AH9h_InitializeDriveForUse
 16835                              <1> %endif
 16836                              <1> 
 16837                              <1> 
 16838                              <1> ;--------------------------------------------------------------------
 16839                              <1> ; Initialize drive to be ready for use.
 16840                              <1> ;
 16841                              <1> ; AH9h_InitializeDriveForUse
 16842                              <1> ;	Parameters:
 16843                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16844                              <1> ;		SS:BP:	Ptr to IDEPACK
 16845                              <1> ;	Returns:
 16846                              <1> ;		AH:		Int 13h return status
 16847                              <1> ;		CF:		0 if successful, 1 if error
 16848                              <1> ;	Corrupts registers:
 16849                              <1> ;		AL, CX
 16850                              <1> ;--------------------------------------------------------------------
 16851                              <1> AH9h_InitializeDriveForUse:
 16852 00000E84 31C0                <1> 	xor		ax, ax				; Clear AH to assume no errors
 16853                              <1> 
 16854                              <1> %ifdef MODULE_ADVANCED_ATA
 16855                              <1> 	; Clear Initialization Error flags from DPT
 16856                              <1> 	mov		[di+DPT.bInitError], al
 16857                              <1> %endif
 16858                              <1> 
 16859                              <1> %ifdef MODULE_SERIAL
 16860                              <1> 	; No need to do this for serial devices
 16861                              <1> 	test		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE	; Clears CF
 16862                              <1> 	jz		SHORT .ContinueInitialization
 16863                              <1> 	ret		; With AH and CF cleared
 16864                              <1> .ContinueInitialization:
 16865                              <1> %endif
 16866                              <1> 
 16867 00000E86 06                  <1> 	push	es
 16868 00000E87 56                  <1> 	push	si
 16869 00000E88 52                  <1> 	push	dx
 16870 00000E89 53                  <1> 	push	bx
 16871                              <1> 
 16872                              <1> 
 16873                              <1> ;;;	SelectDrive
 16874                              <1> 	; Try to select drive and wait until ready
 16875 00000E8A E8C9F6              <1> 	call	AccessDPT_GetDriveSelectByteForOldInt13hToAL
 16876 00000E8D 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
 16877 00000E90 E892FA              <1> 	call	Device_SelectDrive
 16878                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SELECT_DRIVE
 16879 00000E93 B001                <2>  mov al, %1
 16880 00000E95 E89800              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 16881                              <1> %ifdef USE_386
 16882                              <1> 	jc		.ReturnWithErrorCodeInAH
 16883                              <1> %else
 16884 00000E98 7313                <1> 	jnc		SHORT .ContinueInitializationSinceDriveSelectedSuccesfully
 16885 00000E9A E98900              <1> 	jmp		.ReturnWithErrorCodeInAH
 16886                              <1> .ContinueInitializationSinceDriveSelectedSuccesfully:
 16887                              <1> %endif
 16888                              <1> 
 16889                              <1> 
 16890                              <1> ;;; Set XT-CF mode
 16891                              <1> %ifdef MODULE_8BIT_IDE
 16892 00000E9D E8F0F6              <1> 	call	AccessDPT_GetIdevarsToCSBX
 16893 00000EA0 2E8A4702            <1> 	mov		al, [cs:bx+IDEVARS.bXTCFcontrolRegister]
 16894                              <1> 	call	AH9h_SetModeFromALtoXTCF
 16895          ******************  <1>  error: symbol `AH9h_SetModeFromALtoXTCF' undefined
 16896                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_XTCF_MODE
 16897 00000EA4 B080                <2>  mov al, %1
 16898 00000EA6 E88700              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 16899                              <1> .DoNotSetXTCFmode:
 16900                              <1> %endif	; MODULE_8BIT_IDE
 16901                              <1> 
 16902                              <1> %ifdef MODULE_8BIT_IDE
 16903                              <1> ;;; Set 8-bit PIO mode
 16904 00000EA9 E89000              <1> 	call	AH9h_Enable8bitModeForDevice8bitAta
 16905                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_8BIT_MODE
 16906 00000EAC B080                <2>  mov al, %1
 16907 00000EAE E87F00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 16908                              <1> .DoNotSet8bitMode:
 16909                              <1> %endif ; MODULE_8BIT_IDE
 16910                              <1> 
 16911                              <1> 
 16912                              <1> ;;;	InitializeDeviceParameters
 16913                              <1> 	; Initialize CHS parameters if LBA is not used and
 16914                              <1> 	; user has specified P-CHS parameters
 16915 00000EB1 F60508              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_ASSISTED_LBA
 16916 00000EB4 7532                <1> 	jnz		SHORT .SkipInitializeDeviceParameters		; No need to initialize CHS parameters if LBA mode enabled
 16917 00000EB6 E8C8F6              <1> 	call	AccessDPT_GetPointerToDRVPARAMStoCSBX
 16918 00000EB9 2EF60720            <1> 	test	BYTE [cs:bx+DRVPARAMS.wFlags], FLG_DRVPARAMS_USERCHS    ; User specified P-CHS?
 16919 00000EBD 7429                <1> 	jz		SHORT .SkipInitializeDeviceParameters
 16920                              <1> 
 16921                              <1> 	; Initialize Logical Sectors per Track and Max Head number
 16922 00000EBF 2E8B4704            <1> 	mov		ax, [cs:bx+DRVPARAMS.wHeadsAndSectors]
 16923 00000EC3 48                  <1> 	dec		ax						; Max Head number
 16924 00000EC4 86C4                <1> 	xchg		al, ah						; Heads now in AH
 16925 00000EC6 89C2                <1> 	mov		dx, ax						; Sectors per Track now in DL
 16926 00000EC8 B091                <1> 	mov		al, COMMAND_INITIALIZE_DEVICE_PARAMETERS
 16927 00000ECA BB802F              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_BSY, FLG_STATUS_BSY)
 16928 00000ECD E860F9              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
 16929                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_INITIALIZE_CHS_PARAMETERS
 16930 00000ED0 B002                <2>  mov al, %1
 16931 00000ED2 E85B00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 16932                              <1> .SkipInitializeDeviceParameters:
 16933                              <1> 
 16934                              <1> 
 16935                              <1> ;;;	SetWriteCache
 16936                              <1> 	; Enable or Disable Write Cache
 16937 00000ED5 E8A9F6              <1> 	call	AccessDPT_GetPointerToDRVPARAMStoCSBX
 16938 00000ED8 2E8A1F              <1> 	mov		bl, [cs:bx+DRVPARAMS.wFlags]
 16939 00000EDB 53                  <1> 	push		bx	; Save .wFlags for later use in InitializeBlockMode
 16940 00000EDC 83E303              <1> 	and		bx, BYTE MASK_DRVPARAMS_WRITECACHE
 16941 00000EDF 7420                <1> 	jz		SHORT .SkipSetWriteCache		; DEFAULT_WRITE_CACHE
 16942 00000EE1 2E8BB7[2B0F]        <1> 	mov		si, [cs:bx+.rgbWriteCacheCommands]
 16943 00000EE6 E8AC00              <1> 	call	AH23h_SetControllerFeatures
 16944                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_WRITE_CACHE
 16945 00000EE9 B004                <2>  mov al, %1
 16946 00000EEB E84200              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 16947                              <1> .SkipSetWriteCache:
 16948                              <1> 
 16949                              <1> 
 16950                              <1> ;;;	RecalibrateDrive
 16951                              <1> 	; Recalibrate drive by seeking to cylinder 0
 16952 00000EEE E86D00              <1> 	call	AH11h_RecalibrateDrive
 16953                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_RECALIBRATE_DRIVE
 16954 00000EF1 B008                <2>  mov al, %1
 16955 00000EF3 E83A00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 16956                              <1> 
 16957                              <1> 
 16958                              <1> ;;;	InitializeBlockMode
 16959                              <1> 	; Initialize block mode transfers
 16960 00000EF6 58                  <1> 	pop		ax	; Restore .wFlags saved in SetWriteCache
 16961 00000EF7 F6450102            <1> 	test		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_BLOCK_MODE_SUPPORTED
 16962 00000EFB 7429                <1> 	jz		SHORT .BlockModeNotSupportedOrDisabled
 16963 00000EFD A810                <1> 	test		al, FLG_DRVPARAMS_BLOCKMODE
 16964 00000EFF 7425                <1> 	jz		SHORT .BlockModeNotSupportedOrDisabled
 16965                              <1> 
 16966                              <1> 	; Try block sizes until we find largest possible supported by drive
 16967 00000F01 B380                <1> 	mov		bl, 128
 16968                              <1> .TryNextBlockSize:
 16969 00000F03 88D8                <1> 	mov		al, bl
 16970 00000F05 E8A000              <1> 	call	AH24h_SetBlockSize	; Stores block size to DPT
 16971 00000F08 731C                <1> 	jnc		SHORT .SupportedBlockSizeFound
 16972 00000F0A D0EB                <1> 	shr		bl, 1
 16973 00000F0C 73F5                <1> 	jnc		SHORT .TryNextBlockSize
 16974                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_BLOCK_MODE
 16975 00000F0E B010                <2>  mov al, %1
 16976 00000F10 E81D00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 16977                              <1> .BlockModeNotSupportedOrDisabled:
 16978                              <1> .SupportedBlockSizeFound:
 16979                              <1> 
 16980                              <1> 
 16981                              <1> %ifdef MODULE_ADVANCED_ATA
 16982                              <1> ;;;	InitializePioMode
 16983                              <1> 	; Initialize fastest supported PIO mode
 16984                              <1> 	mov		dl, PIO_DEFAULT_MODE_DISABLE_IORDY
 16985                              <1> 	test		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_IORDY
 16986                              <1> 	jz		SHORT .IordyNotSupported
 16987                              <1> 
 16988                              <1> 	; Advanced PIO mode 3 and above
 16989                              <1> 	mov		dl, [di+DPT_ADVANCED_ATA.bPioMode]
 16990                              <1> 	or		dl, PIO_FLOW_CONTROL_MODE_xxx
 16991                              <1> 
 16992                              <1> .IordyNotSupported:
 16993                              <1> 	mov		si, FEATURE_SET_TRANSFER_MODE
 16994                              <1> 	call	AH23h_SetControllerFeatures
 16995                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_PIO_MODE
 16996                              <1> %endif ; MODULE_ADVANCED_ATA
 16997                              <1> 
 16998                              <1> 
 16999                              <1> %ifdef MODULE_FEATURE_SETS
 17000                              <1> ;;;	InitStandbyTimer
 17001                              <1> 	; Initialize the standby timer (if supported)
 17002                              <1> 	test	BYTE [di+DPT.bFlagsHigh], FLGH_DPT_POWER_MANAGEMENT_SUPPORTED
 17003                              <1> 	jz		SHORT .NoPowerManagementSupport
 17004                              <1> 
 17005                              <1> 	mov		al, COMMAND_IDLE
 17006                              <1> 	mov		dl, [cs:ROMVARS.bIdleTimeout]
 17007                              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_BSY, FLG_STATUS_BSY)
 17008                              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
 17009                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_INITIALIZE_STANDBY_TIMER
 17010                              <1> .NoPowerManagementSupport:
 17011                              <1> %endif ; MODULE_FEATURE_SETS
 17012                              <1> 
 17013                              <1> 
 17014                              <1> 	; There might have been several errors so just return one error code for them all
 17015                              <1> .ReturnWithErrorCodeInAH:
 17016                              <1> %ifdef MODULE_ADVANCED_ATA
 17017                              <1> 	mov		ah, [di+DPT.bInitError]
 17018                              <1> 	test		ah, ah	; Clears CF
 17019                              <1> 	jz		SHORT .ReturnWithSuccess
 17020                              <1> 	mov		ah, RET_HD_RESETFAIL
 17021                              <1> 	stc
 17022                              <1> .ReturnWithSuccess:
 17023                              <1> %endif
 17024                              <1> 
 17025 00000F13 5B                  <1> 	pop		bx
 17026 00000F14 5A                  <1> 	pop		dx
 17027 00000F15 5E                  <1> 	pop		si
 17028 00000F16 07                  <1> 	pop		es
 17029 00000F17 C3                  <1> 	ret
 17030                              <1> 
 17031                              <1> 
 17032                              <1> .rgbWriteCacheCommands:
 17033 00000F18 00                  <1> 	db		0								; DEFAULT_WRITE_CACHE
 17034 00000F19 82                  <1> 	db		FEATURE_DISABLE_WRITE_CACHE		; DISABLE_WRITE_CACHE
 17035 00000F1A 02                  <1> 	db		FEATURE_ENABLE_WRITE_CACHE		; ENABLE_WRITE_CACHE
 17036                              <1> 
 17037                              <1> 
 17038                              <1> 
 17039                              <1> ;--------------------------------------------------------------------
 17040                              <1> ; SetErrorFlagFromALwithErrorCodeInAH
 17041                              <1> ;	Parameters:
 17042                              <1> ;		AH:		BIOS Error Code
 17043                              <1> ;		AL:		Error flag to set
 17044                              <1> ;		DS:DI:		Ptr to DPT
 17045                              <1> ;		CF:		Set if error code in AH
 17046                              <1> ;				Clear if AH = 0
 17047                              <1> ;	Returns:
 17048                              <1> ;		CF:		Clear if no error
 17049                              <1> ;				Set if error flag was set
 17050                              <1> ;	Corrupts registers:
 17051                              <1> ;		Nothing
 17052                              <1> ;--------------------------------------------------------------------
 17053                              <1> IgnoreInvalidCommandError:
 17054 00000F1B 30E4                <1> 	xor		ah, ah	; Clears CF
 17055                              <1> SetErrorFlagFromALwithErrorCodeInAH:
 17056 00000F1D 731C                <1> 	jnc		SHORT .NoErrorFlagToSet
 17057 00000F1F 80FC01              <1> 	cmp		ah, RET_HD_INVALID
 17058 00000F22 76F7                <1> 	jbe		SHORT IgnoreInvalidCommandError
 17059                              <1> 
 17060 00000F24 084503              <1> 	or		[di+DPT.bInitError], al
 17061 00000F27 F9                  <1> 	stc
 17062                              <1> .NoErrorFlagToSet:
 17063 00000F28 C3                  <1> 	ret
 17064                              <1> 
 17065                              <1> 
 17066                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 17067                              <1> ;--------------------------------------------------------------------
 17068                              <1> ; AH9h_SetModeFromALtoXTCF
 17069                              <1> ;	Parameters:
 17070                              <1> ;		AL:		XT-CF Mode to set
 17071                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 17072                              <1> ;		SS:BP:		Ptr to IDEPACK
 17073                              <1> ;	Returns:
 17074                              <1> ;		AH:		Int 13h return status
 17075                              <1> ;		CF:		Clear if successful or device is not XT-CF
 17076                              <1> ;				Set if failed to set mode for XT-CF
 17077                              <1> ;	Corrupts registers:
 17078                              <1> ;		AL, BX, CX, DX, SI
 17079                              <1> ;--------------------------------------------------------------------
 17080                              <1> AH9h_SetModeFromALtoXTCF:
 17081                              <1> 	call		AccessDPT_IsThisDeviceXTCF
 17082                              <1> 	jne		SHORT IgnoreInvalidCommandError
 17083                              <1> 	jmp		AH1Eh_ChangeXTCFmodeBasedOnModeInAL
 17084                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 17085                              <1> 
 17086                              <1> %ifdef MODULE_8BIT_IDE
 17087                              <1> ;--------------------------------------------------------------------
 17088                              <1> ; AH9h_Enable8bitModeForDevice8bitAta
 17089                              <1> ;	Parameters:
 17090                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17091                              <1> ;		SS:BP:	Ptr to IDEPACK
 17092                              <1> ;	Returns:
 17093                              <1> ;		AH:		Int 13h return status
 17094                              <1> ;		CF:		Clear if successful or device is not DEVICE_8BIT_ATA
 17095                              <1> ;				Set if failed to set 8-bit mode for DEVICE_8BIT_ATA
 17096                              <1> ;	Corrupts registers:
 17097                              <1> ;		AL, BX, CX, DX, SI
 17098                              <1> ;--------------------------------------------------------------------
 17099                              <1> AH9h_Enable8bitModeForDevice8bitAta:
 17100 00000F29 807D0C04            <1> 	cmp		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_ATA
 17101 00000F2D 75EC                <1> 	jne		SHORT IgnoreInvalidCommandError
 17102 00000F2F EB6C                <1> 	jmp		AH23h_Enable8bitPioMode
 17103                              <1> %endif
 17104                                  	%include "AHCh_HSeek.asm"		; Required by Int13h_Jump.asm
 17105                              <1> ; Project name	:	XTIDE Universal BIOS
 17106                              <1> ; Description	:	Int 13h function AH=Ch, Seek.
 17107                              <1> 
 17108                              <1> ;
 17109                              <1> ; XTIDE Universal BIOS and Associated Tools
 17110                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17111                              <1> ;
 17112                              <1> ; This program is free software; you can redistribute it and/or modify
 17113                              <1> ; it under the terms of the GNU General Public License as published by
 17114                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17115                              <1> ; (at your option) any later version.
 17116                              <1> ;
 17117                              <1> ; This program is distributed in the hope that it will be useful,
 17118                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17119                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17120                              <1> ; GNU General Public License for more details.
 17121                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17122                              <1> ;
 17123                              <1> 
 17124                              <1> ; Section containing code
 17125                              <1> SECTION .text
 17126                              <1> 
 17127                              <1> ;--------------------------------------------------------------------
 17128                              <1> ; Int 13h function AH=Ch, Seek.
 17129                              <1> ;
 17130                              <1> ; AHCh_HandlerForSeek
 17131                              <1> ;	Parameters:
 17132                              <1> ;		CX, DH:	Same as in INTPACK
 17133                              <1> ;		DL:		Translated Drive number
 17134                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17135                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 17136                              <1> ;	Parameters on INTPACK:
 17137                              <1> ;		CH:		Cylinder number, bits 7...0
 17138                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 17139                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 17140                              <1> ;		DH:		Starting head number (0...255)
 17141                              <1> ;	Returns with INTPACK:
 17142                              <1> ;		AH:		BIOS Error code
 17143                              <1> ;		CF:		0 if successful, 1 if error
 17144                              <1> ;--------------------------------------------------------------------
 17145                              <1> ALIGN JUMP_ALIGN
 17146                              <1> AHCh_HandlerForSeek:
 17147                              <1> %ifndef USE_186
 17148 00000F31 E81600              <1> 	call	AHCh_SeekToCylinder
 17149 00000F34 E9C3FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17150                              <1> %else
 17151                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17152                              <1> 	; Fall to AHCh_SeekToCylinder
 17153                              <1> %endif
 17154                              <1> 
 17155                              <1> ;--------------------------------------------------------------------
 17156                              <1> ; AHCh_SeekToCylinder
 17157                              <1> ;	Parameters:
 17158                              <1> ;		CH:		Cylinder number, bits 7...0
 17159                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 17160                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 17161                              <1> ;		DH:		Starting head number (0...255)
 17162                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17163                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 17164                              <1> ;	Returns:
 17165                              <1> ;		AH:		BIOS Error code
 17166                              <1> ;		CF:		0 if successful, 1 if error
 17167                              <1> ;	Corrupts registers:
 17168                              <1> ;		AL, BX, CX, DX
 17169                              <1> ;--------------------------------------------------------------------
 17170                              <1> AHCh_SeekToCylinder:
 17171 00000F37 B470                <1> 	mov		ah, COMMAND_SEEK
 17172 00000F39 BB40FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRDY)
 17173 00000F3C E9CFF8              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 17174                                  	%include "AH10h_HReady.asm"		; Required by Int13h_Jump.asm
 17175                              <1> ; Project name	:	XTIDE Universal BIOS
 17176                              <1> ; Description	:	Int 13h function AH=10h, Check Drive Ready.
 17177                              <1> 
 17178                              <1> ;
 17179                              <1> ; XTIDE Universal BIOS and Associated Tools
 17180                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17181                              <1> ;
 17182                              <1> ; This program is free software; you can redistribute it and/or modify
 17183                              <1> ; it under the terms of the GNU General Public License as published by
 17184                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17185                              <1> ; (at your option) any later version.
 17186                              <1> ;
 17187                              <1> ; This program is distributed in the hope that it will be useful,
 17188                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17189                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17190                              <1> ; GNU General Public License for more details.
 17191                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17192                              <1> ;
 17193                              <1> 
 17194                              <1> ; Section containing code
 17195                              <1> SECTION .text
 17196                              <1> 
 17197                              <1> ;--------------------------------------------------------------------
 17198                              <1> ; Int 13h function AH=10h, Check Drive Ready.
 17199                              <1> ;
 17200                              <1> ; AH10h_HandlerForCheckDriveReady
 17201                              <1> ;	Parameters:
 17202                              <1> ;		DL:		Translated Drive number
 17203                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17204                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 17205                              <1> ;	Returns with INTPACK:
 17206                              <1> ;		AH:		Int 13h return status
 17207                              <1> ;		CF:		0 if successful, 1 if error
 17208                              <1> ;--------------------------------------------------------------------
 17209                              <1> ALIGN JUMP_ALIGN
 17210                              <1> AH10h_HandlerForCheckDriveReady:
 17211                              <1> %ifdef USE_186
 17212                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17213                              <1> 	jmp		Device_SelectDrive
 17214                              <1> %else
 17215 00000F3F E8E3F9              <1> 	call	Device_SelectDrive
 17216 00000F42 E9B5FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17217                              <1> %endif
 17218                                  	%include "AH11h_HRecal.asm"		; Required by Int13h_Jump.asm
 17219                              <1> ; Project name	:	XTIDE Universal BIOS
 17220                              <1> ; Description	:	Int 13h function AH=11h, Recalibrate.
 17221                              <1> 
 17222                              <1> ;
 17223                              <1> ; XTIDE Universal BIOS and Associated Tools
 17224                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17225                              <1> ;
 17226                              <1> ; This program is free software; you can redistribute it and/or modify
 17227                              <1> ; it under the terms of the GNU General Public License as published by
 17228                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17229                              <1> ; (at your option) any later version.
 17230                              <1> ;
 17231                              <1> ; This program is distributed in the hope that it will be useful,
 17232                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17233                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17234                              <1> ; GNU General Public License for more details.
 17235                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17236                              <1> ;
 17237                              <1> 
 17238                              <1> ; Section containing code
 17239                              <1> SECTION .text
 17240                              <1> 
 17241                              <1> ;--------------------------------------------------------------------
 17242                              <1> ; Int 13h function AH=11h, Recalibrate.
 17243                              <1> ;
 17244                              <1> ; AH11h_HandlerForRecalibrate
 17245                              <1> ;	Parameters:
 17246                              <1> ;		DL:		Translated Drive number
 17247                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17248                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 17249                              <1> ;	Returns with INTPACK:
 17250                              <1> ;		AH:		BIOS Error code
 17251                              <1> ;		CF:		0 if successful, 1 if error
 17252                              <1> ;--------------------------------------------------------------------
 17253                              <1> AH11h_HandlerForRecalibrate:
 17254                              <1> %ifndef USE_186
 17255 00000F45 E81600              <1> 	call	AH11h_RecalibrateDrive
 17256 00000F48 E9AFFD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17257                              <1> %else
 17258                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17259                              <1> 	; Fall to AH11h_RecalibrateDrive
 17260                              <1> %endif
 17261                              <1> 
 17262                              <1> 
 17263                              <1> ;--------------------------------------------------------------------
 17264                              <1> ; AH11h_HRecalibrate
 17265                              <1> ;	Parameters:
 17266                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17267                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 17268                              <1> ;	Returns:
 17269                              <1> ;		AH:		BIOS Error code
 17270                              <1> ;		CF:		0 if successful, 1 if error
 17271                              <1> ;	Corrupts registers:
 17272                              <1> ;		AL, BX, CX, DX
 17273                              <1> ;--------------------------------------------------------------------
 17274                              <1> AH11h_RecalibrateDrive:
 17275                              <1> 	; Recalibrate command is optional, vendor specific and not even
 17276                              <1> 	; supported on later ATA-standards. Let's do seek instead.
 17277 00000F4B B90100              <1> 	mov		cx, 1						; Seek to Cylinder 0, Sector 1
 17278 00000F4E 30F6                <1> 	xor		dh, dh						; Head 0
 17279 00000F50 EBE5                <1> 	jmp		AHCh_SeekToCylinder
 17280                                  	%include "AH15h_HSize.asm"		; Required by Int13h_Jump.asm
 17281                              <1> ; Project name	:	XTIDE Universal BIOS
 17282                              <1> ; Description	:	Int 13h function AH=15h, Read Disk Drive Size.
 17283                              <1> 
 17284                              <1> ;
 17285                              <1> ; XTIDE Universal BIOS and Associated Tools
 17286                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17287                              <1> ;
 17288                              <1> ; This program is free software; you can redistribute it and/or modify
 17289                              <1> ; it under the terms of the GNU General Public License as published by
 17290                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17291                              <1> ; (at your option) any later version.
 17292                              <1> ;
 17293                              <1> ; This program is distributed in the hope that it will be useful,
 17294                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17295                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17296                              <1> ; GNU General Public License for more details.
 17297                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17298                              <1> ;
 17299                              <1> 
 17300                              <1> ; Section containing code
 17301                              <1> SECTION .text
 17302                              <1> 
 17303                              <1> ;--------------------------------------------------------------------
 17304                              <1> ; Int 13h function AH=15h, Read Disk Drive Size.
 17305                              <1> ;
 17306                              <1> ; AH15h_HandlerForReadDiskDriveSize
 17307                              <1> ;	Parameters:
 17308                              <1> ;		DL:		Translated Drive number
 17309                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17310                              <1> ;		SS:BP:	Ptr to IDEPACK
 17311                              <1> ;	Returns with INTPACK:
 17312                              <1> ;		If successful:
 17313                              <1> ;			AH:		Hard Disk: 3 (Hard disk accessible)
 17314                              <1> ;                   Floppy:    1 (Floppy disk, without change detection)
 17315                              <1> ;			CX:DX:	Total number of sectors
 17316                              <1> ;			CF:		0
 17317                              <1> ;		If failed:
 17318                              <1> ;			AH:		0 (Drive not present)
 17319                              <1> ;			CX:DX:	0
 17320                              <1> ;			CF:		1
 17321                              <1> ;--------------------------------------------------------------------
 17322                              <1> AH15h_HandlerForReadDiskDriveSize:
 17323                              <1> %ifdef MODULE_SERIAL_FLOPPY
 17324                              <1> 	mov		cl, 1										; 1 = floppy disk, no change detection
 17325                              <1> 
 17326                              <1> 	test	dl,dl										; DO NOT store the sector count if this is a
 17327                              <1> 	jns		.FloppyDrive								; floppy disk, some OS's depend on this not
 17328                              <1> 														; happening for floppies in order to boot.
 17329                              <1> %endif
 17330                              <1> 
 17331 00000F52 E82500              <1> 	call	AH15h_GetSectorCountToBXDXAX
 17332 00000F55 895619              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.cx], dx			; HIWORD to CX
 17333 00000F58 874617              <1> 	xchg	[bp+IDEPACK.intpack+INTPACK.dx], ax			; LOWORD to DX, AL gets drive number
 17334                              <1> 
 17335 00000F5B 30E4                <1> 	xor		ah, ah
 17336                              <1> %ifdef MODULE_SERIAL_FLOPPY
 17337                              <1> 	mov		cl, 3										; 3 = Hard Disk Accessible
 17338                              <1> .FloppyDrive:
 17339                              <1> 
 17340                              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH_ALHasDriveNumber	; Store success to BDA and CF
 17341                              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ah], cl
 17342                              <1> %else
 17343 00000F5D E8DCFD              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH	; Store success to BDA and CF
 17344 00000F60 C6461C03            <1> 	mov		BYTE [bp+IDEPACK.intpack+INTPACK.ah], 3
 17345                              <1> %endif
 17346                              <1> 
 17347 00000F64 E996FD              <1> 	jmp		Int13h_ReturnFromHandlerWithoutStoringErrorCode
 17348                              <1> 
 17349                              <1> 
 17350                              <1> ;--------------------------------------------------------------------
 17351                              <1> ; AH15h_GetSectorCountFromForeignDriveToDXAX:
 17352                              <1> ; AH15h_GetSectorCountToBXDXAX:
 17353                              <1> ;	Parameters:
 17354                              <1> ;		DL:		Drive number (AH15h_GetSectorCountFromForeignDriveToDXAX only)
 17355                              <1> ;		DS:		RAMVARS segment
 17356                              <1> ;		DS:DI:	Ptr to DPT (AH15h_GetSectorCountToDXAX only)
 17357                              <1> ;	Returns:
 17358                              <1> ;		DX:AX:	Total sector count
 17359                              <1> ;		BX:		Zero
 17360                              <1> ;	Corrupts registers:
 17361                              <1> ;		CX
 17362                              <1> ;--------------------------------------------------------------------
 17363                              <1> %ifdef MODULE_BOOT_MENU
 17364                              <1> AH15h_GetSectorCountFromForeignDriveToDXAX:
 17365                              <1> 	mov		ah, GET_DRIVE_PARAMETERS
 17366                              <1> 	call	Int13h_CallPreviousInt13hHandler
 17367                              <1> 	jmp		SHORT ConvertAH08hReturnValuesToSectorCount
 17368                              <1> %endif
 17369                              <1> 
 17370                              <1> AH15h_GetSectorCountToBXDXAX:
 17371 00000F67 E8FBFE              <1> 	call	AH8h_GetDriveParameters
 17372                              <1> 	; Fall to ConvertAH08hReturnValuesToSectorCount
 17373                              <1> 
 17374                              <1> ConvertAH08hReturnValuesToSectorCount:
 17375 00000F6A E86B00              <1> 	call	Address_ExtractLCHSparametersFromOldInt13hAddress
 17376 00000F6D 88F8                <1> 	mov		al, bh		; AL = Max head number
 17377 00000F6F 41                  <1> 	inc		cx			; Max cylinder number to cylinder count
 17378 00000F70 40                  <1> 	inc		ax			; Max head number to head count (AH=8h returns max 254 so no overflow to AH)
 17379 00000F71 F6E3                <1> 	mul		bl			; AX = Head count * Sectors per track
 17380 00000F73 F7E1                <1> 	mul		cx			; DX:AX = Total sector count for AH=0xh transfer functions
 17381 00000F75 31DB                <1> 	xor		bx, bx
 17382 00000F77 C3                  <1> 	ret
 17383                                  %ifdef MODULE_8BIT_IDE_ADVANCED
 17384                                  	%include "AH1Eh_XTCF.asm"
 17385                                  %endif
 17386                                  	%include "AH23h_HFeatures.asm"	; Required by Int13h_Jump.asm
 17387                              <1> ; Project name	:	XTIDE Universal BIOS
 17388                              <1> ; Description	:	Int 13h function AH=23h,
 17389                              <1> ;					Set Controller Features Register.
 17390                              <1> 
 17391                              <1> ;
 17392                              <1> ; XTIDE Universal BIOS and Associated Tools
 17393                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17394                              <1> ;
 17395                              <1> ; This program is free software; you can redistribute it and/or modify
 17396                              <1> ; it under the terms of the GNU General Public License as published by
 17397                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17398                              <1> ; (at your option) any later version.
 17399                              <1> ;
 17400                              <1> ; This program is distributed in the hope that it will be useful,
 17401                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17402                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17403                              <1> ; GNU General Public License for more details.
 17404                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17405                              <1> ;
 17406                              <1> 
 17407                              <1> ; Section containing code
 17408                              <1> SECTION .text
 17409                              <1> 
 17410                              <1> ;--------------------------------------------------------------------
 17411                              <1> ; Int 13h function AH=23h, Set Controller Features Register.
 17412                              <1> ;
 17413                              <1> ; AH23h_HandlerForSetControllerFeatures
 17414                              <1> ;	Parameters:
 17415                              <1> ;		AL, CX:	Same as in INTPACK
 17416                              <1> ;		DL:		Translated Drive number
 17417                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17418                              <1> ;		SS:BP:	Ptr to IDEPACK
 17419                              <1> ;	Parameters on INTPACK:
 17420                              <1> ;		AL:		Feature Number (parameter to Features Register = subcommand)
 17421                              <1> ;	(Parameter registers are undocumented, these are specific for this BIOS):
 17422                              <1> ;		BL:		Parameter to Sector Count Register (subcommand specific)
 17423                              <1> ;		BH:		Parameter to LBA Low / Sector Number Register (subcommand specific)
 17424                              <1> ;		CL:		Parameter to LBA Middle / Cylinder Low Register (subcommand specific)
 17425                              <1> ;		CH:		Parameter to LBA High / Cylinder High Register (subcommand specific)
 17426                              <1> ;	Returns with INTPACK:
 17427                              <1> ;		AH:		Int 13h return status
 17428                              <1> ;		CF:		0 if successful, 1 if error
 17429                              <1> ;--------------------------------------------------------------------
 17430                              <1> AH23h_HandlerForSetControllerFeatures:
 17431 00000F78 96                  <1> 	xchg	si, ax		; SI = Feature Number
 17432 00000F79 8B5615              <1> 	mov		dx, [bp+IDEPACK.intpack+INTPACK.bx]
 17433                              <1> %ifndef USE_186
 17434 00000F7C E81600              <1> 	call	AH23h_SetControllerFeatures
 17435 00000F7F E978FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17436                              <1> %else
 17437                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17438                              <1> 	; Fall to AH23h_SetControllerFeatures
 17439                              <1> %endif
 17440                              <1> 
 17441                              <1> 
 17442                              <1> ;--------------------------------------------------------------------
 17443                              <1> ; AH23h_SetControllerFeatures
 17444                              <1> ;	Parameters:
 17445                              <1> ;		DL:		Parameter to Sector Count Register (subcommand specific)
 17446                              <1> ;		DH:		Parameter to LBA Low / Sector Number Register (subcommand specific)
 17447                              <1> ;		CL:		Parameter to LBA Middle / Cylinder Low Register (subcommand specific)
 17448                              <1> ;		CH:		Parameter to LBA High / Cylinder High Register (subcommand specific)
 17449                              <1> ;		SI:		Feature Number (parameter to Features Register = subcommand)
 17450                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17451                              <1> ;		SS:BP:	Ptr to IDEPACK
 17452                              <1> ;	Returns:
 17453                              <1> ;		AH:		Int 13h return status
 17454                              <1> ;		CF:		0 if successful, 1 if error
 17455                              <1> ;	Corrupts registers:
 17456                              <1> ;		AL, BX, CX, DX
 17457                              <1> ;--------------------------------------------------------------------
 17458                              <1> AH23h_SetControllerFeatures:
 17459 00000F82 B0EF                <1> 	mov		al, COMMAND_SET_FEATURES
 17460 00000F84 BB802F              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_BSY, FLG_STATUS_BSY)
 17461 00000F87 E9A6F8              <1> 	jmp		Idepack_StoreNonExtParametersAndIssueCommandFromAL
 17462                              <1> 
 17463                              <1> 
 17464                              <1> ;--------------------------------------------------------------------
 17465                              <1> ; AH23h_Enable8bitPioMode
 17466                              <1> ;	Parameters:
 17467                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17468                              <1> ;		SS:BP:	Ptr to IDEPACK
 17469                              <1> ;	Returns:
 17470                              <1> ;		AH:		Int 13h return status
 17471                              <1> ;		CF:		0 if successful, 1 if error
 17472                              <1> ;	Corrupts registers:
 17473                              <1> ;		AL, BX, CX, DX, SI
 17474                              <1> ;--------------------------------------------------------------------
 17475                              <1> %ifdef MODULE_8BIT_IDE
 17476                              <1> AH23h_Enable8bitPioMode:
 17477 00000F8A BE0100              <1> 	mov		si, FEATURE_ENABLE_8BIT_PIO_TRANSFER_MODE
 17478 00000F8D EBF3                <1> 	jmp		SHORT AH23h_SetControllerFeatures
 17479                              <1> %endif
 17480                                  	%include "AH24h_HSetBlocks.asm"	; Required by Int13h_Jump.asm
 17481                              <1> ; Project name	:	XTIDE Universal BIOS
 17482                              <1> ; Description	:	Int 13h function AH=24h, Set Multiple Blocks.
 17483                              <1> 
 17484                              <1> ;
 17485                              <1> ; XTIDE Universal BIOS and Associated Tools
 17486                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17487                              <1> ;
 17488                              <1> ; This program is free software; you can redistribute it and/or modify
 17489                              <1> ; it under the terms of the GNU General Public License as published by
 17490                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17491                              <1> ; (at your option) any later version.
 17492                              <1> ;
 17493                              <1> ; This program is distributed in the hope that it will be useful,
 17494                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17495                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17496                              <1> ; GNU General Public License for more details.
 17497                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17498                              <1> ;
 17499                              <1> 
 17500                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 17501                              <1> 
 17502                              <1> ; Section containing code
 17503                              <1> SECTION .text
 17504                              <1> 
 17505                              <1> ;--------------------------------------------------------------------
 17506                              <1> ; Int 13h function AH=24h, Set Multiple Blocks.
 17507                              <1> ;
 17508                              <1> ; AH24h_HandlerForSetMultipleBlocks
 17509                              <1> ;	Parameters:
 17510                              <1> ;		AL:		Same as in INTPACK
 17511                              <1> ;		DL:		Translated Drive number
 17512                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17513                              <1> ;		SS:BP:	Ptr to IDEPACK
 17514                              <1> ;	Parameters on INTPACK:
 17515                              <1> ;		AL:		Number of Sectors per Block (1, 2, 4, 8, 16, 32, 64 or 128)
 17516                              <1> ;	Returns with INTPACK:
 17517                              <1> ;		AH:		Int 13h return status
 17518                              <1> ;		CF:		0 if successful, 1 if error
 17519                              <1> ;--------------------------------------------------------------------
 17520                              <1> AH24h_HandlerForSetMultipleBlocks:
 17521                              <1> %ifndef USE_186
 17522 00000F8F E81600              <1> 	call	AH24h_SetBlockSize
 17523 00000F92 E965FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17524                              <1> %else
 17525                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17526                              <1> 	; Fall to AH24h_SetBlockSize
 17527                              <1> %endif
 17528                              <1> 
 17529                              <1> 
 17530                              <1> ;--------------------------------------------------------------------
 17531                              <1> ; AH24h_SetBlockSize
 17532                              <1> ;	Parameters:
 17533                              <1> ;		AL:		Number of Sectors per Block (1, 2, 4, 8, 16, 32, 64 or 128)
 17534                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 17535                              <1> ;		SS:BP:		Ptr to IDEPACK
 17536                              <1> ;	Returns:
 17537                              <1> ;		AH:		Int 13h return status
 17538                              <1> ;		CF:		0 if successful, 1 if error
 17539                              <1> ;	Corrupts registers:
 17540                              <1> ;		AL, CX, DX
 17541                              <1> ;--------------------------------------------------------------------
 17542                              <1> AH24h_SetBlockSize:
 17543                              <1> %ifdef MODULE_8BIT_IDE
 17544                              <1> 	; XT-CFv3 does not support largest block size in DMA mode,
 17545                              <1> 	; so check for that device:
 17546 00000F95 807D0C0E            <1> 	cmp		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_XTCF_DMA
 17547 00000F99 7519                <1> 	jne	.SetBlockSize
 17548                              <1> 	; XT-CFv3 in DMA mode selected - check requested block size
 17549                              <1> 	cmp		al, XTCF_DMA_MODE_MAX_BLOCK_SIZE
 17550          ******************  <1>  error: symbol `XTCF_DMA_MODE_MAX_BLOCK_SIZE' undefined
 17551 00000F9B 7617                <1> 	jbe	.SetBlockSize
 17552                              <1> 	; Otherwise, limit block size to maximum permitted
 17553                              <1> 	mov		al, XTCF_DMA_MODE_MAX_BLOCK_SIZE
 17554          ******************  <1>  error: symbol `XTCF_DMA_MODE_MAX_BLOCK_SIZE' undefined
 17555                              <1> .SetBlockSize:
 17556                              <1> %endif ; MODULE_8BIT_IDE
 17557 00000F9D 53                  <1> 	push		bx
 17558 00000F9E 50                  <1> 	push		ax
 17559 00000F9F 92                  <1> 	xchg		dx, ax				; DL = Block size (Sector Count Register)
 17560 00000FA0 B0C6                <1> 	mov		al, COMMAND_SET_MULTIPLE_MODE
 17561 00000FA2 BB402F              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRDY, FLG_STATUS_DRDY)
 17562 00000FA5 E888F8              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
 17563 00000FA8 5B                  <1> 	pop		bx				; BL = Block size (preserve AH)
 17564 00000FA9 7319                <1> 	jnc	SHORT .StoreBlockSize
 17565 00000FAB B301                <1> 	mov		bl, 1				; Block size 1 will always work
 17566                              <1> .StoreBlockSize:					; Store new block size to DPT and return
 17567 00000FAD 885D0D              <1> 	mov		[di+DPT_ATA.bBlockSize], bl
 17568 00000FB0 5B                  <1> 	pop		bx
 17569 00000FB1 C3                  <1> 	ret
 17570                              <1> 
 17571                                  	%include "AH25h_HDrvID.asm"		; Required by Int13h_Jump.asm
 17572                              <1> ; Project name	:	XTIDE Universal BIOS
 17573                              <1> ; Description	:	Int 13h function AH=25h, Get Drive Information.
 17574                              <1> 
 17575                              <1> ;
 17576                              <1> ; XTIDE Universal BIOS and Associated Tools
 17577                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17578                              <1> ;
 17579                              <1> ; This program is free software; you can redistribute it and/or modify
 17580                              <1> ; it under the terms of the GNU General Public License as published by
 17581                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17582                              <1> ; (at your option) any later version.
 17583                              <1> ;
 17584                              <1> ; This program is distributed in the hope that it will be useful,
 17585                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17586                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17587                              <1> ; GNU General Public License for more details.
 17588                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17589                              <1> ;
 17590                              <1> 
 17591                              <1> ; Section containing code
 17592                              <1> SECTION .text
 17593                              <1> 
 17594                              <1> ;--------------------------------------------------------------------
 17595                              <1> ; Int 13h function AH=25h, Get Drive Information.
 17596                              <1> ;
 17597                              <1> ; AH25h_HandlerForGetDriveInformation
 17598                              <1> ;	Parameters:
 17599                              <1> ;		ES:		Same as in INTPACK
 17600                              <1> ;		DL:		Translated Drive number
 17601                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17602                              <1> ;		SS:BP:	Ptr to IDEPACK
 17603                              <1> ;	Parameters on INTPACK:
 17604                              <1> ;		ES:BX:	Ptr to buffer to receive 512-byte drive information
 17605                              <1> ;	Returns with INTPACK:
 17606                              <1> ;		AH:		Int 13h return status
 17607                              <1> ;		CF:		0 if successful, 1 if error
 17608                              <1> ;--------------------------------------------------------------------
 17609                              <1> AH25h_HandlerForGetDriveInformation:
 17610 00000FB2 B801EC              <1> 	mov		ax, (COMMAND_IDENTIFY_DEVICE << 8 | 1)		; Read 1 sector
 17611 00000FB5 E88600              <1> 	call	Prepare_BufferToESSIforOldInt13hTransfer	; Preserves AX
 17612 00000FB8 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 17613                              <1> %ifdef USE_186
 17614                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17615                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 17616                              <1> %else
 17617 00000FBB E850F8              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 17618 00000FBE E939FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 17619                              <1> %endif
 17620                                  	%include "Address.asm"			; For sector address translations
 17621                              <1> ; Project name	:	XTIDE Universal BIOS
 17622                              <1> ; Description	:	Functions for address translations.
 17623                              <1> 
 17624                              <1> ;
 17625                              <1> ; XTIDE Universal BIOS and Associated Tools
 17626                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17627                              <1> ;
 17628                              <1> ; This program is free software; you can redistribute it and/or modify
 17629                              <1> ; it under the terms of the GNU General Public License as published by
 17630                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17631                              <1> ; (at your option) any later version.
 17632                              <1> ;
 17633                              <1> ; This program is distributed in the hope that it will be useful,
 17634                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17635                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17636                              <1> ; GNU General Public License for more details.
 17637                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17638                              <1> ;
 17639                              <1> 
 17640                              <1> ; Section containing code
 17641                              <1> SECTION .text
 17642                              <1> 
 17643                              <1> ;---------------------------------------------------------------------
 17644                              <1> ; Address_ExtractLCHSparametersFromOldInt13hAddress
 17645                              <1> ;	Parameters:
 17646                              <1> ;		CH:		Cylinder number, bits 7...0
 17647                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 17648                              <1> ;				Bits 5...0:	Sector number
 17649                              <1> ;		DH:		Head number
 17650                              <1> ;	Returns:
 17651                              <1> ;		BL:		Sector number (1...63)
 17652                              <1> ;		BH:		Head number (0...255)
 17653                              <1> ;		CX:		Cylinder number (0...1023)
 17654                              <1> ;	Corrupts registers:
 17655                              <1> ;		Nothing
 17656                              <1> ;--------------------------------------------------------------------
 17657                              <1> ALIGN JUMP_ALIGN
 17658                              <1> Address_ExtractLCHSparametersFromOldInt13hAddress:
 17659 00000FC1 88CB                <1> 	mov		bl, cl				; Copy sector number...
 17660 00000FC3 80E33F              <1> 	and		bl, 3Fh				; ...and limit to 1...63
 17661 00000FC6 28D9                <1> 	sub		cl, bl				; Remove from cylinder number high
 17662                              <1> 	eROL_IM	cl, 2				; High bits to beginning
 17663                              <2>  eSHIFT_IM %1, %2, rol
 17664                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 17665                              <3> %ifndef USE_186
 17666                              <3>  %ifidni %1, cl
 17667 00000FC8 D0C1<rept>          <3>  times %2 %3 %1, 1
 17668                              <3>  %elifidni %1, ch
 17669                              <3>  times %2 %3 %1, 1
 17670                              <3>  %elifidni %1, cx
 17671                              <3>  times %2 %3 %1, 1
 17672                              <3>  %else
 17673                              <3>  %if %2 > 3
 17674                              <3>  push cx
 17675                              <3>  mov cl, %2
 17676                              <3>  %3 %1, cl
 17677                              <3>  pop cx
 17678                              <3>  %else
 17679                              <3>  times %2 %3 %1, 1
 17680                              <3>  %endif
 17681                              <3>  %endif
 17682                              <3> 
 17683                              <3> %else
 17684                              <3>  %3 %1, %2
 17685                              <3> %endif
 17686                              <3> %endif
 17687 00000FCC 88F7                <1> 	mov		bh, dh				; Copy Head number
 17688 00000FCE 86CD                <1> 	xchg	cl, ch				; Cylinder number now in CX
 17689 00000FD0 C3                  <1> 	ret
 17690                              <1> 
 17691                              <1> 
 17692                              <1> ;---------------------------------------------------------------------
 17693                              <1> ; Converts LARGE addressing mode LCHS parameters to IDE P-CHS parameters.
 17694                              <1> ; PCylinder	= (LCylinder << n) + (LHead / PHeadCount)
 17695                              <1> ; PHead		= LHead % PHeadCount
 17696                              <1> ; PSector	= LSector
 17697                              <1> ;
 17698                              <1> ; ConvertLargeModeLCHStoPCHS:
 17699                              <1> ;	Parameters:
 17700                              <1> ;		BL:		Sector number (1...63)
 17701                              <1> ;		BH:		Head number (0...239)
 17702                              <1> ;		CX:		Cylinder number (0...1023)
 17703                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 17704                              <1> ;	Returns:
 17705                              <1> ;		BL:		Sector number (1...63)
 17706                              <1> ;		BH:		Head number (0...15)
 17707                              <1> ;		CX:		Cylinder number (0...16382)
 17708                              <1> ;	Corrupts registers:
 17709                              <1> ;		AX, DX
 17710                              <1> ;--------------------------------------------------------------------
 17711                              <1> ALIGN JUMP_ALIGN
 17712                              <1> ConvertLargeModeLCHStoPCHS:
 17713                              <1> 	; LHead / PHeadCount and LHead % PHeadCount
 17714                              <1> 	eMOVZX	ax, bh					; Copy L-CHS Head number to AX
 17715                              <2> %ifndef USE_386
 17716                              <2>  %ifidni %1, ax
 17717 00000FD1 88F8                <2>  mov al, %2
 17718 00000FD3 30E4                <2>  xor ah, ah
 17719                              <2>  %elifidni %1, bx
 17720                              <2>  mov bl, %2
 17721                              <2>  xor bh, bh
 17722                              <2>  %elifidni %1, cx
 17723                              <2>  mov cl, %2
 17724                              <2>  xor ch, ch
 17725                              <2>  %elifidni %1, dx
 17726                              <2>  mov dl, %2
 17727                              <2>  xor dh, dh
 17728                              <2>  %else
 17729                              <2>  push ax
 17730                              <2>  mov al, %2
 17731                              <2>  xor ah, ah
 17732                              <2>  xchg ax, %1
 17733                              <2>  pop ax
 17734                              <2>  %endif
 17735                              <2> 
 17736                              <2> %else
 17737                              <2>  movzx %1, %2
 17738                              <2> %endif
 17739 00000FD5 F6750A              <1> 	div		BYTE [di+DPT.bPchsHeads]; AL = LHead / PHeadCount, AH = LHead % PHeadCount
 17740 00000FD8 88E7                <1> 	mov		bh, ah					; Copy P-CHS Head number to BH
 17741 00000FDA 30E4                <1> 	xor		ah, ah					; AX = LHead / PHeadCount
 17742                              <1> 
 17743                              <1> 	; (LCylinder << n) + (LHead / PHeadCount)
 17744 00000FDC 89CA                <1> 	mov		dx, cx					; Copy L-CHS Cylinder number to DX
 17745 00000FDE 8A0D                <1> 	mov		cl, [di+DPT.bFlagsLow]	; Load shift count
 17746 00000FE0 80E103              <1> 	and		cl, MASKL_DPT_CHS_SHIFT_COUNT
 17747 00000FE3 D3E2                <1> 	shl		dx, cl					; DX = LCylinder << n
 17748 00000FE5 01D0                <1> 	add		ax, dx					; AX = P-CHS Cylinder number
 17749 00000FE7 91                  <1> 	xchg	cx, ax					; Move P-CHS Cylinder number to CX
 17750                              <1> DoNotConvertLCHS:
 17751 00000FE8 C3                  <1> 	ret
 17752                              <1> 
 17753                              <1> 
 17754                              <1> ;--------------------------------------------------------------------
 17755                              <1> ; Address_OldInt13hAddressToIdeAddress
 17756                              <1> ;	Parameters:
 17757                              <1> ;		CH:		Cylinder number, bits 7...0
 17758                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 17759                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 17760                              <1> ;		DH:		Starting head number (0...255)
 17761                              <1> ;		DS:DI:	Ptr to DPT
 17762                              <1> ;	Returns:
 17763                              <1> ;		BL:		LBA Low Register / Sector Number Register (LBA 7...0)
 17764                              <1> ;		CL:		LBA Mid Register / Low Cylinder Register (LBA 15...8)
 17765                              <1> ;		CH:		LBA High Register / High Cylinder Register (LBA 23...16)
 17766                              <1> ;		BH:		Drive and Head Register (LBA 27...24)
 17767                              <1> ;	Corrupts registers:
 17768                              <1> ;		AX, DX
 17769                              <1> ;--------------------------------------------------------------------
 17770                              <1> ALIGN JUMP_ALIGN
 17771                              <1> Address_OldInt13hAddressToIdeAddress:
 17772 00000FE9 E8D5FF              <1> 		call	Address_ExtractLCHSparametersFromOldInt13hAddress
 17773                              <1> 		ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF
 17774 00000FEC 8A05                <2>  mov al, [di+DPT.bFlagsLow]
 17775 00000FEE 83E00C              <2>  and ax, BYTE MASKL_DPT_TRANSLATEMODE
 17776                              <1> 
 17777                              <1> ;;; 0: ADDRESSING_MODE_NORMAL
 17778 00000FF1 74F5                <1> 		jz		SHORT DoNotConvertLCHS
 17779                              <1> 
 17780                              <1> ;;; 1: ADDRESSING_MODE_LARGE
 17781 00000FF3 A808                <1> 		test	al, FLGL_DPT_ASSISTED_LBA
 17782 00000FF5 74DA                <1> 		jz		SHORT ConvertLargeModeLCHStoPCHS
 17783                              <1> 
 17784                              <1> ;;; 2: ADDRESSING_MODE_ASSISTED_LBA
 17785                              <1> 		; Fall through to ConvertAssistedLBAModeLCHStoLBARegisterValues
 17786                              <1> 
 17787                              <1> 
 17788                              <1> ;---------------------------------------------------------------------
 17789                              <1> ; Converts LCHS parameters to 28-bit LBA address.
 17790                              <1> ; Only 24-bits are used since LHCS to LBA28 conversion has 8.4GB limit.
 17791                              <1> ; LBA = ((cylToSeek*headsPerCyl+headToSeek)*sectPerTrack)+sectToSeek-1
 17792                              <1> ;
 17793                              <1> ; Returned address is in same registers that
 17794                              <1> ; DoNotConvertLCHS and ConvertLargeModeLCHStoPCHS returns.
 17795                              <1> ;
 17796                              <1> ; ConvertAssistedLBAModeLCHStoLBARegisterValues:
 17797                              <1> ;	Parameters:
 17798                              <1> ;		BL:		Sector number (1...63)
 17799                              <1> ;		BH:		Head number (0...254)
 17800                              <1> ;		CX:		Cylinder number (0...1023)
 17801                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 17802                              <1> ;	Returns:
 17803                              <1> ;		BL:		LBA Low Register / Sector Number Register (LBA 7...0)
 17804                              <1> ;		CL:		LBA Mid Register / Low Cylinder Register (LBA 15...8)
 17805                              <1> ;		CH:		LBA High Register / High Cylinder Register (LBA 23...16)
 17806                              <1> ;		BH:		Drive and Head Register (LBA 27...24)
 17807                              <1> ;	Corrupts registers:
 17808                              <1> ;		AX, DX
 17809                              <1> ;--------------------------------------------------------------------
 17810                              <1> ConvertAssistedLBAModeLCHStoLBARegisterValues:
 17811                              <1> 	; cylToSeek*headsPerCyl (18-bit result)
 17812                              <1> 	; Max = 1023 * 255 = 260,865 = 3FB01h
 17813 00000FF7 B83F00              <1> 	mov		ax, LBA_ASSIST_SPT		; Load Sectors per Track
 17814 00000FFA 91                  <1> 	xchg	cx, ax					; Cylinder number to AX, Sectors per Track to CX
 17815                              <1> %ifdef USE_386
 17816                              <1> 	movzx	dx, [di+DPT.bLchsHeads]
 17817                              <1> %else
 17818 00000FFB 99                  <1> 	cwd
 17819 00000FFC 8A5508              <1> 	mov		dl, [di+DPT.bLchsHeads]
 17820                              <1> %endif
 17821 00000FFF F7E2                <1> 	mul		dx						; DX:AX = cylToSeek*headsPerCyl
 17822                              <1> 
 17823                              <1> 	; +=headToSeek (18-bit result)
 17824                              <1> 	; Max = 260,865 + 254 = 261,119 = 3FBFFh
 17825 00001001 00F8                <1> 	add		al, bh					; Add Head number to DX:AX
 17826 00001003 10F4                <1> 	adc		ah, dh					; DH = Zero after previous multiplication
 17827 00001005 10F2                <1> 	adc		dl, dh
 17828                              <1> 
 17829                              <1> 	; *=sectPerTrack (18-bit by 6-bit multiplication with 24-bit result)
 17830                              <1> 	; Max = 261,119 * 63 = 16,450,497 = FB03C1h
 17831 00001007 92                  <1> 	xchg	ax, dx					; Hiword to AX, loword to DX
 17832 00001008 F6E1                <1> 	mul		cl						; AX = hiword * Sectors per Track
 17833 0000100A 88C7                <1> 	mov		bh, al					; Backup hiword * Sectors per Track
 17834 0000100C 92                  <1> 	xchg	ax, dx					; Loword back to AX
 17835 0000100D F7E1                <1> 	mul		cx						; DX:AX = loword * Sectors per Track
 17836 0000100F 00FA                <1> 	add		dl, bh					; DX:AX = (cylToSeek*headsPerCyl+headToSeek)*sectPerTrack
 17837                              <1> 
 17838                              <1> 	; +=sectToSeek-1 (24-bit result)
 17839                              <1> 	; Max = 16,450,497 + 63 - 1 = 16,450,559 = FB03FFh
 17840 00001011 30FF                <1> 	xor		bh, bh					; Sector number now in BX
 17841 00001013 4B                  <1> 	dec		bx						; sectToSeek-=1
 17842 00001014 01D8                <1> 	add		ax, bx					; Add to loword
 17843 00001016 10FA                <1> 	adc		dl, bh					; Add possible carry to byte2, BH=zero
 17844                              <1> 
 17845                              <1> 	; Copy DX:AX to proper return registers
 17846 00001018 93                  <1> 	xchg	bx, ax					; BL = Sector Number Register (LBA 7...0)
 17847 00001019 88F9                <1> 	mov		cl, bh					; Low Cylinder Register (LBA 15...8)
 17848 0000101B 88D5                <1> 	mov		ch, dl					; High Cylinder Register (LBA 23...16)
 17849 0000101D 88F7                <1> 	mov		bh, dh					; Drive and Head Register (LBA 27...24)
 17850 0000101F C3                  <1> 	ret
 17851                                  	%include "Prepare.asm"			; For buffer pointer normalization
 17852                              <1> ; Project name	:	XTIDE Universal BIOS
 17853                              <1> ; Description	:	Functions for preparing data buffer for transfer.
 17854                              <1> 
 17855                              <1> ;
 17856                              <1> ; XTIDE Universal BIOS and Associated Tools
 17857                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17858                              <1> ;
 17859                              <1> ; This program is free software; you can redistribute it and/or modify
 17860                              <1> ; it under the terms of the GNU General Public License as published by
 17861                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17862                              <1> ; (at your option) any later version.
 17863                              <1> ;
 17864                              <1> ; This program is distributed in the hope that it will be useful,
 17865                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17866                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17867                              <1> ; GNU General Public License for more details.
 17868                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17869                              <1> ;
 17870                              <1> 
 17871                              <1> ; Section containing code
 17872                              <1> SECTION .text
 17873                              <1> 
 17874                              <1> ;--------------------------------------------------------------------
 17875                              <1> ; Prepare_ByLoadingDapToESSIandVerifyingForTransfer
 17876                              <1> ;	Parameters:
 17877                              <1> ;		SI:		Offset to DAP
 17878                              <1> ;		DS:DI:	Ptr to DPT
 17879                              <1> ;		SS:BP:	Ptr to IDEPACK
 17880                              <1> ;	Parameters on INTPACK:
 17881                              <1> ;		DS:SI:	Ptr to Disk Address Packet
 17882                              <1> ;	Returns:
 17883                              <1> ;		BX:		Index to command lookup table
 17884                              <1> ;		ES:SI:	Ptr to Disk Address Packet (DAP)
 17885                              <1> ;		Exits from INT 13h if invalid DAP
 17886                              <1> ;	Corrupts registers:
 17887                              <1> ;		AX, DX
 17888                              <1> ;--------------------------------------------------------------------
 17889                              <1> %ifdef MODULE_EBIOS
 17890                              <1> ALIGN JUMP_ALIGN
 17891                              <1> Prepare_ByLoadingDapToESSIandVerifyingForTransfer:
 17892                              <1> 	; Load pointer to DAP to ES:SI and make sure it is valid
 17893                              <1> 	mov		es, [bp+IDEPACK.intpack+INTPACK.ds]	; ES:SI to point Disk Address Packet
 17894                              <1> 	cmp		BYTE [es:si+DAP.bSize], MINIMUM_DAP_SIZE
 17895                              <1> 	jb		SHORT InvalidDAP
 17896                              <1> 
 17897                              <1> 	; Make sure that sector count is valid
 17898                              <1> 	mov		ax, [es:si+DAP.wSectorCount]
 17899                              <1> 	test	ax, ax
 17900                              <1> 	jz		SHORT ZeroSectorsRequestedSoNoErrors
 17901                              <1> 	cmp		ax, BYTE 127
 17902                              <1> 	ja		SHORT InvalidNumberOfSectorsRequested
 17903                              <1> 
 17904                              <1> 	; Get EBIOS command index to BX
 17905                              <1> 	; LBA28 or LBA48 command
 17906                              <1> 	call	Prepare_GetOldInt13hCommandIndexToBX
 17907                              <1> 	mov		al, [di+DPT.bFlagsLow]
 17908                              <1> 	eSHL_IM	al, 1					; Set CF if LBA48 supported
 17909                              <1> 	adc		bl, bh					; LBA48 EXT commands
 17910                              <1> 	ret
 17911                              <1> %endif ; MODULE_EBIOS
 17912                              <1> 
 17913                              <1> 
 17914                              <1> ;--------------------------------------------------------------------
 17915                              <1> ; Prepare_GetOldInt13hCommandIndexToBX
 17916                              <1> ;	Parameters:
 17917                              <1> ;		DS:DI:	Ptr to DPT
 17918                              <1> ;	Returns:
 17919                              <1> ;		BX:		Index to command lookup table
 17920                              <1> ;	Corrupts registers:
 17921                              <1> ;		Nothing
 17922                              <1> ;--------------------------------------------------------------------
 17923                              <1> ALIGN JUMP_ALIGN
 17924                              <1> Prepare_GetOldInt13hCommandIndexToBX:
 17925                              <1> 	; Block mode or single sector
 17926 00001020 8A5D01              <1> 	mov		bl, [di+DPT.bFlagsHigh]
 17927 00001023 83E302              <1> 	and		bx, BYTE FLGH_DPT_BLOCK_MODE_SUPPORTED	; Bit 1
 17928 00001026 C3                  <1> 	ret
 17929                              <1> 
 17930                              <1> 
 17931                              <1> ;---------------------------------------------------------------------
 17932                              <1> ; Prepare_BufferToESSIforOldInt13hTransfer
 17933                              <1> ;	Parameters:
 17934                              <1> ;		AL:		Number of sectors to transfer
 17935                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17936                              <1> ;		SS:BP:	Ptr to IDEPACK
 17937                              <1> ;	Parameters on INTPACK:
 17938                              <1> ;		ES:BX:	Ptr to data buffer
 17939                              <1> ;	Returns:
 17940                              <1> ;		ES:SI:	Ptr to normalized data buffer
 17941                              <1> ;		Exits INT 13h if error
 17942                              <1> ;	Corrupts registers:
 17943                              <1> ;		BX
 17944                              <1> ;--------------------------------------------------------------------
 17945                              <1> ALIGN JUMP_ALIGN
 17946                              <1> Prepare_BufferToESSIforOldInt13hTransfer:
 17947 00001027 8B7615              <1> 	mov		si, [bp+IDEPACK.intpack+INTPACK.bx]	; Load offset
 17948 0000102A 8E4609              <1> 	mov		es, [bp+IDEPACK.intpack+INTPACK.es]	; Load segment
 17949                              <1> 	; Fall to Prepare_ByValidatingSectorsInALforOldInt13h
 17950                              <1> 
 17951                              <1> ;---------------------------------------------------------------------
 17952                              <1> ; Prepare_ByValidatingSectorsInALforOldInt13h
 17953                              <1> ;	Parameters:
 17954                              <1> ;		AL:		Number of sectors to transfer
 17955                              <1> ;	Returns:
 17956                              <1> ;		Exits INT 13h if invalid number of sectors in AL
 17957                              <1> ;	Corrupts registers:
 17958                              <1> ;		Nothing
 17959                              <1> ;--------------------------------------------------------------------
 17960                              <1> Prepare_ByValidatingSectorsInALforOldInt13h:
 17961 0000102D 84C0                <1> 	test	al, al
 17962 0000102F 781A                <1> 	js		SHORT .CheckZeroOffsetFor128Sectors		; 128 or more
 17963 00001031 7421                <1> 	jz		SHORT InvalidNumberOfSectorsRequested	; Zero not allowed for old INT 13h
 17964 00001033 C3                  <1> 	ret		; Continue with transfer
 17965                              <1> 
 17966                              <1> ALIGN JUMP_ALIGN
 17967                              <1> .CheckZeroOffsetFor128Sectors:
 17968 00001034 3C80                <1> 	cmp		al, 128
 17969 00001036 771C                <1> 	ja		SHORT InvalidNumberOfSectorsRequested
 17970 00001038 85F6                <1> 	test	si, si								; Offset must be zero to xfer 128 sectors
 17971 0000103A 751B                <1> 	jnz		SHORT CannotAlignPointerProperly
 17972 0000103C C3                  <1> 	ret		; Continue with transfer
 17973                              <1> 
 17974                              <1> InvalidDAP:
 17975                              <1> InvalidNumberOfSectorsRequested:
 17976                              <1> Prepare_ReturnFromInt13hWithInvalidFunctionError:
 17977 0000103D B401                <1> 	mov		ah, RET_HD_INVALID
 17978                              <1> 	SKIP2B	f
 17979                              <2>  %ifidni %1, f
 17980 0000103F 3D                  <2>  db 03Dh
 17981                              <2> 
 17982                              <2>  %elifidni %1, ax
 17983                              <2>  db 0B8h
 17984                              <2>  %elifidni %1, cx
 17985                              <2>  db 0B9h
 17986                              <2>  %elifidni %1, dx
 17987                              <2>  db 0BAh
 17988                              <2>  %elifidni %1, bx
 17989                              <2>  db 0BBh
 17990                              <2>  %elifidni %1, sp
 17991                              <2>  db 0BCh
 17992                              <2>  %elifidni %1, bp
 17993                              <2>  db 0BDh
 17994                              <2>  %elifidni %1, si
 17995                              <2>  db 0BEh
 17996                              <2>  %elifidni %1, di
 17997                              <2>  db 0BFh
 17998                              <2>  %else
 17999                              <2>  %error "Invalid parameter passed to SKIP2B"
 18000                              <2>  %endif
 18001                              <1> CannotAlignPointerProperly:
 18002 00001040 B409                <1> 	mov		ah, RET_HD_BOUNDARY
 18003                              <1> ZeroSectorsRequestedSoNoErrors:
 18004 00001042 E9B5FC              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 18005                              <1> 
 18006                              <1> 
 18007                              <1> 
 18008                              <1> ; Command lookup tables
 18009                              <1> g_rgbReadCommandLookup:
 18010 00001045 20                  <1> 	db		COMMAND_READ_SECTORS		; 00b, CHS or LBA28 single sector
 18011 00001046 24                  <1> 	db		COMMAND_READ_SECTORS_EXT	; 01b, LBA48 single sector
 18012 00001047 C4                  <1> 	db		COMMAND_READ_MULTIPLE		; 10b, CHS or LBA28 block mode
 18013                              <1> %ifdef MODULE_EBIOS
 18014                              <1> 	db		COMMAND_READ_MULTIPLE_EXT	; 11b, LBA48 block mode
 18015                              <1> %endif
 18016                              <1> 
 18017                              <1> g_rgbWriteCommandLookup:
 18018 00001048 30                  <1> 	db		COMMAND_WRITE_SECTORS
 18019 00001049 34                  <1> 	db		COMMAND_WRITE_SECTORS_EXT
 18020 0000104A C5                  <1> 	db		COMMAND_WRITE_MULTIPLE
 18021                              <1> %ifdef MODULE_EBIOS
 18022                              <1> 	db		COMMAND_WRITE_MULTIPLE_EXT
 18023                              <1> %endif
 18024                              <1> 
 18025                              <1> g_rgbVerifyCommandLookup:
 18026 0000104B 40                  <1> 	db		COMMAND_VERIFY_SECTORS
 18027 0000104C 42                  <1> 	db		COMMAND_VERIFY_SECTORS_EXT
 18028 0000104D 40                  <1> 	db		COMMAND_VERIFY_SECTORS
 18029                              <1> %ifdef MODULE_EBIOS
 18030                              <1> 	db		COMMAND_VERIFY_SECTORS_EXT
 18031                              <1> %endif
 18032                                  %ifdef MODULE_EBIOS
 18033                                  	%include "AH42h_ExtendedReadSectors.asm"
 18034                                  	%include "AH43h_ExtendedWriteSectors.asm"
 18035                                  	%include "AH44h_ExtendedVerifySectors.asm"
 18036                                  	%include "AH47h_ExtendedSeek.asm"
 18037                                  	%include "AH48h_GetExtendedDriveParameters.asm"
 18038                                  	%include "AH41h_CheckIfExtensionsPresent.asm"
 18039                                  %endif
