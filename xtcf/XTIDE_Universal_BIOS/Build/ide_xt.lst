     1                                  ; Project name	:	XTIDE Universal BIOS
     2                                  ; Authors		:	Tomi Tilli
     3                                  ;				:	aitotat@gmail.com
     4                                  ;				:
     5                                  ;				:	Greg Lindhorst
     6                                  ;				:	gregli@hotmail.com
     7                                  ;				;
     8                                  ;				:	Krister Nordvall
     9                                  ;				:	krille_n_@hotmail.com
    10                                  ;				:
    11                                  ; Description	:	Main file for BIOS. This is the only file that needs
    12                                  ;					to be compiled since other files are included to this
    13                                  ;					file (so no linker needed, Nasm does it all).
    14                                  
    15                                  ;
    16                                  ; XTIDE Universal BIOS and Associated Tools
    17                                  ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
    18                                  ;
    19                                  ; This program is free software; you can redistribute it and/or modify
    20                                  ; it under the terms of the GNU General Public License as published by
    21                                  ; the Free Software Foundation; either version 2 of the License, or
    22                                  ; (at your option) any later version.
    23                                  ;
    24                                  ; This program is distributed in the hope that it will be useful,
    25                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    26                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    27                                  ; GNU General Public License for more details.
    28                                  ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    29                                  ;
    30                                  
    31                                  	ORG 0							; Code start offset 0000h
    32                                  
    33                                  	; We must define included libraries before including "AssemblyLibrary.inc".
    34                                  %define	EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS	; Exclude unused library functions
    35                                  %ifdef MODULE_BOOT_MENU
    36                                  	%define MENUEVENT_INLINE_OFFSETS    	; Only one menu required, save space and inline offsets
    37                                  	%define INCLUDE_MENU_LIBRARY
    38                                  	%define MENU_NO_ESC					    ; User cannot 'esc' out of the menu
    39                                  %else	; If no boot menu included
    40                                  	%define	INCLUDE_DISPLAY_LIBRARY
    41                                  	%define INCLUDE_KEYBOARD_LIBRARY
    42                                  	%define INCLUDE_TIME_LIBRARY
    43                                  %endif
    44                                  
    45                                  
    46                                  	; Included .inc files
    47                                  	%include "AssemblyLibrary.inc"	; Assembly Library. Must be included first!
     1                              <1> ; Project name	:	Assembly Library
     2                              <1> ; Description	:	Common defines for all library functions.
     3                              <1> %ifndef ASSEMBLY_LIBRARY_INC
     4                              <1> %define ASSEMBLY_LIBRARY_INC
     5                              <1> 
     6                              <1> ; Include .inc files
     7                              <1> %include "Emulate.inc"			; Must be included first!
     1                              <2> ; Project name	:	Emulation library
     2                              <2> ; Description	:	Macros for emulating later x86 instructions with older
     3                              <2> ;					processors.
     4                              <2> ;					Macros are used so optimized builds can be done
     5                              <2> ;					easily for different processors.
     6                              <2> ;
     7                              <2> ;					This file must be first to be included to
     8                              <2> ;					any source file.
     9                              <2> %ifndef EMULATE_INC
    10                              <2> %define EMULATE_INC
    11                              <2> 
    12                              <2> ; Defines for processor support (should be set in makefile).
    13                              <2> ; Unsupported instructions will be emulated using macros.
    14                              <2> ; If AT class PC is used (instead of XT), define USE_AT
    15                              <2> 
    16                              <2> ;%define USE_186				; Define to use 18x/V20/V30 instructions
    17                              <2> ;%define USE_286				; Define to use 286 instructions
    18                              <2> ;%define USE_386				; Define to use 386 instructions
    19                              <2> ;%define USE_AT					; Define for AT class machine
    20                              <2> 
    21                              <2> %ifdef USE_386
    22                              <2> 	%define USE_286				; Define to use 286 instructions
    23                              <2> %endif
    24                              <2> %ifdef USE_286
    25                              <2> 	%define USE_186				; Define to use 18x/V20/V30 instructions
    26                              <2> 	%define USE_UNDOC_INTEL		; Not supported by NEC V20/V30
    27                              <2> %endif
    28                              <2> 
    29                              <2> %ifdef USE_386
    30                              <2> 	CPU 386						; Allow instructions up to 386
    31                              <2> %elifdef USE_286
    32                              <2> 	CPU 286						; Allow instructions up to 286
    33                              <2> %elifdef USE_186
    34                              <2> 	CPU 186						; Allow instructions up to 188/186/V20/V30
    35                              <2> %else
    36                              <2> 	CPU 8086					; Allow 8088/8086 instructions only
    37                              <2> %endif
    38                              <2> 
    39                              <2> BITS 16							; Set 16 bit code generation
    40                              <2> 
    41                              <2> ; Alignments for jump targets.
    42                              <2> ; Following values are optimal for different processor types:
    43                              <2> ; 286 and 386SX			WORD (16-bit, 2 bytes)
    44                              <2> ; 386DX and 486			DWORD (32-bit, 4 bytes)
    45                              <2> ; Pentium and later		QWORD (64-bit, 8 bytes)
    46                              <2> %ifdef USE_AT
    47                              <2> 	%ifdef USE_386
    48                              <2> 		JUMP_ALIGN		EQU		4
    49                              <2> 		WORD_ALIGN		EQU		2
    50                              <2> 	%else ; USE_286
    51                              <2> 		JUMP_ALIGN		EQU		2
    52                              <2> 		WORD_ALIGN		EQU		2
    53                              <2> 	%endif
    54                              <2> %else ; XT
    55                              <2> 	JUMP_ALIGN		EQU		1
    56                              <2> 	WORD_ALIGN		EQU		1
    57                              <2> %endif
    58                              <2> 
    59                              <2> ;==========================================================================
    60                              <2> 
    61                              <2> ;--------------------------------------------------------------------
    62                              <2> ; The undocumented instruction SALC (Set AL According to CF).
    63                              <2> ; Available on all Intel processors and truly compatible clones.
    64                              <2> ; Does not work on the NEC V20/V30 or Sony CXQ70108 processors.
    65                              <2> ;
    66                              <2> ; eSALC
    67                              <2> ;	Parameters:
    68                              <2> ;		Nothing
    69                              <2> ;	Returns:
    70                              <2> ;		AL:		FFh if CF=1
    71                              <2> ;				00h if CF=0
    72                              <2> ;	Corrupts registers:
    73                              <2> ;		Nothing
    74                              <2> ;--------------------------------------------------------------------
    75                              <2> %macro eSALC 0
    76                              <2> 	db		0D6h
    77                              <2> %endmacro
    78                              <2> 
    79                              <2> 
    80                              <2> ;--------------------------------------------------------------------
    81                              <2> ; The AAD instruction (ASCII Adjust before Division).
    82                              <2> ; Available on all Intel processors and truly compatible clones.
    83                              <2> ; Does not work on the NEC V20/V30 or Sony CXQ70108 processors
    84                              <2> ; unless %1 is 10 (0Ah).
    85                              <2> ;
    86                              <2> ; eAAD
    87                              <2> ;	Parameters:
    88                              <2> ;		%1:		Any 8 bit number (0...255)
    89                              <2> ;	Returns:
    90                              <2> ;		AL:		AH * %1 + AL
    91                              <2> ;		AH:		0
    92                              <2> ;		Flags:	Set according to result
    93                              <2> ;	Corrupts registers:
    94                              <2> ;		Nothing
    95                              <2> ;--------------------------------------------------------------------
    96                              <2> %macro eAAD 1
    97                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    98                              <2> 	%if %1 > 255
    99                              <2> 		%error Invalid parameter passed to eAAD (%1 > 255)
   100                              <2> 	%else
   101                              <2> 		db		0D5h, %1
   102                              <2> 	%endif
   103                              <2> %endif
   104                              <2> %endmacro
   105                              <2> 
   106                              <2> 
   107                              <2> ;--------------------------------------------------------------------
   108                              <2> ; The AAM instruction (ASCII Adjust after Multiplication).
   109                              <2> ; Available on all Intel processors and truly compatible clones.
   110                              <2> ; Does not work on the NEC V20/V30 or Sony CXQ70108 processors
   111                              <2> ; unless %1 is 10 (0Ah).
   112                              <2> ;
   113                              <2> ; eAAM
   114                              <2> ;	Parameters:
   115                              <2> ;		%1:		Any 8 bit number except 0 (1...255)
   116                              <2> ;	Returns:
   117                              <2> ;		AL:		AL MOD %1
   118                              <2> ;		AH:		AL / %1
   119                              <2> ;		Flags:	Set according to result
   120                              <2> ;	Corrupts registers:
   121                              <2> ;		Nothing
   122                              <2> ;--------------------------------------------------------------------
   123                              <2> %macro eAAM 1
   124                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   125                              <2> 	%if %1 > 255
   126                              <2> 		%error Invalid parameter passed to eAAM (%1 > 255)
   127                              <2> 	%elif %1 = 0
   128                              <2> 		%error Invalid parameter passed to eAAM (%1 = 0). This would cause a divide-by-zero exception!
   129                              <2> 	%else
   130                              <2> 		db		0D4h, %1
   131                              <2> 	%endif
   132                              <2> %endif
   133                              <2> %endmacro
   134                              <2> 
   135                              <2> 
   136                              <2> ;--------------------------------------------------------------------
   137                              <2> ; Emulates BSF (Bit Scan Forward) instruction when necessary.
   138                              <2> ; BSF is used to find index of least significant bit.
   139                              <2> ;
   140                              <2> ; eBSF
   141                              <2> ;	Parameters:
   142                              <2> ;		%1:		Destination WORD Register for bit index (not CX or same as %2!)
   143                              <2> ;		%2:		Source WORD operand where to search bit (not CX or same as %1!)
   144                              <2> ;	Returns:
   145                              <2> ;		%1:		Index of highest order bit from %2
   146                              <2> ;		ZF:		Set if %2 is zero
   147                              <2> ;				Cleared if %2 is non-zero
   148                              <2> ;	Corrupts registers:
   149                              <2> ;		Nothing
   150                              <2> ;--------------------------------------------------------------------
   151                              <2> %macro eBSF 2
   152                              <2> %ifndef USE_386
   153                              <2> 	push	cx
   154                              <2> 	cmp		WORD %2, BYTE 0		; Source operand is zero?
   155                              <2> 	je		SHORT %%Return		;  If so, return with ZF set
   156                              <2> 
   157                              <2> 	; Set destination to zero and load mask for bit 0
   158                              <2> 	xor		%1, %1
   159                              <2> 	mov		cx, 1
   160                              <2> 
   161                              <2> ALIGN JUMP_ALIGN
   162                              <2> %%BitLoop:
   163                              <2> 	test	%2, cx				; Bit set?
   164                              <2> 	jnz		SHORT %%Return		;  If so, return with ZF cleared
   165                              <2> 	shl		cx, 1				; Prepare to test next bit
   166                              <2> 	inc		%1					; Increment bit index
   167                              <2> 	jmp		SHORT %%BitLoop		; Loop until bit found
   168                              <2> %%Return:
   169                              <2> 	pop		cx
   170                              <2> ;-----------------------------------
   171                              <2> %else
   172                              <2> 	bsf		%1, %2
   173                              <2> %endif
   174                              <2> %endmacro
   175                              <2> 
   176                              <2> 
   177                              <2> ;--------------------------------------------------------------------
   178                              <2> ; Emulates BSR (Bit Scan Reverse) instruction when necessary.
   179                              <2> ; BSR is used to find index of most significant bit.
   180                              <2> ;
   181                              <2> ; eBSR
   182                              <2> ;	Parameters:
   183                              <2> ;		%1:		Destination WORD Register for bit index (not CX or same as %2!)
   184                              <2> ;		%2:		Source WORD operand where to search bit (not CX or same as %1!)
   185                              <2> ;	Returns:
   186                              <2> ;		%1:		Index of highest order bit from %2
   187                              <2> ;		ZF:		Set if %2 is zero
   188                              <2> ;				Cleared if %2 is non-zero
   189                              <2> ;	Corrupts registers:
   190                              <2> ;		Nothing
   191                              <2> ;--------------------------------------------------------------------
   192                              <2> %macro eBSR 2
   193                              <2> %ifndef USE_386
   194                              <2> 	push	cx
   195                              <2> 	cmp		WORD %2, BYTE 0		; Source operand is zero?
   196                              <2> 	je		SHORT %%Return		;  If so, return with ZF set
   197                              <2> 
   198                              <2> 	; Load mask for highest order bit
   199                              <2> 	mov		cx, 1<<15
   200                              <2> 	mov		%1, 15
   201                              <2> 
   202                              <2> ALIGN JUMP_ALIGN
   203                              <2> %%BitLoop:
   204                              <2> 	test	%2, cx				; Bit set?
   205                              <2> 	jnz		SHORT %%Return		;  If so, return with ZF cleared
   206                              <2> 	shr		cx, 1				; Prepare to test next bit
   207                              <2> 	dec		%1					; Decrement bit index
   208                              <2> 	jmp		SHORT %%BitLoop		; Loop until bit found
   209                              <2> %%Return:
   210                              <2> 	pop		cx
   211                              <2> ;-----------------------------------
   212                              <2> %else
   213                              <2> 	bsr		%1, %2
   214                              <2> %endif
   215                              <2> %endmacro
   216                              <2> 
   217                              <2> 
   218                              <2> ;--------------------------------------------------------------------
   219                              <2> ; Conditional Move.
   220                              <2> ;
   221                              <2> ; eCMOVcc
   222                              <2> ;	Parameters:
   223                              <2> ;		%1:		Destination data
   224                              <2> ;		%2:		Source data
   225                              <2> ;	Returns:
   226                              <2> ;		Nothing
   227                              <2> ;	Corrupts registers:
   228                              <2> ;		Nothing
   229                              <2> ;--------------------------------------------------------------------
   230                              <2> %macro eCMOVA 2
   231                              <2> 	jbe		SHORT %%Return
   232                              <2> 	mov		%1, %2
   233                              <2> %%Return:
   234                              <2> %endmacro
   235                              <2> 
   236                              <2> %macro eCMOVC 2
   237                              <2> 	jnc		SHORT %%Return
   238                              <2> 	mov		%1, %2
   239                              <2> %%Return:
   240                              <2> %endmacro
   241                              <2> 
   242                              <2> %macro eCMOVNC 2
   243                              <2> 	jc		SHORT %%Return
   244                              <2> 	mov		%1, %2
   245                              <2> %%Return:
   246                              <2> %endmacro
   247                              <2> 
   248                              <2> %macro eCMOVZ 2
   249                              <2> 	jnz		SHORT %%Return
   250                              <2> 	mov		%1, %2
   251                              <2> %%Return:
   252                              <2> %endmacro
   253                              <2> 
   254                              <2> %macro eCMOVNZ 2
   255                              <2> 	jz		SHORT %%Return
   256                              <2> 	mov		%1, %2
   257                              <2> %%Return:
   258                              <2> %endmacro
   259                              <2> 
   260                              <2> %macro eCMOVE 2
   261                              <2> 	eCMOVZ %1, %2
   262                              <2> %endmacro
   263                              <2> 
   264                              <2> %macro eCMOVNE 2
   265                              <2> 	eCMOVNZ %1, %2
   266                              <2> %endmacro
   267                              <2> 
   268                              <2> %macro eCMOVB 2
   269                              <2> 	jnb		SHORT %%Return
   270                              <2> 	mov		%1, %2
   271                              <2> %%Return:
   272                              <2> %endmacro
   273                              <2> 
   274                              <2> %macro eCMOVS 2
   275                              <2> 	jns		SHORT %%Return
   276                              <2> 	mov		%1, %2
   277                              <2> %%Return:
   278                              <2> %endmacro
   279                              <2> 
   280                              <2> %macro eCMOVNS 2
   281                              <2> 	js		SHORT %%Return
   282                              <2> 	mov		%1, %2
   283                              <2> %%Return:
   284                              <2> %endmacro
   285                              <2> 
   286                              <2> 
   287                              <2> ;--------------------------------------------------------------------
   288                              <2> ; Conditional Set.
   289                              <2> ;
   290                              <2> ; eCSETcc
   291                              <2> ;	Parameters:
   292                              <2> ;		%1:		Destination data
   293                              <2> ;	Returns:
   294                              <2> ;		Nothing
   295                              <2> ;	Corrupts registers:
   296                              <2> ;		Flags
   297                              <2> ;--------------------------------------------------------------------
   298                              <2> %macro eCSETZ 1
   299                              <2> 	mov		%1, 0			; Clear while preserving flags
   300                              <2> 	jnz		SHORT %%Return	; Nothing to set
   301                              <2> 	inc		%1
   302                              <2> %%Return:
   303                              <2> %endmacro
   304                              <2> 
   305                              <2> 
   306                              <2> ;--------------------------------------------------------------------
   307                              <2> ; Moves byte with zero-extending to any Register.
   308                              <2> ;
   309                              <2> ; eMOVZX
   310                              <2> ;	Parameters:
   311                              <2> ;		%1:		Destination Register (SP not supported)
   312                              <2> ;		%2:		Byte register or byte address
   313                              <2> ;	Returns:
   314                              <2> ;		Nothing
   315                              <2> ;	Corrupts registers:
   316                              <2> ;		FLAGS
   317                              <2> ;--------------------------------------------------------------------
   318                              <2> %macro eMOVZX 2
   319                              <2> %ifndef USE_386
   320                              <2> 	%ifidni %1, ax
   321                              <2> 		mov		al, %2
   322                              <2> 		xor		ah, ah
   323                              <2> 	%elifidni %1, bx
   324                              <2> 		mov		bl, %2
   325                              <2> 		xor		bh, bh		; %2 may use BX in effective address
   326                              <2> 	%elifidni %1, cx
   327                              <2> 		mov		cl, %2
   328                              <2> 		xor		ch, ch
   329                              <2> 	%elifidni %1, dx
   330                              <2> 		mov		dl, %2
   331                              <2> 		xor		dh, dh
   332                              <2> 	%else	; SI, DI, BP (all may be used in effective address)
   333                              <2> 		push	ax
   334                              <2> 		mov		al, %2
   335                              <2> 		xor		ah, ah
   336                              <2> 		xchg	ax, %1
   337                              <2> 		pop		ax
   338                              <2> 	%endif
   339                              <2> ;-----------------------------------
   340                              <2> %else
   341                              <2> 	movzx	%1, %2
   342                              <2> %endif
   343                              <2> %endmacro
   344                              <2> 
   345                              <2> 
   346                              <2> ;--------------------------------------------------------------------
   347                              <2> ; Emulates PUSHA instruction when necessary.
   348                              <2> ;
   349                              <2> ; ePUSHA
   350                              <2> ;	Parameters:
   351                              <2> ;		Nothing
   352                              <2> ;	Returns:
   353                              <2> ;		Nothing
   354                              <2> ;	Corrupts registers:
   355                              <2> ;		Nothing
   356                              <2> ;--------------------------------------------------------------------
   357                              <2> %macro ePUSHA 0
   358                              <2> %ifndef USE_186
   359                              <2> 	push	ax
   360                              <2> 	push	cx
   361                              <2> 	push	dx
   362                              <2> 	push	bx
   363                              <2> 	push	sp
   364                              <2> 	push	bp
   365                              <2> 	push	si
   366                              <2> 	push	di
   367                              <2> ;-----------------------------------
   368                              <2> %else
   369                              <2> 	pusha
   370                              <2> %endif
   371                              <2> %endmacro
   372                              <2> 
   373                              <2> 
   374                              <2> ;--------------------------------------------------------------------
   375                              <2> ; Emulates POPA instruction when necessary.
   376                              <2> ;
   377                              <2> ; ePOPA
   378                              <2> ;	Parameters:
   379                              <2> ;		Nothing
   380                              <2> ;	Returns:
   381                              <2> ;		Nothing
   382                              <2> ;	Corrupts registers:
   383                              <2> ;		Nothing
   384                              <2> ;--------------------------------------------------------------------
   385                              <2> %macro ePOPA 0
   386                              <2> %ifndef USE_186
   387                              <2> 	pop		di
   388                              <2> 	pop		si
   389                              <2> 	pop		bp
   390                              <2> 	pop		ax		; Skip SP
   391                              <2> 	pop		bx
   392                              <2> 	pop		dx
   393                              <2> 	pop		cx
   394                              <2> 	pop		ax
   395                              <2> ;-----------------------------------
   396                              <2> %else
   397                              <2> 	popa
   398                              <2> %endif
   399                              <2> %endmacro
   400                              <2> 
   401                              <2> 
   402                              <2> ;--------------------------------------------------------------------
   403                              <2> ; Emulates ENTER instruction when necessary.
   404                              <2> ;
   405                              <2> ; eENTER
   406                              <2> ;	Parameters:
   407                              <2> ;		%1:		Number of bytes to reserve from stack
   408                              <2> ;		%2:		The lexical nesting level (not emulated, set to 0)
   409                              <2> ;	Returns:
   410                              <2> ;		SS:BP:	Ptr to old BP
   411                              <2> ;				([bp-2] points to highest local stack frame word)
   412                              <2> ;	Corrupts registers:
   413                              <2> ;		FLAGS
   414                              <2> ;--------------------------------------------------------------------
   415                              <2> %macro eENTER 2
   416                              <2> %ifndef USE_186
   417                              <2> 	push	bp
   418                              <2> 	mov		bp, sp
   419                              <2> 	sub		sp, %1
   420                              <2> ;-----------------------------------
   421                              <2> %else
   422                              <2> 	enter	%1, %2
   423                              <2> %endif
   424                              <2> %endmacro
   425                              <2> 
   426                              <2> ;--------------------------------------------------------------------
   427                              <2> ; Emulates LEAVE instruction when necessary.
   428                              <2> ;
   429                              <2> ; eLEAVE
   430                              <2> ;	Parameters:
   431                              <2> ;		Nothing
   432                              <2> ;	Returns:
   433                              <2> ;		BP:		What it was before eENTER
   434                              <2> ;	Corrupts registers:
   435                              <2> ;		Nothing
   436                              <2> ;--------------------------------------------------------------------
   437                              <2> %macro eLEAVE 0
   438                              <2> %ifndef USE_186
   439                              <2> 	mov		sp, bp
   440                              <2> 	pop		bp
   441                              <2> ;-----------------------------------
   442                              <2> %else
   443                              <2> 	leave
   444                              <2> %endif
   445                              <2> %endmacro
   446                              <2> 
   447                              <2> 
   448                              <2> ;--------------------------------------------------------------------
   449                              <2> ; Emulates LSS instruction when necessary.
   450                              <2> ;
   451                              <2> ; eLSS
   452                              <2> ;	Parameters:
   453                              <2> ;		%1:		Destination register
   454                              <2> ;		%2:		Source memory address without brackets
   455                              <2> ;	Returns:
   456                              <2> ;		IF:		0 (interrupts disabled)
   457                              <2> ;	Corrupts registers:
   458                              <2> ;		Nothing
   459                              <2> ;--------------------------------------------------------------------
   460                              <2> %macro eLSS 2
   461                              <2> %ifndef USE_386
   462                              <2> 	cli							; Disable interrupts
   463                              <2> 	mov		%1, [%2]			; Load offset
   464                              <2> 	mov		ss, [%2+2]			; Load segment
   465                              <2> ;-----------------------------------
   466                              <2> %else
   467                              <2> 	lss		%1, [%2]
   468                              <2> %endif
   469                              <2> %endmacro
   470                              <2> 
   471                              <2> 
   472                              <2> ;--------------------------------------------------------------------
   473                              <2> ; Repeats string instruction with segment override.
   474                              <2> ; This macro prevents 8088/8086 restart bug.
   475                              <2> ;
   476                              <2> ; eSEG_STR
   477                              <2> ;	Parameters:
   478                              <2> ;		%1:		REP/REPNE or REPE prefix
   479                              <2> ;		%2:		Source segment override (destination is always ES)
   480                              <2> ;		%3:		String instruction
   481                              <2> ;		CX:		Repeat count
   482                              <2> ;	Returns:
   483                              <2> ;		FLAGS for cmps and scas only
   484                              <2> ;	Corrupts registers:
   485                              <2> ;		Nothing
   486                              <2> ;--------------------------------------------------------------------
   487                              <2> %macro eSEG_STR 3
   488                              <2> %ifndef USE_186	; 8088/8086 has string instruction restart bug when more than one prefix
   489                              <2> 	%%Loop:
   490                              <2> 		%1						; REP is the prefix that can be lost
   491                              <2> 		%2						; SEG is the prefix that won't be lost
   492                              <2> 		%3						; String instruction
   493                              <2> 		jcxz	%%End			; Jump to end if no repeats left (preserves FLAGS)
   494                              <2> 		jmp		SHORT %%Loop	; Loop while repeats left
   495                              <2> 	%%End:
   496                              <2> %else	; No bug on V20/V30 and later, don't know about 188/186
   497                              <2> 	%2
   498                              <2> 	%1 %3
   499                              <2> %endif
   500                              <2> %endmacro
   501                              <2> 
   502                              <2> 
   503                              <2> ;--------------------------------------------------------------------
   504                              <2> ; Bit shifts and rotates with immediate.
   505                              <2> ;
   506                              <2> ; eSHIFT_IM
   507                              <2> ;	Parameters:
   508                              <2> ;		%1:		Shift target
   509                              <2> ;		%2:		Number of bits to shift
   510                              <2> ;		%3:		Instruction (SHL, SHR, ROL, ROR, RCL, RCR)
   511                              <2> ;	Returns:
   512                              <2> ;		FLAGS
   513                              <2> ;	Corrupts registers:
   514                              <2> ;		Nothing
   515                              <2> ;--------------------------------------------------------------------
   516                              <2> %macro eSHIFT_IM 3
   517                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   518                              <2> %ifndef USE_186
   519                              <2> 	%ifidni %1, cl
   520                              <2> 		times %2	%3		%1, 1
   521                              <2> 	%elifidni %1, ch
   522                              <2> 		times %2	%3		%1, 1
   523                              <2> 	%elifidni %1, cx
   524                              <2> 		times %2	%3		%1, 1
   525                              <2> 	%else
   526                              <2> 		%if %2 > 3	; Size optimized value
   527                              <2> 			push	cx
   528                              <2> 			mov		cl, %2
   529                              <2> 			%3		%1, cl
   530                              <2> 			pop		cx
   531                              <2> 		%else
   532                              <2> 			times %2	%3		%1, 1
   533                              <2> 		%endif
   534                              <2> 	%endif
   535                              <2> ;-----------------------------------
   536                              <2> %else
   537                              <2> 	%3		%1, %2
   538                              <2> %endif
   539                              <2> %endif
   540                              <2> %endmacro
   541                              <2> 
   542                              <2> %macro eSHR_IM 2
   543                              <2> 	eSHIFT_IM	%1, %2, shr
   544                              <2> %endmacro
   545                              <2> 
   546                              <2> %macro eSHL_IM 2
   547                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   548                              <2> %ifdef USE_386
   549                              <2> 	%if %2 = 1
   550                              <2> 		add		%1, %1	; Same size but faster on 386 and 486. Fails if %1 is a memory operand.
   551                              <2> 	%else
   552                              <2> 		eSHIFT_IM	%1, %2, shl
   553                              <2> 	%endif
   554                              <2> %else
   555                              <2> 	eSHIFT_IM	%1, %2, shl
   556                              <2> %endif
   557                              <2> %endif
   558                              <2> %endmacro
   559                              <2> 
   560                              <2> %macro eROR_IM 2
   561                              <2> 	eSHIFT_IM	%1, %2, ror
   562                              <2> %endmacro
   563                              <2> 
   564                              <2> %macro eROL_IM 2
   565                              <2> 	eSHIFT_IM	%1, %2, rol
   566                              <2> %endmacro
   567                              <2> 
   568                              <2> %macro eRCR_IM 2
   569                              <2> 	eSHIFT_IM	%1, %2, rcr
   570                              <2> %endmacro
   571                              <2> 
   572                              <2> %macro eRCL_IM 2
   573                              <2> 	eSHIFT_IM	%1, %2, rcl
   574                              <2> %endmacro
   575                              <2> 
   576                              <2> 
   577                              <2> ;--------------------------------------------------------------------
   578                              <2> ; Emulates PUSH imm instruction when necessary.
   579                              <2> ;
   580                              <2> ; ePUSH_I
   581                              <2> ;	Parameters:
   582                              <2> ;		%1:		Immediate to push
   583                              <2> ;	Returns:
   584                              <2> ;		Nothing
   585                              <2> ;	Corrupts registers:
   586                              <2> ;		Nothing
   587                              <2> ;--------------------------------------------------------------------
   588                              <2> %macro ePUSH_I 1
   589                              <2> %ifndef USE_186
   590                              <2> 	push	bp					; Immediate goes here
   591                              <2> 	push	bp
   592                              <2> 	mov		bp, sp
   593                              <2> 	mov		WORD [bp+2], %1
   594                              <2> 	pop		bp
   595                              <2> ;-----------------------------------
   596                              <2> %else
   597                              <2> 	push	%1
   598                              <2> %endif
   599                              <2> %endmacro
   600                              <2> 
   601                              <2> 
   602                              <2> ;--------------------------------------------------------------------
   603                              <2> ; Emulates PUSH imm instruction when necessary.
   604                              <2> ; ePUSH_T uses temporary register for faster performance
   605                              <2> ; and smaller code size than ePUSH_I.
   606                              <2> ;
   607                              <2> ; ePUSH_T
   608                              <2> ;	Parameters:
   609                              <2> ;		%1:		Temporary Register
   610                              <2> ;		%2:		Immediate to push
   611                              <2> ;	Returns:
   612                              <2> ;		Nothing
   613                              <2> ;	Corrupts registers:
   614                              <2> ;		%1
   615                              <2> ;--------------------------------------------------------------------
   616                              <2> %macro ePUSH_T 2
   617                              <2> %ifndef USE_186
   618                              <2> 	%ifidni %2, 0
   619                              <2> 		xor		%1, %1
   620                              <2> 	%else
   621                              <2> 		mov		%1, %2
   622                              <2> 	%endif
   623                              <2> 	push	%1
   624                              <2> ;-----------------------------------
   625                              <2> %else
   626                              <2> 	push	%2
   627                              <2> %endif
   628                              <2> %endmacro
   629                              <2> 
   630                              <2> 
   631                              <2> %endif ; EMULATE_INC
     8                              <1> %include "Macros.inc"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	This is the place to put various generic macros.
     3                              <2> ;					Should be included immediately after emulate.inc
     4                              <2> %ifndef MACROS_INC
     5                              <2> %define MACROS_INC
     6                              <2> 
     7                              <2> ;--------------------------------------------------------------------
     8                              <2> ; Skips the immediately following 2 byte instruction by using it
     9                              <2> ; as an immediate value to a dummy instruction.
    10                              <2> ; Destroys the contents of %1.
    11                              <2> ;
    12                              <2> ; SKIP2B
    13                              <2> ;	Parameters:
    14                              <2> ;		%1:		Any 16 bit general purpose register or F for flags.
    15                              <2> ;	Returns:
    16                              <2> ;		Nothing
    17                              <2> ;	Corrupts registers:
    18                              <2> ;		%1
    19                              <2> ;--------------------------------------------------------------------
    20                              <2> %macro SKIP2B 1
    21                              <2> 	%ifidni		%1, f
    22                              <2> 		db	03Dh					; Opcode byte for CMP AX, <immed>
    23                              <2> 		;db	0A9h					; Alt. version TEST AX, <immed>
    24                              <2> 	%elifidni	%1, ax
    25                              <2> 		db	0B8h					; Opcode byte for MOV AX, <immed>
    26                              <2> 	%elifidni	%1, cx
    27                              <2> 		db	0B9h					; Opcode byte for MOV CX, <immed>
    28                              <2> 	%elifidni	%1, dx
    29                              <2> 		db	0BAh					; Opcode byte for MOV DX, <immed>
    30                              <2> 	%elifidni	%1, bx
    31                              <2> 		db	0BBh					; Opcode byte for MOV BX, <immed>
    32                              <2> 	%elifidni	%1, sp
    33                              <2> 		db	0BCh					; Opcode byte for MOV SP, <immed>
    34                              <2> 	%elifidni	%1, bp
    35                              <2> 		db	0BDh					; Opcode byte for MOV BP, <immed>
    36                              <2> 	%elifidni	%1, si
    37                              <2> 		db	0BEh					; Opcode byte for MOV SI, <immed>
    38                              <2> 	%elifidni	%1, di
    39                              <2> 		db	0BFh					; Opcode byte for MOV DI, <immed>
    40                              <2> 	%else
    41                              <2> 		%error "Invalid parameter passed to SKIP2B"
    42                              <2> 	%endif
    43                              <2> %endmacro
    44                              <2> 
    45                              <2> 
    46                              <2> ;--------------------------------------------------------------------
    47                              <2> ; Load BDA (Bios Data Area) segment to wanted segment register.
    48                              <2> ;
    49                              <2> ; Use an exclamation point (!) as the third parameter when you want
    50                              <2> ; to force the use of the register in the second parameter. This is
    51                              <2> ; useful when that register needs to be zeroed in subsequent code or
    52                              <2> ; when stack usage is undesirable (ie speed is critical).
    53                              <2> ;
    54                              <2> ; The PRESERVE_FLAGS version will zero the register with a MOV instead
    55                              <2> ; of an XOR, thus preserving the flags.  It is one byte larger on
    56                              <2> ; non-186 or higher systems.
    57                              <2> ;
    58                              <2> ; LOAD_BDA_SEGMENT_TO
    59                              <2> ; LOAD_BDA_SEGMENT_PRESERVE_FLAGS_TO
    60                              <2> ;	Parameters:
    61                              <2> ;		%1:		Destination Segment Register
    62                              <2> ;		%2:		Temporary WORD Register
    63                              <2> ;		%3:		Can be ! or empty
    64                              <2> ;	Returns:
    65                              <2> ;		%1:		BDA segment (zero)
    66                              <2> ;	Corrupts registers:
    67                              <2> ;		%2
    68                              <2> ;--------------------------------------------------------------------
    69                              <2> %macro LOAD_BDA_SEGMENT_TO 2-3
    70                              <2> %ifndef USE_186
    71                              <2> 	xor		%2, %2
    72                              <2> 	mov		%1, %2
    73                              <2> %elifidn %3, !
    74                              <2> 	xor		%2, %2
    75                              <2> 	mov		%1, %2
    76                              <2> %else
    77                              <2> 	push	BYTE 0
    78                              <2> 	pop		%1
    79                              <2> %endif
    80                              <2> %endmacro
    81                              <2> 
    82                              <2> %macro LOAD_BDA_SEGMENT_PRESERVE_FLAGS_TO 2-3
    83                              <2> %ifndef USE_186
    84                              <2> 	mov		%2, 0
    85                              <2> 	mov		%1, %2
    86                              <2> %elifidn %3, !
    87                              <2> 	mov		%2, 0
    88                              <2> 	mov		%1, %2
    89                              <2> %else
    90                              <2> 	push	BYTE 0
    91                              <2> 	pop		%1
    92                              <2> %endif
    93                              <2> %endmacro
    94                              <2> 
    95                              <2> 
    96                              <2> ;--------------------------------------------------------------------
    97                              <2> ; eENTER_STRUCT
    98                              <2> ;	Parameters:
    99                              <2> ;		%1:		Number of bytes to reserve from stack
   100                              <2> ;	Returns:
   101                              <2> ;		SS:BP:	Ptr to beginning of struct reserved from stack
   102                              <2> ;	Corrupts registers:
   103                              <2> ;		FLAGS
   104                              <2> ;--------------------------------------------------------------------
   105                              <2> %macro eENTER_STRUCT 1
   106                              <2> 	push	bp
   107                              <2> 	sub		sp, %1
   108                              <2> 	mov		bp, sp
   109                              <2> %endmacro
   110                              <2> 
   111                              <2> ;--------------------------------------------------------------------
   112                              <2> ; eLEAVE_STRUCT
   113                              <2> ;	Parameters:
   114                              <2> ;		%1:		Number of bytes reserved with eENTER_STRUCT
   115                              <2> ;	Returns:
   116                              <2> ;		BP:		What it was before eENTER_STRUCT
   117                              <2> ;	Corrupts registers:
   118                              <2> ;		FLAGS
   119                              <2> ;--------------------------------------------------------------------
   120                              <2> %macro eLEAVE_STRUCT 1
   121                              <2> 	add		sp, %1
   122                              <2> 	pop		bp
   123                              <2> %endmacro
   124                              <2> 
   125                              <2> 
   126                              <2> %endif ; MACROS_INC
     9                              <1> %include "BiosData.inc"
     1                              <2> ; Project name	:	XTIDE Universal BIOS
     2                              <2> ; Description	:	Equates for BIOS Data Area.
     3                              <2> %ifndef BIOSDATA_INC
     4                              <2> %define BIOSDATA_INC
     5                              <2> 
     6                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     7                              <2> ; BIOS DATA AREA VARIABLES ;
     8                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     9                              <2> 
    10                              <2> ; BIOS Data Area (related to floppy drives and hard disks)
    11                              <2> struc BDA
    12 00000000 <res 00000400>      <2> 					resb	400h	; 40:0h, Start of BDA
    13 00000400 <res 00000002>      <2> 	.wCOM1			resb	2		; 0:400h, Serial I/O Address, Port 1
    14 00000402 <res 00000002>      <2> 	.wCOM2			resb	2		; 0:402h, Serial I/O Address, Port 2
    15 00000404 <res 00000002>      <2> 	.wCOM3			resb	2		; 0:404h, Serial I/O Address, Port 3
    16 00000406 <res 00000002>      <2> 	.wCOM4			resb	2		; 0:406h, Serial I/O Address, Port 4
    17 00000408 <res 00000002>      <2> 	.wLPT1			resb	2		; 0:408h, Parallel I/O Address, Port 1
    18 0000040A <res 00000002>      <2> 	.wLPT2			resb	2		; 0:40Ah, Parallel I/O Address, Port 2
    19 0000040C <res 00000002>      <2> 	.wLPT3			resb	2		; 0:40Ch, Parallel I/O Address, Port 3
    20                              <2> 	.wLPT4:							; 0:40Eh, Parallel I/O Address, Port 4 (PC/XT)
    21 0000040E <res 00000002>      <2> 	.wSegEBDA		resb	2		; 0:40Eh, Extended BIOS Data Area segment (AT+)
    22                              <2> 
    23 00000410 <res 00000002>      <2> 	.wEquipment		resb	2		; 0:410h, Equipment Word
    24 00000412 <res 00000001>      <2> 	.bTest			resb	1		; 0:412h, Manufacturing test
    25 00000413 <res 00000002>      <2> 	.wBaseMem		resb	2		; 0:413h, Base Memory Size in kB
    26                              <2> 	.wAdptrMem:						; 0:415h, Adapter Memory Size (PC/XT)
    27 00000415 <res 00000002>      <2> 	.wError			resb	2		; 0:415h, Error Codes (AT+)
    28 00000417 <res 00000001>      <2> 	.bKBFlgs1		resb	1		; 0:417h, Keyboard, Shift Flags, Set 1
    29 00000418 <res 00000001>      <2> 	.bKBFlgs2		resb	1		; 0:418h, Keyboard, Shift Flags, Set 2
    30 00000419 <res 00000001>      <2> 	.bKBNumpad		resb	1		; 0:419h, Keyboard, ALT+Numpad work area
    31 0000041A <res 00000002>      <2> 	.wKBHead		resb	2		; 0:41Ah, Keyboard, Head of buffer pointer
    32 0000041C <res 00000002>      <2> 	.wKBTail		resb	2		; 0:41Ch, Keyboard, Tail of buffer pointer
    33 0000041E <res 00000020>      <2> 	.rgwKBBuff		resb	32		; 0:41Eh, Keyboard, 16-word buffer
    34                              <2> 
    35 0000043E <res 00000001>      <2> 	.bFDRecal		resb	1		; 0:43Eh, Diskette, Recalibrate status
    36 0000043F <res 00000001>      <2> 	.bFDMotor		resb	1		; 0:43Fh, Diskette, Motor status
    37                              <2> 
    38 00000440 <res 00000001>      <2> 	.bFDMotTime		resb	1		; 0:440h, Diskette, Motor timeout counter
    39 00000441 <res 00000001>      <2> 	.bFDRetST		resb	1		; 0:441h, Diskette, Controller status return code
    40 00000442 <res 00000007>      <2> 	.rgbFDStatus	resb	7		; 0:442h, Diskette, Diskette and Disk Controller status bytes
    41 00000449 <res 00000001>      <2> 	.bVidMode		resb	1		; 0:449h, Video, Mode
    42 0000044A <res 00000002>      <2> 	.wVidColumns	resb	2		; 0:44Ah, Video, Number of columns
    43 0000044C <res 00000002>      <2> 	.wVidBpP		resb	2		; 0:44Ch, Video, Total number of bytes per page
    44 0000044E <res 00000002>      <2> 	.wVidPageOff	resb	2		; 0:44Eh, Video, Current page offset
    45                              <2> 
    46 00000450 <res 00000010>      <2> 	.rgwVidCurPos	resb	16		; 0:450h, Video, Cursor position, pages 0...7
    47                              <2> 
    48 00000460 <res 00000002>      <2> 	.wVidCurShape	resb	2		; 0:460h, Video, Cursor shape
    49 00000462 <res 00000001>      <2> 	.bVidPageIdx	resb	1		; 0:462h, Video, Active display page
    50 00000463 <res 00000002>      <2> 	.wVidPort		resb	2		; 0:463h, Video, I/O Port number base
    51 00000465 <res 00000001>      <2> 	.bVidModeReg	resb	1		; 0:465h, Video, Internal mode register
    52 00000466 <res 00000001>      <2> 	.bVidPalette	resb	1		; 0:466h, Video, Color palette
    53                              <2> 	.wCasTimeCnt:					; 0:467h, Cassette, Time count at data edge (PC)
    54 00000467 <res 00000002>      <2> 	.wGenOff		resb	2		; 0:467h, General use offset (XT+)
    55                              <2> 	.wCasCRC:						; 0:469h, Cassette, CRC register (PC)
    56 00000469 <res 00000002>      <2> 	.wGenSeg		resb	2		; 0:469h, General use segment (XT+)
    57                              <2> 	.bCasLast:						; 0:46Bh, Cassette, Last value read
    58 0000046B <res 00000001>      <2> 	.bLastIRQ		resb	1		; 0:46Bh, Last interrupt that occurred (XT+)
    59 0000046C <res 00000004>      <2> 	.dwTimerTicks	resb	4		; 0:46Ch, Timer ticks count
    60                              <2> 
    61 00000470 <res 00000001>      <2> 	.bTimer24h		resb	1		; 0:470h, Timer ticks rollover flag
    62 00000471 <res 00000001>      <2> 	.bKBCtrlBrk		resb	1		; 0:471h, Keyboard, Ctrl+Break flag
    63 00000472 <res 00000002>      <2> 	.wBoot			resb	2		; 0:472h, Warm boot flag
    64 00000474 <res 00000001>      <2> 	.bHDLastSt		resb	1		; 0:474h, Hard Disk, Status of Last Operation (XT+)
    65 00000475 <res 00000001>      <2> 	.bHDCount		resb	1		; 0:475h, Hard Disk, Number of HDs Attached (XT+)
    66 00000476 <res 00000001>      <2> 	.bHDCtrl		resb	1		; 0:476h, Hard Disk, Control Byte (temp, XT+)
    67 00000477 <res 00000001>      <2> 	.bHDPortOff		resb	1		; 0:477h, Hard Disk, Port Offset (XT)
    68 00000478 <res 00000001>      <2> 	.bLPT1Timeout	resb	1		; 0:478h, Parallel Printer 1, Timeout (XT+)
    69 00000479 <res 00000001>      <2> 	.bLPT2Timeout	resb	1		; 0:479h, Parallel Printer 2, Timeout (XT+)
    70 0000047A <res 00000001>      <2> 	.bLPT3Timeout	resb	1		; 0:47Ah, Parallel Printer 3, Timeout (XT+)
    71 0000047B <res 00000001>      <2> 	.bLPT4Timeout	resb	1		; 0:47Bh, Parallel Printer 4, Timeout (XT+)
    72 0000047C <res 00000001>      <2> 	.bCOM1Timeout	resb	1		; 0:47Ch, Serial 1, Timeout (XT+)
    73 0000047D <res 00000001>      <2> 	.bCOM2Timeout	resb	1		; 0:47Dh, Serial 2, Timeout (XT+)
    74 0000047E <res 00000001>      <2> 	.bCOM3Timeout	resb	1		; 0:47Eh, Serial 3, Timeout (XT+)
    75 0000047F <res 00000001>      <2> 	.bCOM4Timeout	resb	1		; 0:47Fh, Serial 4, Timeout (XT+)
    76                              <2> 
    77 00000480 <res 00000002>      <2> 	.wKBPtrStart	resb	2		; 0:480h, Keyboard, Pointer to start of buffer (XT+)
    78 00000482 <res 00000002>      <2> 	.wKBPtrEnd		resb	2		; 0:482h, Keyboard, Pointer to end of buffer (XT+)
    79 00000484 <res 00000001>      <2> 	.bVidRows		resb	1		; 0:484h, Video, Number of rows (EGA+)
    80 00000485 <res 00000002>      <2> 	.wVidPpC		resb	2		; 0:485h, Video, Pixels per character (EGA+)
    81 00000487 <res 00000001>      <2> 	.bVidOptns		resb	1		; 0:487h, Video, Options (EGA+)
    82 00000488 <res 00000001>      <2> 	.bVidSwitches	resb	1		; 0:488h, Video, Switches (EGA+)
    83 00000489 <res 00000001>      <2> 	.bVidSave1		resb	1		; 0:489h, Video, Save area 1 (VGA+)
    84 0000048A <res 00000001>      <2> 	.bVidSave2		resb	1		; 0:48Ah, Video, Save area 2 (VGA+)
    85 0000048B <res 00000001>      <2> 	.bFDCfgData		resb	1		; 0:48Bh, Diskette, Configuration data (AT+)
    86 0000048C <res 00000001>      <2> 	.bHDStatus		resb	1		; 0:48Ch, Hard Disk, Status Register (AT+)
    87 0000048D <res 00000001>      <2> 	.bHDError		resb	1		; 0:48Dh, Hard Disk, Error Register (AT+)
    88 0000048E <res 00000001>      <2> 	.bHDTaskFlg		resb	1		; 0:48Eh, Hard Disk, Task Complete Flag (AT+)
    89 0000048F <res 00000001>      <2> 	.bFDCtrlInfo	resb	1		; 0:48Fh, Diskette, Controller information (AT+)
    90                              <2> 
    91 00000490 <res 00000001>      <2> 	.bFDMedia0		resb	1		; 0:490h, Diskette 0, Media state (AT+)
    92 00000491 <res 00000001>      <2> 	.bFDMedia1		resb	1		; 0:491h, Diskette 1, Media state (AT+)
    93 00000492 <res 00000001>      <2> 	.bFDOpStart0	resb	1		; 0:492h, Diskette 0, Operational starting state (AT+)
    94 00000493 <res 00000001>      <2> 	.bFDOpStart1	resb	1		; 0:493h, Diskette 1, Operational starting state (AT+)
    95 00000494 <res 00000001>      <2> 	.bFDCurCyl0		resb	1		; 0:494h, Diskette 0, Current cylinder (AT+)
    96 00000495 <res 00000001>      <2> 	.bFDCurCyl1		resb	1		; 0:495h, Diskette 1, Current cylinder (AT+)
    97 00000496 <res 00000001>      <2> 	.bKBFlgs3		resb	1		; 0:496h, Keyboard, Status flags 3 (AT+)
    98 00000497 <res 00000001>      <2> 	.bKBFlgs4		resb	1		; 0:497h, Keyboard, Status flags 4 (AT+)
    99 00000498 <res 00000004>      <2> 	.dwWaitPtr		resb	4		; 0:498h, User's wait flag pointer (AT+)
   100 0000049C <res 00000004>      <2> 	.dwWaitCnt		resb	4		; 0:49Ch, User's wait count (AT+)
   101                              <2> 
   102 000004A0 <res 00000001>      <2> 	.bWaitFlg		resb	1		; 0:4A0h, Wait flag (AT+)
   103 000004A1 <res 00000007>      <2> 	.rgbLAN			resb	7		; 0:4A1h, Local Area Network (AT+)
   104 000004A8 <res 00000004>      <2> 	.dwVidPtr		resb	4		; 0:4A8h, Video, Parameter Control Block Pointer (EGA+)
   105 000004AC <res 00000022>      <2> 					resb	22h		; Reserved from 0:4ACh...0:4CDh
   106                              <2> 
   107 000004CE <res 00000004>      <2> 	.dwDays			resb	4		; 0:4CEh, Clock, Days since 1980 (some BIOSes, AT+)
   108 000004D2 <res 0000002E>      <2> 					resb	2Eh		; Reserved from 0:4D2h...0:4FFh
   109                              <2> 
   110 00000500 <res 00000001>      <2> 	.bPrntScrn		resb	1		; 0:500, Print screen status
   111                              <2> endstruc
   112                              <2> 
   113                              <2> ; BDA struct with only Hard Disk related locations
   114                              <2> struc HDBDA
   115 00000000 <res 00000474>      <2> 					resb	474h
   116 00000474 <res 00000001>      <2> 	.bHDLastSt		resb	1		; 0:474h, Status of Last Operation (XT+)
   117 00000475 <res 00000001>      <2> 	.bHDCount		resb	1		; 0:475h, Number of HDs Attached (XT+)
   118 00000476 <res 00000001>      <2> 	.bHDCtrl		resb	1		; 0:476h, Control Byte (temp, XT+)
   119 00000477 <res 00000001>      <2> 	.bHDPortOff		resb	1		; 0:477h, Port Offset (XT)
   120 00000478 <res 00000015>      <2> 					resb	15h
   121                              <2> 	.bHDStatus:						; 0:48Ch, Status Register (AT+)
   122                              <2> 	.bHDError:						; 0:48Dh, Error Register (AT+)
   123 0000048D <res 00000002>      <2> 	.wHDStAndErr	resb	2
   124 0000048F <res 00000001>      <2> 	.bHDTaskFlg		resb	1		; 0:48Eh, Task Complete Flag (AT+)
   125                              <2> endstruc
   126                              <2> 
   127                              <2> 
   128                              <2> ; Warm Boot Flags for BDA.wBoot
   129                              <2> BOOT_FLAG_COLD			EQU	0
   130                              <2> BOOT_FLAG_WARM			EQU	1234h	; Same effect as CTRL + ALT + DEL, skips memory tests
   131                              <2> BOOT_FLAG_PRESERVE_RAM	EQU	4321h	; No mem test, leave memory unchanged (AT+)
   132                              <2> 
   133                              <2> 
   134                              <2> %endif ; BIOSDATA_INC
    10                              <1> %include "BiosFunctions.inc"
     1                              <2> ; Project name	:	AssemblyLibrary
     2                              <2> ; Description	:	Defines for BIOS functions.
     3                              <2> %ifndef BIOS_FUNCTIONS_INC
     4                              <2> %define BIOS_FUNCTIONS_INC
     5                              <2> 
     6                              <2> ; BIOS interrupts
     7                              <2> BIOS_VIDEO_INTERRUPT_10h		EQU		10h
     8                              <2> BIOS_DISK_INTERRUPT_13h			EQU		13h
     9                              <2> BIOS_SYSTEM_INTERRUPT_15h		EQU		15h
    10                              <2> BIOS_KEYBOARD_INTERRUPT_16h		EQU		16h
    11                              <2> BIOS_BOOT_FAILURE_INTERRUPT_18h	EQU		18h
    12                              <2> BIOS_BOOT_LOADER_INTERRUPT_19h	EQU		19h
    13                              <2> BIOS_DISKETTE_INTERRUPT_40h		EQU		40h
    14                              <2> HD0_DPT_POINTER_41h				EQU		41h
    15                              <2> HD1_DPT_POINTER_46h				EQU		46h
    16                              <2> 
    17                              <2> ; Hardware interrupts
    18                              <2> HARDWARE_IRQ_0_INTERRUPT_08h	EQU		08h		; System timer
    19                              <2> HARDWARE_IRQ_1_INTERRUPT_09h	EQU		09h		; Keyboard
    20                              <2> HARDWARE_IRQ_2_INTERRUPT_0Ah	EQU		0Ah
    21                              <2> HARDWARE_IRQ_3_INTERRUPT_0Bh	EQU		0Bh
    22                              <2> HARDWARE_IRQ_4_INTERRUPT_0Ch	EQU		0Ch
    23                              <2> HARDWARE_IRQ_5_INTERRUPT_0Dh	EQU		0Dh
    24                              <2> HARDWARE_IRQ_6_INTERRUPT_0Eh	EQU		0Eh
    25                              <2> HARDWARE_IRQ_7_INTERRUPT_0Fh	EQU		0Fh
    26                              <2> HARDWARE_IRQ_8_INTERRUPT_70h	EQU		70h
    27                              <2> HARDWARE_IRQ_9_INTERRUPT_71h	EQU		71h
    28                              <2> HARDWARE_IRQ_10_INTERRUPT_72h	EQU		72h
    29                              <2> HARDWARE_IRQ_11_INTERRUPT_73h	EQU		73h
    30                              <2> HARDWARE_IRQ_12_INTERRUPT_74h	EQU		74h
    31                              <2> HARDWARE_IRQ_13_INTERRUPT_75h	EQU		75h
    32                              <2> HARDWARE_IRQ_14_INTERRUPT_76h	EQU		76h
    33                              <2> HARDWARE_IRQ_15_INTERRUPT_77h	EQU		77h
    34                              <2> 
    35                              <2> 
    36                              <2> ; BIOS video functions
    37                              <2> SET_VIDEO_MODE					EQU		00h
    38                              <2> SET_TEXT_MODE_CURSOR_SHAPE		EQU		01h
    39                              <2> SET_CURSOR_POSITION				EQU		02h
    40                              <2> GET_CURSOR_POSITION_AND_SIZE	EQU		03h
    41                              <2> SELECT_ACTIVE_DISPLAY_PAGE		EQU		05h
    42                              <2> TELETYPE_OUTPUT					EQU		0Eh
    43                              <2> 
    44                              <2> ; BIOS disk functions
    45                              <2> READ_SECTORS_INTO_MEMORY		EQU		02h
    46                              <2> GET_DRIVE_PARAMETERS			EQU		08h
    47                              <2> RESET_HARD_DISK					EQU		0Dh
    48                              <2> GET_DISK_TYPE					EQU		15h
    49                              <2> LOTECH_XTCF_FEATURES			EQU		1Eh
    50                              <2> GET_DRIVE_INFORMATION			EQU		25h
    51                              <2> CHECK_EXTENSIONS_PRESENT		EQU		41h
    52                              <2> GET_EXTENDED_DRIVE_INFORMATION	EQU		48h
    53                              <2> 
    54                              <2> ; BIOS system functions
    55                              <2> OS_HOOK_DEVICE_BUSY				EQU		90h
    56                              <2> OS_HOOK_DEVICE_POST				EQU		91h
    57                              <2> 
    58                              <2> ; BIOS keyboard functions
    59                              <2> GET_KEYSTROKE					EQU		00h
    60                              <2> CHECK_FOR_KEYSTROKE				EQU		01h
    61                              <2> 
    62                              <2> ; BIOS system functions
    63                              <2> EVENT_WAIT						EQU		86h
    64                              <2> 
    65                              <2> 
    66                              <2> %endif ; BIOS_FUNCTIONS_INC
    11                              <1> %include "CgaSnow.inc"
     1                              <2> ; File name		:	CgaSnow.inc
     2                              <2> ; Project name	:	AssemblyLibrary
     3                              <2> ; Created date	:	8.10.2010
     4                              <2> ; Last update	:	11.10.2010
     5                              <2> ; Author		:	Tomi Tilli
     6                              <2> ; Description	:	Macros for preventing CGA snow.
     7                              <2> %ifndef CGASNOW_INC
     8                              <2> %define CGASNOW_INC
     9                              <2> 
    10                              <2> ;--------------------------------------------------------------------
    11                              <2> ; WAIT_RETRACE_IF_NECESSARY_THEN
    12                              <2> ;	Parameters:
    13                              <2> ;		%1:		Instruction that accessed CGA memory
    14                              <2> ;		AL:		Character to output
    15                              <2> ;		AH:		Attribute to output (stosw only)
    16                              <2> ;		DS:		BDA segment (zero)
    17                              <2> ;		ES:SI:	Ptr to video memory where to read from (if %1 reads)
    18                              <2> ;		ES:DI:	Ptr to video memory where to output (if %1 writes)
    19                              <2> ;	Returns:
    20                              <2> ;		SI, DI:	Updated according to instruction
    21                              <2> ;	Corrupts registers:
    22                              <2> ;		AX, DX
    23                              <2> ;--------------------------------------------------------------------
    24                              <2> %macro WAIT_RETRACE_IF_NECESSARY_THEN 1
    25                              <2> %ifdef ELIMINATE_CGA_SNOW
    26                              <2> 	%ifidn %1, stosb
    27                              <2> 		call	CgaSnow_Stosb
    28                              <2> 	%elifidn %1, stosw
    29                              <2> 		call	CgaSnow_Stosw
    30                              <2> 	%elifidn %1, rep movsb
    31                              <2> 		call	CgaSnow_RepMovsb
    32                              <2> 	%else
    33                              <2> 		%error	"Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
    34                              <2> 	%endif
    35                              <2> %else	; No CGA snow prevention
    36                              <2> 	%ifidn %1, rep movsb
    37                              <2> 		eSEG_STR rep, es, movsb
    38                              <2> 	%else
    39                              <2> 		%1	; Single instruction
    40                              <2> 	%endif
    41                              <2> %endif
    42                              <2> %endmacro
    43                              <2> 
    44                              <2> 
    45                              <2> ;--------------------------------------------------------------------
    46                              <2> ; WAIT_UNTIL_SAFE_CGA_WRITE
    47                              <2> ;	Parameters:
    48                              <2> ;		DX:		CGA Status Register Address (3DAh)
    49                              <2> ;	Returns:
    50                              <2> ;		Nothing
    51                              <2> ;	Corrupts registers:
    52                              <2> ;		AL
    53                              <2> ;--------------------------------------------------------------------
    54                              <2> %macro WAIT_UNTIL_SAFE_CGA_WRITE 0
    55                              <2> %%WaitUntilNotInRetrace:
    56                              <2> 	in		al, dx
    57                              <2> 	shr		al, 1	; 1 = Bit 0: A 1 indicates that regen-buffer memory access can be
    58                              <2> 					; made without interfering with the display. (H or V retrace)
    59                              <2> 	jc		SHORT %%WaitUntilNotInRetrace
    60                              <2> %%WaitUntilNextRetraceStarts:
    61                              <2> 	in		al, dx
    62                              <2> 	shr		al, 1
    63                              <2> 	jnc		SHORT %%WaitUntilNextRetraceStarts
    64                              <2> %endmacro
    65                              <2> 
    66                              <2> 
    67                              <2> %endif ; CGASNOW_INC
    12                              <1> %include "Debug.inc"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Debugging macros.
     3                              <2> %ifndef DEBUG_INC
     4                              <2> %define DEBUG_INC
     5                              <2> 
     6                              <2> 
     7                              <2> ;--------------------------------------------------------------------
     8                              <2> ; DISPLAY_DEBUG_WORD_AND_WAIT_ANY_KEY
     9                              <2> ;	Parameters:
    10                              <2> ;		%1:		Debug word
    11                              <2> ;		%2:		Numeric base (2, 10, 16)
    12                              <2> ;	Returns:
    13                              <2> ;		Nothing
    14                              <2> ;	Corrupts registers:
    15                              <2> ;		Nothing
    16                              <2> ;--------------------------------------------------------------------
    17                              <2> %macro DISPLAY_DEBUG_WORD_AND_WAIT_ANY_KEY 2
    18                              <2> 	pushf
    19                              <2> 	push	di
    20                              <2> 	push	bx
    21                              <2> 	push	ax
    22                              <2> 
    23                              <2> 	mov		ax, %1
    24                              <2> 	mov		bx, %2
    25                              <2> 	CALL_DISPLAY_LIBRARY PrintWordFromAXwithBaseInBX
    26                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    27                              <2> 	call	Keyboard_RemoveAllKeystrokesFromBuffer
    28                              <2> %endif
    29                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary
    30                              <2> 
    31                              <2> 	pop		ax
    32                              <2> 	pop		bx
    33                              <2> 	pop		di
    34                              <2> 	popf
    35                              <2> %endmacro
    36                              <2> 
    37                              <2> 
    38                              <2> ;--------------------------------------------------------------------
    39                              <2> ; DISPLAY_DEBUG_CHARACTER_AND_WAIT_ANY_KEY
    40                              <2> ;	Parameters:
    41                              <2> ;		%1:		Character to print
    42                              <2> ;	Returns:
    43                              <2> ;		Nothing
    44                              <2> ;	Corrupts registers:
    45                              <2> ;		Nothing
    46                              <2> ;--------------------------------------------------------------------
    47                              <2> %macro DISPLAY_DEBUG_CHARACTER_AND_WAIT_ANY_KEY 1
    48                              <2> 	pushf
    49                              <2> 	push	di
    50                              <2> 	push	ax
    51                              <2> 
    52                              <2> 	mov		al, %1
    53                              <2> 	CALL_DISPLAY_LIBRARY PrintCharacterFromAL
    54                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    55                              <2> 	call	Keyboard_RemoveAllKeystrokesFromBuffer
    56                              <2> %endif
    57                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary
    58                              <2> 
    59                              <2> 	pop		ax
    60                              <2> 	pop		di
    61                              <2> 	popf
    62                              <2> %endmacro
    63                              <2> 
    64                              <2> 
    65                              <2> ;--------------------------------------------------------------------
    66                              <2> ; DISPLAY_DEBUG_CHARACTER
    67                              <2> ;	Parameters:
    68                              <2> ;		%1:		Character to print
    69                              <2> ;	Returns:
    70                              <2> ;		Nothing
    71                              <2> ;	Corrupts registers:
    72                              <2> ;		Nothing
    73                              <2> ;--------------------------------------------------------------------
    74                              <2> %macro DISPLAY_DEBUG_CHARACTER 1
    75                              <2> 	pushf
    76                              <2> 	push	di
    77                              <2> 	push	ax
    78                              <2> 	mov		al, %1
    79                              <2> 	CALL_DISPLAY_LIBRARY PrintCharacterFromAL
    80                              <2> 	pop		ax
    81                              <2> 	pop		di
    82                              <2> 	popf
    83                              <2> %endmacro
    84                              <2> 
    85                              <2> 
    86                              <2> ;--------------------------------------------------------------------
    87                              <2> ; WAIT_ANY_KEY_TO_CONTINUE
    88                              <2> ;	Parameters:
    89                              <2> ;		Nothing
    90                              <2> ;	Returns:
    91                              <2> ;		Nothing
    92                              <2> ;	Corrupts registers:
    93                              <2> ;		Nothing
    94                              <2> ;--------------------------------------------------------------------
    95                              <2> %macro WAIT_ANY_KEY_TO_CONTINUE 0
    96                              <2> 	push	ax
    97                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    98                              <2> 	call	Keyboard_RemoveAllKeystrokesFromBuffer
    99                              <2> %endif
   100                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary
   101                              <2> 	pop		ax
   102                              <2> %endmacro
   103                              <2> 
   104                              <2> 
   105                              <2> %endif ; DEBUG_INC
    13                              <1> %include "Delay.inc"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Delay macros.
     3                              <2> %ifndef DELAY_INC
     4                              <2> %define DELAY_INC
     5                              <2> 
     6                              <2> ;--------------------------------------------------------------------
     7                              <2> ; Clears prefetch queue by jumping to next instruction.
     8                              <2> ; This delays much more than nop instruction of fast systems.
     9                              <2> ;
    10                              <2> ; JMP_DELAY
    11                              <2> ;	Parameters
    12                              <2> ;		Nothing
    13                              <2> ;	Returns:
    14                              <2> ;		Nothing
    15                              <2> ;	Corrupts registers:
    16                              <2> ;		Nothing
    17                              <2> ;--------------------------------------------------------------------
    18                              <2> %macro JMP_DELAY 0
    19                              <2> 	jmp		SHORT %%NextInstruction
    20                              <2> %%NextInstruction:
    21                              <2> %endmacro
    22                              <2> 
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; Mimimun delays (without fetching) with some CPU architectures:
    26                              <2> ;	8088/8086:	17 cycles for jump + 5 cycles for last comparison
    27                              <2> ;	286:		10 cycles for jump + 4 cycles for last comparison
    28                              <2> ;	386:		13 cycles for jump + ? cycles for last comparison
    29                              <2> ;	486:		 7 cycles for jump + 6 cycles for last comparison
    30                              <2> ;
    31                              <2> ; LOOP instruction uses two bytes so aligned fetching will require:
    32                              <2> ;   8088:		8 cycles (two BYTE reads)
    33                              <2> ;   8086:		4 cycles (one WORD read)
    34                              <2> ;   286:		2 cycles + wait states (usually 1)
    35                              <2> ;   386:		?
    36                              <2> ;	486:		Fetched only once to internal cache
    37                              <2> ;
    38                              <2> ; DELAY_WITH_LOOP_INSTRUCTION_NA	; No JUMP_ALIGN
    39                              <2> ; DELAY_WITH_LOOP_INSTRUCTION
    40                              <2> ;	Parameters
    41                              <2> ;		CX:		Loop iterations (0 is maximum delay with 65536 iterations)
    42                              <2> ;	Returns:
    43                              <2> ;		CX:		Zero
    44                              <2> ;	Corrupts registers:
    45                              <2> ;		Nothing
    46                              <2> ;--------------------------------------------------------------------
    47                              <2> %macro DELAY_WITH_LOOP_INSTRUCTION_NA 0
    48                              <2> %%StartOfLoop:
    49                              <2> 	loop	%%StartOfLoop
    50                              <2> %endmacro
    51                              <2> 
    52                              <2> %macro DELAY_WITH_LOOP_INSTRUCTION 0
    53                              <2> ALIGN JUMP_ALIGN
    54                              <2> %%StartOfLoop:
    55                              <2> 	loop	%%StartOfLoop
    56                              <2> %endmacro
    57                              <2> 
    58                              <2> 
    59                              <2> %endif ; DELAY_INC
    14                              <1> %include "DosFunctions.inc"
     1                              <2> ; Project name	:	AssemblyLibrary
     2                              <2> ; Description	:	Defines for MS-DOS functions.
     3                              <2> %ifndef DOS_FUNCTIONS_INC
     4                              <2> %define DOS_FUNCTIONS_INC
     5                              <2> 
     6                              <2> ; DOS interrupts
     7                              <2> DOS_INTERRUPT_21h									EQU		21h
     8                              <2> DOS_CRITICAL_ERROR_HANDLER_24h						EQU		24h
     9                              <2> DOS_TSR_MULTIPLEX_INTERRUPT_2Fh						EQU		2Fh
    10                              <2> 
    11                              <2> ; DOS drive and file functions
    12                              <2> SELECT_DEFAULT_DRIVE								EQU		0Eh
    13                              <2> GET_CURRENT_DEFAULT_DRIVE							EQU		19h
    14                              <2> GET_DISK_TRANSFER_AREA_ADDRESS						EQU		2Fh
    15                              <2> GET_DOS_DRIVE_PARAMETER_BLOCK_FOR_SPECIFIC_DRIVE	EQU		32h
    16                              <2> SET_CURRENT_DIRECTORY								EQU		3Bh
    17                              <2> CREATE_OR_TRUNCATE_FILE								EQU		3Ch
    18                              <2> OPEN_EXISTING_FILE									EQU		3Dh
    19                              <2> CLOSE_FILE											EQU		3Eh
    20                              <2> READ_FROM_FILE_OR_DEVICE							EQU		3Fh
    21                              <2> WRITE_TO_FILE_OR_DEVICE								EQU		40h
    22                              <2> SET_CURRENT_FILE_POSITION							EQU		42h
    23                              <2> GET_CURRENT_DIRECTORY								EQU		47h
    24                              <2> FIND_FIRST_MATCHING_FILE							EQU		4Eh
    25                              <2> FIND_NEXT_MATCHING_FILE								EQU		4Fh
    26                              <2> 
    27                              <2> ; DOS functions for TSRs
    28                              <2> SET_INTERRUPT_VECTOR								EQU		25h
    29                              <2> GET_INTERRUPT_VECTOR								EQU		35h
    30                              <2> 
    31                              <2> ; DOS errors
    32                              <2> ERR_DOS_DRIVE_NOT_READY								EQU		15h
    33                              <2> 
    34                              <2> 
    35                              <2> 
    36                              <2> ; DOS Program Segment Prefix (PSP, first 256 (100h) bytes on top of program)
    37                              <2> struc PSP
    38 00000000 <res 00000002>      <2> 	.int20hInstruction				resb	2
    39 00000002 <res 00000002>      <2> 	.wSizeOfMemoryInParagraphs		resb	2
    40 00000004 <res 00000001>      <2> 	.reservedAt4h					resb	1
    41 00000005 <res 00000005>      <2> 	.callToDosFunctionDispatcher	resb	5
    42 0000000A <res 00000004>      <2> 	.fpInt22hTerminate				resb	4
    43 0000000E <res 00000004>      <2> 	.fpInt23hCtrlC					resb	4
    44 00000012 <res 00000004>      <2> 	.fpInt24hCriticalError			resb	4
    45 00000016 <res 00000016>      <2> 	.reservedAt16h					resb	22
    46 0000002C <res 00000002>      <2> 	.wEnvironmentSegment			resb	2
    47 0000002E <res 00000022>      <2> 	.reservedAt2Eh					resb	34
    48 00000050 <res 00000003>      <2> 	.int21hAndRetfInstructions		resb	3
    49 00000053 <res 00000009>      <2> 	.reservedAt53h					resb	9
    50 0000005C <res 00000010>      <2> 	.FCB1							resb	16
    51 0000006C <res 00000014>      <2> 	.FCB2							resb	20
    52                              <2> 	.DiskTransferArea:
    53 00000080 <res 00000001>      <2> 	.bCommandLineLength				resb	1
    54 00000081 <res 0000007F>      <2> 	.szCommandLine					resb	127
    55                              <2> endstruc
    56                              <2> 
    57                              <2> 
    58                              <2> ; DOS DTA (Disk Transfer Area)
    59                              <2> struc DTA
    60                              <2> 	; Undocumented fields
    61 00000000 <res 00000015>      <2> 	.reservedAt0h		resb	21
    62                              <2> 	; Documented fields
    63 00000015 <res 00000001>      <2> 	.bFileAttributes	resb	1	; 15h, Attribute of matching file
    64 00000016 <res 00000002>      <2> 	.wFileTime			resb	2	; 16h, File time
    65 00000018 <res 00000002>      <2> 	.wFileDate			resb	2	; 18h, File date
    66 0000001A <res 00000004>      <2> 	.dwFileSize			resb	4	; 1Ah, File size in bytes
    67 0000001E <res 0000000D>      <2> 	.szFile				resb	13	; 1Eh, ASCIZ filename + extension
    68                              <2> endstruc
    69                              <2> 
    70                              <2> 
    71                              <2> %endif ; DOS_FUNCTIONS_INC
    15                              <1> %include "File.inc"
     1                              <2> ; File name		:	File.inc
     2                              <2> ; Project name	:	Assembly Library
     3                              <2> ; Created date	:	8.10.2010
     4                              <2> ; Last update	:	6.12.2010
     5                              <2> ; Author		:	Tomi Tilli
     6                              <2> ; Description	:	File library defines.
     7                              <2> %ifndef FILE_INC
     8                              <2> %define FILE_INC
     9                              <2> 
    10                              <2> ; File access and sharing modes
    11                              <2> struc FILE_ACCESS
    12 00000000 <res 00000001>      <2> 	.ReadOnly		resb	1
    13 00000001 <res 00000001>      <2> 	.WriteOnly		resb	1
    14 00000002 <res 00000001>      <2> 	.ReadAndWrite	resb	1
    15                              <2> endstruc
    16                              <2> 
    17                              <2> ; Origin of file seek
    18                              <2> struc SEEK_FROM
    19 00000000 <res 00000001>      <2> 	.startOfFile			resb	1	; 00h
    20 00000001 <res 00000001>      <2> 	.currentFilePosition	resb	1	; 01h
    21 00000002 <res 00000001>      <2> 	.endOfFile				resb	1	; 02h
    22                              <2> endstruc
    23                              <2> 
    24                              <2> ; File attribute flags
    25                              <2> FLG_FILEATTR_READ_ONLY			EQU		(1<<0)
    26                              <2> FLG_FILEATTR_HIDDEN				EQU		(1<<1)
    27                              <2> FLG_FILEATTR_SYSTEM				EQU		(1<<2)
    28                              <2> FLG_FILEATTR_VOLUME_LABEL		EQU		(1<<3)
    29                              <2> FLG_FILEATTR_DIRECTORY			EQU		(1<<4)
    30                              <2> FLG_FILEATTR_ARCHIVE			EQU		(1<<5)
    31                              <2> 
    32                              <2> 
    33                              <2> ; Max number of bytes to read/write per DOS call when transferring DX:CX bytes
    34                              <2> SPLIT_SIZE_FOR_LARGE_TRANSFERS	EQU		(32<<10)
    35                              <2> 
    36                              <2> 
    37                              <2> %endif ; FILE_INC
    16                              <1> %include "Math.inc"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Math related macros.
     3                              <2> %ifndef MATH_INC
     4                              <2> %define MATH_INC
     5                              <2> 
     6                              <2> FALSE		EQU		0
     7                              <2> TRUE		EQU		1
     8                              <2> 
     9                              <2> 
    10                              <2> ;--------------------------------------------------------------------
    11                              <2> ; MIN_U		Unsigned comparison
    12                              <2> ; MIN_S		Signed comparison
    13                              <2> ;	Parameters:
    14                              <2> ;		%1:		Operand 1
    15                              <2> ;		%2:		Operand 2
    16                              <2> ;	Returns:
    17                              <2> ;		%1:		Lesser operand
    18                              <2> ;	Corrupts registers:
    19                              <2> ;		Nothing
    20                              <2> ;--------------------------------------------------------------------
    21                              <2> %macro MIN_U 2
    22                              <2> 	cmp		%1, %2				; Is %1 smaller?
    23                              <2> 	jb		%%Return			;  If so, return
    24                              <2> 	mov		%1, %2				; Copy %2 to %1
    25                              <2> ALIGN JUMP_ALIGN
    26                              <2> %%Return:
    27                              <2> %endmacro
    28                              <2> 
    29                              <2> %macro MIN_S 2
    30                              <2> 	cmp		%1, %2				; Is %1 smaller?
    31                              <2> 	jl		%%Return			;  If so, return
    32                              <2> 	mov		%1, %2				; Copy %2 to %1
    33                              <2> ALIGN JUMP_ALIGN
    34                              <2> %%Return:
    35                              <2> %endmacro
    36                              <2> 
    37                              <2> 
    38                              <2> ;--------------------------------------------------------------------
    39                              <2> ; MAX_U		Unsigned comparison
    40                              <2> ; MAX_S		Signed comparison
    41                              <2> ;	Parameters:
    42                              <2> ;		%1:		Operand 1
    43                              <2> ;		%2:		Operand 2
    44                              <2> ;	Returns:
    45                              <2> ;		%1:		Greater operand
    46                              <2> ;	Corrupts registers:
    47                              <2> ;		Nothing
    48                              <2> ;--------------------------------------------------------------------
    49                              <2> %macro MAX_U 2
    50                              <2> 	cmp		%1, %2				; Is %1 greater?
    51                              <2> 	ja		%%Return			;  If so, return
    52                              <2> 	mov		%1, %2				; Copy %2 to %1
    53                              <2> ALIGN JUMP_ALIGN
    54                              <2> %%Return:
    55                              <2> %endmacro
    56                              <2> 
    57                              <2> %macro MAX_S 2
    58                              <2> 	cmp		%1, %2				; Is %1 greater?
    59                              <2> 	jg		%%Return			;  If so, return
    60                              <2> 	mov		%1, %2				; Copy %2 to %1
    61                              <2> ALIGN JUMP_ALIGN
    62                              <2> %%Return:
    63                              <2> %endmacro
    64                              <2> 
    65                              <2> 
    66                              <2> ;--------------------------------------------------------------------
    67                              <2> ; SHL_DXAX
    68                              <2> ;	Parameters:
    69                              <2> ;		%1:		Number of bits to shift
    70                              <2> ;	Returns:
    71                              <2> ;		DX:AX	Shifted value
    72                              <2> ;	Corrupts registers:
    73                              <2> ;		CX
    74                              <2> ;--------------------------------------------------------------------
    75                              <2> %macro SHL_DXAX 1
    76                              <2> 	%ifnidni %1, cx
    77                              <2> 		mov		cx, %1
    78                              <2> 	%endif
    79                              <2> ALIGN JUMP_ALIGN
    80                              <2> .ShiftNextBit:
    81                              <2> 	eSHL_IM	ax, 1
    82                              <2> 	rcl		dx, 1
    83                              <2> 	loop	.ShiftNextBit
    84                              <2> %endmacro
    85                              <2> 
    86                              <2> 
    87                              <2> ;--------------------------------------------------------------------
    88                              <2> ; SHR_DXAX
    89                              <2> ;	Parameters:
    90                              <2> ;		%1:		Number of bits to shift
    91                              <2> ;	Returns:
    92                              <2> ;		DX:AX	Shifted value
    93                              <2> ;	Corrupts registers:
    94                              <2> ;		CX
    95                              <2> ;--------------------------------------------------------------------
    96                              <2> %macro SHR_DXAX 1
    97                              <2> 	%ifnidni %1, cx
    98                              <2> 		mov		cx, %1
    99                              <2> 	%endif
   100                              <2> ALIGN JUMP_ALIGN
   101                              <2> .ShiftNextBit:
   102                              <2> 	shr		dx, 1
   103                              <2> 	rcr		ax, 1
   104                              <2> 	loop	.ShiftNextBit
   105                              <2> %endmacro
   106                              <2> 
   107                              <2> 
   108                              <2> %endif ; MATH_INC
    17                              <1> %include "Registers.inc"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Register related macros.
     3                              <2> %ifndef REGISTERS_INC
     4                              <2> %define REGISTERS_INC
     5                              <2> 
     6                              <2> struc INTPACK
     7                              <2> %ifdef USE_386
     8                              <2> ;	.gs				resb	2
     9                              <2> ;	.fs				resb	2
    10                              <2> %endif
    11 00000000 <res 00000002>      <2> 	.es				resb	2
    12 00000002 <res 00000002>      <2> 	.ds				resb	2
    13 00000004 <res 00000002>      <2> 	.di				resb	2
    14 00000006 <res 00000002>      <2> 	.si				resb	2
    15 00000008 <res 00000002>      <2> 	.bp				resb	2
    16 0000000A <res 00000002>      <2> 	.sp				resb	2
    17                              <2> 	.bx:
    18 0000000C <res 00000001>      <2> 	.bl				resb	1
    19 0000000D <res 00000001>      <2> 	.bh				resb	1
    20                              <2> 	.dx:
    21 0000000E <res 00000001>      <2> 	.dl				resb	1
    22 0000000F <res 00000001>      <2> 	.dh				resb	1
    23                              <2> 	.cx:
    24 00000010 <res 00000001>      <2> 	.cl				resb	1
    25 00000011 <res 00000001>      <2> 	.ch				resb	1
    26                              <2> 	.ax:
    27 00000012 <res 00000001>      <2> 	.al				resb	1
    28 00000013 <res 00000001>      <2> 	.ah				resb	1
    29 00000014 <res 00000002>      <2> 	.ip				resb	2
    30 00000016 <res 00000002>      <2> 	.cs				resb	2
    31 00000018 <res 00000002>      <2> 	.flags			resb	2
    32                              <2> endstruc
    33                              <2> 
    34                              <2> ; 8086/8088 FLAGS
    35                              <2> FLG_FLAGS_CF		EQU (1<<0)
    36                              <2> FLG_FLAGS_PF		EQU (1<<2)
    37                              <2> FLG_FLAGS_AF		EQU (1<<4)
    38                              <2> FLG_FLAGS_ZF		EQU (1<<6)
    39                              <2> FLG_FLAGS_SF		EQU (1<<7)
    40                              <2> FLG_FLAGS_TF		EQU (1<<8)
    41                              <2> FLG_FLAGS_IF		EQU (1<<9)
    42                              <2> FLG_FLAGS_DF		EQU (1<<10)
    43                              <2> FLG_FLAGS_OF		EQU (1<<11)
    44                              <2> 
    45                              <2> 
    46                              <2> ;--------------------------------------------------------------------
    47                              <2> ; This macro must be the first thing to call on Interrupt Service Routine.
    48                              <2> ;
    49                              <2> ; CREATE_INTPACK_TO_SSBP
    50                              <2> ;	Parameters
    51                              <2> ;		Nothing
    52                              <2> ;	Returns:
    53                              <2> ;		SS:BP:	Points to INTPACK
    54                              <2> ;	Corrupts registers:
    55                              <2> ;		Nothing
    56                              <2> ;--------------------------------------------------------------------
    57                              <2> %macro CREATE_INTPACK_TO_SSBP 0
    58                              <2> 	ePUSHA
    59                              <2> 	push	ds
    60                              <2> 	push	es
    61                              <2> %ifdef USE_386
    62                              <2> ;	push	fs
    63                              <2> ;	push	gs
    64                              <2> %endif
    65                              <2> 	mov		bp, sp
    66                              <2> %endmacro
    67                              <2> 
    68                              <2> ;--------------------------------------------------------------------
    69                              <2> ; This macro must be the last thing to call on Interrupt Service Routine.
    70                              <2> ;
    71                              <2> ; RESTORE_INTPACK_FROM_SSBP
    72                              <2> ;	Parameters
    73                              <2> ;		SS:BP:	Ptr to INTPACK
    74                              <2> ;	Returns:
    75                              <2> ;		All Registers will be loaded from INTPACK
    76                              <2> ;--------------------------------------------------------------------
    77                              <2> %macro RESTORE_INTPACK_FROM_SSBP 0
    78                              <2> %ifdef USE_386
    79                              <2> ;	pop		gs
    80                              <2> ;	pop		fs
    81                              <2> %endif
    82                              <2> 	pop		es
    83                              <2> 	pop		ds
    84                              <2> 	ePOPA
    85                              <2> 	iret
    86                              <2> %endmacro
    87                              <2> 
    88                              <2> 
    89                              <2> ;--------------------------------------------------------------------
    90                              <2> ; This macro must be the first thing to call on Interrupt Service Routine.
    91                              <2> ;
    92                              <2> ; CREATE_FRAME_INTPACK_TO_SSBP
    93                              <2> ;	Parameters
    94                              <2> ;		%1:		Number of extra bytes to reserve before INTPACK
    95                              <2> ;	Returns:
    96                              <2> ;		SS:BP:	Points to INTPACK
    97                              <2> ;	Corrupts registers:
    98                              <2> ;		Nothing
    99                              <2> ;--------------------------------------------------------------------
   100                              <2> %macro CREATE_FRAME_INTPACK_TO_SSBP 1
   101                              <2> 	ePUSHA
   102                              <2> 	push	ds
   103                              <2> 	push	es
   104                              <2> %ifdef USE_386
   105                              <2> ;	push	fs
   106                              <2> ;	push	gs
   107                              <2> %endif
   108                              <2> 	sub		sp, BYTE %1
   109                              <2> 	mov		bp, sp
   110                              <2> %endmacro
   111                              <2> 
   112                              <2> ;--------------------------------------------------------------------
   113                              <2> ; This macro must be the last thing to call on Interrupt Service Routine.
   114                              <2> ;
   115                              <2> ; RESTORE_FRAME_INTPACK_FROM_SSBP
   116                              <2> ;	Parameters
   117                              <2> ;		%1:		Number of extra bytes in INTPACK
   118                              <2> ;		SS:BP:	Ptr to INTPACK
   119                              <2> ;	Returns:
   120                              <2> ;		All Registers will be loaded from INTPACK
   121                              <2> ;--------------------------------------------------------------------
   122                              <2> %macro RESTORE_FRAME_INTPACK_FROM_SSBP 1
   123                              <2> 	add		sp, BYTE %1
   124                              <2> %ifdef USE_386
   125                              <2> ;	pop		gs
   126                              <2> ;	pop		fs
   127                              <2> %endif
   128                              <2> 	pop		es
   129                              <2> 	pop		ds
   130                              <2> 	ePOPA
   131                              <2> 	iret
   132                              <2> %endmacro
   133                              <2> 
   134                              <2> 
   135                              <2> ;--------------------------------------------------------------------
   136                              <2> ; NORMALIZE_FAR_POINTER
   137                              <2> ;	Parameters:
   138                              <2> ;		%1:%2:		Far pointer to normalize
   139                              <2> ;		%3:			Scratch register
   140                              <2> ;		%4:			Scratch register
   141                              <2> ;	Returns:
   142                              <2> ;		%1:%2:		Normalized far pointer
   143                              <2> ;	Corrupts registers:
   144                              <2> ;		%3, %4
   145                              <2> ;--------------------------------------------------------------------
   146                              <2> %macro NORMALIZE_FAR_POINTER 4
   147                              <2> 	mov		%4, %2				; Copy offset to scratch reg
   148                              <2> 	and		%2, BYTE 0Fh		; Clear offset bits 15...4
   149                              <2> 	eSHR_IM	%4, 4				; Divide offset by 16
   150                              <2> 	mov		%3, %1				; Copy segment to scratch reg
   151                              <2> 	add		%3, %4				; Add shifted offset to segment
   152                              <2> 	mov		%1, %3				; Set normalized segment
   153                              <2> %endmacro
   154                              <2> 
   155                              <2> 
   156                              <2> ;--------------------------------------------------------------------
   157                              <2> ; COPY_SSBP_TO_ESDI
   158                              <2> ; COPY_SSBP_TO_DSSI
   159                              <2> ; COPY_DSSI_TO_ESDI
   160                              <2> ; COPY_ESDI_to_DSSI
   161                              <2> ;	Parameters
   162                              <2> ;		Nothing
   163                              <2> ;	Returns:
   164                              <2> ;		Copies farm pointer to different segment/pointer register pair
   165                              <2> ;	Corrupts registers:
   166                              <2> ;		Nothing
   167                              <2> ;--------------------------------------------------------------------
   168                              <2> %macro COPY_SSBP_TO_ESDI 0
   169                              <2> 	push	ss
   170                              <2> 	pop		es
   171                              <2> 	mov		di, bp
   172                              <2> %endmacro
   173                              <2> 
   174                              <2> %macro COPY_SSBP_TO_DSSI 0
   175                              <2> 	push	ss
   176                              <2> 	pop		ds
   177                              <2> 	mov		si, bp
   178                              <2> %endmacro
   179                              <2> 
   180                              <2> %macro COPY_DSSI_TO_ESDI 0
   181                              <2> 	push	ds
   182                              <2> 	pop		es
   183                              <2> 	mov		di, si
   184                              <2> %endmacro
   185                              <2> 
   186                              <2> %macro COPY_ESDI_to_DSSI 0
   187                              <2> 	push	es
   188                              <2> 	pop		ds
   189                              <2> 	mov		si, di
   190                              <2> %endmacro
   191                              <2> 
   192                              <2> 
   193                              <2> 
   194                              <2> %endif ; REGISTERS_INC
    18                              <1> %include "SystemTimer.inc"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	System Timer (8254) relates equates and macros.
     3                              <2> %ifndef SYSTEMTIMER_INC
     4                              <2> %define SYSTEMTIMER_INC
     5                              <2> 
     6                              <2> ; Timer/Counter to program
     7                              <2> TIMER_0									EQU	(0<<6)
     8                              <2> TIMER_1									EQU	(1<<6)
     9                              <2> TIMER_2									EQU	(2<<6)
    10                              <2> 
    11                              <2> ; Counter commands
    12                              <2> LATCH									EQU	(0<<4)	; Counter Latch Command (latches the count for reading)
    13                              <2> READ_OR_WRITE_LSB_ONLY					EQU	(1<<4)	; MSB is always zero
    14                              <2> READ_OR_WRITE_MSB_ONLY					EQU	(2<<4)	; LSB is always zero
    15                              <2> READ_OR_WRITE_LSB_THEN_MSB				EQU	(3<<4)
    16                              <2> 
    17                              <2> ; Timer modes
    18                              <2> MODE_0_SINGLE_TIMEOUT					EQU	(0<<1)	; Interrupt on Terminal Count
    19                              <2> MODE_1_ONE_SHOT							EQU	(1<<1)	; Hardware Retriggerable One-Shot
    20                              <2> MODE_2_RATE_GENERATOR					EQU	(2<<1)
    21                              <2> MODE_3_SQUARE_WAVE_MODE					EQU	(3<<1)
    22                              <2> MODE_4_SOFTWARE_TRIGGERED_STROBE		EQU	(4<<1)
    23                              <2> MODE_5_HARDWARE_RETRIGGERABLE_STROBE	EQU	(5<<1)
    24                              <2> 
    25                              <2> ; Binary / BCD Mode
    26                              <2> BINARY_COUNTER							EQU	0
    27                              <2> BCD_COUNTER								EQU	1
    28                              <2> 
    29                              <2> 
    30                              <2> ; Ports
    31                              <2> COUNT_REGISTER_0						EQU	40h		; Timer 0 Count Register (System Timer Ticks)
    32                              <2> COUNT_REGISTER_1						EQU	41h		; Timer 1 Count Register (DRAM Refresh)
    33                              <2> COUNT_REGISTER_2						EQU	42h		; Timer 2 Count Register (General Use)
    34                              <2> CONTROL_WORD_REGISTER_out				EQU	43h
    35                              <2> 
    36                              <2> ; Timer 2 is connected to PC Speaker that can be controller from port 61h.
    37                              <2> SPEAKER_CONTROL_REGISTER				EQU	61h
    38                              <2> FLG_TIMER_2_OUTPUT_in					EQU	(1<<5)	; AT+ only
    39                              <2> FLG_SPEAKER_DATA_ENABLED				EQU	(1<<1)
    40                              <2> FLG_SPEAKER_GATE_TIMER_2_ON				EQU	(1<<0)
    41                              <2> 
    42                              <2> 
    43                              <2> ; The duration of one tick
    44                              <2> TIMER_CYCLE_TIME						EQU	838		; nanosecs
    45                              <2> 
    46                              <2> 
    47                              <2> 
    48                              <2> 
    49                              <2> ;--------------------------------------------------------------------
    50                              <2> ; OUTPUT_COUNTER_COMMAND_TO
    51                              <2> ;	Parameters:
    52                              <2> ;		%1:		TIMER_0, TIMER_1 or TIMER_2
    53                              <2> ;		%2:		Command to counter
    54                              <2> ;		%3:		Timer mode
    55                              <2> ;		%4:		BINARY_COUNTER or BCD_COUNTER
    56                              <2> ;	Returns:
    57                              <2> ;		Nothing
    58                              <2> ;	Corrupts registers:
    59                              <2> ;		AL
    60                              <2> ;--------------------------------------------------------------------
    61                              <2> %macro OUTPUT_COUNTER_COMMAND_TO 4
    62                              <2> 	mov		al, %1 | %2 | %3 | %4
    63                              <2> 	out		CONTROL_WORD_REGISTER_out, al
    64                              <2> %endmacro
    65                              <2> 
    66                              <2> 
    67                              <2> ;--------------------------------------------------------------------
    68                              <2> ; WRITE_COUNT_FROM_AL_TO
    69                              <2> ; WRITE_COUNT_FROM_AX_TO
    70                              <2> ;	Parameters:
    71                              <2> ;		%1:		TIMER_0, TIMER_1 or TIMER_2
    72                              <2> ;		AX:		Count to write to timer
    73                              <2> ;	Returns:
    74                              <2> ;		Nothing
    75                              <2> ;	Corrupts registers:
    76                              <2> ;		AL (WRITE_COUNT_FROM_AX_TO only)
    77                              <2> ;--------------------------------------------------------------------
    78                              <2> %macro WRITE_COUNT_FROM_AL_TO 1
    79                              <2> 	%ifidni %1, TIMER_0
    80                              <2> 		out		COUNT_REGISTER_0, al
    81                              <2> 	%elifidni %1, TIMER_1
    82                              <2> 		out		COUNT_REGISTER_1, al
    83                              <2> 	%elifidni %1, TIMER_2
    84                              <2> 		out		COUNT_REGISTER_2, al
    85                              <2> 	%else
    86                              <2> 		%error "Invalid timer name passed to WRITE_COUNT_FROM_AL_TO"
    87                              <2> 	%endif
    88                              <2> %endmacro
    89                              <2> 
    90                              <2> %macro WRITE_COUNT_FROM_AX_TO 1
    91                              <2> 	%ifidni %1, TIMER_0
    92                              <2> 		out		COUNT_REGISTER_0, al
    93                              <2> 		mov		al, ah
    94                              <2> 		out		COUNT_REGISTER_0, al
    95                              <2> 	%elifidni %1, TIMER_1
    96                              <2> 		out		COUNT_REGISTER_1, al
    97                              <2> 		mov		al, ah
    98                              <2> 		out		COUNT_REGISTER_1, al
    99                              <2> 	%elifidni %1, TIMER_2
   100                              <2> 		out		COUNT_REGISTER_2, al
   101                              <2> 		mov		al, ah
   102                              <2> 		out		COUNT_REGISTER_2, al
   103                              <2> 	%else
   104                              <2> 		%error "Invalid timer name passed to WRITE_COUNT_FROM_AX_TO"
   105                              <2> 	%endif
   106                              <2> %endmacro
   107                              <2> 
   108                              <2> 
   109                              <2> ;--------------------------------------------------------------------
   110                              <2> ; READ_COUNT_TO_AL_FROM
   111                              <2> ; READ_COUNT_TO_AX_FROM
   112                              <2> ;	Parameters:
   113                              <2> ;		%1:		TIMER_0, TIMER_1 or TIMER_2
   114                              <2> ;	Returns:
   115                              <2> ;		AL/AX:	Counter value
   116                              <2> ;	Corrupts registers:
   117                              <2> ;		Nothing
   118                              <2> ;--------------------------------------------------------------------
   119                              <2> %macro READ_COUNT_TO_AL_FROM 1
   120                              <2> 	%ifidni %1, TIMER_0
   121                              <2> 		in		al, COUNT_REGISTER_0
   122                              <2> 	%elifidni %1, TIMER_1
   123                              <2> 		in		al, COUNT_REGISTER_1
   124                              <2> 	%elifidni %1, TIMER_2
   125                              <2> 		in		al, COUNT_REGISTER_2
   126                              <2> 	%else
   127                              <2> 		%error "Invalid timer name passed to READ_COUNT_TO_AL_FROM"
   128                              <2> 	%endif
   129                              <2> %endmacro
   130                              <2> 
   131                              <2> %macro READ_COUNT_TO_AX_FROM 1
   132                              <2> 	%ifidni %1, TIMER_0
   133                              <2> 		in		al, COUNT_REGISTER_0
   134                              <2> 		mov		ah, al
   135                              <2> 		in		al, COUNT_REGISTER_0
   136                              <2> 	%elifidni %1, TIMER_1
   137                              <2> 		in		al, COUNT_REGISTER_1
   138                              <2> 		mov		ah, al
   139                              <2> 		in		al, COUNT_REGISTER_1
   140                              <2> 	%elifidni %1, TIMER_2
   141                              <2> 		in		al, COUNT_REGISTER_2
   142                              <2> 		mov		ah, al
   143                              <2> 		in		al, COUNT_REGISTER_2
   144                              <2> 	%else
   145                              <2> 		%error "Invalid timer name passed to READ_COUNT_TO_AX_FROM"
   146                              <2> 	%endif
   147                              <2> 		xchg	al, ah
   148                              <2> %endmacro
   149                              <2> 
   150                              <2> 
   151                              <2> ;--------------------------------------------------------------------
   152                              <2> ; START_PRECISE_EVENT_TIMER
   153                              <2> ;	Parameters:
   154                              <2> ;		Nothing
   155                              <2> ;	Returns:
   156                              <2> ;		Nothing
   157                              <2> ;	Corrupts registers:
   158                              <2> ;		AL
   159                              <2> ;--------------------------------------------------------------------
   160                              <2> %macro START_PRECISE_EVENT_TIMER 0
   161                              <2> 	in		al, SPEAKER_CONTROL_REGISTER
   162                              <2> 	or		al, FLG_SPEAKER_GATE_TIMER_2_ON
   163                              <2> 	out		SPEAKER_CONTROL_REGISTER, al
   164                              <2> %endmacro
   165                              <2> 
   166                              <2> 
   167                              <2> ;--------------------------------------------------------------------
   168                              <2> ; STOP_PRECISE_EVENT_TIMER
   169                              <2> ;	Parameters:
   170                              <2> ;		Nothing
   171                              <2> ;	Returns:
   172                              <2> ;		Nothing
   173                              <2> ;	Corrupts registers:
   174                              <2> ;		AL
   175                              <2> ;--------------------------------------------------------------------
   176                              <2> %macro STOP_PRECISE_EVENT_TIMER 0
   177                              <2> 	in		al, SPEAKER_CONTROL_REGISTER
   178                              <2> 	and		al, ~(FLG_SPEAKER_DATA_ENABLED | FLG_SPEAKER_GATE_TIMER_2_ON)
   179                              <2> 	out		SPEAKER_CONTROL_REGISTER, al
   180                              <2> %endmacro
   181                              <2> 
   182                              <2> 
   183                              <2> %endif ; SYSTEMTIMER_INC
    19                              <1> 
    20                              <1> 
    21                              <1> ; Library dependencies
    22                              <1> %ifdef INCLUDE_MENU_DIALOGS
    23                              <1> 	%include "Dialog.inc"
    24                              <1> 	%define INCLUDE_MENU_LIBRARY
    25                              <1> 	%define INCLUDE_FILE_LIBRARY
    26                              <1> %endif
    27                              <1> 
    28                              <1> %ifdef INCLUDE_MENU_LIBRARY
    29                              <1> 	%include "Menu.inc"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Defines for Menu library.
     3                              <2> %ifndef MENU_INC
     4                              <2> %define MENU_INC
     5                              <2> 
     6                              <2> ;--------------------------------------------------------------------
     7                              <2> ; Menu Library users need to use this macro since it will provide
     8                              <2> ; compatibility with future library versions.
     9                              <2> ;
    10                              <2> ; CALL_MENU_LIBRARY
    11                              <2> ;	Parameters:
    12                              <2> ;		%1:			Function to call (functionName from MENU_LIB)
    13                              <2> ;		BP:			Menu handle
    14                              <2> ;		Registers:	Depends on function to call
    15                              <2> ;	Returns:
    16                              <2> ;		Depends on function to call
    17                              <2> ;	Corrupts registers:
    18                              <2> ;		AX (unless used as a return register), DI
    19                              <2> ;--------------------------------------------------------------------
    20                              <2> %macro CALL_MENU_LIBRARY 1
    21                              <2> 	%ifidn %1, CloseMenuIfExitEventAllows
    22                              <2> 		call	MenuInit_CloseMenuIfExitEventAllows
    23                              <2> 
    24                              <2> 	%elifidn %1, Close
    25                              <2> 		call	MenuInit_CloseMenuWindow
    26                              <2> 
    27                              <2> 	%elifidn %1, SetUserDataFromDSSI
    28                              <2> 		call	MenuInit_SetUserDataFromDSSI
    29                              <2> 
    30                              <2> 	%elifidn %1, GetUserDataToDSSI
    31                              <2> 		call	MenuInit_GetUserDataToDSSI
    32                              <2> 
    33                              <2> 	%elifidn %1, SetTitleHeightFromAL
    34                              <2> 		call	MenuInit_SetTitleHeightFromAL
    35                              <2> 
    36                              <2> 	%elifidn %1, GetHighlightedItemToAX
    37                              <2> 		call	MenuInit_GetHighlightedItemToAX
    38                              <2> 
    39                              <2> 	%elifidn %1, SetTotalItemsFromAX
    40                              <2> 		call	MenuInit_SetTotalItemsFromAX
    41                              <2> 
    42                              <2> 	%elifidn %1, SetInformationHeightFromAL
    43                              <2> 		call	MenuInit_SetInformationHeightFromAL
    44                              <2> 
    45                              <2> 	%elifidn %1, SetTimeoutValueFromAX
    46                              <2> 		call	MenuTime_SetSelectionTimeoutValueFromAX
    47                              <2> 
    48                              <2> 	%else
    49                              <2> 		mov		di, %1
    50                              <2> 		call	Menu_FunctionFromDI
    51                              <2> 	%endif
    52                              <2> %endmacro
    53                              <2> 
    54                              <2> %if 0
    55                              <2> ;;;
    56                              <2> ;;; struc no longer needed with direct call to function
    57                              <2> ;;;
    58                              <2> 
    59                              <2> ; Menu library functions
    60                              <2> struc MENU_LIB
    61                              <2> 	.DisplayWithHandlerInBXandUserDataInDXAX	resb	2
    62                              <2> 	.SendExitMenuEvent:
    63                              <2> 	.Close:
    64                              <2> 	.RefreshWindow								resb	2
    65                              <2> 
    66                              <2> 	.SetUserDataFromDSSI:
    67                              <2> 	.GetUserDataToDSSI:
    68                              <2> 
    69                              <2> 	.SetTitleHeightFromAL:
    70                              <2> 	.ClearTitleArea								resb	2
    71                              <2> 	.RefreshTitle								resb	2
    72                              <2> 
    73                              <2> 	.GetHighlightedItemToAX:
    74                              <2> 	.HighlightItemFromAX						resb	2
    75                              <2> 	.SetTotalItemsFromAX:
    76                              <2> 	.RefreshItemFromAX							resb	2
    77                              <2> 
    78                              <2> 	.SetInformationHeightFromAL:
    79                              <2> 	.ClearInformationArea						resb	2
    80                              <2> 	.RefreshInformation							resb	2
    81                              <2> 
    82                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
    83                              <2> 	.StartSelectionTimeoutWithTicksInAX			resb	2
    84                              <2> %endif
    85                              <2> 
    86                              <2> %ifdef INCLUDE_MENU_DIALOGS
    87                              <2> 	.StartProgressTaskWithIoInDSSIandParamInDXAX	resb	2
    88                              <2> 	.SetProgressValueFromAX							resb	2
    89                              <2> 
    90                              <2> 	.DisplayMessageWithInputInDSSI					resb	2
    91                              <2> 	.GetSelectionToAXwithInputInDSSI				resb	2
    92                              <2> 	.GetWordWithIoInDSSI							resb	2
    93                              <2> 	.GetStringWithIoInDSSI							resb	2
    94                              <2> 	.GetFileNameWithIoInDSSI						resb	2
    95                              <2> 	.GetDriveWithIoInDSSI							resb	2
    96                              <2> %endif
    97                              <2> endstruc
    98                              <2> %endif
    99                              <2> 
   100                              <2> ; Menu initialization parameters
   101                              <2> struc MENUINIT
   102 00000000 <res 00000002>      <2> 	.wItems							resb	2	; Number of items in menu
   103 00000002 <res 00000002>      <2> 	.wHighlightedItem				resb	2	; Index for highlighted item
   104                              <2> 
   105                              <2> 	.wTitleAndInfoLines:
   106 00000004 <res 00000001>      <2> 	.bTitleLines					resb	1	; Number of title lines
   107 00000005 <res 00000001>      <2> 	.bInfoLines						resb	1	; Number of information lines
   108                              <2> 
   109                              <2> 	.wWidthAndHeight:
   110 00000006 <res 00000001>      <2> 	.bWidth							resb	1	; Menu width in characters
   111 00000007 <res 00000001>      <2> 	.bHeight						resb	1	; Menu height in characters
   112                              <2> endstruc
   113                              <2> 
   114                              <2> 
   115                              <2> ; All menu parameters
   116                              <2> struc MENU
   117 00000000 <res 00000008>      <2> 	.menuInit						resb	MENUINIT_size	; Must be first
   118 00000008 <res 00000002>      <2> 	.fnEventHandler					resb	2	; Offset to Menu event handler
   119 0000000A <res 00000004>      <2> 	.dwUserData						resb	4	; User specified data
   120                              <2> 
   121 0000000E <res 00000001>      <2> 	.bFlags							resb	1	; Menu flags
   122 0000000F <res 00000001>      <2> 									resb	1
   123 00000010 <res 00000002>      <2> 	.wTimeoutCounter				resb	2
   124 00000012 <res 00000002>      <2> 	.wFirstVisibleItem				resb	2	; Index for first visible item on the menu
   125                              <2> endstruc
   126                              <2> 
   127                              <2> ; Flags for MENU.wFlags
   128                              <2> FLG_MENU_EXIT						EQU		(1<<0)	; Close and exit menu
   129                              <2> FLG_MENU_NOHIGHLIGHT				EQU		(1<<1)	; Never highlight items
   130                              <2> FLG_MENU_USER_HANDLES_SCROLLING		EQU		(1<<2)
   131                              <2> FLG_MENU_TIMEOUT_COUNTDOWN			EQU		(1<<3)	; Timeout countdown in progress
   132                              <2> 
   133                              <2> 
   134                              <2> MENU_VERTICAL_BORDER_LINES			EQU		5	; Title top and bottom + Info top and bottom + bottom shadow
   135                              <2> MENU_HORIZONTAL_BORDER_LINES		EQU		3	; Left + Right borders + Right shadow
   136                              <2> MENU_TEXT_ROW_OFFSET				EQU		1
   137                              <2> MENU_TEXT_COLUMN_OFFSET				EQU		2
   138                              <2> MENU_TIMEOUT_STRING_CHARACTERS		EQU		19
   139                              <2> MENU_TIMEOUT_SECONDS_FOR_HURRY		EQU		3
   140                              <2> 
   141                              <2> SCROLL_TRACK_CHARACTER				EQU		BLOCK_EVEN_BACKGROUND_AND_FOREGROUND
   142                              <2> SCROLL_THUMB_CHARACTER				EQU		BLOCK_FULL_FOREGROUND
   143                              <2> 
   144                              <2> NO_ITEM_SELECTED					EQU		-1
   145                              <2> NO_ITEM_HIGHLIGHTED					EQU		-1
   146                              <2> NO_TIMEOUT_USED						EQU		0
   147                              <2> 
   148                              <2> 
   149                              <2> ; Keyboard keys (scan codes) used by menu library
   150                              <2> ;MENU_KEY_ENTER		EQU		1Ch
   151                              <2> ;MENU_KEY_ESC		EQU		01h
   152                              <2> MENU_KEY_UP			EQU		48h
   153                              <2> MENU_KEY_DOWN		EQU		50h
   154                              <2> MENU_KEY_PGUP		EQU		49h
   155                              <2> MENU_KEY_PGDN		EQU		51h
   156                              <2> MENU_KEY_HOME		EQU		47h
   157                              <2> MENU_KEY_END		EQU		4Fh
   158                              <2> 
   159                              <2> 
   160                              <2> %endif ; MENU_INC
    30                              <1> 	%include "MenuEvents.inc"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Defines for Menu events send to the user.
     3                              <2> %ifndef MENUEVENTS_INC
     4                              <2> %define MENUEVENTS_INC
     5                              <2> 
     6                              <2> ;--------------------------------------------------------------------
     7                              <2> ; Events to be processed in user implemented handler.
     8                              <2> ;	Common parameters for all events:
     9                              <2> ;		BX:			Menu event (anything from MENUEVENT struct)
    10                              <2> ;		SS:BP:		Menu library handle
    11                              <2> ;	Common return values for all events:
    12                              <2> ;		CF:			Set if event processed
    13                              <2> ;					Cleared if event not processed
    14                              <2> ;	Corrupts registers:
    15                              <2> ;		All
    16                              <2> ;--------------------------------------------------------------------
    17                              <2> 
    18                              <2> ;
    19                              <2> ; There are two ways to use MENUEVENT:
    20                              <2> ;
    21                              <2> ; 1. If the program needs two different menus, include the definition of the MENUEVENT structure below,
    22                              <2> ;    instantiate with members that point to the routines that make up the menu.
    23                              <2> ;
    24                              <2> ; 2. If the program needs only one menu, %define MENUEVENT_INLINE_OFFSETS before this include file,
    25                              <2> ;    and define (through EQU statements) each of the entry points as offsets from a base address.
    26                              <2> ;
    27                              <2> 
    28                              <2> ;
    29                              <2> ; If user level idle processing is desired, %define this symbol and .IdleProcessing will be called.
    30                              <2> ; Otherwise, the code and structure entry will be omitted.  Note that INCLUDE_MENU_DIALOGS requires
    31                              <2> ; the idle processing (if that is the case, it is turned on here).
    32                              <2> ;
    33                              <2> ;%define MENUEVENT_IDLEPROCESSING_ENABLE
    34                              <2> ;
    35                              <2> 
    36                              <2> %ifdef INCLUDE_MENU_DIALOGS
    37                              <2> %define MENUEVENT_IDLEPROCESSING_ENABLE
    38                              <2> %endif
    39                              <2> 
    40                              <2> %ifndef MENUEVENT_INLINE_OFFSETS
    41                              <2> 
    42                              <2> struc MENUEVENT
    43                              <2> 	; Parameters:
    44                              <2> 	;	DS:SI:		Ptr to MENUINIT struct to initialize
    45                              <2> 	; Returns:
    46                              <2> 	;	DS:SI:		Ptr to initialized MENUINIT struct
    47                              <2> 	.InitializeMenuinitFromDSSI	resb	2
    48                              <2> %define MENUEVENT_InitializeMenuinitFromDSSI	MENUEVENT.InitializeMenuinitFromDSSI
    49                              <2> 
    50                              <2> 	; Parameters:
    51                              <2> 	;	None
    52                              <2> 	; Returns:
    53                              <2> 	;	CF:			Set to exit menu
    54                              <2> 	;				Clear to cancel exit
    55                              <2> 	.ExitMenu					resb	2
    56                              <2> %define MENUEVENT_ExitMenu						MENUEVENT.ExitMenu
    57                              <2> 
    58                              <2> %ifdef MENUEVENT_IDLEPROCESSING_ENABLE
    59                              <2> 	; Parameters:
    60                              <2> 	;	None
    61                              <2> 	; See the definition of MENUEVENT_IDLEPROCESSING_ENABLE below.
    62                              <2> 	.IdleProcessing				resb	2
    63                              <2> %define MENUEVENT_IdleProcessing				MENUEVENT.IdleProcessing
    64                              <2> %endif
    65                              <2> 
    66                              <2> 	; Parameters:
    67                              <2> 	;	CX:			Index of new highlighted item
    68                              <2> 	;	DX:			Index of previously highlighted item or NO_ITEM_HIGHLIGHTED
    69                              <2> 	.ItemHighlightedFromCX		resb	2
    70                              <2> %define MENUEVENT_ItemHighlightedFromCX			MENUEVENT.ItemHighlightedFromCX
    71                              <2> 
    72                              <2> 	; Parameters:
    73                              <2> 	;	CX:			Index of selected item
    74                              <2> 	.ItemSelectedFromCX			resb	2
    75                              <2> %define MENUEVENT_ItemSelectedFromCX			MENUEVENT.ItemSelectedFromCX
    76                              <2> 
    77                              <2> 	; Parameters:
    78                              <2> 	;	AL:			ASCII character for the key
    79                              <2> 	;	AH:			Keyboard library scan code for the key
    80                              <2> 	.KeyStrokeInAX				resb	2
    81                              <2> %define MENUEVENT_KeyStrokeInAX					MENUEVENT.KeyStrokeInAX
    82                              <2> 
    83                              <2> 	; Parameters:
    84                              <2> 	;	CX:			Index of highlighted item
    85                              <2> 	;	Cursor has been positioned to the beginning of first line
    86                              <2> 	.RefreshTitle				resb	2
    87                              <2> 	.RefreshInformation			resb	2
    88                              <2> %define MENUEVENT_RefreshTitle					MENUEVENT.RefreshTitle
    89                              <2> %define MENUEVENT_RefreshInformation			MENUEVENT.RefreshInformation
    90                              <2> 
    91                              <2> 	; Parameters:
    92                              <2> 	;	CX:			Index of item to refresh
    93                              <2> 	;	Cursor has been positioned to the beginning of item line
    94                              <2> 	.RefreshItemFromCX			resb	2
    95                              <2> %define MENUEVENT_RefreshItemFromCX				MENUEVENT.RefreshItemFromCX
    96                              <2> endstruc
    97                              <2> 
    98                              <2> %endif ; MENUEVENT_INLINE_OFFSETS
    99                              <2> 
   100                              <2> %endif ; MENUEVENTS_INC
    31                              <1> 	%define INCLUDE_KEYBOARD_LIBRARY
    32                              <1> 	%define INCLUDE_TIME_LIBRARY
    33                              <1> %endif
    34                              <1> 
    35                              <1> %ifdef INCLUDE_KEYBOARD_LIBRARY
    36                              <1> 	%define INCLUDE_DISPLAY_LIBRARY
    37                              <1> 	%define INCLUDE_UTIL_LIBRARY
    38                              <1> %endif
    39                              <1> 
    40                              <1> %ifdef INCLUDE_DISPLAY_LIBRARY
    41                              <1> 	%include "Display.inc"
     1                              <2> ; Project name	:	AssemblyLibrary
     2                              <2> ; Description	:	Defines for display library.
     3                              <2> %ifndef DISPLAY_INC
     4                              <2> %define DISPLAY_INC
     5                              <2> 
     6                              <2> %ifndef MODULE_STRINGS_COMPRESSED_PRECOMPRESS
     7                              <2> ;--------------------------------------------------------------------
     8                              <2> ; Display Library users need to use these macros since it will provide
     9                              <2> ; compatibility with future library versions.
    10                              <2> ;
    11                              <2> ; CALL_DISPLAY_LIBRARY
    12                              <2> ; JMP_DISPLAY_LIBRARY
    13                              <2> ;	Parameters:
    14                              <2> ;		%1:			Function to call (functionName from DISPLAY_LIB)
    15                              <2> ;		Registers:	Depends on function to call
    16                              <2> ;	Returns:
    17                              <2> ;		Depends on function to call
    18                              <2> ;	Corrupts registers:
    19                              <2> ;		AX (unless used as a return register), DI
    20                              <2> ;--------------------------------------------------------------------
    21                              <2> %macro CALL_DISPLAY_LIBRARY 1
    22                              <2> 	%ifidn %1, PushDisplayContext
    23                              <2> 		call	DisplayContext_Push
    24                              <2> 	%elifidn %1, PopDisplayContext
    25                              <2> 		call	DisplayContext_Pop
    26                              <2> 	%elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    27                              <2> 		call	DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    28                              <2> 	%else
    29                              <2> 		mov		di, %1
    30                              <2> 		call	Display_FunctionFromDI
    31                              <2> 	%endif
    32                              <2> %endmacro
    33                              <2> 
    34                              <2> %macro JMP_DISPLAY_LIBRARY 1
    35                              <2> 	%ifidn %1, PushDisplayContext
    36                              <2> 		jmp		DisplayContext_Push
    37                              <2> 	%elifidn %1, PopDisplayContext
    38                              <2> 		call	DisplayContext_Pop
    39                              <2> 		ret
    40                              <2> 	%elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    41                              <2> 		jmp		DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    42                              <2> 	%elifidn %1, FormatNullTerminatedStringFromCSSI
    43                              <2> 		mov		di, %1
    44                              <2> 		call	Display_FunctionFromDI
    45                              <2> 		ret
    46                              <2> 	%else
    47                              <2> 		mov		di, %1
    48                              <2> 		jmp		Display_FunctionFromDI
    49                              <2> 	%endif
    50                              <2> %endmacro
    51                              <2> 
    52                              <2> %if 0
    53                              <2> ;;;
    54                              <2> ;;; struc no longer needed with direct calls to functions
    55                              <2> ;;;
    56                              <2> 
    57                              <2> ; Display library functions
    58                              <2> struc DISPLAY_LIB
    59                              <2> 	.PushDisplayContext:
    60                              <2> 	.PopDisplayContext:
    61                              <2> 	.InitializeDisplayContext						resb	2
    62                              <2> 
    63                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    64                              <2> 	.SetCharacterPointerFromBXAX					resb	2
    65                              <2> %endif
    66                              <2> 	.SetCharOutputFunctionFromAXwithAttribFlagInBL	resb	2
    67                              <2> 	.SetCharacterOutputParameterFromAX				resb	2
    68                              <2> 	.SetCharacterAttributeFromAL					resb	2
    69                              <2> 	.SetCursorShapeFromAX							resb	2
    70                              <2> 	.SetCursorCoordinatesFromAX						resb	2
    71                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
    72                              <2> 	.SetNewPageFromAL								resb	2
    73                              <2> %endif
    74                              <2> 	.SynchronizeDisplayContextToHardware			resb	2
    75                              <2> 
    76                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    77                              <2> 	.GetCharacterPointerToBXAX						resb	2
    78                              <2> %endif
    79                              <2> 	.GetSoftwareCoordinatesToAX						resb	2
    80                              <2> 	.GetColumnsToALandRowsToAH						resb	2
    81                              <2> 
    82                              <2> 	.FormatNullTerminatedStringFromCSSI				resb	2
    83                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    84                              <2> 	.PrintSignedWordFromAXWithBaseInBX				resb	2
    85                              <2> %endif
    86                              <2> 	.PrintWordFromAXwithBaseInBX					resb	2
    87                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
    88                              <2> 	.PrintQWordFromSSBPwithBaseInBX					resb	2
    89                              <2> %endif
    90                              <2> 	.PrintCharBufferFromBXSIwithLengthInCX			resb	2
    91                              <2> 	.PrintNullTerminatedStringFromBXSI				resb	2
    92                              <2> 	.PrintNullTerminatedStringFromCSSI				resb	2
    93                              <2> 	.PrintRepeatedCharacterFromALwithCountInCX		resb	2
    94                              <2> 	.PrintCharacterFromAL							resb	2
    95                              <2> 	.PrintNewlineCharacters							resb	2
    96                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    97                              <2> 	.ClearAreaWithHeightInAHandWidthInAL			resb	2
    98                              <2> %endif
    99                              <2> 	.ClearScreenWithCharInALandAttrInAH				resb	2
   100                              <2> endstruc
   101                              <2> %endif
   102                              <2> 
   103                              <2> ; Attribute flags for DISPLAY_LIB.SetCharacterOutputFunctionFromAXwithAttributeFlagInBL
   104                              <2> ATTRIBUTES_NOT_USED							EQU		0
   105                              <2> ATTRIBUTES_ARE_USED							EQU		FLG_CONTEXT_ATTRIBUTES
   106                              <2> 
   107                              <2> ; Character output functions for DISPLAY_LIB.SetCharacterOutputFunctionFromAXwithAttributeFlagInBL
   108                              <2> TELETYPE_OUTPUT_WITH_ATTRIBUTE				EQU		DisplayCharOut_TeletypeOutputWithAttribute
   109                              <2> TELETYPE_OUTPUT_WITHOUT_ATTRIBUTE			EQU		DisplayCharOut_TeletypeOutput
   110                              <2> TELETYPE_OUTPUT_USING_BIOS					EQU		DisplayCharOut_BiosTeletypeOutput
   111                              <2> FAST_OUTPUT_WITH_ATTRIBUTE_ONLY				EQU		DisplayCharOut_Attribute
   112                              <2> FAST_OUTPUT_WITH_CHAR_ONLY					EQU		DisplayCharOut_Character
   113                              <2> FAST_OUTPUT_WITH_CHAR_AND_ATTRIBUTE			EQU		DisplayCharOut_CharacterWithAttribute
   114                              <2> BUFFER_OUTPUT_WITH_CHAR_ONLY				EQU		DisplayCharOut_WriteCharacterToBuffer
   115                              <2> 
   116                              <2> DEFAULT_CHARACTER_OUTPUT					EQU		TELETYPE_OUTPUT_WITH_ATTRIBUTE
   117                              <2> 
   118                              <2> 
   119                              <2> struc VIDEO_BDA
   120 00000000 <res 00000449>      <2> 						resb	449h
   121 00000449 <res 00000001>      <2> 	.bMode				resb	1		; 0:449h, Video, Mode
   122 0000044A <res 00000002>      <2> 	.wColumns			resb	2		; 0:44Ah, Video, Number of columns
   123 0000044C <res 00000002>      <2> 	.wBytesPerPage		resb	2		; 0:44Ch, Video, Total number of bytes per page
   124 0000044E <res 00000002>      <2> 	.wPageOffset		resb	2		; 0:44Eh, Video, Current page offset
   125 00000450 <res 00000004>      <2> 	.rgwCursors			resb	4		; 0:450h, Video, Cursor position, pages 0...1
   126 00000454 <res 0000000C>      <2> 	.displayContext		resb	12		; Our own display context (normally cursors for pages 2...7)
   127 00000460 <res 00000002>      <2> 	.wCursorShape		resb	2		; 0:460h, Video, Cursor shape
   128 00000462 <res 00000001>      <2> 	.bActivePage		resb	1		; 0:462h, Video, Active display page
   129 00000463 <res 00000002>      <2> 	.wVideoPort			resb	2		; 0:463h, Video, I/O Port number base
   130 00000465 <res 00000001>      <2> 	.bInternalModeReg	resb	1		; 0:465h, Video, Internal mode register
   131 00000466 <res 00000001>      <2> 	.bColorPalette		resb	1		; 0:466h, Video, Color palette
   132                              <2> endstruc
   133                              <2> 
   134                              <2> struc DISPLAY_CONTEXT
   135 00000000 <res 00000004>      <2> 	.fpCursorPosition	resb	4	; Far pointer to cursor position in video memory
   136 00000004 <res 00000002>      <2> 	.fnCharOut			resb	2	; Function to draw character with
   137 00000006 <res 00000002>      <2> 	.wCharOutParam		resb	2	; User parameter for custom character output function
   138 00000008 <res 00000002>      <2> 	.wCursorShape		resb	2	; Current cursor shape
   139 0000000A <res 00000001>      <2> 	.bAttribute			resb	1	; Selected character attribute
   140 0000000B <res 00000001>      <2> 	.bFlags				resb	1	; Display context flags
   141                              <2> endstruc
   142                              <2> 
   143                              <2> ; Display context flags
   144                              <2> FLG_CONTEXT_ATTRIBUTES		EQU		(1<<0)	; Character output function uses attributes
   145                              <2> FLG_CONTEXT_CGA				EQU		(1<<1)	; CGA detected so prevent CGA snow
   146                              <2> 
   147                              <2> 
   148                              <2> ; Text mode character attribute byte bits for CGA+ (color adapters)
   149                              <2> FLG_COLOR_FORE_BLUE			EQU		(1<<0)
   150                              <2> FLG_COLOR_FORE_GREEN		EQU		(1<<1)
   151                              <2> FLG_COLOR_FORE_RED			EQU		(1<<2)
   152                              <2> FLG_COLOR_FORE_INTENSITY	EQU		(1<<3)
   153                              <2> FLG_COLOR_FORE_FONT_B		EQU		(1<<3)	; Select font set B (if available, EGA+)
   154                              <2> FLG_COLOR_BACK_BLUE			EQU		(1<<4)
   155                              <2> FLG_COLOR_BACK_GREEN		EQU		(1<<5)
   156                              <2> FLG_COLOR_BACK_RED			EQU		(1<<6)
   157                              <2> FLG_COLOR_BACK_INTENSITY	EQU		(1<<7)	; Intensity when blinking is disabled
   158                              <2> FLG_COLOR_BLINK				EQU		(1<<7)	; Blinking color when enabled (enabled by default)
   159                              <2> 
   160                              <2> ; CGA colors
   161                              <2> %define COLOR_ATTRIBUTE(foreground, background)	( (foreground) | ((background)<<4) )
   162                              <2> COLOR_BLACK					EQU		0
   163                              <2> COLOR_BLUE					EQU		1
   164                              <2> COLOR_GREEN					EQU		2
   165                              <2> COLOR_CYAN					EQU		3
   166                              <2> COLOR_RED					EQU		4
   167                              <2> COLOR_MAGENTA				EQU		5
   168                              <2> COLOR_BROWN					EQU		6
   169                              <2> COLOR_WHITE					EQU		7		; Last background color if blinking enabled
   170                              <2> COLOR_GRAY					EQU		8
   171                              <2> COLOR_LIGHT_BLUE			EQU		9
   172                              <2> COLOR_LIGHT_GREEN			EQU		10
   173                              <2> COLOR_LIGHT_CYAN			EQU		11
   174                              <2> COLOR_LIGHT_RED				EQU		12
   175                              <2> COLOR_LIGHT_MAGENTA			EQU		13
   176                              <2> COLOR_YELLOW				EQU		14
   177                              <2> COLOR_BRIGHT_WHITE			EQU		15
   178                              <2> 
   179                              <2> 
   180                              <2> ; Text mode character attribute byte bits for MDA (monochrome adapters)
   181                              <2> ; (attributes 00h, 08h, 80h, 88h, 70h, 78h, F0h and F8h are exceptions)
   182                              <2> FLG_MONO_UNDERLINE			EQU		(1<<1)
   183                              <2> FLG_MONO_INTENSITY			EQU		(1<<3)
   184                              <2> FLG_MONO_BLINK				EQU		(1<<7)
   185                              <2> 
   186                              <2> ; Text mode character attribute bytes for MDA/Hercules (monochrome adapters)
   187                              <2> ; *Not displayed on some monitors
   188                              <2> MONO_HIDDEN					EQU		00h		; Not displayed (same for 08h, 80h and 88h)
   189                              <2> MONO_UNDERLINE				EQU		01h		; Underlined
   190                              <2> MONO_NORMAL					EQU		07h		; Normal (white on black)
   191                              <2> MONO_BRIGHT_UNDERLINE		EQU		09h		; High intensity, underlined
   192                              <2> MONO_BRIGHT					EQU		0Fh		; High intensity
   193                              <2> MONO_REVERSE				EQU		70h		; Reverse video (black on white)
   194                              <2> MONO_REVERSE_DARK			EQU		78h		; (dark green on green)
   195                              <2> MONO_BLINK					EQU		87h		; Blinking white on black*
   196                              <2> MONO_BRIGHT_BLINK			EQU		8Fh		; Blinking high intensity*
   197                              <2> MONO_REVERSE_BLINK			EQU		0F0h	; Blinking reverse video
   198                              <2> MONO_REVERSE_DARK_BLINK		EQU		0F8h	; (blinking dark green on green)
   199                              <2> 
   200                              <2> 
   201                              <2> ; Cursor position macro for DX register
   202                              <2> %define CURSOR_XY(x, y)	( (x) | ((y)<<8) )
   203                              <2> 
   204                              <2> ; Cursor shapes
   205                              <2> CURSOR_NORMAL_COLOR			EQU		0607h		; Two line cursor near or at the bottom of cell (not valid for IBM MDA)
   206                              <2> CURSOR_NORMAL_MDA			EQU		0B0Ch		; Scanlines 11 and 12
   207                              <2> CURSOR_HIDDEN				EQU		2000h
   208                              <2> 
   209                              <2> 
   210                              <2> ; Display modes
   211                              <2> CGA_TEXT_MODE_BW40			EQU		0		; Applications should use...
   212                              <2> CGA_TEXT_MODE_CO40			EQU		1
   213                              <2> CGA_TEXT_MODE_BW80			EQU		2		; ..black, white and bright white attributes only
   214                              <2> CGA_TEXT_MODE_CO80			EQU		3
   215                              <2> MDA_TEXT_MODE				EQU		7		; Real monochrome attributes available
   216                              <2> 
   217                              <2> 
   218                              <2> ; Display segments
   219                              <2> COLOR_TEXT_SEGMENT			EQU		0B800h	; Text modes 0...3 (CGA+)
   220                              <2> MONO_TEXT_SEGMENT			EQU		0B000h	; Text mode 7 (MDA, Hercules)
   221                              <2> 
   222                              <2> OFFSET_TO_CGA_STATUS_REGISTER	EQU		6	; Base port 3D4h + 6 = 3DAh
   223                              <2> CGA_STATUS_REGISTER				EQU		3DAh
   224                              <2> 
   225                              <2> %endif ; MODULE_STRINGS_COMPRESS_PRECOMPRESS
   226                              <2> 
   227                              <2> ; Control characters for teletype output
   228                              <2> NULL						EQU		00h
   229                              <2> SOH							EQU		01h		; Start of heading
   230                              <2> STX							EQU		02h		; Start of text
   231                              <2> BELL						EQU		07h		; Bell
   232                              <2> BS							EQU		08h		; Backspace
   233                              <2> TAB							EQU		09h		; Horizontal TAB
   234                              <2> LF							EQU		0Ah		; Line feed (newline)
   235                              <2> CR							EQU		0Dh		; Carriage return
   236                              <2> ESC							EQU		1Bh		; Escape
   237                              <2> 
   238                              <2> ; Non ASCII characters (code page 437)
   239                              <2> BETA										EQU		225
   240                              <2> QUOTATION_MARK								EQU		34
   241                              <2> DOUBLE_TOP_RIGHT_CORNER						EQU		187
   242                              <2> DOUBLE_TOP_LEFT_CORNER						EQU		201
   243                              <2> DOUBLE_BOTTOM_RIGHT_CORNER					EQU		188
   244                              <2> DOUBLE_BOTTOM_LEFT_CORNER					EQU		200
   245                              <2> DOUBLE_VERTICAL								EQU		186
   246                              <2> DOUBLE_HORIZONTAL							EQU		205
   247                              <2> DOUBLE_VERTICAL_TO_RIGHT_SINGLE				EQU		199
   248                              <2> DOUBLE_VERTICAL_TO_LEFT_SINGLE				EQU		182
   249                              <2> DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL	EQU		181
   250                              <2> DOUBLE_RIGHT_HORIZONTAL_TO_SINGLE_VERTICAL	EQU		198
   251                              <2> SINGLE_VERTICAL								EQU		179
   252                              <2> SINGLE_HORIZONTAL							EQU		196
   253                              <2> SINGLE_LEFT_HORIZONTAL_TO_VERTICAL			EQU		180
   254                              <2> SINGLE_RIGHT_HORIZONTAL_TO_VERTICAL			EQU		195
   255                              <2> ANGLE_QUOTE_LEFT							EQU		174
   256                              <2> ANGLE_QUOTE_RIGHT							EQU		175
   257                              <2> BLOCK_MOSTLY_BACKGROUND						EQU		176
   258                              <2> BLOCK_EVEN_BACKGROUND_AND_FOREGROUND		EQU		177
   259                              <2> BLOCK_MOSTLY_FOREGROUND						EQU		178
   260                              <2> BLOCK_FULL_FOREGROUND						EQU		219
   261                              <2> ONE_HALF									EQU		171
   262                              <2> ONE_QUARTER									EQU		172
   263                              <2> 
   264                              <2> 
   265                              <2> ; Background character for clearing screen
   266                              <2> %ifndef SCREEN_BACKGROUND_CHARACTER
   267                              <2> 	%define	SCREEN_BACKGROUND_CHARACTER		BLOCK_MOSTLY_BACKGROUND
   268                              <2> %endif
   269                              <2> %ifndef SCREEN_BACKGROUND_ATTRIBUTE
   270                              <2> 	%define	SCREEN_BACKGROUND_ATTRIBUTE		MONO_NORMAL
   271                              <2> %endif
   272                              <2> %define SCREEN_BACKGROUND_CHARACTER_AND_ATTRIBUTE	(SCREEN_BACKGROUND_CHARACTER | (SCREEN_BACKGROUND_ATTRIBUTE<<8))
   273                              <2> %define DOS_BACKGROUND_CHARACTER_AND_ATTRIBUTE		(' ' | (MONO_NORMAL<<8))
   274                              <2> 
   275                              <2> %endif ; DISPLAY_INC
    42                              <1> 	%define INCLUDE_STRING_LIBRARY
    43                              <1> %endif
    44                              <1> 
    45                              <1> %ifdef INCLUDE_STRING_LIBRARY
    46                              <1> 	%define INCLUDE_UTIL_LIBRARY
    47                              <1> %endif
    48                              <1> 
    49                              <1> %ifdef INCLUDE_FILE_LIBRARY
    50                              <1> 	%define INCLUDE_UTIL_LIBRARY
    51                              <1> %endif
    52                              <1> 
    53                              <1> 
    54                              <1> %endif ; ASSEMBLY_LIBRARY_INC
    48                                  	%include "ModuleDependency.inc"	; Dependency checks for optional modules. Must be included second!
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Dependencies for optional modules.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Allow RELOCATE_INT13H_STACK only for AT builds
    21                              <1> %ifndef USE_AT
    22                              <1> 	%ifdef RELOCATE_INT13H_STACK
    23                              <1> 		%undef RELOCATE_INT13H_STACK
    24                              <1> 		%warning "RELOCATE_INT13H_STACK is not supported for XT builds!"
    25                              <1> 	%endif
    26                              <1> %endif
    27                              <1> 
    28                              <1> 
    29                              <1> %ifdef MODULE_SERIAL_FLOPPY
    30                              <1> 	%ifndef MODULE_SERIAL
    31                              <1> 		%define MODULE_SERIAL
    32                              <1> 	%endif
    33                              <1> %endif
    34                              <1> 
    35                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
    36                              <1> 	%define MODULE_8BIT_IDE
    37                              <1> 	%include "DmaController.inc"
     1                              <2> ; Project name	:	XTIDE Universal BIOS
     2                              <2> ; Description	:	Equates for 8237 DMA Controllers.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> %ifndef DMA_CONTROLLER_INC
    21                              <2> %define DMA_CONTROLLER_INC
    22                              <2> 
    23                              <2> ; 8237 Master (8-bit) and Slave (16-bit) DMA Controller Ports
    24                              <2> 
    25                              <2> ; Page Registers
    26                              <2> PAGE_DMA8_CH_1		EQU		83h
    27                              <2> PAGE_DMA8_CH_2		EQU		81h
    28                              <2> PAGE_DMA8_CH_3		EQU		82h
    29                              <2> PAGE_DMA16_CH_5		EQU		8Bh		; AT+
    30                              <2> PAGE_DMA16_CH_6		EQU		89h		; AT+
    31                              <2> PAGE_DMA16_CH_7		EQU		8Ah		; AT+
    32                              <2> 
    33                              <2> ; Base and Current Address Registers
    34                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH1_out	EQU		02h
    35                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH2_out	EQU		04h
    36                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH3_out	EQU		06h
    37                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA16_CH5_out	EQU		0C4h	; AT+
    38                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA16_CH6_out	EQU		0C8h	; AT+
    39                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA16_CH7_out	EQU		0CCh	; AT+
    40                              <2> CURRENT_ADDRESS_REGISTER_DMA8_CH1_in			EQU		02h
    41                              <2> CURRENT_ADDRESS_REGISTER_DMA8_CH2_in			EQU		04h
    42                              <2> CURRENT_ADDRESS_REGISTER_DMA8_CH3_in			EQU		06h
    43                              <2> CURRENT_ADDRESS_REGISTER_DMA16_CH5_in			EQU		0C4h	; AT+
    44                              <2> CURRENT_ADDRESS_REGISTER_DMA16_CH6_in			EQU		0C8h	; AT+
    45                              <2> CURRENT_ADDRESS_REGISTER_DMA16_CH7_in			EQU		0CCh	; AT+
    46                              <2> 
    47                              <2> ; Base and Current Count Registers
    48                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH1_out	EQU		03h
    49                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH2_out	EQU		05h
    50                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH3_out	EQU		07h
    51                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA16_CH5_out	EQU		0C6h	; AT+
    52                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA16_CH6_out	EQU		0CAh	; AT+
    53                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA16_CH7_out	EQU		0CEh	; AT+
    54                              <2> CURRENT_COUNT_REGISTER_DMA8_CH1_in				EQU		03h
    55                              <2> CURRENT_COUNT_REGISTER_DMA8_CH2_in				EQU		05h
    56                              <2> CURRENT_COUNT_REGISTER_DMA8_CH3_in				EQU		07h
    57                              <2> CURRENT_COUNT_REGISTER_DMA16_CH5_in				EQU		0C6h	; AT+
    58                              <2> CURRENT_COUNT_REGISTER_DMA16_CH6_in				EQU		0CAh	; AT+
    59                              <2> CURRENT_COUNT_REGISTER_DMA16_CH7_in				EQU		0CEh	; AT+
    60                              <2> 
    61                              <2> ; Command Registers (Command Value used by PCs is 0)
    62                              <2> COMMAND_REGISTER_DMA8_out		EQU		08h
    63                              <2> COMMAND_REGISTER_DMA16_out		EQU		0D0h	; AT+
    64                              <2> 	MEM_TO_MEM_XFERS_DISABLE	EQU		0
    65                              <2> 	MEM_TO_MEM_XFERS_ENABLE		EQU		(1<<0)
    66                              <2> 
    67                              <2> 	CH0_ADDRESS_HOLD_DISABLE	EQU		0
    68                              <2> 	CH0_ADDRESS_HOLD_ENABLE		EQU		(1<<1)	; When MEM_TO_MEM_XFERS_ENABLE
    69                              <2> 
    70                              <2> 	CONTROLLER_ENABLE			EQU		0
    71                              <2> 	CONTROLLER_DISABLE			EQU		(1<<2)	; Instead of Controller Enable
    72                              <2> 
    73                              <2> 	NORMAL_TIMING				EQU		0
    74                              <2> 	COMPRESSED_TIMING			EQU		(1<<3)	; Instead of Normal Timing when MEM_TO_MEM_XFERS_DISABLE
    75                              <2> 
    76                              <2> 	FIXED_PRIORITY				EQU		0
    77                              <2> 	ROTATING_PRIORITY			EQU		(1<<4)	; Instead of Fixed Priority
    78                              <2> 
    79                              <2> 	LATE_WRITE_SELECTION		EQU		0
    80                              <2> 	EXTENDED_WRITE_SELECTION	EQU		(1<<5)	; Instead of Late Write Selection
    81                              <2> 
    82                              <2> 	DREQ_SENSE_ACTIVE_HIGH		EQU		0
    83                              <2> 	DREQ_SENSE_ACTIVE_LOW		EQU		(1<<6)	; Instead of DREQ Sense Active High
    84                              <2> 
    85                              <2> 	DACK_SENSE_ACTIVE_LOW		EQU		0
    86                              <2> 	DACK_SENSE_ACTIVE_HIGH		EQU		(1<<7)	; Instead of DACK Sense Active Low
    87                              <2> 
    88                              <2> 
    89                              <2> ; Status Registers (reading will clear Terminal Count flags)
    90                              <2> STATUS_REGISTER_DMA8_in			EQU		COMMAND_REGISTER_DMA8_out
    91                              <2> 	FLG_CH1_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<1)
    92                              <2> 	FLG_CH2_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<2)
    93                              <2> 	FLG_CH3_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<3)
    94                              <2> 	FLG_CH1_REQUEST							EQU		(1<<5)
    95                              <2> 	FLG_CH2_REQUEST							EQU		(1<<6)
    96                              <2> 	FLG_CH3_REQUEST							EQU		(1<<7)
    97                              <2> STATUS_REGISTER_DMA16_in		EQU		COMMAND_REGISTER_DMA16_out	; AT+
    98                              <2> 	FLG_CH5_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<1)
    99                              <2> 	FLG_CH6_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<2)
   100                              <2> 	FLG_CH7_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<3)
   101                              <2> 	FLG_CH5_REQUEST							EQU		(1<<5)
   102                              <2> 	FLG_CH6_REQUEST							EQU		(1<<6)
   103                              <2> 	FLG_CH7_REQUEST							EQU		(1<<7)
   104                              <2> 
   105                              <2> 
   106                              <2> ; Request Registers (Software DMA Request)
   107                              <2> REQUEST_REGISTER_DMA8_out		EQU		09h
   108                              <2> 	FLG_SET_REQUEST		EQU		(1<<2)
   109                              <2> 	CLEAR_CH1_REQUEST	EQU		CHANNEL_1
   110                              <2> 	CLEAR_CH2_REQUEST	EQU		CHANNEL_2
   111                              <2> 	CLEAR_CH3_REQUEST	EQU		CHANNEL_3
   112                              <2> 	SET_CH1_REQUEST		EQU		(CHANNEL_1 | FLG_SET_REQUEST)
   113                              <2> 	SET_CH2_REQUEST		EQU		(CHANNEL_2 | FLG_SET_REQUEST)
   114                              <2> 	SET_CH3_REQUEST		EQU		(CHANNEL_3 | FLG_SET_REQUEST)
   115                              <2> REQUEST_REGISTER_DMA16_out		EQU		0D2h	; AT+
   116                              <2> 	CLEAR_CH5_REQUEST	EQU		CLEAR_CH1_REQUEST
   117                              <2> 	CLEAR_CH6_REQUEST	EQU		CLEAR_CH2_REQUEST
   118                              <2> 	CLEAR_CH7_REQUEST	EQU		CLEAR_CH3_REQUEST
   119                              <2> 	SET_CH5_REQUEST		EQU		SET_CH1_REQUEST
   120                              <2> 	SET_CH6_REQUEST		EQU		SET_CH2_REQUEST
   121                              <2> 	SET_CH7_REQUEST		EQU		SET_CH3_REQUEST
   122                              <2> 
   123                              <2> 
   124                              <2> ; Mask Registers (setting a mask bit disables DMA channel)
   125                              <2> MASK_REGISTER_DMA8_out			EQU		0Ah
   126                              <2> 	FLG_SET_MASK		EQU		FLG_SET_REQUEST
   127                              <2> 	CLEAR_CH1_MASK_BIT	EQU		CLEAR_CH1_REQUEST
   128                              <2> 	CLEAR_CH2_MASK_BIT	EQU		CLEAR_CH2_REQUEST
   129                              <2> 	CLEAR_CH3_MASK_BIT	EQU		CLEAR_CH3_REQUEST
   130                              <2> 	SET_CH1_MASK_BIT	EQU		SET_CH1_REQUEST
   131                              <2> 	SET_CH2_MASK_BIT	EQU		SET_CH2_REQUEST
   132                              <2> 	SET_CH3_MASK_BIT	EQU		SET_CH3_REQUEST
   133                              <2> MASK_REGISTER_DMA16_out			EQU		0D4h	; AT+
   134                              <2> 	CLEAR_CH5_MASK_BIT	EQU		CLEAR_CH5_REQUEST
   135                              <2> 	CLEAR_CH6_MASK_BIT	EQU		CLEAR_CH6_REQUEST
   136                              <2> 	CLEAR_CH7_MASK_BIT	EQU		CLEAR_CH7_REQUEST
   137                              <2> 	SET_CH5_MASK_BIT	EQU		SET_CH5_REQUEST
   138                              <2> 	SET_CH6_MASK_BIT	EQU		SET_CH6_REQUEST
   139                              <2> 	SET_CH7_MASK_BIT	EQU		SET_CH7_REQUEST
   140                              <2> 
   141                              <2> 
   142                              <2> ; Mode Registers
   143                              <2> MODE_REGISTER_DMA8_out			EQU		0Bh
   144                              <2> 	; Select channel number (bits 0...1)
   145                              <2> 	CHANNEL_1			EQU		1
   146                              <2> 	CHANNEL_2			EQU		2
   147                              <2> 	CHANNEL_3			EQU		3
   148                              <2> MODE_REGISTER_DMA16_out			EQU		0D6h	; AT+
   149                              <2> 	CHANNEL_5			EQU		CHANNEL_1
   150                              <2> 	CHANNEL_6			EQU		CHANNEL_2
   151                              <2> 	CHANNEL_7			EQU		CHANNEL_3
   152                              <2> 	; Transfer type (bits 2...3)
   153                              <2> 	VERIFY				EQU		(0<<2)
   154                              <2> 	WRITE				EQU		(1<<2)	; To memory
   155                              <2> 	READ				EQU		(2<<2)	; From memory
   156                              <2> 	; Autoinitialization enable/disable (bit 4)
   157                              <2> 	AUTOINIT_DISABLE	EQU		0
   158                              <2> 	AUTOINIT_ENABLE		EQU		(1<<4)	; Instead of autoinitialization disable
   159                              <2> 	; Address increment/decrement select (bit 5)
   160                              <2> 	ADDRESS_INCREMENT	EQU		0
   161                              <2> 	ADDRESS_DECREMENT	EQU		(1<<5)	; Instead of address increment
   162                              <2> 	; Mode type selection (bits 6...7)
   163                              <2> 	DEMAND_MODE			EQU		(0<<6)
   164                              <2> 	SINGLE_MODE			EQU		(1<<6)
   165                              <2> 	BLOCK_MODE			EQU		(2<<6)
   166                              <2> 	CASCADE_MODE		EQU		(3<<6)
   167                              <2> 
   168                              <2> 
   169                              <2> ; Clear Byte Flip-Flops (any byte resets low/high byte flip-flop to low)
   170                              <2> CLEAR_FLIPFLOP_DMA8_out			EQU		0Ch
   171                              <2> CLEAR_FLIPFLOP_DMA16_out		EQU		0D8h	; AT+
   172                              <2> 
   173                              <2> 
   174                              <2> ; Temporary Registers
   175                              <2> TEMP_REGISTER_DMA8_in			EQU		0Dh
   176                              <2> TEMP_REGISTER_DMA16_in			EQU		0DAh	; AT+
   177                              <2> 
   178                              <2> 
   179                              <2> ; Master Clear (any byte does the same as hardware reset)
   180                              <2> MASTER_CLEAR_DMA8_out			EQU		TEMP_REGISTER_DMA8_in
   181                              <2> MASTER_CLEAR_DMA16_out			EQU		TEMP_REGISTER_DMA16_in	; AT+
   182                              <2> 
   183                              <2> 
   184                              <2> ; Clear all mask bits (any byte enables all DMA channels)
   185                              <2> CLEAR_ALL_MASK_BITS_DMA8_out	EQU		0Eh
   186                              <2> CLEAR_ALL_MASK_BITS_DMA16_out	EQU		0DCh	; AT+
   187                              <2> 
   188                              <2> 
   189                              <2> ; Write All Mask Bits
   190                              <2> WRITE_ALL_MASK_BITS_DMA8_out	EQU		0Fh
   191                              <2> 	ALL_MASK_BITS_SET_CH0		EQU		(1<<0)
   192                              <2> 	ALL_MASK_BITS_SET_CH1		EQU		(1<<CHANNEL_1)
   193                              <2> 	ALL_MASK_BITS_SET_CH2		EQU		(1<<CHANNEL_2)
   194                              <2> 	ALL_MASK_BITS_SET_CH3		EQU		(1<<CHANNEL_3)
   195                              <2> WRITE_ALL_MASK_BITS_DMA16_out	EQU		0DEh	; AT+
   196                              <2> 	ALL_MASK_BITS_SET_CH4		EQU		ALL_MASK_BITS_SET_CH0
   197                              <2> 	ALL_MASK_BITS_SET_CH5		EQU		(1<<CHANNEL_5)
   198                              <2> 	ALL_MASK_BITS_SET_CH6		EQU		(1<<CHANNEL_6)
   199                              <2> 	ALL_MASK_BITS_SET_CH7		EQU		(1<<CHANNEL_7)
   200                              <2> 
   201                              <2> 
   202                              <2> %endif ; DMA_CONTROLLER_INC
    38                              <1> 	%include "XTCF.inc"				; For Lo-tech XT-CF
     1                              <2> ; Project name	:	XTIDE Universal BIOS
     2                              <2> ; Description	:	Lo-tech XT-CFv2 board specifications.
     3                              <2> ;
     4                              <2> ; More information at http://www.lo-tech.co.uk/XT-CF
     5                              <2> 
     6                              <2> ;
     7                              <2> ; XTIDE Universal BIOS and Associated Tools
     8                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     9                              <2> ;
    10                              <2> ; This program is free software; you can redistribute it and/or modify
    11                              <2> ; it under the terms of the GNU General Public License as published by
    12                              <2> ; the Free Software Foundation; either version 2 of the License, or
    13                              <2> ; (at your option) any later version.
    14                              <2> ;
    15                              <2> ; This program is distributed in the hope that it will be useful,
    16                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <2> ; GNU General Public License for more details.
    19                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    20                              <2> ;
    21                              <2> 
    22                              <2> ; Modified by JJP for XT-CFv3 support, Mar-13
    23                              <2> 
    24                              <2> 
    25                              <2> %ifndef XTCF_INC
    26                              <2> %define XTCF_INC
    27                              <2> 
    28                              <2> ; XT-CF requires that block must be less than 128 sectors (64 kiB) for DMA
    29                              <2> ; transfers.
    30                              <2> ; 
    31                              <2> ; Note: XT-CFv3 DMA will not interfere with PC & PC/XT memory refresh,
    32                              <2> ; since the XT-CFv3 detaches itself from the bus every 16 bytes transferred.
    33                              <2> ;
    34                              <2> XTCF_DMA_MODE_MAX_BLOCK_SIZE		EQU		64		; Sectors
    35                              <2> 
    36                              <2> ; Possible base addresses. Note that all XT-CF IDE registers are SHL 1 compared
    37                              <2> ; to standard IDE registers.
    38                              <2> XTCF_BASE_PORT_DETECTION_SEED		EQU		140h		; Not a valid base address but needed for autodetection
    39                              <2> XTCF_BASE_PORT_1			EQU		200h
    40                              <2> XTCF_BASE_PORT_2			EQU		240h
    41                              <2> XTCF_BASE_PORT_3			EQU		300h		; Default setting
    42                              <2> XTCF_BASE_PORT_4			EQU		340h
    43                              <2> 
    44                              <2> 
    45                              <2> ; XT-CF Control Register (do not SHL 1 these!)
    46                              <2> ; Note: XT-CFv3 control register is used *only* to raise DRQ.  The register cannot be read.
    47                              <2> ;
    48                              <2> XTCF_CONTROL_REGISTER			EQU		1Fh
    49                              <2> 
    50                              <2> ; Transfer Mode Constants
    51                              <2> ;
    52                              <2> ; Available transfer modes depend on the controller.  All XT-CF controllers
    53                              <2> ; support 8-bit PIO, either with 8-bit or 16-bit instructions (i.e., data
    54                              <2> ; can be fetched from the controller with REP INSW or REP INSB since A0 is
    55                              <2> ; not decoded).  However, errors in the implementation of the BIU on some
    56                              <2> ; machines will prevent 16-bit instructions delivering data correctly.
    57                              <2> ;
    58                              <2> ; For XT-CFv3 adapter, DMA transfers are also supported via channel 3.
    59                              <2> ;
    60                              <2> ; XT-CFv3 cannot be distinguised by software, so user must decide and set
    61                              <2> ; the mode via a call to Int 13h function 1Eh accordingly (see AH1E_XTCF.asm).
    62                              <2> ;;
    63                              <2> XTCF_8BIT_PIO_MODE			EQU		00h
    64                              <2> XTCF_8BIT_PIO_MODE_WITH_BIU_OFFLOAD	EQU		01h
    65                              <2> XTCF_DMA_MODE				EQU		02h
    66                              <2> 
    67                              <2> ; Subcommands for AH=1Eh, Lo-tech XT-CF features.
    68                              <2> ; Return values common for all subcommands:
    69                              <2> ;		AH:		RET_HD_SUCCESS if drive is XT-CF
    70                              <2> ;				RET_HD_INVALID if drive is not XT-CF
    71                              <2> ;		CF:		0 if successful, 1 if error
    72                              <2> 
    73                              <2> ;--------------------------------------------------------------------
    74                              <2> ; IS_THIS_DRIVE_XTCF
    75                              <2> ;	Parameters:
    76                              <2> ;		DL:		Drive Number
    77                              <2> ;--------------------------------------------------------------------
    78                              <2> IS_THIS_DRIVE_XTCF			EQU		0
    79                              <2> 
    80                              <2> ;--------------------------------------------------------------------
    81                              <2> ; GET_XTCF_TRANSFER_MODE
    82                              <2> ;	Parameters:
    83                              <2> ;		DL:		Drive Number
    84                              <2> ;	Returns:
    85                              <2> ;		DH:		One of the mode values listed above,
    86                              <2> ;                               i.e. XTCF_8BIT_PIO_MODE
    87                              <2> ;--------------------------------------------------------------------
    88                              <2> GET_XTCF_TRANSFER_MODE			EQU		1
    89                              <2> 
    90                              <2> ;--------------------------------------------------------------------
    91                              <2> ; SET_XTCF_TRANSFER_MODE
    92                              <2> ;	Parameters:
    93                              <2> ;		DH:		Mode to select,
    94                              <2> ;                               i.e. XTCF_8BIT_PIO_MODE
    95                              <2> ;				Note there's no way to know if an
    96                              <2> ;				XT-CF adapter supports DMA, so the
    97                              <2> ;				user should enable DMA only if a
    98                              <2> ;				DMA-enabled XT-CFv3 is fitted.
    99                              <2> ;		DL:		Drive Number
   100                              <2> ;--------------------------------------------------------------------
   101                              <2> SET_XTCF_TRANSFER_MODE			EQU		2
   102                              <2> 
   103                              <2> 
   104                              <2> %endif ; XTCF_INC
   105                              <2> 
    39                              <1> 	%include "JRIDE_ISA.inc"		; For JR-IDE/ISA
     1                              <2> ; Project name	:	XTIDE Universal BIOS
     2                              <2> ; Description	:	JR-IDE/ISA specifications.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> %ifndef JRIDEISA_INC
    21                              <2> %define JRIDEISA_INC
    22                              <2> 
    23                              <2> JRIDE_DEFAULT_SEGMENT_ADDRESS				EQU	0D800h
    24                              <2> JRIDE_SECTOR_ACCESS_WINDOW_OFFSET			EQU	3C00h	; 512 byte IDE Sector Access Window
    25                              <2> JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET	EQU	3E00h	; 8 byte CS0 IDE Register Window
    26                              <2> JRIDE_CONTROL_BLOCK_REGISTER_WINDOW_OFFSET	EQU	3E08h	; 8 byte CS1 IDE Register Window
    27                              <2> 
    28                              <2> 
    29                              <2> %endif ; JRIDEISA_INC
    40                              <1> %endif
    41                              <1> 
    42                              <1> ; Include module specific .INC files
    43                              <1> %ifdef MODULE_8BIT_IDE
    44                              <1> 	%include "IDE_8bit.inc"			; For IDE 8-bit data port macros
     1                              <2> ; Project name	:	XTIDE Universal BIOS
     2                              <2> ; Description	:	Macros for accessing data port(s) on 8-bit
     3                              <2> ;					IDE controllers.
     4                              <2> 
     5                              <2> ;
     6                              <2> ; XTIDE Universal BIOS and Associated Tools
     7                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <2> ;
     9                              <2> ; This program is free software; you can redistribute it and/or modify
    10                              <2> ; it under the terms of the GNU General Public License as published by
    11                              <2> ; the Free Software Foundation; either version 2 of the License, or
    12                              <2> ; (at your option) any later version.
    13                              <2> ;
    14                              <2> ; This program is distributed in the hope that it will be useful,
    15                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <2> ; GNU General Public License for more details.
    18                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <2> ;
    20                              <2> 
    21                              <2> %ifndef IDE_8BIT_INC
    22                              <2> %define IDE_8BIT_INC
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; UNROLL_SECTORS_IN_CX_TO_DWORDS
    26                              <2> ; UNROLL_SECTORS_IN_CX_TO_QWORDS
    27                              <2> ; UNROLL_SECTORS_IN_CX_TO_OWORDS
    28                              <2> ;	Parameters:
    29                              <2> ;		CX:		Number of sectors in block
    30                              <2> ;	Returns:
    31                              <2> ;		CX:		Number of DWORDs, QWORDs or OWORDs in block
    32                              <2> ;	Corrupts registers:
    33                              <2> ;		Nothing
    34                              <2> ;--------------------------------------------------------------------
    35                              <2> %macro UNROLL_SECTORS_IN_CX_TO_DWORDS 0
    36                              <2> %ifdef USE_186
    37                              <2> 	shl		cx, 7
    38                              <2> %else
    39                              <2> 	xchg	cl, ch		; Sectors to WORDs (SHL CX, 8)
    40                              <2> 	shr		cx, 1
    41                              <2> %endif
    42                              <2> %endmacro
    43                              <2> 
    44                              <2> %macro UNROLL_SECTORS_IN_CX_TO_QWORDS 0
    45                              <2> %ifdef USE_186
    46                              <2> 	shl		cx, 6
    47                              <2> %else
    48                              <2> 	UNROLL_SECTORS_IN_CX_TO_DWORDS
    49                              <2> 	shr		cx, 1
    50                              <2> %endif
    51                              <2> %endmacro
    52                              <2> 
    53                              <2> %macro UNROLL_SECTORS_IN_CX_TO_OWORDS 0
    54                              <2> %ifdef USE_186
    55                              <2> 	shl		cx, 5
    56                              <2> %else
    57                              <2> ;	UNROLL_SECTORS_IN_CX_TO_QWORDS
    58                              <2> ;	shr		cx, 1
    59                              <2> 	mov		ch, cl		; 2 bytes shorter but possibly slower
    60                              <2> 	mov		cl, 3
    61                              <2> 	shr		cx, cl
    62                              <2> %endif
    63                              <2> %endmacro
    64                              <2> 
    65                              <2> 
    66                              <2> ;--------------------------------------------------------------------
    67                              <2> ; Emulates INSW for XTIDE.
    68                              <2> ;
    69                              <2> ; XTIDE_INSW
    70                              <2> ;	Parameters:
    71                              <2> ;		BL:		Bit mask for toggling XTIDE data low/high reg
    72                              <2> ;		DX:		XTIDE Data Low Register address
    73                              <2> ;		ES:DI:	Ptr to destination buffer
    74                              <2> ;	Returns:
    75                              <2> ;		ES:DI:	Incremented/decremented for next word
    76                              <2> ;	Corrupts registers:
    77                              <2> ;		AL, FLAGS
    78                              <2> ;--------------------------------------------------------------------
    79                              <2> %macro XTIDE_INSW 0
    80                              <2> %ifdef USE_186	; INS instruction available
    81                              <2> 	insb						; Load low byte from port DX to [ES:DI]
    82                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
    83                              <2> 	insb						; Load high byte from port DX to [ES:DI]
    84                              <2> 	xor		dl, bl				; Restore to IDE Data Register
    85                              <2> %else	; If 8088/8086
    86                              <2> 	in		al, dx				; Load low byte from port
    87                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
    88                              <2> 	stosb						; Store byte to [ES:DI]
    89                              <2> 	in		al, dx				; Load high byte from port
    90                              <2> 	xor		dl, bl				; Restore to IDE Data Register
    91                              <2> 	stosb						; Store byte to [ES:DI]
    92                              <2> %endif
    93                              <2> %endmacro
    94                              <2> 
    95                              <2> 
    96                              <2> ;--------------------------------------------------------------------
    97                              <2> ; Emulates OUTSW for XTIDE.
    98                              <2> ;
    99                              <2> ; XTIDE_OUTSW
   100                              <2> ;	Parameters:
   101                              <2> ;		BL:		Bit mask for toggling XTIDE data low/high reg
   102                              <2> ;		DX:		XTIDE Data Low Register address
   103                              <2> ;		DS:SI:	Ptr to source buffer
   104                              <2> ;	Returns:
   105                              <2> ;		SI:		Incremented/decremented for next word
   106                              <2> ;	Corrupts registers:
   107                              <2> ;		AX, FLAGS
   108                              <2> ;--------------------------------------------------------------------
   109                              <2> %macro XTIDE_OUTSW 0
   110                              <2> %ifdef USE_186	; OUTS instruction available
   111                              <2> 	lodsb						; Load low byte from [DS:SI] to AL
   112                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
   113                              <2> 	outsb						; Output high byte from [DS:SI]
   114                              <2> 	xor		dl, bl				; XTIDE Data High Reg to Data Low Reg
   115                              <2> 	out		dx, al				; Output low byte from AL
   116                              <2> %else	; If 8088/8086
   117                              <2> 	lodsw						; Load word from [DS:SI]
   118                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
   119                              <2> 	xchg	al, ah				; => AL=high byte, AH=low byte
   120                              <2> 	out		dx, al				; Output high byte
   121                              <2> 	xor		dl, bl				; XTIDE Data High Reg to Data Low Reg
   122                              <2> 	mov		al, ah				; Copy low byte to AL
   123                              <2> 	out		dx, al				; Output low byte
   124                              <2> %endif
   125                              <2> %endmacro
   126                              <2> 
   127                              <2> 
   128                              <2> ;--------------------------------------------------------------------
   129                              <2> ; Emulates OUTSW for modified XTIDE.
   130                              <2> ;
   131                              <2> ; XTIDE_MOD_OUTSW
   132                              <2> ;	Parameters:
   133                              <2> ;		DX:		XTIDE Data Low Register address
   134                              <2> ;		DS:SI:	Ptr to source buffer
   135                              <2> ;	Returns:
   136                              <2> ;		SI:		Incremented/decremented for next word
   137                              <2> ;	Corrupts registers:
   138                              <2> ;		AX, FLAGS
   139                              <2> ;--------------------------------------------------------------------
   140                              <2> %macro XTIDE_MOD_OUTSW 0
   141                              <2> %ifdef USE_186	; OUTS instruction available
   142                              <2> 	lodsb						; Load low byte from [DS:SI] to AL
   143                              <2> 	inc		dx					; IDE Data Reg to XTIDE MOD Data High Reg
   144                              <2> 	outsb						; Output high byte from [DS:SI]
   145                              <2> 	dec		dx					; XTIDE Data High Reg to Data Low Reg
   146                              <2> 	out		dx, al				; Output low byte from AL
   147                              <2> %else	; If 8088/8086
   148                              <2> 	lodsw						; Load word from [DS:SI]
   149                              <2> 	inc		dx					; IDE Data Reg to XTIDE MOD Data High Reg
   150                              <2> 	xchg	al, ah				; => AL=high byte, AH=low byte
   151                              <2> 	out		dx, al				; Output high byte
   152                              <2> 	dec		dx					; XTIDE Data High Reg to Data Low Reg
   153                              <2> 	mov		al, ah				; Copy low byte to AL
   154                              <2> 	out		dx, al				; Output low byte
   155                              <2> %endif
   156                              <2> %endmacro
   157                              <2> 
   158                              <2> 
   159                              <2> %endif ; IDE_8BIT_INC
    45                              <1> %endif
    46                              <1> 
    47                              <1> %ifdef MODULE_ADVANCED_ATA
    48                              <1> 	%include "Vision.inc"			; For QDI Vision QD65xx VLB IDE Controllers
    49                              <1> %endif
    50                              <1> 
    51                              <1> %ifdef MODULE_EBIOS
    52                              <1> 	%include "EBIOS.inc"			; Equates for EBIOS functions
    53                              <1> %endif
    54                              <1> 
    55                              <1> %ifdef MODULE_HOTKEYS
    56                              <1> 	%include "HotkeyBar.inc"		; For Hotkeys
     1                              <2> ; Project name	:	XTIDE Universal BIOS
     2                              <2> ; Description	:	Equates and structs used in Hotkey Bar.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> %ifndef HOTKEYBAR_INC
    21                              <2> %define HOTKEYBAR_INC
    22                              <2> 
    23                              <2> MIN_TIME_TO_DISPLAY_HOTKEY_BAR			EQU	(4000/55)	; 4000 ms
    24                              <2> 
    25                              <2> ROM_BOOT_HOTKEY_SCANCODE				EQU	42h	; F8
    26                              <2> 
    27                              <2> %ifdef MODULE_BOOT_MENU
    28                              <2> BOOT_MENU_HOTKEY_SCANCODE				EQU	3Ch	; F2
    29                              <2> %endif
    30                              <2> 
    31                              <2> %ifdef MODULE_SERIAL
    32                              <2> COM_DETECT_HOTKEY_SCANCODE				EQU	40h	; F6
    33                              <2> %endif
    34                              <2> 
    35                              <2> %endif ; HOTKEYBAR_INC
    57                              <1> %endif
    58                              <1> 
    59                              <1> %ifdef MODULE_BOOT_MENU
    60                              <1> 	%include "BootMenu.inc"			; For Boot Menu
     1                              <2> ; Project name	:	XTIDE Universal BIOS
     2                              <2> ; Description	:	Equates and structs used in Boot Menu.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> %ifndef BOOTMENU_INC
    21                              <2> %define BOOTMENU_INC
    22                              <2> 
    23                              <2> ; Boot menu sizes
    24                              <2> BOOT_MENU_DEFAULT_TIMEOUT				EQU	(30 * TICKS_PER_SECOND)
    25                              <2> BOOT_MENU_TITLE_LINES					EQU	2	; Number of title lines
    26                              <2> BOOT_MENU_INFO_LINES					EQU	3	; Number of info lines
    27                              <2> BOOT_MENU_SEPARATOR_LINES_PLUS_SHADOW	EQU	5
    28                              <2> BOOT_MENU_TITLE_AND_INFO_LINES			EQU	(BOOT_MENU_TITLE_LINES | (BOOT_MENU_INFO_LINES<<8))
    29                              <2> BOOT_MENU_WIDTH							EQU	40	; Menu width in characters (including shadow)
    30                              <2> BOOT_MENU_HEIGHT_WITHOUT_ITEMS			EQU	(BOOT_MENU_TITLE_LINES + BOOT_MENU_INFO_LINES + BOOT_MENU_SEPARATOR_LINES_PLUS_SHADOW)
    31                              <2> MENU_SCREEN_BOTTOM_LINES				EQU	1
    32                              <2> 
    33                              <2> 
    34                              <2> %endif ; BOOTMENU_INC
    61                              <1> %endif
    62                              <1> 
    63                              <1> %ifdef MODULE_BOOT_MENU OR MODULE_HOTKEYS
    64                              <1> 	%define MODULE_DRIVEXLATE
    65                              <1> %endif
    66                              <1> 
    67                              <1> %ifdef MODULE_IRQ
    68                              <1> 	%include "IntController.inc"
    69                              <1> %endif
    70                              <1> 
    71                              <1> 
    72                              <1> ; Included modules for ROMVARS.wFlags
    73                              <1> %ifdef MODULE_8BIT_IDE
    74                              <1> 	MAIN_FLG_MODULE_8BIT_IDE	EQU	FLG_ROMVARS_MODULE_8BIT_IDE
    75                              <1> %else
    76                              <1> 	MAIN_FLG_MODULE_8BIT_IDE	EQU	0
    77                              <1> %endif
    78                              <1> 
    79                              <1> %ifdef MODULE_ADVANCED_ATA
    80                              <1> 	MAIN_FLG_MODULE_ADVANCED_ATA	EQU	FLG_ROMVARS_MODULE_ADVANCED_ATA
    81                              <1> %else
    82                              <1> 	MAIN_FLG_MODULE_ADVANCED_ATA	EQU	0
    83                              <1> %endif
    84                              <1> 
    85                              <1> %ifdef MODULE_BOOT_MENU
    86                              <1> 	MAIN_FLG_MODULE_BOOT_MENU	EQU	FLG_ROMVARS_MODULE_BOOT_MENU
    87                              <1> %else
    88                              <1> 	MAIN_FLG_MODULE_BOOT_MENU	EQU	0
    89                              <1> %endif
    90                              <1> 
    91                              <1> %ifdef MODULE_EBIOS
    92                              <1> 	MAIN_FLG_MODULE_EBIOS	EQU	FLG_ROMVARS_MODULE_EBIOS
    93                              <1> %else
    94                              <1> 	MAIN_FLG_MODULE_EBIOS	EQU	0
    95                              <1> %endif
    96                              <1> 
    97                              <1> %ifdef MODULE_HOTKEYS
    98                              <1> 	MAIN_FLG_MODULE_HOTKEYS	EQU	FLG_ROMVARS_MODULE_HOTKEYS
    99                              <1> %else
   100                              <1> 	MAIN_FLG_MODULE_HOTKEYS	EQU	0
   101                              <1> %endif
   102                              <1> 
   103                              <1> %ifdef MODULE_IRQ
   104                              <1> 	MAIN_FLG_MODULE_IRQ		EQU	FLG_ROMVARS_MODULE_IRQ
   105                              <1> %else
   106                              <1> 	MAIN_FLG_MODULE_IRQ		EQU	0
   107                              <1> %endif
   108                              <1> 
   109                              <1> %ifdef MODULE_SERIAL
   110                              <1> 	MAIN_FLG_MODULE_SERIAL	EQU	FLG_ROMVARS_MODULE_SERIAL
   111                              <1> %else
   112                              <1> 	MAIN_FLG_MODULE_SERIAL	EQU	0
   113                              <1> %endif
   114                              <1> 
   115                              <1> %ifdef MODULE_SERIAL_FLOPPY
   116                              <1> 	MAIN_FLG_MODULE_SERIAL_FLOPPY	EQU	FLG_ROMVARS_MODULE_SERIAL_FLOPPY
   117                              <1> %else
   118                              <1> 	MAIN_FLG_MODULE_SERIAL_FLOPPY	EQU	0
   119                              <1> %endif
   120                              <1> 
   121                              <1> %ifdef MODULE_STRINGS_COMPRESSED
   122                              <1> 	MAIN_FLG_MODULE_STRINGS_COMPRESSED	EQU	FLG_ROMVARS_MODULE_STRINGS_COMPRESSED
   123                              <1> %else
   124                              <1> 	MAIN_FLG_MODULE_STRINGS_COMPRESSED	EQU	0
   125                              <1> %endif
   126                              <1> 
   127                              <1> %ifdef MODULE_FEATURE_SETS
   128                              <1> 	MAIN_FLG_MODULE_FEATURE_SETS	EQU	FLG_ROMVARS_MODULE_FEATURE_SETS
   129                              <1> %else
   130                              <1> 	MAIN_FLG_MODULE_FEATURE_SETS	EQU	0
   131                              <1> %endif
   132                              <1> 
   133                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   134                              <1> 	MAIN_FLG_MODULE_8BIT_IDE_ADVANCED	EQU	FLG_ROMVARS_MODULE_8BIT_IDE_ADVANCED
   135                              <1> %else
   136                              <1> 	MAIN_FLG_MODULE_8BIT_IDE_ADVANCED	EQU	0
   137                              <1> %endif
   138                              <1> 
   139                              <1> MASK_ROMVARS_INCLUDED_MODULES	EQU	MAIN_FLG_MODULE_8BIT_IDE | MAIN_FLG_MODULE_ADVANCED_ATA | MAIN_FLG_MODULE_BOOT_MENU | MAIN_FLG_MODULE_EBIOS | MAIN_FLG_MODULE_HOTKEYS | MAIN_FLG_MODULE_IRQ | MAIN_FLG_MODULE_SERIAL | MAIN_FLG_MODULE_SERIAL_FLOPPY | MAIN_F
   140                              <1> 
    49                                  	%include "Version.inc"
     1                              <1> ; /*
     2                              <1> ; Project name	:	XTIDE Universal BIOS
     3                              <1> ; Description	:	Version information.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ;
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> ;--------------------------------------------------------------------------------
    22                              <1> ;
    23                              <1> ; Assembler Version
    24                              <1> ;
    25                              <1> 
    26                              <1> %ifndef VERSION_INC
    27                              <1> %define VERSION_INC
    28                              <1> 
    29                              <1> 
    30                              <1> %define TITLE_STRING_START	"-=XTIDE Universal BIOS "
    31                              <1> %ifdef USE_AT
    32                              <1> 	%ifdef USE_386
    33                              <1> 		%define	TITLE_STRING_END	"(386)=-",NULL
    34                              <1> 	%else
    35                              <1> 		%define	TITLE_STRING_END	"(AT)=-",NULL
    36                              <1> 	%endif
    37                              <1> %elifdef USE_186
    38                              <1> 	%define	TITLE_STRING_END	"(XT+)=-",NULL
    39                              <1> %else
    40                              <1> 	%define	TITLE_STRING_END	"(XT)=-",NULL
    41                              <1> %endif
    42                              <1> 
    43                              <1> %define	TITLE_STRING			TITLE_STRING_START, TITLE_STRING_END
    44                              <1> %define	ROM_VERSION_STRING		"v2.0.0",BETA,"3+ (",__DATE__,")",NULL
    45                              <1> %define	FLASH_SIGNATURE			"XTIDE203"	; Do not terminate with NULL
    46                              <1> 
    47                              <1> 
    48                              <1> %endif ; VERSION_INC
    49                              <1> 
    50                              <1> %if 0			; equivalent of a NASM comment block
    51                              <1> ;*/
    52                              <1> 
    53                              <1> //--------------------------------------------------------------------------------
    54                              <1> //
    55                              <1> // C/C++ Version
    56                              <1> //
    57                              <1> 
    58                              <1> #define BETA " Beta "
    59                              <1> 
    60                              <1> #define ROM_VERSION_STRING		"v2.0.0" BETA "3 (" __DATE__ ")"
    61                              <1> 
    62                              <1> /*
    63                              <1> %endif
    64                              <1> ;*/
    50                                  	%include "ATA_ID.inc"			; For ATA Drive Information structs
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	ATA Identify Drive information.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> %ifndef ATA_ID_INC
    21                              <1> %define ATA_ID_INC
    22                              <1> 
    23                              <1> ; Maximum valid P-CHS parameters
    24                              <1> MAX_VALID_PCHS_CYLINDERS			EQU		16383
    25                              <1> MAX_VALID_PCHS_HEADS				EQU		16
    26                              <1> MAX_VALID_PCHS_SECTORS_PER_TRACK	EQU		63
    27                              <1> 
    28                              <1> 
    29                              <1> ; PIO Minimum Cycle Times (t0)
    30                              <1> ; Timings for Advanced Modes (3 and above) can be read from ATA info WORDs 67 and 68
    31                              <1> ; Those usually have the same Cycle Time as below
    32                              <1> PIO_0_MIN_CYCLE_TIME_NS		EQU		600
    33                              <1> PIO_1_MIN_CYCLE_TIME_NS		EQU		383
    34                              <1> PIO_2_MIN_CYCLE_TIME_NS		EQU		240
    35                              <1> PIO_3_MIN_CYCLE_TIME_NS		EQU		180
    36                              <1> PIO_4_MIN_CYCLE_TIME_NS		EQU		120
    37                              <1> PIO_5_MIN_CYCLE_TIME_NS		EQU		100		; CF specification
    38                              <1> PIO_6_MIN_CYCLE_TIME_NS		EQU		80		; CF specification
    39                              <1> 
    40                              <1> ; PIO Minimum Address Valid Times (t1)
    41                              <1> PIO_0_MIN_ADDRESS_VALID_NS	EQU		70
    42                              <1> PIO_1_MIN_ADDRESS_VALID_NS	EQU		50
    43                              <1> PIO_2_MIN_ADDRESS_VALID_NS	EQU		30
    44                              <1> PIO_3_MIN_ADDRESS_VALID_NS	EQU		30
    45                              <1> PIO_4_MIN_ADDRESS_VALID_NS	EQU		25
    46                              <1> PIO_5_MIN_ADDRESS_VALID_NS	EQU		15
    47                              <1> PIO_6_MIN_ADDRESS_VALID_NS	EQU		10
    48                              <1> 
    49                              <1> ; PIO Minimum Active Times (t2)
    50                              <1> PIO_0_MIN_ACTIVE_TIME_NS	EQU		165
    51                              <1> PIO_1_MIN_ACTIVE_TIME_NS	EQU		125
    52                              <1> PIO_2_MIN_ACTIVE_TIME_NS	EQU		100
    53                              <1> PIO_3_MIN_ACTIVE_TIME_NS	EQU		80
    54                              <1> PIO_4_MIN_ACTIVE_TIME_NS	EQU		70
    55                              <1> PIO_5_MIN_ACTIVE_TIME_NS	EQU		65
    56                              <1> PIO_6_MIN_ACTIVE_TIME_NS	EQU		55
    57                              <1> 
    58                              <1> ; PIO Minimum Recovery Times or Inactive Times (t2i) can be calculated
    59                              <1> ; from Minimum Cycle Time (t0) - Minimum Active Time (t2) - Address Valid Time (t1).
    60                              <1> ; I'm not sure about this calculation so correct me if I'm wrong!
    61                              <1> ; Recovery time should be calculated at run time since Cycle Time t0 can be
    62                              <1> ; read from ATA information (ATA2+) but most drives just report the
    63                              <1> ; Min Cycle Times listed above.
    64                              <1> 
    65                              <1> 
    66                              <1> 
    67                              <1> ; ATA-1 Drive Information struct
    68                              <1> ; F = Fixed value
    69                              <1> ; V = Variable value
    70                              <1> ; R = Reserved word
    71                              <1> ; X = Vendor specific word
    72                              <1> struc ATA1
    73 00000000 <res 00000002>      <1> 	.wGenCfg	resw 1	; 0F, General configuration bit-significant information
    74 00000002 <res 00000002>      <1> 	.wCylCnt	resw 1	; 1F, Number of cylinders
    75 00000004 <res 00000002>      <1> 				resw 1	; 2R
    76 00000006 <res 00000002>      <1> 	.wHeadCnt	resw 1	; 3F, Number of heads
    77 00000008 <res 00000002>      <1> 	.wBpTrck	resw 1	; 4F, Number of unformatted bytes per track
    78 0000000A <res 00000002>      <1> 	.wBpSect	resw 1	; 5F, Number of unformatted bytes per sector
    79 0000000C <res 00000002>      <1> 	.wSPT		resw 1	; 6F, Number of sectors per track
    80 0000000E <res 00000006>      <1> 				resw 3	; 7...9X
    81 00000014 <res 00000014>      <1> 	.strSerial	resb 20	; 10...19F, Serial number (20 ASCII characters, 0000h=not specified)
    82 00000028 <res 00000002>      <1> 	.wBuffType	resw 1	; 20F, Buffer type
    83 0000002A <res 00000002>      <1> 	.wBuffSize	resw 1	; 21F, Buffer size in 512 byte increments (0000h=not specified)
    84 0000002C <res 00000002>      <1> 	.wEccCnt	resw 1	; 22F, # of ECC bytes avail on read/write long cmds (0000h=not spec'd)
    85 0000002E <res 00000008>      <1> 	.strFirmW	resb 8	; 23...26F, Firmware revision (8 ASCII characters, 0000h=not specified)
    86 00000036 <res 00000028>      <1> 	.strModel	resb 40	; 27...46F, Model number (40 ASCII characters, 0000h=not specified)
    87 0000005E <res 00000001>      <1> 	.bBlckSize	resb 1	; 47[0-7]F, Maximum number of sectors that can be transferred
    88                              <1> 						;          per interrupt on read and write multiple commands
    89                              <1> 						;		   (00h=Read/write multiple commands not implemented)
    90 0000005F <res 00000001>      <1> 				resb 1	; 47[8-15]X
    91 00000060 <res 00000002>      <1> 	.wDWIO		resw 1	; 48F, Can perform doubleword I/O (boolean)
    92 00000062 <res 00000002>      <1> 	.wCaps		resw 1	; 49FRX, Capabilities
    93 00000064 <res 00000002>      <1> 				resw 1	; 50R
    94 00000066 <res 00000001>      <1> 				resb 1	; 51[0-7]X
    95 00000067 <res 00000001>      <1> 	.bPioMode	resb 1	; 51[8-15]F, PIO data transfer cycle timing mode (0, 1 or 2)
    96 00000068 <res 00000001>      <1> 				resb 1	; 52[0-7]X
    97 00000069 <res 00000001>      <1> 	.bDMATiming	resb 1	; 52[8-15]F, DMA data transfer cycle timing mode
    98 0000006A <res 00000002>      <1> 	.wFields	resw 1	; 53FVR, Field (next words) validity bits
    99                              <1> 
   100                              <1> 	; Words 54-58 are valid only if bit0 is set in .wFields
   101 0000006C <res 00000002>      <1> 	.wCurCyls	resw 1	; 54V, Number of current cylinders
   102 0000006E <res 00000002>      <1> 	.wCurHeads	resw 1	; 55V, Number of current heads
   103 00000070 <res 00000002>      <1> 	.wCurSPT	resw 1	; 56V, Number of current sectors per track
   104 00000072 <res 00000004>      <1> 	.dwCurSCnt	resd 1	; 57...58V, Current capacity in sectors
   105                              <1> 
   106                              <1> 	; Words 59-63 are always valid
   107 00000076 <res 00000001>      <1> 	.bBlockSel	resb 1	; 59[0-7]V, Current setting for number of sectors that
   108                              <1> 						;           can be transferred per interrupt on R/W multiple command
   109 00000077 <res 00000001>      <1> 	.bBlockFlgs	resb 1	; 59[8-15]VR, bit 0 set if Multiple sector setting is valid
   110 00000078 <res 00000004>      <1> 	.dwLBACnt	resd 1	; 60...61F, Total number of user addressable sectors (LBA mode only)
   111 0000007C <res 00000001>      <1> 	.bSDMASupp	resb 1	; 62[0-7]F, Single word DMA transfer modes supported
   112 0000007D <res 00000001>      <1> 	.bSDMAAct	resb 1	; 62[8-15]V, Single word DMA transfer mode active
   113 0000007E <res 00000001>      <1> 	.bMDMASupp	resb 1	; 63[0-7]F, Multiword DMA transfer modes supported
   114 0000007F <res 00000001>      <1> 	.bMDMAAct	resb 1	; 63[8-15]V, Multiword DMA transfer mode active
   115                              <1> endstruc
   116                              <1> 
   117                              <1> A1_MODEL_NUMBER_LENGTH	EQU	40		; 40 ASCII characters
   118                              <1> 
   119                              <1> ; ATA-1 Word 0, General configuration
   120                              <1> A1_wGenCfg_NONMAG		EQU	(1<<15)	; Reserved for non-magnetic drives
   121                              <1> A1_wGenCfg_FGAPREQ		EQU	(1<<14)	; Format speed tolerance gap required
   122                              <1> A1_wGenCfg_TRCKOFF		EQU	(1<<13)	; Track offset option available
   123                              <1> A1_wGenCfg_DATAOFF		EQU	(1<<12)	; Data strobe offset option available
   124                              <1> A1_wGenCfg_ROTTOL		EQU	(1<<11)	; Rotational speed tolerance is > 0,5%
   125                              <1> A1_wGenCfg_XFERFAST		EQU (1<<10)	; Disk transfer rate > 10 Mbs
   126                              <1> A1_wGenCfg_XFERMED		EQU	(1<<9)	; Disk transfer rate > 5Mbs but <= 10Mbs
   127                              <1> A1_wGenCfg_XFERSLOW		EQU (1<<8)	; Disk transfer rate <= 5Mbs
   128                              <1> A1_wGenCfg_REMOVABLE	EQU	(1<<7)	; Removable cartridge drive
   129                              <1> A1_wGenCfg_FIXED		EQU	(1<<6)	; Fixed drive
   130                              <1> A1_wGenCfg_MOTCTRL		EQU	(1<<5)	; Spindle motor control option implemented
   131                              <1> A1_wGenCfg_HEADSLOW		EQU	(1<<4)	; Head switch time > 15 usec
   132                              <1> A1_wGenCfg_NOTMFM		EQU	(1<<3)	; Not MFM encoded
   133                              <1> A1_wGenCfg_SOFTSECT		EQU	(1<<2)	; Soft sectored
   134                              <1> A1_wGenCfg_HARDSECT		EQU	(1<<1)	; Hard sectored
   135                              <1> 
   136                              <1> ; ATA-1 Word 49, Capabilities
   137                              <1> A1_wCaps_LBA			EQU	(1<<9)	; LBA supported
   138                              <1> A1_wCaps_DMA			EQU	(1<<8)	; DMA supported
   139                              <1> 
   140                              <1> ; ATA-1 Word 53, Fields
   141                              <1> A1_wFields_54to58		EQU	(1<<0)	; The fields reported in words 54-58 are valid
   142                              <1> 
   143                              <1> ; ATA-1 Word 59 high byte, Block mode flags
   144                              <1> A1_bBlockFlgs_VALID		EQU	(1<<0)	; Multiple sector setting (bBlockSel) is valid
   145                              <1> 
   146                              <1> 
   147                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   148                              <1> 
   149                              <1> ; ATA-2 Drive Information struct
   150                              <1> ; F = Fixed value
   151                              <1> ; V = Variable value
   152                              <1> ; R = Reserved word
   153                              <1> ; X = Vendor specific word
   154                              <1> struc ATA2
   155 00000000 <res 00000002>      <1> 	.wGenCfg	resw 1	; 0F, General configuration bit-significant information
   156 00000002 <res 00000002>      <1> 	.wCylCnt	resw 1	; 1F, Number of logical cylinders
   157 00000004 <res 00000002>      <1> 				resw 1	; 2R
   158 00000006 <res 00000002>      <1> 	.wHeadCnt	resw 1	; 3F, Number of logical heads
   159 00000008 <res 00000002>      <1> 				resw 1	; 4X
   160 0000000A <res 00000002>      <1> 				resw 1	; 5X
   161 0000000C <res 00000002>      <1> 	.wSPT		resw 1	; 6F, Number of logical sectors per track
   162 0000000E <res 00000006>      <1> 				resw 3	; 7...9X
   163 00000014 <res 00000014>      <1> 	.strSerial	resb 20	; 10...19F, Serial number (20 ASCII characters, 0000h=not specified)
   164 00000028 <res 00000002>      <1> 				resw 1	; 20X
   165 0000002A <res 00000002>      <1> 				resw 1	; 21X
   166 0000002C <res 00000002>      <1> 	.wEccCnt	resw 1	; 22F, # of ECC bytes avail on read/write long cmds (0000h=not spec'd)
   167 0000002E <res 00000008>      <1> 	.strFirmW	resb 8	; 23...26F, Firmware revision (8 ASCII characters, 0000h=not specified)
   168 00000036 <res 00000028>      <1> 	.strModel	resb 40	; 27...46F, Model number (40 ASCII characters, 0000h=not specified)
   169 0000005E <res 00000001>      <1> 	.bBlckSize	resb 1	; 47[0-7]F, Maximum number of sectors that can be transferred
   170                              <1> 						;          per interrupt on read and write multiple commands
   171                              <1> 						;		   (00h=Read/write multiple commands not implemented)
   172 0000005F <res 00000001>      <1> 				resb 1	; 47[8-15]X
   173 00000060 <res 00000002>      <1> 				resw 1	; 48R
   174 00000062 <res 00000002>      <1> 	.wCaps		resw 1	; 49FRX, Capabilities
   175 00000064 <res 00000002>      <1> 				resw 1	; 50R
   176 00000066 <res 00000001>      <1> 				resb 1	; 51[0-7]X
   177 00000067 <res 00000001>      <1> 	.bPIOTiming	resb 1	; 51[8-15]F, PIO data transfer cycle timing mode
   178 00000068 <res 00000001>      <1> 				resb 1	; 52[0-7]X
   179 00000069 <res 00000001>      <1> 	.bDMATiming	resb 1	; 52[8-15]F, DMA data transfer cycle timing mode
   180 0000006A <res 00000002>      <1> 	.wFields	resw 1	; 53FVR, Field (next words) validity bits
   181                              <1> 
   182                              <1> 	; Words 54-58 are valid only if bit0 is set in .wFields
   183 0000006C <res 00000002>      <1> 	.wCurCyls	resw 1	; 54V, Number of current logical cylinders
   184 0000006E <res 00000002>      <1> 	.wCurHeads	resw 1	; 55V, Number of current logical heads
   185 00000070 <res 00000002>      <1> 	.wCurSPT	resw 1	; 56V, Number of current logical sectors per track
   186 00000072 <res 00000004>      <1> 	.dwCurSCnt	resd 1	; 57...58V, Current capacity in sectors
   187                              <1> 
   188                              <1> 	; Words 59-63 are always valid
   189 00000076 <res 00000001>      <1> 	.bBlockSel	resb 1	; 59[0-7]V, Current setting for number of sectors that
   190                              <1> 						;           can be transferred per interrupt on R/W multiple command
   191 00000077 <res 00000001>      <1> 	.bBlockFlgs	resb 1	; 59[8-15]VR, bit 0 set if Multiple sector setting is valid
   192 00000078 <res 00000004>      <1> 	.dwLBACnt	resd 1	; 60...61F, Total number of user addressable sectors (LBA mode only)
   193 0000007C <res 00000001>      <1> 	.bSDMASupp	resb 1	; 62[0-7]F, Single word DMA transfer modes supported
   194 0000007D <res 00000001>      <1> 	.bSDMAAct	resb 1	; 62[8-15]V, Single word DMA transfer mode active
   195 0000007E <res 00000001>      <1> 	.bMDMASupp	resb 1	; 63[0-7]F, Multiword DMA transfer modes supported
   196 0000007F <res 00000001>      <1> 	.bMDMAAct	resb 1	; 63[8-15]V, Multiword DMA transfer mode active
   197                              <1> 
   198                              <1> 	; Words 64-70 are valid only if bit1 is set in .wFields (ATA2+)
   199 00000080 <res 00000001>      <1> 	.bPIOSupp	resb 1	; 64[0-7]F, Advanced PIO Transfer Modes Supported
   200 00000081 <res 00000001>      <1> 				resb 1	; 64[8-15]R
   201 00000082 <res 00000002>      <1> 	.wMDMAMinCy	resw 1	; 65F, Minimum Multiword DMA Transfer Cycle Time Per Word
   202 00000084 <res 00000002>      <1> 	.wMDMARecCy	resw 1	; 66F, Manufacturers Recommended Multiword DMA Transfer Cycle Time
   203 00000086 <res 00000002>      <1> 	.wPIOMinCy	resw 1	; 67F, Minimum PIO Transfer Cycle Time Without Flow Control
   204 00000088 <res 00000002>      <1> 	.wPIOMinCyF	resw 1	; 68F, Minimum PIO Transfer Cycle Time With IORDY Flow Control
   205                              <1> endstruc
   206                              <1> 
   207                              <1> ; ATA-2 Word 0, General configuration
   208                              <1> A2_wGenCfg_NONMAG		EQU	(1<<15)	; Reserved for non-magnetic drives
   209                              <1> A2_wGenCfg_REMOVABLE	EQU	(1<<7)	; Removable media device
   210                              <1> A2_wGenCfg_FIXED		EQU	(1<<6)	; Not removable controller and/or device
   211                              <1> 
   212                              <1> ; ATA-1 Word 49, Capabilities
   213                              <1> A2_wCaps_TIMER			EQU	(1<<13)	; Standby timer values as specified in this standard are supported
   214                              <1> A2_wCaps_IORDY			EQU	(1<<11)	; IORDY supported
   215                              <1> A2_wCaps_CANDISIORDY	EQU	(1<<10)	; IORDY can be disabled
   216                              <1> A2_wCaps_LBA			EQU	(1<<9)	; LBA supported
   217                              <1> A2_wCaps_DMA			EQU	(1<<8)	; DMA supported
   218                              <1> 
   219                              <1> ; ATA-2 Word 53, Fields
   220                              <1> A2_wFields_54to58		EQU	(1<<0)	; The fields reported in words 54-58 are valid
   221                              <1> A2_wFields_64to70		EQU	(1<<1)	; The fields reported in words 64-70 are valid
   222                              <1> 
   223                              <1> ; ATA-2 Word 59 high byte, Block mode flags
   224                              <1> A2_bBlockFlgs_VALID		EQU	(1<<0)	; Multiple sector setting (bBlockSel) is valid
   225                              <1> 
   226                              <1> ; ATA-2 Word 64, Advanced PIO transfer modes supported
   227                              <1> A2_bPIOSupp_PIO3		EQU	(1<<0)
   228                              <1> A2_bPIOSupp_PIO4		EQU	(1<<1)
   229                              <1> 
   230                              <1> 
   231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   232                              <1> 
   233                              <1> ; ATA-6 Drive Information struct
   234                              <1> ; F = Fixed value
   235                              <1> ; V = Variable value
   236                              <1> ; R = Reserved word
   237                              <1> ; X = Vendor specific word
   238                              <1> struc ATA6
   239 00000000 <res 00000002>      <1> 	.wGenCfg	resw 1	; 0F, General configuration bit-significant information
   240 00000002 <res 00000002>      <1> 				resw 1	; 1X, Obsolete (Number of logical cylinders)
   241 00000004 <res 00000002>      <1> 				resw 1	; 2V, Specific configuration
   242 00000006 <res 00000002>      <1> 				resw 1	; 3X, Obsolete (Number of logical heads)
   243 00000008 <res 00000002>      <1> 				resw 1	; 4X
   244 0000000A <res 00000002>      <1> 				resw 1	; 5X
   245 0000000C <res 00000002>      <1> 				resw 1	; 6X, Obsolete (Number of logical sectors per track)
   246 0000000E <res 00000004>      <1> 				resw 2	; 7...8V, Reserved for assignment by the CompactFlash Association
   247 00000012 <res 00000002>      <1> 				resw 1	; 9X
   248 00000014 <res 00000014>      <1> 	.strSerial	resb 20	; 10...19F, Serial number (20 ASCII characters, 0000h=not specified)
   249 00000028 <res 00000002>      <1> 				resw 1	; 20X
   250 0000002A <res 00000002>      <1> 				resw 1	; 21X
   251 0000002C <res 00000002>      <1> 				resw 1	; 22X, Obsolete (# of ECC bytes avail on read/write long cmds (0000h=not spec'd))
   252 0000002E <res 00000008>      <1> 	.strFirmW	resb 8	; 23...26F, Firmware revision (8 ASCII characters, 0000h=not specified)
   253 00000036 <res 00000028>      <1> 	.strModel	resb 40	; 27...46F, Model number (40 ASCII characters, 0000h=not specified)
   254 0000005E <res 00000001>      <1> 	.bBlckSize	resb 1	; 47[0-7]F, Maximum number of sectors that can be transferred
   255                              <1> 						;           per interrupt on read and write multiple commands
   256                              <1> 						;		    (00h=Read/write multiple commands not implemented)
   257 0000005F <res 00000001>      <1> 				resb 1	; 47[8-15]F, 80h
   258 00000060 <res 00000002>      <1> 				resw 1	; 48R
   259 00000062 <res 00000002>      <1> 	.wCaps		resw 1	; 49FX, Capabilities
   260 00000064 <res 00000002>      <1> 	.wCapsHigh	resw 1	; 50FX, Capabilities 2
   261 00000066 <res 00000002>      <1> 				resw 1	; 51X, Obsolete (PIO data transfer cycle timing mode)
   262 00000068 <res 00000002>      <1> 				resw 1	; 52X, Obsolete (DMA data transfer cycle timing mode)
   263 0000006A <res 00000002>      <1> 	.wFields	resw 1	; 53FX, Field (next words) validity bits
   264                              <1> 
   265                              <1> 	; Words 54-58 are valid only if bit0 is set in .wFields
   266 0000006C <res 00000002>      <1> 				resw 1	; 54X, Obsolete (Number of current logical cylinders)
   267 0000006E <res 00000002>      <1> 				resw 1	; 55X, Obsolete (Number of current logical heads)
   268 00000070 <res 00000002>      <1> 				resw 1	; 56X, Obsolete (Number of current logical sectors per track)
   269 00000072 <res 00000004>      <1> 				resd 1	; 57...58X, Obsolete (Current capacity in sectors)
   270                              <1> 
   271                              <1> 	; Words 59-63 are always valid
   272 00000076 <res 00000001>      <1> 	.bBlockSel	resb 1	; 59[0-7]V, Current setting for number of sectors that
   273                              <1> 						;           can be transferred per interrupt on R/W multiple command
   274 00000077 <res 00000001>      <1> 	.bBlockFlgs	resb 1	; 59[8-15]VR, bit 0 set if Multiple sector setting is valid
   275 00000078 <res 00000004>      <1> 	.dwLBACnt	resd 1	; 60...61F, Total number of user addressable sectors (LBA-28)
   276 0000007C <res 00000001>      <1> 				resb 1	; 62[0-7]X, Obsolete (Single word DMA transfer modes supported)
   277 0000007D <res 00000001>      <1> 				resb 1	; 62[8-15]X, Obsolete (Single word DMA transfer mode active)
   278 0000007E <res 00000002>      <1> 	.wMDMA		resw 1	; 63FV, Multiword DMA transfer modes supported and active
   279                              <1> 
   280                              <1> 	; Words 64-70 are valid only if bit1 is set in .wFields (ATA2+)
   281 00000080 <res 00000001>      <1> 	.bPIOSupp	resb 1	; 64[0-7]F, Advanced PIO Transfer Modes Supported
   282 00000081 <res 00000001>      <1> 				resb 1	; 64[8-15]R
   283 00000082 <res 00000002>      <1> 	.wMDMAMinCy	resw 1	; 65F, Minimum Multiword DMA Transfer Cycle Time Per Word
   284 00000084 <res 00000002>      <1> 	.wMDMARecCy	resw 1	; 66F, Manufacturers Recommended Multiword DMA Transfer Cycle Time
   285 00000086 <res 00000002>      <1> 	.wPIOMinCy	resw 1	; 67F, Minimum PIO Transfer Cycle Time Without Flow Control
   286 00000088 <res 00000002>      <1> 	.wPIOMinCyF	resw 1	; 68F, Minimum PIO Transfer Cycle Time With IORDY Flow Control
   287 0000008A <res 00000004>      <1> 				resw 71-69	; 69...70R
   288                              <1> 
   289                              <1> 	; Words 71...74 are reserved for IDENTIFY PACKET DEVICE command
   290 0000008E <res 00000008>      <1> 				resw 75-71	; 71...74R
   291                              <1> 
   292 00000096 <res 00000002>      <1> 	.wQueue		resw 1	; 75[0-4]F, Maximum queue depth - 1
   293 00000098 <res 00000008>      <1> 				resw 80-76	; 76...79R
   294                              <1> 
   295 000000A0 <res 00000002>      <1> 	.wMajorVer	resw 1	; 80F, Major Version Number
   296 000000A2 <res 00000002>      <1> 	.wMinorVer	resw 1	; 81F, Minor Version Number
   297 000000A4 <res 00000002>      <1> 	.wSetSup82	resw 1	; 82F, Command set supported
   298 000000A6 <res 00000002>      <1> 	.wSetSup83	resw 1	; 83F, Command sets supported
   299 000000A8 <res 00000002>      <1> 	.wSetSup84	resw 1	; 84F, Command set / Feature supported extension
   300 000000AA <res 00000002>      <1> 	.wEnFor82	resw 1	; 85FV, Command set / feature enabled (for word 82)
   301 000000AC <res 00000002>      <1> 	.wEnFor83	resw 1	; 86FV, Command set / feature enabled (for word 83)
   302 000000AE <res 00000002>      <1> 	.wEnFor84	resw 1	; 87FV, Command set / feature enabled (for word 84)
   303                              <1> 
   304                              <1> 	; Word 88 is valid only if bit2 is set in .wFields (word 53)
   305 000000B0 <res 00000002>      <1> 	.wUDMA		resw 1	; 88FV, Ultra DMA Mode support
   306                              <1> 
   307 000000B2 <res 00000002>      <1> 	.wEraseTime	resw 1	; 89F, Time required for security erase unit completion
   308 000000B4 <res 00000002>      <1> 	.wEnhErTime	resw 1	; 90F, Time required for Enhanced security erase completion
   309 000000B6 <res 00000002>      <1> 	.wCurPower	resw 1	; 91V, Current advanced power management value
   310 000000B8 <res 00000002>      <1> 	.wPWRev		resw 1	; 92V, Master Password Revision Code
   311 000000BA <res 00000002>      <1> 	.wReset		resw 1	; 93FV, Hardware reset result
   312 000000BC <res 00000001>      <1> 	.bCurAcous	resb 1	; 94[0-7]V, Current automatic acoustic management value
   313 000000BD <res 00000001>      <1> 	.bRecAcous	resb 1	; 94[8-15]V, Vendors recommended acoustic management value
   314 000000BE <res 0000000A>      <1> 				resw 100-95		; 95...99R
   315 000000C8 <res 00000008>      <1> 	.qwLBACnt	resb 8	; 100...103V, Total number of user addressable sectors (LBA48)
   316 000000D0 <res 0000002E>      <1> 				resw 127-104	; 104...126R
   317 000000FE <res 00000002>      <1> 	.wRMSN		resw 1	; 127F, Removable Media Status Notification feature set support
   318 00000100 <res 00000002>      <1> 	.wSecurity	resw 1	; 128FV, Security Status
   319 00000102 <res 0000003E>      <1> 				resw 160-129	; 129...157X, Vendor Specific
   320 00000140 <res 00000002>      <1> 	.wCFAPower	resw 1	; 160FV, CFA Power Mode 1
   321 00000142 <res 0000001E>      <1> 				resw 176-161	; 161...175R, Reserved for assignment by the CompactFlash Association
   322 00000160 <res 0000003C>      <1> 	.strMediaSr	resw 206-176	; 176...205V, Current media serial number
   323 0000019C <res 00000062>      <1> 				resw 255-206	; 206...254R
   324                              <1> 	.wIntegrityWord:
   325 000001FE <res 00000001>      <1> 	.bSignature	resb 1	; 255[0-7]X, Signature
   326 000001FF <res 00000001>      <1> 	.bChecksum	resb 1	; 255[8-15]X, Checksum
   327                              <1> endstruc
   328                              <1> 
   329                              <1> ; ATA-6 Word 0, General configuration
   330                              <1> A6_wGenCfg_REMOVABLE	EQU	(1<<7)	; Removable media device
   331                              <1> A6_wGenCfg_INCOMPLETE	EQU	(1<<2)	; Response incomplete
   332                              <1> 
   333                              <1> ; ATA-6 Word 49, Capabilities
   334                              <1> A6_wCaps_TIMER			EQU	(1<<13)	; Standby timer values as specified in this standard are supported
   335                              <1> A6_wCaps_IORDY			EQU	(1<<11)	; IORDY supported
   336                              <1> A6_wCaps_CANDISIORDY	EQU	(1<<10)	; IORDY can be disabled
   337                              <1> A6_wCaps_LBA			EQU	(1<<9)	; LBA supported
   338                              <1> A6_wCaps_DMA			EQU	(1<<8)	; DMA supported
   339                              <1> 
   340                              <1> ; ATA-6 Word 53, Fields
   341                              <1> A6_wFields_88			EQU	(1<<2)	; The fields reported in word 88 are valid
   342                              <1> A6_wFields_64to70		EQU	(1<<1)	; The fields reported in words 64-70 are valid
   343                              <1> 
   344                              <1> ; ATA-6 Word 59 high byte, Block mode flags
   345                              <1> A6_bBlockFlgs_VALID		EQU	(1<<0)	; Multiple sector setting (bBlockSel) is valid
   346                              <1> 
   347                              <1> ; ATA-6 Word 63, Multiword DMA Mode
   348                              <1> A6_wMDMA_MODE2_SELECTED	EQU	(1<<10)	; Multiword DMA mode 2 is selected
   349                              <1> A6_wMDMA_MODE1_SELECTED	EQU	(1<<9)	; Multiword DMA mode 1 is selected
   350                              <1> A6_wMDMA_MODE0_SELECTED	EQU	(1<<8)	; Multiword DMA mode 0 is selected
   351                              <1> A6_wMDMA_MODE2_SUPRTD	EQU	(1<<2)	; Multiword DMA mode 2 and below are supported
   352                              <1> A6_wMDMA_MODE1_SUPRTD	EQU	(1<<1)	; Multiword DMA mode 1 and below are supported
   353                              <1> A6_wMDMA_MODE0_SUPRTD	EQU	(1<<0)	; Multiword DMA mode 0 is supported
   354                              <1> 
   355                              <1> ; ATA-6 Word 80, Major version number
   356                              <1> A6_wMajorVer_ATA6		EQU	(1<<6)
   357                              <1> A6_wMajorVer_ATA5		EQU	(1<<5)
   358                              <1> A6_wMajorVer_ATA4		EQU	(1<<4)
   359                              <1> A6_wMajorVer_ATA3		EQU	(1<<3)
   360                              <1> 
   361                              <1> ; ATA-6 Word 82, Command set supported
   362                              <1> A6_wSetSup82_NOP		EQU	(1<<14)	; NOP command supported
   363                              <1> A6_wSetSup82_RDBUFF		EQU	(1<<13)	; READ BUFFER command supported
   364                              <1> A6_wSetSup82_WRBUFF		EQU	(1<<12)	; WRITE BUFFER command supported
   365                              <1> A6_wSetSup82_PROT_AREA	EQU	(1<<10)	; Host Protected Area feature set supported
   366                              <1> A6_wSetSup82_DEV_RESET	EQU	(1<<9)	; DEVICE RESET command supported
   367                              <1> A6_wSetSup82_SERVICE	EQU	(1<<8)	; SERVICE interrupt supported
   368                              <1> A6_wSetSup82_RELEASE	EQU	(1<<7)	; Release interrupt supported
   369                              <1> A6_wSetSup82_LOOKAHEAD	EQU	(1<<6)	; Look-ahead supported
   370                              <1> A6_wSetSup82_WRCACHE	EQU	(1<<5)	; Write cache supported
   371                              <1> A6_wSetSup82_POWERMAN	EQU	(1<<3)	; Power Management feature set supported
   372                              <1> A6_wSetSup82_REM_MEDIA	EQU	(1<<2)	; Removable Media feature set supported
   373                              <1> A6_wSetSup82_SECURITY	EQU	(1<<1)	; Security Mode feature set supported
   374                              <1> A6_wSetSup82_SMART		EQU	(1<<0)	; SMART feature set supported
   375                              <1> 
   376                              <1> ; ATA-6 Word 83, Command sets supported
   377                              <1> A6_wSetSup83_FLUSH_EXT	EQU	(1<<13)	; FLUSH CACHE EXT command supported
   378                              <1> A6_wSetSup83_FLUSH		EQU	(1<<12)	; FLUSH CACHE command supported
   379                              <1> A6_wSetSup83_CFG		EQU	(1<<11)	; Device Configuration Overlay feature set supported
   380                              <1> A6_wSetSup83_LBA48		EQU	(1<<10)	; 48-bit LBA feature set supported
   381                              <1> A6_wSetSup83_ACOUSTIC	EQU	(1<<9)	; Automatic Acoustic Management feature set supported
   382                              <1> A6_wSetSup83_SET_MAX	EQU	(1<<8)	; SET MAX security extension supported
   383                              <1> A6_wSetSup83_FEATURES	EQU	(1<<6)	; SET FEATURES subcommand required to spinup after power-up
   384                              <1> A6_wSetSup83_POWERUP	EQU	(1<<5)	; Power-Up In Standby feature set supported
   385                              <1> A6_wSetSup83_RMSN		EQU	(1<<4)	; Removable Media Status Notification feature set supported
   386                              <1> A6_wSetSup83_APM		EQU	(1<<3)	; Advanced Power Management feature set supported
   387                              <1> A6_wSetSup83_CFA		EQU	(1<<2)	; CFA feature set supported
   388                              <1> A6_wSetSup83_DMAQUEUED	EQU	(1<<1)	; READ/WRITE DMA QUEUED supported
   389                              <1> A6_wSetSup83_MICROCODE	EQU	(1<<0)	; DOWNLOAD MICROCODE command supported
   390                              <1> 
   391                              <1> ; ATA-6 Word 84, Command set/feature supported extension
   392                              <1> A6_wSetSup84_GENLOG		EQU	(1<<5)	; General Purpose Logging feature set supported
   393                              <1> A6_wSetSup84_MEDIAPASS	EQU	(1<<3)	; Media Card Pass Through Command feature set supported
   394                              <1> A6_wSetSup84_MEDIASER	EQU	(1<<2)	; Media serial number supported
   395                              <1> A6_wSetSup84_SMARTTEST	EQU	(1<<1)	; SMART self-test supported
   396                              <1> A6_wSetSup84_SMARTLOG	EQU	(1<<0)	; SMART error logging supported
   397                              <1> 
   398                              <1> ; ATA-6 Word 85, Command set/feature enabled (supported by word 82)
   399                              <1> A6_wEnFor82_NOP			EQU	(1<<14)	; NOP command enabled
   400                              <1> A6_wEnFor82_RDBUFF		EQU	(1<<13)	; READ BUFFER command enabled
   401                              <1> A6_wEnFor82_WRBUFF		EQU	(1<<12)	; WRITE BUFFER command enabled
   402                              <1> A6_wEnFor82_PROT_AREA	EQU	(1<<10)	; Host Protected Area feature set enabled
   403                              <1> A6_wEnFor82_DEV_RESET	EQU	(1<<9)	; DEVICE RESET command enabled
   404                              <1> A6_wEnFor82_SERVICE		EQU	(1<<8)	; SERVICE interrupt enabled
   405                              <1> A6_wEnFor82_RELEASE		EQU	(1<<7)	; Release interrupt enabled
   406                              <1> A6_wEnFor82_LOOKAHEAD	EQU	(1<<6)	; Look-ahead enabled
   407                              <1> A6_wEnFor82_WRCACHE		EQU	(1<<5)	; Write cache enabled
   408                              <1> A6_wEnFor82_POWERMAN	EQU	(1<<3)	; Power Management feature set enabled
   409                              <1> A6_wEnFor82_REM_MEDIA	EQU	(1<<2)	; Removable Media feature set enabled
   410                              <1> A6_wEnFor82_SECURITY	EQU	(1<<1)	; Security Mode feature set enabled
   411                              <1> A6_wEnFor82_SMART		EQU	(1<<0)	; SMART feature set enabled
   412                              <1> 
   413                              <1> ; ATA-6 Word 86, Command set/feature enabled (supported by word 83)
   414                              <1> A6_wEnFor83_FLUSH_EXT	EQU	(1<<13)	; FLUSH CACHE EXT command supported
   415                              <1> A6_wEnFor83_FLUSH		EQU	(1<<12)	; FLUSH CACHE command supported
   416                              <1> A6_wEnFor83_CFG			EQU	(1<<11)	; Device Configuration Overlay supported
   417                              <1> A6_wEnFor83_LBA48		EQU	(1<<10)	; 48-bit LBA feature set supported
   418                              <1> A6_wEnFor83_ACOUSTIC	EQU	(1<<9)	; Automatic Acoustic Management feature set enabled
   419                              <1> A6_wEnFor83_SET_MAX		EQU	(1<<8)	; SET MAX security extension enabled by SET MAX SET PASSWORD
   420                              <1> A6_wEnFor83_FEATURES	EQU	(1<<6)	; SET FEATURES subcommand required to spinup after power-up
   421                              <1> A6_wEnFor83_POWERUP		EQU	(1<<5)	; Power-Up In Standby feature set enabled
   422                              <1> A6_wEnFor83_RMSN		EQU	(1<<4)	; Removable Media Status Notification feature set enabled
   423                              <1> A6_wEnFor83_APM			EQU	(1<<3)	; Advanced Power Management feature set enabled
   424                              <1> A6_wEnFor83_CFA			EQU	(1<<2)	; CFA feature set enabled
   425                              <1> A6_wEnFor83_DMAQUEUED	EQU	(1<<1)	; READ/WRITE DMA QUEUED supported
   426                              <1> A6_wEnFor83_MICROCODE	EQU	(1<<0)	; DOWNLOAD MICROCODE command supported
   427                              <1> 
   428                              <1> ; ATA-6 Word 87, Command set/feature default
   429                              <1> A6_wEnFor84_GENLOG		EQU	(1<<5)	; General Purpose Logging feature set supported
   430                              <1> A6_wEnFor84_MEDIAPASS	EQU	(1<<3)	; Media Card Pass Through Command feature set enabled
   431                              <1> A6_wEnFor84_MEDIASER	EQU	(1<<2)	; Media serial number is valid
   432                              <1> A6_wEnFor84_SMARTTEST	EQU	(1<<1)	; SMART self-test supported
   433                              <1> A6_wEnFor84_SMARTLOG	EQU	(1<<0)	; SMART error logging supported
   434                              <1> 
   435                              <1> ; ATA-6 Word 88, Ultra DMA Mode
   436                              <1> A6_wUDMA_MODE5_SELECTED	EQU	(1<<13)	; Ultra DMA mode 5 is selected
   437                              <1> A6_wUDMA_MODE4_SELECTED	EQU	(1<<12)	; Ultra DMA mode 4 is selected
   438                              <1> A6_wUDMA_MODE3_SELECTED	EQU	(1<<11)	; Ultra DMA mode 3 is selected
   439                              <1> A6_wUDMA_MODE2_SELECTED	EQU	(1<<10)	; Ultra DMA mode 2 is selected
   440                              <1> A6_wUDMA_MODE1_SELECTED	EQU	(1<<9)	; Ultra DMA mode 1 is selected
   441                              <1> A6_wUDMA_MODE0_SELECTED	EQU	(1<<8)	; Ultra DMA mode 0 is selected
   442                              <1> A6_wUDMA_MODE5_SUPRTD	EQU	(1<<5)	; Ultra DMA mode 5 and below are supported
   443                              <1> A6_wUDMA_MODE4_SUPRTD	EQU	(1<<4)	; Ultra DMA mode 4 and below are supported
   444                              <1> A6_wUDMA_MODE3_SUPRTD	EQU	(1<<3)	; Ultra DMA mode 3 and below are supported
   445                              <1> A6_wUDMA_MODE2_SUPRTD	EQU	(1<<2)	; Ultra DMA mode 2 and below are supported
   446                              <1> A6_wUDMA_MODE1_SUPRTD	EQU	(1<<1)	; Ultra DMA mode 1 and below are supported
   447                              <1> A6_wUDMA_MODE0_SUPRTD	EQU	(1<<0)	; Ultra DMA mode 0 is supported
   448                              <1> 
   449                              <1> ; ATA-6 Word 93, Hardware reset result
   450                              <1> A6_wReset_CBLID_BELOW	EQU	(1<<13)	; Device detected CBLID- above ViH
   451                              <1> A6_wReset_DEV1_PDIAG	EQU	(1<<11)	; Device 1 asserted PDIAG-
   452                              <1> A6_wReset_DEV0_RESP_D1	EQU	(1<<6)	; Device 0 responds when Device 1 is selected
   453                              <1> A6_wReset_DEV0_DASP		EQU	(1<<5)	; Device 0 detected the assertion of DASP-
   454                              <1> A6_wReset_DEV0_PDIAG	EQU	(1<<4)	; Device 0 detected the assertion of PDIAG
   455                              <1> A6_wReset_DEV0_PASSED	EQU	(1<<3)	; Device 0 passed diagnostics
   456                              <1> A6_wReset_MASK_DEV1_DETERMINE	EQU ((1<<10)|(1<<9))	; These bits indicate how Device 1 determined the device number
   457                              <1> A6_wReset_MASK_DEV0_DETERMINE	EQU ((1<<2)|(1<<1))		; These bits indicate how Device 0 determined the device number:
   458                              <1> A6_wReset_RESERVED		EQU	00b
   459                              <1> A6_wReset_JUMPER		EQU	01b		; a jumper was used
   460                              <1> A6_wReset_CSEL			EQU	10b		; the CSEL signal was used
   461                              <1> A6_wReset_UNKNOWN		EQU	11b		; some other method was used or the method is unknown
   462                              <1> 
   463                              <1> ; ATA-6 Word 127, Removable Media Status Notification feature set support
   464                              <1> A6_wRMSN_SUPPORTED		EQU	(1<<0)	; Removable Media Status Notification feature supported
   465                              <1> 
   466                              <1> ; ATA-6 Word 128, Security status
   467                              <1> A6_wSecurity_MAX		EQU	(1<<8)	; Security level 0 = High, 1 = Maximum
   468                              <1> A6_wSecurity_ENH_ERASE	EQU	(1<<5)	; Enhanced security erase supported
   469                              <1> A6_wSecurity_EXPIRED	EQU	(1<<4)	; Security count expired
   470                              <1> A6_wSecurity_FROZEN		EQU	(1<<3)	; Security frozen
   471                              <1> A6_wSecurity_LOCKED		EQU	(1<<2)	; Security locked
   472                              <1> A6_wSecurity_ENABLED	EQU	(1<<1)	; Security enabled
   473                              <1> A6_wSecurity_SUPPORTED	EQU	(1<<0)	; Security supported
   474                              <1> 
   475                              <1> ; ATA-6 Word 160, CFA Power Mode 1
   476                              <1> A6_wCFAPower_WORDSUPP	EQU	(1<<15)	; Word 160 supported
   477                              <1> A6_wCFAPower_REQUIRED	EQU	(1<<13)	; CFA power mode 1 is required for one or more commands implemented by the device
   478                              <1> A6_wCFAPower_DISABLED	EQU	(1<<12)	; CFA power mode 1 disabled
   479                              <1> A6_wCFAPower_MASK_mA	EQU	0FFFh	; Maximum current in mA
   480                              <1> 
   481                              <1> ; ATA-6 WORD 255, Integrity Word (Signature and Checksum)
   482                              <1> A6_wIntegrity_SIGNATURE	EQU	0A5h
   483                              <1> 
   484                              <1> 
   485                              <1> %endif ; ATA_ID_INC
    51                                  	%include "IdeRegisters.inc"		; For ATA Registers, flags and commands
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Equates for IDE registers, flags and commands.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> %ifndef IDEREGISTERS_INC
    21                              <1> %define IDEREGISTERS_INC
    22                              <1> 
    23                              <1> ; IDE Register offsets from Command Block base port
    24                              <1> DATA_REGISTER					EQU		0
    25                              <1> ERROR_REGISTER_in				EQU		1		; Read only
    26                              <1> FEATURES_REGISTER_out			EQU		1		; Write only, ATA1+
    27                              <1> ;WRITE_PRECOMPENSATION_out		EQU		1		; Write only, Obsolete on ATA1+
    28                              <1> SECTOR_COUNT_REGISTER			EQU		2
    29                              <1> SECTOR_NUMBER_REGISTER			EQU		3		; LBA Low Register
    30                              <1> LOW_CYLINDER_REGISTER			EQU		4		; LBA Middle Register
    31                              <1> HIGH_CYLINDER_REGISTER			EQU		5		; LBA High Register
    32                              <1> LBA_LOW_REGISTER				EQU		3		; LBA 7...0, LBA48 31...24
    33                              <1> LBA_MIDDLE_REGISTER				EQU		4		; LBA 15...8, LBA48 39...32
    34                              <1> LBA_HIGH_REGISTER				EQU		5		; LBA 23...16, LBA48 47...40
    35                              <1> DRIVE_AND_HEAD_SELECT_REGISTER	EQU		6		; LBA28 27...24
    36                              <1> STATUS_REGISTER_in				EQU		7		; Read only
    37                              <1> COMMAND_REGISTER_out			EQU		7		; Write only
    38                              <1> ;XTIDE_DATA_HIGH_REGISTER		EQU		8		; Non-standard (actually first Control Block reg)
    39                              <1> 
    40                              <1> ; IDE Register offsets from Control Block base port
    41                              <1> ; (usually Command Block base port + 200h)
    42                              <1> ALTERNATE_STATUS_REGISTER_in	EQU		6		; Read only
    43                              <1> DEVICE_CONTROL_REGISTER_out		EQU		6		; Write only
    44                              <1> ;DRIVE_ADDRESS_REGISTER			EQU		7		; Obsolete on ATA2+
    45                              <1> 
    46                              <1> ; Bit mask for XTIDE mod with reversed A0 and A3 address lines
    47                              <1> MASK_A3_AND_A0_ADDRESS_LINES	EQU		((1<<3) | (1<<0))
    48                              <1> 
    49                              <1> ; Bit definitions for IDE Error Register
    50                              <1> FLG_ERROR_BBK			EQU		(1<<7)	; Bad Block Detected (reserved on ATA2+, command dependent on ATA4+)
    51                              <1> FLG_ERROR_UNC			EQU		(1<<6)	; Uncorrectable Data Error (command dependent on ATA4+)
    52                              <1> FLG_ERROR_MC			EQU		(1<<5)	; Media Changed (command dependent on ATA4+)
    53                              <1> FLG_ERROR_IDNF			EQU		(1<<4)	; ID Not Found (command dependent on ATA4+)
    54                              <1> FLG_ERROR_MCR			EQU		(1<<3)	; Media Change Request (command dependent on ATA4+)
    55                              <1> FLG_ERROR_ABRT			EQU		(1<<2)	; Command Aborted
    56                              <1> FLG_ERROR_TK0NF			EQU		(1<<1)	; Track 0 Not Found (command dependent on ATA4+)
    57                              <1> FLG_ERROR_AMNF			EQU		(1<<0)	; Address Mark Not Found (command dependent on ATA4+)
    58                              <1> 
    59                              <1> ; Bit definitions for IDE Drive and Head Select Register
    60                              <1> FLG_DRVNHEAD_LBA		EQU		(1<<6)	; LBA Addressing enabled (instead of CHS)
    61                              <1> FLG_DRVNHEAD_DRV		EQU		(1<<4)	; Drive Select (0=Master, 1=Slave)
    62                              <1> MASK_DRVNHEAD_HEAD		EQU		0Fh		; Head select bits (bits 0...3)
    63                              <1> MASK_DRVNHEAD_SET		EQU		0A0h	; Bits that must be set to 1 on ATA1 (reserved on ATA2+)
    64                              <1> 
    65                              <1> ; Bit definitions for IDE Status Register
    66                              <1> FLG_STATUS_BSY			EQU		(1<<7)	; Busy (other flags undefined when set)
    67                              <1> FLG_STATUS_DRDY			EQU		(1<<6)	; Device Ready
    68                              <1> FLG_STATUS_DF			EQU		(1<<5)	; Device Fault (command dependent on ATA4+)
    69                              <1> FLG_STATUS_DSC			EQU		(1<<4)	; Device Seek Complete (command dependent on ATA4+)
    70                              <1> FLG_STATUS_DRQ			EQU		(1<<3)	; Data Request
    71                              <1> FLG_STATUS_CORR			EQU		(1<<2)	; Corrected Data (obsolete on ATA4+)
    72                              <1> FLG_STATUS_IDX			EQU		(1<<1)	; Index (vendor specific on ATA2+, obsolete on ATA4+)
    73                              <1> FLG_STATUS_ERR			EQU		(1<<0)	; Error
    74                              <1> 
    75                              <1> ; Bit definitions for IDE Device Control Register
    76                              <1> ; Bit 0 must be zero, unlisted bits are reserved.
    77                              <1> ;FLG_DEVCONTROL_HOB		EQU		(1<<7)	; High Order Byte (ATA6+)
    78                              <1> ;FLG_DEVCONTROL_O8H		EQU		(1<<3)	; Drive has more than 8 heads (pre-ATA only, 1 on ATA1, reserved on ATA2+)
    79                              <1> FLG_DEVCONTROL_SRST		EQU		(1<<2)	; Software Reset
    80                              <1> FLG_DEVCONTROL_nIEN		EQU		(1<<1)	; Negated Interrupt Enable (IRQ disabled when set)
    81                              <1> 
    82                              <1> ; Commands for IDE Controller
    83                              <1> COMMAND_RECALIBRATE						EQU		10h
    84                              <1> COMMAND_READ_SECTORS					EQU		20h
    85                              <1> COMMAND_READ_SECTORS_EXT				EQU		24h		; LBA48
    86                              <1> COMMAND_WRITE_SECTORS					EQU		30h
    87                              <1> COMMAND_WRITE_SECTORS_EXT				EQU		34h		; LBA48
    88                              <1> COMMAND_VERIFY_SECTORS					EQU		40h
    89                              <1> COMMAND_VERIFY_SECTORS_EXT				EQU		42h		; LBA48
    90                              <1> COMMAND_SEEK							EQU		70h
    91                              <1> COMMAND_INITIALIZE_DEVICE_PARAMETERS	EQU		91h
    92                              <1> COMMAND_SET_MULTIPLE_MODE				EQU		0C6h	; Block mode
    93                              <1> COMMAND_READ_MULTIPLE					EQU		0C4h	; Block mode
    94                              <1> COMMAND_READ_MULTIPLE_EXT				EQU		29h		; LBA48, Block mode
    95                              <1> COMMAND_WRITE_MULTIPLE					EQU		0C5h	; Block mode
    96                              <1> COMMAND_WRITE_MULTIPLE_EXT				EQU		39h		; LBA48, Block mode
    97                              <1> COMMAND_IDENTIFY_DEVICE					EQU		0ECh
    98                              <1> COMMAND_SET_FEATURES					EQU		0EFh
    99                              <1> COMMAND_IDLE							EQU		0E3h
   100                              <1> 
   101                              <1> 
   102                              <1> ; Subcommands for COMMAND_SET_FEATURES
   103                              <1> FEATURE_ENABLE_8BIT_PIO_TRANSFER_MODE	EQU		01h		; CFA feature set only
   104                              <1> FEATURE_ENABLE_WRITE_CACHE				EQU		02h
   105                              <1> FEATURE_DISABLE_8BIT_PIO_TRANSFER_MODE	EQU		81h		; CFA feature set only
   106                              <1> FEATURE_DISABLE_WRITE_CACHE				EQU		82h		; Can also be used to flush cache
   107                              <1> FEATURE_SET_TRANSFER_MODE				EQU		03h		; Transfer mode goes to the Sector Count Register
   108                              <1> 	PIO_DEFAULT_MODE					EQU		0h
   109                              <1> 	PIO_DEFAULT_MODE_DISABLE_IORDY		EQU		1h
   110                              <1> 	PIO_FLOW_CONTROL_MODE_xxx			EQU		(1<<3)	; Bits 2...0 hold the PIO mode
   111                              <1> 
   112                              <1> 
   113                              <1> %endif ; IDEREGISTERS_INC
    52                                  	%include "Int13h.inc"			; Equates for INT 13h functions
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Equates used in INT 13h functions.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> %ifndef INT13H_INC
    21                              <1> %define INT13H_INC
    22                              <1> 
    23                              <1> ; Hard Disk function (INT 13h) return status codes in AH
    24                              <1> RET_HD_SUCCESS			EQU		0h		; Operation successful, no error occurred
    25                              <1> RET_HD_INVALID			EQU		1h		; Invalid value passed or unsupported func
    26                              <1> RET_HD_ADDRMARK			EQU		2h		; Missing address mark
    27                              <1> RET_HD_WRITEPROT		EQU		3h		; Removable media is write protected
    28                              <1> RET_HD_NOT_FOUND		EQU		4h		; Requested sector not found
    29                              <1> RET_HD_RESETFAIL		EQU		5h		; Reset failed
    30                              <1> RET_HD_CHANGED			EQU		6h		; Media changed
    31                              <1> RET_HD_PARAMACT			EQU		7h		; Drive parameter activity failed
    32                              <1> RET_HD_OVERRUN			EQU		8h		; DMA overrun
    33                              <1> RET_HD_BOUNDARY			EQU		9h		; Data boundary error
    34                              <1> RET_HD_BADSECTOR		EQU		0Ah		; Bad sector detected
    35                              <1> RET_HD_BADTRACK			EQU		0Bh		; Bad track detected
    36                              <1> RET_HD_UNCORRECC		EQU		10h		; Uncorrectable ECC error
    37                              <1> RET_HD_ECC				EQU		11h		; Corrected ECC error
    38                              <1> RET_HD_CONTROLLER		EQU		20h		; Hard disk controller or drive problem
    39                              <1> RET_HD_NOMEDIA			EQU		31h		; No media in removable media drive
    40                              <1> RET_HD_SEEK_FAIL		EQU		40h		; Seek operation failed
    41                              <1> RET_HD_TIMEOUT			EQU		80h		; Drive failed to respond
    42                              <1> RET_HD_NOTREADY			EQU		0AAh	; Drive is not ready or is not selected
    43                              <1> RET_HD_NOTLOCKED		EQU		0B0h	; Volume not locked in drive
    44                              <1> RET_HD_LOCKED			EQU		0B1h	; Volume locked in drive
    45                              <1> RET_HD_NOTREMOVABLE		EQU		0B2h	; Volume not removable
    46                              <1> RET_HD_INUSE			EQU		0B3h	; Volume in use
    47                              <1> RET_HD_LOCKEXCEEDED		EQU		0B4h	; Lock count exceeded
    48                              <1> RET_HD_EJECTFAIL		EQU		0B5h	; Valid eject request failed
    49                              <1> RET_HD_UNDEFINED		EQU		0BBh	; Undefined error occurred
    50                              <1> RET_HD_WRFAULT			EQU		0CCh	; Write fault on selected drive
    51                              <1> RET_HD_STATUSERR		EQU		0E0h	; Status error without error
    52                              <1> RET_HD_SENSEFAIL		EQU		0FFh	; Sense operation failed
    53                              <1> 
    54                              <1> 
    55                              <1> ; Floppy Drive types returned by INT 13h, AH=08h
    56                              <1> FLOPPY_TYPE_525_OR_35_DD	EQU	0
    57                              <1> FLOPPY_TYPE_525_DD			EQU	1
    58                              <1> FLOPPY_TYPE_525_HD			EQU	2
    59                              <1> FLOPPY_TYPE_35_DD			EQU	3
    60                              <1> FLOPPY_TYPE_35_HD			EQU	4
    61                              <1> FLOPPY_TYPE_35_ED			EQU	6
    62                              <1> 
    63                              <1> 
    64                              <1> %define TIMEOUT_AND_STATUS_TO_WAIT(timeout, status)		(((timeout)<<8) | (status))
    65                              <1> 
    66                              <1> 
    67                              <1> %endif ; INT13H_INC
    53                                  	%include "CustomDPT.inc"		; For Disk Parameter Table
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Defines for DPT structs containing custom
     3                              <1> ;					Disk Parameter Table used by this BIOS.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ;
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> %ifndef CUSTOMDPT_INC
    22                              <1> %define CUSTOMDPT_INC
    23                              <1> 
    24                              <1> ; Base DPT for all device types
    25                              <1> struc DPT
    26                              <1> 	; General Disk Parameter Table related
    27                              <1> 	.wFlags:
    28 00000000 <res 00000001>      <1> 	.bFlagsLow				resb	1
    29 00000001 <res 00000001>      <1> 	.bFlagsHigh				resb	1
    30 00000002 <res 00000001>      <1> 	.bIdevarsOffset			resb	1	; Offset to IDEVARS for this drive
    31 00000003 <res 00000001>      <1> 	.bInitError				resb	1	; Flags for AH=09h initialization errors
    32 00000004 <res 00000002>      <1> 	.wBasePort				resb	2	; Segment for JR-IDE/ISA
    33                              <1> 
    34                              <1> 	; CHS variables
    35 00000006 <res 00000002>      <1> 	.wLchsCylinders			resb	2	; (1...1027, yes 1027)
    36                              <1> 	.wLchsHeadsAndSectors:
    37 00000008 <res 00000001>      <1> 	.bLchsHeads				resb	1	; (1...255)
    38 00000009 <res 00000001>      <1> 	.bLchsSectorsPerTrack	resb	1	; (1...63)
    39 0000000A <res 00000001>      <1> 	.bPchsHeads				resb	1	; (1...16)
    40                              <1> 
    41                              <1> 	; LBA and remaining P-CHS variables
    42                              <1> %ifdef MODULE_EBIOS
    43                              <1> 	.bPchsSectorsPerTrack	resb	1
    44                              <1> 	.wPchsCylinders			resb	2
    45                              <1> 	.twLbaSectors			resb	6	; 48-bit sector count for LBA addressing
    46                              <1> %endif
    47 0000000B <res 00000001>      <1> 							alignb	2	; WORD alignment for DPT_SERIAL or DPT_ATA
    48                              <1> endstruc
    49                              <1> 
    50                              <1> 	; Bit definitions for DPT.bFlagsLow
    51                              <1> 	MASKL_DPT_CHS_SHIFT_COUNT			EQU	(3<<0)				; Bits 0...1, P-CHS to L-CHS bit shift count (0...3)
    52                              <1> 	MASKL_DPT_TRANSLATEMODE				EQU	MASK_DRVPARAMS_TRANSLATEMODE	; Bits 2...3, NORMAL, LARGE or Assisted LBA addressing mode
    53                              <1> 	FLGL_DPT_ASSISTED_LBA				EQU	(1<<(TRANSLATEMODE_FIELD_POSITION+1))
    54                              <1> 	FLGL_DPT_SLAVE						EQU	FLG_DRVNHEAD_DRV	; Bit 4, Drive is a Slave Drive
    55                              <1> %ifdef MODULE_IRQ
    56                              <1> 	FLGL_DPT_ENABLE_IRQ					EQU	(1<<5)				; Bit 5, Enable IRQ
    57                              <1> %endif
    58                              <1> %ifdef MODULE_EBIOS
    59                              <1> 	FLGL_DPT_LBA_AND_EBIOS_SUPPORTED	EQU	FLG_DRVNHEAD_LBA	; Bit 6, Drive supports LBA and so EBIOS functions can be supported
    60                              <1> 	FLGL_DPT_LBA48						EQU	(1<<7)				; Bit 7, Drive supports 48-bit LBA (Must be bit 7!)
    61                              <1> %endif
    62                              <1> 
    63                              <1> 
    64                              <1> 	; Bit definitions for DPT.bFlagsHigh
    65                              <1> 	FLGH_DPT_BLOCK_MODE_SUPPORTED		EQU	(1<<1)	; Bit 1, Use block transfer commands (must be bit 1!)
    66                              <1> %ifdef MODULE_SERIAL
    67                              <1> 	FLGH_DPT_SERIAL_DEVICE				EQU	(1<<2)	; Bit 2, Serial Port Device
    68                              <1> %endif
    69                              <1> %ifdef MODULE_IRQ
    70                              <1> 	FLGH_DPT_INTERRUPT_IN_SERVICE		EQU	(1<<3)	; Bit 3, Set when waiting for IRQ
    71                              <1> %endif
    72                              <1> %ifdef MODULE_FEATURE_SETS
    73                              <1> 	FLGH_DPT_POWER_MANAGEMENT_SUPPORTED	EQU (1<<5)	; Bit 5, Drive supports power management
    74                              <1> %endif
    75                              <1> %ifdef MODULE_ADVANCED_ATA
    76                              <1> 	FLGH_DPT_IORDY						EQU	(1<<7)	; Bit 7, Controller and Drive supports IORDY
    77                              <1> %endif
    78                              <1> 
    79                              <1> 	; Serial device only
    80                              <1> %ifdef MODULE_SERIAL_FLOPPY
    81                              <1> 	FLGH_DPT_SERIAL_FLOPPY						EQU	(1<<4)
    82                              <1> 	FLGH_DPT_SERIAL_FLOPPY_TYPE_MASK			EQU	0e0h
    83                              <1> 	FLGH_DPT_SERIAL_FLOPPY_TYPE_FIELD_POSITION	EQU	5
    84                              <1> %endif
    85                              <1> 
    86                              <1> 
    87                              <1> 	; Flags for DPT_ADVANCED_ATA.bInitError
    88                              <1> 	FLG_INITERROR_FAILED_TO_SELECT_DRIVE				EQU (1<<0)
    89                              <1> 	FLG_INITERROR_FAILED_TO_INITIALIZE_CHS_PARAMETERS	EQU (1<<1)
    90                              <1> 	FLG_INITERROR_FAILED_TO_SET_WRITE_CACHE				EQU (1<<2)
    91                              <1> 	FLG_INITERROR_FAILED_TO_RECALIBRATE_DRIVE			EQU (1<<3)
    92                              <1> 	FLG_INITERROR_FAILED_TO_SET_BLOCK_MODE				EQU (1<<4)
    93                              <1> 	FLG_INITERROR_FAILED_TO_SET_PIO_MODE				EQU (1<<5)
    94                              <1> 	FLG_INITERROR_FAILED_TO_INITIALIZE_STANDBY_TIMER	EQU	(1<<6)
    95                              <1> 	FLG_INITERROR_FAILED_TO_SET_XTCF_MODE				EQU	(1<<7)
    96                              <1> 	FLG_INITERROR_FAILED_TO_SET_8BIT_MODE				EQU	FLG_INITERROR_FAILED_TO_SET_XTCF_MODE
    97                              <1> 
    98                              <1> 
    99                              <1> 
   100                              <1> ; DPT for ATA devices
   101                              <1> struc DPT_ATA
   102 00000000 <res 0000000C>      <1> 	.dpt					resb	DPT_size
   103 0000000C <res 00000001>      <1> 	.bDevice				resb	1	; Device Type from IDEVARS (overrided when 32-bit controller detected)
   104 0000000D <res 00000001>      <1> 	.bBlockSize				resb	1	; Current block size in sectors (do not set to zero!)
   105                              <1> endstruc
   106                              <1> 
   107                              <1> 
   108                              <1> 
   109                              <1> ; Additional variables needed to initialize and reset Advanced IDE Controllers.
   110                              <1> ; EBDA must be reserved for DPTs when using these!
   111                              <1> %ifdef MODULE_ADVANCED_ATA
   112                              <1> struc DPT_ADVANCED_ATA
   113                              <1> 	.dpt_ata				resb	DPT_ATA_size
   114                              <1> 	.wControllerID			resb	2	; Controller specific ID WORD (from Advanced Controller detection)
   115                              <1> 	.wControllerBasePort	resb	2	; Advanced Controller port (not IDE port)
   116                              <1> 	.wMinPioCycleTime		resb	2	; Minimum PIO Cycle Time in ns
   117                              <1> 	.bPioMode				resb	1	; Best supported PIO mode
   118                              <1> 							alignb	2
   119                              <1> endstruc
   120                              <1> %endif
   121                              <1> 
   122                              <1> 
   123                              <1> ; DPT for Serial devices
   124                              <1> %ifdef MODULE_SERIAL
   125                              <1> struc DPT_SERIAL
   126                              <1> 	.dpt					resb	DPT_size
   127                              <1> 	.wSerialPortAndBaud:
   128                              <1> 	.bSerialPort			resb	1	; Serial connection I/O port address, divided by 4
   129                              <1> 	.bSerialBaud			resb 	1	; Serial connection baud rate divisor
   130                              <1> endstruc
   131                              <1> 
   132                              <1> ; On performance critical situations we compare DPT_ATA.bDevice without checking FLGH_DPT_SERIAL_DEVICE
   133                              <1> ; first! DPT_ATA.bDevice uses small values so there will be no problems.
   134                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   135                              <1> 	%if DPT_SERIAL.bSerialPort <> DPT_ATA.bDevice
   136                              <1> 		%error "DPT_ATA.bDevice and DPT_SERIAL.bSerialPort must be in same offsets!"
   137                              <1> 	%endif
   138                              <1> %endif
   139                              <1> %endif ; MODULE_SERIAL
   140                              <1> 
   141                              <1> 
   142                              <1> ; This is the common size for all DPTs. All DPTs must be equal size.
   143                              <1> %ifdef MODULE_ADVANCED_ATA
   144                              <1> 	LARGEST_DPT_SIZE			EQU		DPT_ADVANCED_ATA_size
   145                              <1> %else
   146                              <1> 	LARGEST_DPT_SIZE			EQU		DPT_ATA_size
   147                              <1> %endif
   148                              <1> 
   149                              <1> 
   150                              <1> 	; Number of Sectors per Track is fixed to 63 for LBA assist calculation.
   151                              <1> 	; 1024 cylinders, 256 heads, 63 sectors = 8.4 GB limit (but DOS does not support more than 255 heads)
   152                              <1> 	MAX_LCHS_CYLINDERS			EQU		1024
   153                              <1> 	LBA_ASSIST_SPT				EQU		63
   154                              <1> 
   155                              <1> 
   156                              <1> %endif ; CUSTOMDPT_INC
    54                                  	%include "RomVars.inc"			; For ROMVARS and IDEVARS structs
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Defines for ROMVARS struct containing variables stored
     3                              <1> ;			in BIOS ROM.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ;
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    22                              <1> 
    23                              <1> 
    24                              <1> %ifndef ROMVARS_INC
    25                              <1> %define ROMVARS_INC
    26                              <1> 
    27                              <1> ; ROM Variables. Written to the ROM image before flashing.
    28                              <1> struc ROMVARS
    29 00000000 <res 00000002>      <1> 	.wRomSign			resb	2	; ROM Signature (AA55h)
    30 00000002 <res 00000001>      <1> 	.bRomSize			resb	1	; ROM size in 512 byte blocks
    31 00000003 <res 00000003>      <1> 	.rgbJump			resb	3	; First instruction to ROM init (jmp)
    32                              <1> 
    33 00000006 <res 00000008>      <1> 	.rgbSign			resb	8	; Signature for XTIDE Configurator Program
    34 0000000E <res 0000001F>      <1> 	.szTitle			resb	31	; BIOS title string
    35 0000002D <res 00000019>      <1> 	.szVersion			resb	25	; BIOS version string
    36                              <1> 
    37 00000046 <res 00000002>      <1> 	.wFlags				resb	2	; Word for ROM flags
    38 00000048 <res 00000002>      <1> 	.wDisplayMode			resb	2	; Display mode for boot menu
    39 0000004A <res 00000002>      <1> 	.wBootTimeout			resb	2	; Boot Menu selection timeout in system timer ticks
    40 0000004C <res 00000001>      <1> 	.bIdeCnt			resb	1	; Number of available IDE controllers
    41 0000004D <res 00000001>      <1> 	.bBootDrv			resb	1	; Default drive to boot from
    42 0000004E <res 00000001>      <1> 	.bMinFddCnt			resb	1	; Minimum number of Floppy Drives
    43 0000004F <res 00000001>      <1> 	.bStealSize			resb	1	; Number of 1kB blocks stolen from 640kB base RAM
    44 00000050 <res 00000001>      <1> 	.bIdleTimeout			resb	1	; Standby timer value
    45                              <1> 
    46                              <1> 	.ideVarsBegin:
    47 00000051 <res 00000012>      <1> 	.ideVars0			resb	IDEVARS_size
    48 00000063 <res 00000012>      <1> 	.ideVars1			resb	IDEVARS_size
    49 00000075 <res 00000012>      <1> 	.ideVars2			resb	IDEVARS_size
    50 00000087 <res 00000012>      <1> 	.ideVars3			resb	IDEVARS_size
    51                              <1> 
    52                              <1> %ifdef MODULE_SERIAL
    53                              <1> 	.ideVarsSerialAuto		resb	IDEVARS_size
    54                              <1> %endif
    55                              <1> 
    56                              <1> 	.ideVarsEnd:
    57                              <1> endstruc
    58                              <1> 
    59                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    60                              <1> 	%if ROMVARS.ideVarsEnd & 0xff00 <> 0
    61                              <1> 		%error ".ideVars structures must fit within the first 256 bytes of the ROM image"
    62                              <1> 	%endif
    63                              <1> 	%if (ROMVARS.ideVarsEnd - ROMVARS.ideVarsBegin) = 0
    64                              <1> 		%error "there must be at least one .ideVars structure, it would be bizarre if this were not true, but it is assumed in the ah0h reset code."
    65                              <1> 	%endif
    66                              <1> %endif
    67                              <1> 
    68                              <1> NUMBER_OF_IDEVARS					EQU	((ROMVARS.ideVarsEnd - ROMVARS.ideVarsBegin) / IDEVARS_size)
    69                              <1> 
    70                              <1> ; Bit defines for ROMVARS.wFlags
    71                              <1> FLG_ROMVARS_FULLMODE					EQU	(1<<0)	; Full operating mode (steals base RAM, supports EBIOS etc.)
    72                              <1> FLG_ROMVARS_SERIAL_SCANDETECT 				EQU	(1<<3)	; Scan COM ports at the end of drive detection.  Can also be invoked
    73                              <1> 									; by holding down the ALT key at the end of drive detection.
    74                              <1> 									; (Conveniently, this is 8, a fact we exploit when testing the bit)
    75                              <1> 
    76                              <1> ; Here in case the configuration needs to know functionality is present
    77                              <1> FLG_ROMVARS_MODULE_FEATURE_SETS				EQU	(1<<5)
    78                              <1> FLG_ROMVARS_MODULE_8BIT_IDE				EQU	(1<<6)
    79                              <1> FLG_ROMVARS_MODULE_8BIT_IDE_ADVANCED			EQU	(1<<7)
    80                              <1> FLG_ROMVARS_MODULE_ADVANCED_ATA				EQU	(1<<8)
    81                              <1> FLG_ROMVARS_MODULE_BOOT_MENU				EQU	(1<<9)
    82                              <1> FLG_ROMVARS_MODULE_EBIOS				EQU	(1<<10)
    83                              <1> FLG_ROMVARS_MODULE_HOTKEYS				EQU	(1<<11)
    84                              <1> FLG_ROMVARS_MODULE_IRQ					EQU	(1<<12)
    85                              <1> FLG_ROMVARS_MODULE_SERIAL				EQU	(1<<13)
    86                              <1> FLG_ROMVARS_MODULE_SERIAL_FLOPPY			EQU	(1<<14)
    87                              <1> FLG_ROMVARS_MODULE_STRINGS_COMPRESSED			EQU	(1<<15)
    88                              <1> 
    89                              <1> 
    90                              <1> ; Boot Menu Display Modes (see Assembly Library Display.inc for standard modes)
    91                              <1> DEFAULT_TEXT_MODE					EQU	4
    92                              <1> 
    93                              <1> 
    94                              <1> ; Controller specific variables
    95                              <1> struc IDEVARS
    96                              <1> ;;; Word 0
    97                              <1> 	.wSerialPortAndBaud:						; Serial connection port (low, divided by 4) and baud rate divisor (high)
    98                              <1> 	.wBasePort:							; IDE Base Port for Command Block (usual) Registers
    99 00000000 <res 00000001>      <1> 	.bSerialPort					resb	1
   100 00000001 <res 00000001>      <1> 	.bSerialBaud					resb	1
   101                              <1> 
   102                              <1> ;;; Word 1
   103                              <1> 	.wControlBlockPort:
   104                              <1> 	.bXTCFcontrolRegister:						; XT-CFv3 port used to initiate a DMA transfer
   105 00000002 <res 00000001>      <1> 	.bSerialUnused					resb	1	; IDE Base Port for Control Block Registers
   106                              <1> 
   107                              <1> 	.wSerialCOMPortCharAndDevice:					; In DetectPrint, we grab the COM Port char and Device at the same time
   108 00000003 <res 00000001>      <1> 	.bSerialCOMPortChar				resb	1	; Serial connection COM port number/letter
   109                              <1> 
   110                              <1> ;;; Word 2
   111 00000004 <res 00000001>      <1> 	.bDevice					resb	1	; Device type
   112 00000005 <res 00000001>      <1> 	.bIRQ						resb	1	; Interrupt Request Number
   113                              <1> 
   114                              <1> ;;; And more...
   115 00000006 <res 00000006>      <1> 	.drvParamsMaster				resb	DRVPARAMS_size
   116 0000000C <res 00000006>      <1> 	.drvParamsSlave					resb	DRVPARAMS_size
   117                              <1> endstruc
   118                              <1> 
   119                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   120                              <1> 	%if IDEVARS.bSerialCOMPortChar+1 != IDEVARS.bDevice
   121                              <1> 		%error "IDEVARS.bSerialCOMPortChar needs to come immediately before IDEVARS.bDevice so that both bytes can be fetched at the same time inside DetectPrint.asm"
   122                              <1> 	%endif
   123                              <1> %endif
   124                              <1> 
   125                              <1> STANDARD_CONTROL_BLOCK_OFFSET				EQU		200h
   126                              <1> XTIDE_CONTROL_BLOCK_OFFSET				EQU		8h	; for XTIDE, A3 is used to control selected register (CS0 vs CS1)
   127                              <1> XTCF_CONTROL_BLOCK_OFFSET				EQU		10h	; and for XT-CF (all varients), it's A4
   128                              <1> 
   129                              <1> ; Default values for Port and PortCtrl, shared with the configurator
   130                              <1> ;
   131                              <1> DEVICE_XTIDE_DEFAULT_PORT				EQU		300h	; Also the default port for XT-CF
   132                              <1> DEVICE_XTIDE_DEFAULT_PORTCTRL				EQU		(DEVICE_XTIDE_DEFAULT_PORT + XTIDE_CONTROL_BLOCK_OFFSET)
   133                              <1> DEVICE_XTCF_DEFAULT_PORTCTRL				EQU		(DEVICE_XTIDE_DEFAULT_PORT + XTCF_CONTROL_BLOCK_OFFSET)
   134                              <1> 
   135                              <1> DEVICE_ATA_PRIMARY_PORT					EQU		1F0h
   136                              <1> DEVICE_ATA_PRIMARY_PORTCTRL				EQU		(DEVICE_ATA_PRIMARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
   137                              <1> 
   138                              <1> DEVICE_ATA_SECONDARY_PORT				EQU		170h
   139                              <1> DEVICE_ATA_SECONDARY_PORTCTRL				EQU		(DEVICE_ATA_SECONDARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
   140                              <1> 
   141                              <1> DEVICE_ATA_TERTIARY_PORT				EQU		1E8h
   142                              <1> DEVICE_ATA_TERTIARY_PORTCTRL				EQU		(DEVICE_ATA_TERTIARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
   143                              <1> 
   144                              <1> DEVICE_ATA_QUATERNARY_PORT				EQU		168h
   145                              <1> DEVICE_ATA_QUATERNARY_PORTCTRL				EQU		(DEVICE_ATA_QUATERNARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
   146                              <1> 
   147                              <1> 
   148                              <1> ; Device types for IDEVARS.bDevice
   149                              <1> ; IDE Devices are grouped so device numbers cannot be changed without modifying code elsewhere!
   150                              <1> ;
   151                              <1> COUNT_OF_STANDARD_IDE_DEVICES				EQU	2	; 16- and 32-bit controllers
   152                              <1> COUNT_OF_8BIT_IDE_DEVICES				EQU	7
   153                              <1> COUNT_OF_ALL_IDE_DEVICES				EQU	(COUNT_OF_8BIT_IDE_DEVICES + COUNT_OF_STANDARD_IDE_DEVICES)
   154                              <1> ; Standard port mapped I/O
   155                              <1> DEVICE_16BIT_ATA					EQU	(0<<1)
   156                              <1> DEVICE_32BIT_ATA					EQU	(1<<1)
   157                              <1> DEVICE_8BIT_ATA						EQU	((COUNT_OF_STANDARD_IDE_DEVICES+0)<<1)	; 16- or 32-bit controller in 8-bit mode
   158                              <1> DEVICE_8BIT_XTIDE_REV1					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+1)<<1)
   159                              <1> ; Address lines A0 and A3 are swapped
   160                              <1> DEVICE_8BIT_XTIDE_REV2					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+2)<<1)	; Or rev 1 with swapped A0 and A3
   161                              <1> ; IDE Register offsets are SHL 1
   162                              <1> ; Note: ordering swapped to support XT-CFv3 and all other XT-CF derivatives
   163                              <1> DEVICE_8BIT_XTCF_PIO8					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+3)<<1)	; XT-CF using 8-bit PIO mode
   164                              <1> DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD			EQU	((COUNT_OF_STANDARD_IDE_DEVICES+4)<<1)	; XT-CF using 8-bit PIO mode, but with 16-bit instructions
   165                              <1> DEVICE_8BIT_XTCF_DMA					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+5)<<1)	; XT-CFv3 using DMA
   166                              <1> ; Memory Mapped I/O
   167                              <1> DEVICE_8BIT_JRIDE_ISA					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+6)<<1)	; JR-IDE/ISA (Memory Mapped I/O)
   168                              <1> ; Virtual devices
   169                              <1> DEVICE_SERIAL_PORT					EQU	(COUNT_OF_ALL_IDE_DEVICES<<1)
   170                              <1> 
   171                              <1> 
   172                              <1> 
   173                              <1> ; Master/Slave drive specific parameters
   174                              <1> struc DRVPARAMS
   175 00000000 <res 00000002>      <1> 	.wFlags						resb	2	; Drive flags
   176                              <1> 	.dwMaximumLBA:							; User specified maximum number of sectors
   177 00000002 <res 00000002>      <1> 	.wCylinders					resb	2	; User specified cylinders (1...16383)
   178                              <1> 	.wHeadsAndSectors:
   179 00000004 <res 00000001>      <1> 	.bHeads						resb	1	; User specified Heads (1...16)
   180 00000005 <res 00000001>      <1> 	.bSect						resb	1	; User specified Sectors per track (1...63)
   181                              <1> endstruc
   182                              <1> 
   183                              <1> ; Bit defines for DRVPARAMS.wFlags
   184                              <1> 	MASK_DRVPARAMS_WRITECACHE			EQU	(3<<0)	; Bits 0...1, Drive internal write cache settings (must start at bit 0)
   185                              <1> 	DEFAULT_WRITE_CACHE				EQU	0	; Must be 0
   186                              <1> 	DISABLE_WRITE_CACHE				EQU	1
   187                              <1> 	ENABLE_WRITE_CACHE				EQU	2
   188                              <1> 	MASK_DRVPARAMS_TRANSLATEMODE			EQU	(3<<TRANSLATEMODE_FIELD_POSITION)	; Bits 2...3, Position shared with DPT
   189                              <1> 	TRANSLATEMODE_FIELD_POSITION			EQU	2
   190                              <1> 	TRANSLATEMODE_NORMAL				EQU	0
   191                              <1> 	TRANSLATEMODE_LARGE				EQU	1
   192                              <1> 	TRANSLATEMODE_ASSISTED_LBA			EQU	2	; 28-bit or 48-bit LBA
   193                              <1> 	TRANSLATEMODE_AUTO				EQU	3	; Only available in ROMVARS, not in DPTs
   194                              <1> 	FLG_DRVPARAMS_BLOCKMODE				EQU	(1<<4)	; Enable Block mode transfers
   195                              <1> 	FLG_DRVPARAMS_USERCHS				EQU	(1<<5)	; User specified P-CHS values
   196                              <1> 	MAX_USER_CYLINDERS				EQU	16383
   197                              <1> 	MAX_USER_HEADS					EQU	16
   198                              <1> 	MAX_USER_SECTORS_PER_TRACK			EQU	63
   199                              <1> 	FLG_DRVPARAMS_USERLBA				EQU	(1<<6)	; User specified LBA value
   200                              <1> 	MIN_USER_LBA_COUNT				EQU	((MAX_USER_CYLINDERS*MAX_USER_HEADS*MAX_USER_SECTORS_PER_TRACK)+1)
   201                              <1> 	MAX_USER_LBA_COUNT				EQU	((2^28)-1)
   202                              <1> 
   203                              <1> 
   204                              <1> %endif ; ROMVARS_INC
    55                                  	%include "RamVars.inc"			; For RAMVARS struct
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	RAMVARS struct containing BIOS variables stored in RAM.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> %ifndef RAMVARS_INC
    21                              <1> %define RAMVARS_INC
    22                              <1> 
    23                              <1> ; Segment when RAMVARS is stored to top of interrupt vectors.
    24                              <1> %ifndef USE_AT
    25                              <1> 	LITE_MODE_RAMVARS_SEGMENT	EQU		30h
    26                              <1> %endif
    27                              <1> 
    28                              <1> 
    29                              <1> %ifdef MODULE_SERIAL_FLOPPY OR MODULE_DRIVEXLATE
    30                              <1> 	%define NEED_XLATEVARS
    31                              <1> %endif
    32                              <1> 
    33                              <1> 
    34                              <1> ; RAM Variables.
    35                              <1> ; Variables should be kept to minimum since they might be located
    36                              <1> ; at the top of interrupt vectors.
    37                              <1> struc RAMVARS
    38                              <1> %ifdef RELOCATE_INT13H_STACK
    39                              <1> 						resb	252
    40                              <1> 	.dwStackChangeDSDI:
    41                              <1> 	.wStackChangeDI		resb	2	; Used during stack
    42                              <1> 	.wStackChangeDS		resb	2	; switching only
    43                              <1> 	.rgbTopOfStack:					; 256 bytes of stack
    44                              <1> 	.fpInt13hEntryStack	resb	4
    45                              <1> %endif
    46                              <1> 	.wDrvDetectSignature:			; Signature when BIOS is in drive detection mode
    47 00000000 <res 00000004>      <1> 	.fpOldI13h			resb	4	; Far pointer to old INT 13h handler
    48 00000004 <res 00000002>      <1> 	.wSignature			resb	2	; Sign for finding stolen 1...64 kiB
    49 00000006 <res 00000001>      <1> 	.bTimeoutTicksLeft	resb	1
    50 00000007 <res 00000001>      <1> 	.bLastTimeoutUpdate	resb	1
    51                              <1> 
    52                              <1> 	.wFirstDrvAndCount:
    53 00000008 <res 00000001>      <1> 	.bFirstDrv			resb	1	; Number of first drive for this BIOS
    54                              <1> 	.wDrvCntAndFlopCnt:				; Both the hard disk and floppy counts in one word
    55                              <1> 									; (yes, misaligned, but it is only used this way during initialization)
    56 00000009 <res 00000001>      <1> 	.bDrvCnt			resb	1	; Number of drives handled by this BIOS
    57                              <1> 
    58                              <1> 	; Variables for drive number translation
    59                              <1> %ifdef NEED_XLATEVARS
    60 0000000A <res 00000004>      <1> 	.xlateVars			resb	XLATEVARS_size
    61                              <1> %endif
    62                              <1> endstruc
    63                              <1> 
    64                              <1> ; Note!!! .wDrvDetectSignature and .wSignature are intentionally in different locations.
    65                              <1> RAMVARS_RAM_SIGNATURE			EQU	"Xu"	; RAMVARS signature for .wSignature
    66                              <1> RAMVARS_DRV_DETECT_SIGNATURE	EQU	5A5Ah	; Signature when BIOS is in drive detection mode
    67                              <1> 
    68                              <1> 
    69                              <1> %ifdef NEED_XLATEVARS
    70                              <1> ; Variables for translating drive numbers.
    71                              <1> 	struc XLATEVARS
    72                              <1> 	%ifdef MODULE_SERIAL_FLOPPY
    73                              <1> 		.bFlopCreateCnt:
    74                              <1> 		.bFlopCntAndFirst	resb	1	; Normally, packed starting floppy drive number (high order 7 bits)
    75                              <1> 										; and number of drives (low order bit, max 2 drives supported).
    76                              <1> 										; During initialization, until the end of DetectDrives_FromAllIDEControllers,
    77                              <1> 										; this byte contains the raw number of floppy drives seen
    78                              <1> 										; (using .bFlopCreateCnt)
    79                              <1> 	%else
    80 00000000 <res 00000001>      <1> 							resb	1	; alignment
    81                              <1> 	%endif
    82                              <1> 
    83                              <1> 	%ifdef MODULE_DRIVEXLATE
    84 00000001 <res 00000001>      <1> 		.bXlatedDrv			resb	1	; Drive number after translation
    85                              <1> 		.wFDandHDswap:
    86 00000002 <res 00000001>      <1> 		.bFDSwap			resb	1	; Floppy Drive to swap to 00h and vice versa
    87 00000003 <res 00000001>      <1> 		.bHDSwap			resb	1	; Hard Drive to swap to 80h and vice versa
    88                              <1> 	%else
    89                              <1> 							resb	1	; alignment
    90                              <1> 	%endif
    91                              <1> 	endstruc
    92                              <1> %endif
    93                              <1> 
    94                              <1> %ifdef MODULE_SERIAL_FLOPPY
    95                              <1>   %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    96                              <1> 	%if RAMVARS.xlateVars != RAMVARS.bDrvCnt+1 || XLATEVARS.bFlopCreateCnt != 0
    97                              <1> 		%error "bFlopCreateCnt needs to be the first thing in XLATEVARS, and .xlateVars needs to come immediately after .bDrvCnt.  In at least one place, we read .wDrvCntAndFlopCnt to get both counts in one fetch"
    98                              <1> 	%endif
    99                              <1>   %endif
   100                              <1> %endif
   101                              <1> 
   102                              <1> 
   103                              <1> 
   104                              <1> ;
   105                              <1> ; IDEPACK NOTE: The first six bytes of this structure are directly put on the
   106                              <1> ; wire for MODULE_SERIAL, please do not change the order or insert other members.
   107                              <1> ;
   108                              <1> struc IDEPACK	; PIOVARS and MEMPIOVARS overwrite the first 7 bytes
   109 00000000 <res 00000001>      <1> 	.bFeatures				resb	1
   110 00000001 <res 00000001>      <1> 	.bDrvAndHead			resb	1	; LBA28 27...24
   111                              <1> 
   112                              <1> 	.wSectorCountAndLbaLow:
   113 00000002 <res 00000001>      <1> 	.bSectorCount			resb	1
   114                              <1> 	.bSectorNumber:
   115 00000003 <res 00000001>      <1> 	.bLbaLow				resb	1	; LBA 7...0
   116                              <1> 
   117                              <1> 	.wCylinder:
   118                              <1> 	.wLbaMiddleAndHigh:
   119 00000004 <res 00000001>      <1> 	.bLbaMiddle				resb	1	; LBA 15...8
   120 00000005 <res 00000001>      <1> 	.bLbaHigh				resb	1	; LBA 23...16
   121                              <1> 
   122 00000006 <res 00000001>      <1> 	.bCommand				resb	1
   123 00000007 <res 00000001>      <1> 	.bDeviceControl			resb	1	; Offset 7 shared with PIOVARS and MEMPIOVARS
   124 00000008 <res 00000001>      <1> 							resb	1	; Used by PIOVARS and MEMPIOVARS
   125                              <1> 
   126                              <1> %ifdef MODULE_EBIOS
   127                              <1> 	; Parameters for 48-bit LBA
   128                              <1> 	.bLbaLowExt				resb	1	; LBA48 31...24
   129                              <1> 	.wLbaMiddleAndHighExt:
   130                              <1> 	.bLbaMiddleExt			resb	1	; LBA48 39...32
   131                              <1> 	.bLbaHighExt			resb	1	; LBA48 47...40
   132                              <1> %endif
   133                              <1> 
   134 00000009 <res 0000001A>      <1> 	.intpack				resb	INTPACK_size
   135                              <1> endstruc
   136                              <1> 
   137                              <1> SIZE_OF_IDEPACK_WITHOUT_INTPACK		EQU	(IDEPACK_size - INTPACK_size)
   138                              <1> 
   139                              <1> 
   140                              <1> %endif ; RAMVARS_INC
    56                                  	%include "BootVars.inc"			; For BOOTVARS struct
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Defines for BOOTVARS struct used by boot menu
     3                              <1> ;					and drive initialization.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ;
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    22                              <1> 
    23                              <1> %ifndef BOOTVARS_INC
    24                              <1> %define BOOTVARS_INC
    25                              <1> 
    26                              <1> ; Default drives
    27                              <1> DEFAULT_FLOPPY_DRIVE_LETTER				EQU	'A'
    28                              <1> DEFAULT_HARD_DRIVE_LETTER				EQU	'C'
    29                              <1> 
    30                              <1> ; Number of times to retry booting before accepting error
    31                              <1> BOOT_READ_RETRY_TIMES		EQU		3
    32                              <1> 
    33                              <1> 
    34                              <1> 
    35                              <1> ; Pre-boot variables. These do not exist after successful boot to OS.
    36                              <1> ; Segment is always 0000h, same as BDA segment
    37                              <1> struc BOOTVARS
    38 00000000 <res 00007C00>      <1> 						resb	7C00h
    39                              <1> 	.rgbAtaInfo:						; 7C00h, ATA Information for drive detection
    40 00007C00 <res 00000200>      <1> 	.rgbBootSect		resb 	512		; 7C00h, Boot sector
    41 00007E00 <res 00000100>      <1> 						resb	256		; Boot Menu stack
    42                              <1> 	.rgbMnuStack:
    43 00007F00 <res 00000004>      <1> 	.dwPostStack		resb	4		; POST stack pointer when entering INT 19h
    44                              <1> 
    45                              <1> %ifdef MODULE_8BIT_IDE
    46 00007F04 <res 00000002>      <1> 	.wNextXTCFportToScan	resb	2	; Needed for XT-CF port autodetection
    47                              <1> %endif
    48                              <1> %ifdef MODULE_HOTKEYS
    49 00007F06 <res 00000006>      <1> 	.hotkeyVars				resb	HOTKEYVARS_size
    50                              <1> %endif
    51                              <1> 	.rgDrvDetectInfo:					; Array containing DRVDETECTINFO structs
    52                              <1> endstruc
    53                              <1> 
    54                              <1> 
    55                              <1> %ifdef MODULE_HOTKEYS
    56                              <1> 
    57                              <1> struc HOTKEYVARS
    58 00000000 <res 00000002>      <1> 	.wTimeWhenDisplayed	resb	2		; System time (ticks) when Hotkey bar was first displayed
    59                              <1> 	.wFddAndHddLetters:
    60 00000002 <res 00000001>      <1> 	.bFddLetter			resb	1		; Floppy Drive letter hotkey (upper case)
    61 00000003 <res 00000001>      <1> 	.bHddLetter			resb	1		; Hard Drive letter hotkey (upper case). Must be after .bFddLetter!
    62 00000004 <res 00000001>      <1> 	.bFlags				resb	1		; Must be just after .bHddLetter!  (dependency in Hotkeybar.asm)
    63 00000005 <res 00000001>      <1> 	.bScancode			resb	1		; Function hotkey scancode, must be just after .bFlags!
    64                              <1> endstruc
    65                              <1> 
    66                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    67                              <1> %if HOTKEYVARS.bFddLetter+1 != HOTKEYVARS.bHddLetter || HOTKEYVARS.bHddLetter+1 != HOTKEYVARS.bFlags || HOTKEYVARS.bFlags+1 != HOTKEYVARS.bScancode
    68                              <1> %error "HOTKEYVARS: bytes need to come in the order .bFddLetter, then .bHddLetter, then .bFlags, then .bScancode"
    69                              <1> %endif
    70                              <1> %endif
    71                              <1> 
    72                              <1> ; Bit defines for HOTKEYVARS.bFlags
    73                              <1> FLG_HOTKEY_HD_FIRST			EQU		(1<<0)	; First try to boot from HDD, then FDD
    74                              <1> 
    75                              <1> %endif ; MODULE_HOTKEYS
    76                              <1> 
    77                              <1> struc DRVDETECTINFO
    78                              <1> 	.StartOfDrvDetectInfo:
    79 00000000 <res 0000001E>      <1> 	.szDrvName				resb	MAX_HARD_DISK_NAME_LENGTH
    80 0000001E <res 00000002>      <1> 							resb	2	; Zero word (ensures string terminates)
    81 00000020 <res 00000002>      <1> 	.wInitErrorFlags		resb	2	; Errors during initialization
    82                              <1> 
    83                              <1> 	; DRVDETECTINFO's size must be an even multiple of DPT's size
    84 00000022 <res 00000008>      <1> 	.EndOfDriveDetectInfo:	resb	LARGEST_DPT_SIZE - (.EndOfDriveDetectInfo % LARGEST_DPT_SIZE)
    85                              <1> endstruc
    86                              <1> 
    87                              <1> ; Boot Menu Information Table. These are generated for all XTIDE Universal
    88                              <1> ; BIOS drives. Available only until boot is successful.
    89                              <1> MAX_HARD_DISK_NAME_LENGTH			EQU		30		; Bytes reserved for drive name
    90                              <1> DPT_DRVDETECTINFO_SIZE_MULTIPLIER	EQU		DRVDETECTINFO_size / LARGEST_DPT_SIZE
    91                              <1> 
    92                              <1> 
    93                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    94                              <1> 
    95                              <1> %if MAX_HARD_DISK_NAME_LENGTH % 2 <> 0
    96                              <1> 	%error "MAX_HARD_DISK_NAME_LENGTH needs to be a multiple of 2, memory is moved with word operations."
    97                              <1> %endif
    98                              <1> 
    99                              <1> %if DRVDETECTINFO_size % LARGEST_DPT_SIZE <> 0
   100                              <1> 	%error "DRVDETECTINFO's size must be an even multiple of DPT's size.  Add or remove padding at the bottom of DRVDETECTINFO to bring the two sizes into alignment.  As DRVDETECTINFO is only used at boot time, with plenty of memory to consume, it is OK to w
   101                              <1> %endif
   102                              <1> 
   103                              <1> %if DRVDETECTINFO.szDrvName <> 0
   104                              <1> 	%error "DRVDETECTINFO.szDrvName is assumed to be the first member of struc DRVDETECTINFO, in BootMenuPrint_RefreshItem"
   105                              <1> %endif
   106                              <1> 
   107                              <1> %endif
   108                              <1> 
   109                              <1> 
   110                              <1> ;--------------------------------------------------------------------
   111                              <1> ; Stores POST stack pointer to BOOTVARS.
   112                              <1> ;
   113                              <1> ; STORE_POST_STACK_POINTER
   114                              <1> ;	Parameters:
   115                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
   116                              <1> ;	Returns:
   117                              <1> ;		Nothing
   118                              <1> ;	Corrupts registers:
   119                              <1> ;		Nothing
   120                              <1> ;--------------------------------------------------------------------
   121                              <1> %macro STORE_POST_STACK_POINTER 0
   122                              <1> 	mov		[es:BOOTVARS.dwPostStack], sp
   123                              <1> 	mov		[es:BOOTVARS.dwPostStack+2], ss
   124                              <1> %endmacro
   125                              <1> 
   126                              <1> 
   127                              <1> ;--------------------------------------------------------------------
   128                              <1> ; Initializes stack for boot menu usage.
   129                              <1> ; POST stack is not large enough when DPTs are stored to 30:0h.
   130                              <1> ;
   131                              <1> ; Note regarding LOAD_BDA_SEGMENT_TO: If you force the use of SP
   132                              <1> ; then you also have to unconditionally enable the CLI/STI pair.
   133                              <1> ; The reason for this is that only some buggy 808x CPU:s need the
   134                              <1> ; CLI/STI instruction pair when changing stacks. Other CPU:s disable
   135                              <1> ; interrupts automatically when SS is modified for the duration of
   136                              <1> ; the immediately following instruction to give time to change SP.
   137                              <1> ;
   138                              <1> ; SWITCH_TO_BOOT_MENU_STACK
   139                              <1> ;	Parameters:
   140                              <1> ;		Nothing
   141                              <1> ;	Returns:
   142                              <1> ;		SS:SP:	Pointer to top of Boot Menu stack
   143                              <1> ;	Corrupts registers:
   144                              <1> ;		Nothing
   145                              <1> ;--------------------------------------------------------------------
   146                              <1> %macro SWITCH_TO_BOOT_MENU_STACK 0
   147                              <1> %ifndef USE_186
   148                              <1> 	cli									; Disable interrupts
   149                              <1> %endif
   150                              <1> 	LOAD_BDA_SEGMENT_TO	ss, sp
   151                              <1> 	mov		sp, BOOTVARS.rgbMnuStack	; Load offset to stack
   152                              <1> %ifndef USE_186
   153                              <1> 	sti									; Enable interrupts
   154                              <1> %endif
   155                              <1> %endmacro
   156                              <1> 
   157                              <1> 
   158                              <1> ;--------------------------------------------------------------------
   159                              <1> ; Restores SS and SP to initial boot loader values.
   160                              <1> ;
   161                              <1> ; Note! Must return with AX=0 and CF preserved.
   162                              <1> ; See Int19hMenu_JumpToBootSector_or_RomBoot.
   163                              <1> ;
   164                              <1> ; SWITCH_BACK_TO_POST_STACK
   165                              <1> ;	Parameters:
   166                              <1> ;		AX:		BDA and Interrupt Vector segment (zero)
   167                              <1> ;	Returns:
   168                              <1> ;		SS:SP:	Ptr to POST stack
   169                              <1> ;	Corrupts registers:
   170                              <1> ;		Nothing (not even FLAGS)
   171                              <1> ;--------------------------------------------------------------------
   172                              <1> %macro SWITCH_BACK_TO_POST_STACK 0
   173                              <1> %ifndef USE_386
   174                              <1> 	cli
   175                              <1> 	mov		ss, ax
   176                              <1> 	mov		sp, [ss:BOOTVARS.dwPostStack]
   177                              <1> 	mov		ss, [ss:BOOTVARS.dwPostStack+2]
   178                              <1> 	sti
   179                              <1> %else
   180                              <1> 	mov		ss, ax
   181                              <1> 	lss		sp, [ss:BOOTVARS.dwPostStack]
   182                              <1> %endif
   183                              <1> %endmacro
   184                              <1> 
   185                              <1> 
   186                              <1> %endif ; BOOTVARS_INC
    57                                  	%include "IdeIO.inc"			; Macros for IDE port I/O
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Macros for normal I/O mapped ATA controllers.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> %ifndef IDE_IO_INC
    21                              <1> %define IDE_IO_INC
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; OUTPUT_AL_TO_IDE_REGISTER
    25                              <1> ; OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER
    26                              <1> ;	Parameters:
    27                              <1> ;		AL:		Byte to output
    28                              <1> ;		%1:		IDE Register				(OUTPUT_AL_TO_IDE_REGISTER)
    29                              <1> ;				IDE Control Block Register	(OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER)
    30                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    31                              <1> ;	Returns:
    32                              <1> ;		Nothing
    33                              <1> ;	Corrupts registers:
    34                              <1> ;		BX, DX
    35                              <1> ;--------------------------------------------------------------------
    36                              <1> %macro OUTPUT_AL_TO_IDE_REGISTER 1
    37                              <1> %ifndef MODULE_8BIT_IDE	; Standard IDE controllers only
    38                              <1> 
    39                              <1> 	%ifnidni %1, dx
    40                              <1> 		mov		dx, %1
    41                              <1> 	%endif
    42                              <1> 	add		dx, [di+DPT.wBasePort]
    43                              <1> 	out		dx, al
    44                              <1> 
    45                              <1> %else	; Register translations required
    46                              <1> 
    47                              <1> 	%ifnidni %1, dl
    48                              <1> 		mov		dl, %1
    49                              <1> 	%endif
    50                              <1> 	call	IdeIO_OutputALtoIdeRegisterInDL
    51                              <1> 
    52                              <1> %endif
    53                              <1> %endmacro
    54                              <1> 
    55                              <1> 
    56                              <1> %macro OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER 1
    57                              <1> %ifndef MODULE_8BIT_IDE	; Standard IDE controllers only
    58                              <1> 
    59                              <1> 	%ifnidni %1, dx
    60                              <1> 		mov		dx, %1
    61                              <1> 	%endif
    62                              <1> 	eMOVZX	bx, BYTE [di+DPT.bIdevarsOffset]
    63                              <1> 	add		dx, [cs:bx+IDEVARS.wControlBlockPort]
    64                              <1> 	out		dx, al
    65                              <1> 
    66                              <1> %else	; Register translations required
    67                              <1> 
    68                              <1> 	%ifnidni %1, dl
    69                              <1> 		mov		dl, %1
    70                              <1> 	%endif
    71                              <1> 	call	IdeIO_OutputALtoIdeControlBlockRegisterInDL
    72                              <1> 
    73                              <1> %endif
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> 
    77                              <1> ;--------------------------------------------------------------------
    78                              <1> ; INPUT_TO_AL_FROM_IDE_REGISTER
    79                              <1> ;	Parameters:
    80                              <1> ;		%1:		IDE Register
    81                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    82                              <1> ;	Returns:
    83                              <1> ;		AL:		Inputted byte
    84                              <1> ;	Corrupts registers:
    85                              <1> ;		BX, DX
    86                              <1> ;--------------------------------------------------------------------
    87                              <1> %macro INPUT_TO_AL_FROM_IDE_REGISTER 1
    88                              <1> %ifndef MODULE_8BIT_IDE	; Standard IDE controllers only
    89                              <1> 
    90                              <1> 	%ifnidni %1, dx
    91                              <1> 		mov		dx, %1
    92                              <1> 	%endif
    93                              <1> 	add		dx, [di+DPT.wBasePort]
    94                              <1> 	in		al, dx
    95                              <1> 
    96                              <1> %else	; Register translations required
    97                              <1> 
    98                              <1> 	%ifnidni %1, dl
    99                              <1> 		mov		dl, %1
   100                              <1> 	%endif
   101                              <1> 		call	IdeIO_InputToALfromIdeRegisterInDL
   102                              <1> 
   103                              <1> %endif
   104                              <1> %endmacro
   105                              <1> 
   106                              <1> 
   107                              <1> %endif ; IDE_IO_INC
    58                                  	%include "DeviceIDE.inc"		; For IDE device equates
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Device specific equates for IDE drives.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> %ifndef DEVICEIDE_INC
    21                              <1> %define DEVICEIDE_INC
    22                              <1> 
    23                              <1> ; Reset delays
    24                              <1> HSR0_RESET_WAIT_US		EQU		6		; Delay must be at least 5 us
    25                              <1> HSR1_RESET_WAIT_US		EQU		2100	; Delay must be at least 2 ms
    26                              <1> 
    27                              <1> ; Polling timeout delays (system timer ticks, 1 tick = 54.9 ms)
    28                              <1> TIMEOUT_DRQ				EQU		255			;   14 s (some CF cards occasionally have long write delays)
    29                              <1> TIMEOUT_SELECT_DRIVE_DURING_DRIVE_DETECTION	EQU	(500/55)	;  500 ms
    30                              <1> TIMEOUT_MOTOR_STARTUP	EQU		(10000/55)	;   10 s
    31                              <1> TIMEOUT_MAXIMUM			EQU		255			; We would actually want 31 seconds here but I don't think there are so slow drives
    32                              <1> 
    33                              <1> %ifdef MODULE_FEATURE_SETS
    34                              <1> 	TIMEOUT_BSY			EQU		TIMEOUT_MOTOR_STARTUP
    35                              <1> 	TIMEOUT_DRDY		EQU		TIMEOUT_MOTOR_STARTUP
    36                              <1> %else
    37                              <1> 	TIMEOUT_BSY			EQU		(2600/55)	; 2600 ms
    38                              <1> 	TIMEOUT_DRDY		EQU		(2600/55)	; 2600 ms
    39                              <1> %endif
    40                              <1> 
    41                              <1> %endif ; DEVICEIDE_INC
    59                                  
    60                                  
    61                                  
    62                                  ; Section containing code
    63                                  SECTION .text
    64                                  
    65                                  ; ROM variables (must start at offset 0)
    66                                  CNT_ROM_BLOCKS		EQU		BIOS_SIZE / 512		; number of 512B blocks, 16 = 8kB BIOS
    67                                  istruc ROMVARS
    68 00000000 55AA                    	at	ROMVARS.wRomSign,	dw	0AA55h			; PC ROM signature
    69 00000002 10                      	at	ROMVARS.bRomSize,	db	CNT_ROM_BLOCKS	; ROM size in 512B blocks
    70 00000003 E9920A                  	at	ROMVARS.rgbJump,	jmp	Initialize_FromMainBiosRomSearch
    71 00000006 5854494445323033        	at	ROMVARS.rgbSign,	db	FLASH_SIGNATURE
    72 0000000E 2D3D58544944452055-     	at	ROMVARS.szTitle,	db	TITLE_STRING
    72 00000017 6E6976657273616C20-
    72 00000020 42494F532028585429-
    72 00000029 3D2D00             
    73 0000002C 0076322E302E30E133-     	at	ROMVARS.szVersion,	db	ROM_VERSION_STRING
    73 00000035 2B2028323032312D30-
    73 0000003E 392D32322900       
    74                                  
    75                                  ;---------------------------;
    76                                  ; AT Build default settings ;
    77                                  ;---------------------------;
    78                                  %ifdef USE_AT
    79                                  	at	ROMVARS.wFlags,			dw	FLG_ROMVARS_FULLMODE | MASK_ROMVARS_INCLUDED_MODULES
    80                                  	at	ROMVARS.wDisplayMode,	dw	DEFAULT_TEXT_MODE
    81                                  %ifdef MODULE_BOOT_MENU
    82                                  	at	ROMVARS.wBootTimeout,	dw	BOOT_MENU_DEFAULT_TIMEOUT
    83                                  %endif
    84                                  	at	ROMVARS.bIdeCnt,		db	2						; Number of supported controllers
    85                                  	at	ROMVARS.bBootDrv,		db	80h						; Boot Menu default drive
    86                                  	at	ROMVARS.bMinFddCnt, 	db	0						; Do not force minimum number of floppy drives
    87                                  	at	ROMVARS.bStealSize,		db	1						; Steal 1kB from base memory
    88                                  	at	ROMVARS.bIdleTimeout,	db	0						; Standby timer disabled by default
    89                                  
    90                                  	at	ROMVARS.ideVars0+IDEVARS.wBasePort,			dw	DEVICE_ATA_PRIMARY_PORT 		; Controller Command Block base port
    91                                  	at	ROMVARS.ideVars0+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_PRIMARY_PORTCTRL 	; Controller Control Block base port
    92                                  	at	ROMVARS.ideVars0+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
    93                                  	at	ROMVARS.ideVars0+IDEVARS.bIRQ,				db	14
    94                                  	at	ROMVARS.ideVars0+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
    95                                  	at	ROMVARS.ideVars0+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
    96                                  
    97                                  	at	ROMVARS.ideVars1+IDEVARS.wBasePort,			dw	DEVICE_ATA_SECONDARY_PORT
    98                                  	at	ROMVARS.ideVars1+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_SECONDARY_PORTCTRL
    99                                  	at	ROMVARS.ideVars1+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
   100                                  	at	ROMVARS.ideVars1+IDEVARS.bIRQ,				db	15
   101                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   102                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   103                                  
   104                                  	at	ROMVARS.ideVars2+IDEVARS.wBasePort,			dw	DEVICE_ATA_TERTIARY_PORT
   105                                  	at	ROMVARS.ideVars2+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_TERTIARY_PORTCTRL
   106                                  	at	ROMVARS.ideVars2+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
   107                                  	at	ROMVARS.ideVars2+IDEVARS.bIRQ,				db	0
   108                                  	at	ROMVARS.ideVars2+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   109                                  	at	ROMVARS.ideVars2+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   110                                  
   111                                  	at	ROMVARS.ideVars3+IDEVARS.wBasePort,			dw	DEVICE_ATA_QUATERNARY_PORT
   112                                  	at	ROMVARS.ideVars3+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_QUATERNARY_PORTCTRL
   113                                  	at	ROMVARS.ideVars3+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
   114                                  	at	ROMVARS.ideVars3+IDEVARS.bIRQ,				db	0
   115                                  	at	ROMVARS.ideVars3+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   116                                  	at	ROMVARS.ideVars3+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   117                                  
   118                                  %ifdef MODULE_SERIAL
   119                                  	at	ROMVARS.ideVarsSerialAuto+IDEVARS.bDevice,		db	DEVICE_SERIAL_PORT
   120                                  %endif
   121                                  %else
   122                                  ;-----------------------------------;
   123                                  ; XT and XT+ Build default settings ;
   124                                  ;-----------------------------------;
   125 00000044 00<rept>C08A            	at	ROMVARS.wFlags,			dw	MASK_ROMVARS_INCLUDED_MODULES
   126 00000048 0400                    	at	ROMVARS.wDisplayMode,	dw	DEFAULT_TEXT_MODE
   127                                  %ifdef MODULE_BOOT_MENU
   128 0000004A 1C02                    	at	ROMVARS.wBootTimeout,	dw	BOOT_MENU_DEFAULT_TIMEOUT
   129                                  %endif
   130                                  %ifdef MODULE_8BIT_IDE_ADVANCED
   131 0000004C 02                      	at	ROMVARS.bIdeCnt,		db	2						; Number of supported controllers
   132                                  %else
   133                                  	at  ROMVARS.bIdeCnt,		db	1
   134                                  %endif
   135 0000004D 80                      	at	ROMVARS.bBootDrv,		db	80h						; Boot Menu default drive
   136 0000004E 00                      	at	ROMVARS.bMinFddCnt, 	db	0						; Do not force minimum number of floppy drives
   137 0000004F 01                      	at	ROMVARS.bStealSize,		db	1						; Steal 1kB from base memory in full mode
   138 00000050 00                      	at	ROMVARS.bIdleTimeout,	db	0						; Standby timer disabled by default
   139                                  
   140 00000051 0003                    	at	ROMVARS.ideVars0+IDEVARS.wBasePort,			dw	DEVICE_XTIDE_DEFAULT_PORT			; Controller Command Block base port
   141 00000053 0803                    	at	ROMVARS.ideVars0+IDEVARS.wControlBlockPort,	dw	DEVICE_XTIDE_DEFAULT_PORTCTRL		; Controller Control Block base port
   142 00000055 0A                      	at	ROMVARS.ideVars0+IDEVARS.bDevice,			db	DEVICE_8BIT_XTCF_PIO8
   143 00000056 001D                    	at	ROMVARS.ideVars0+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   144 00000058 00<rept>1D              	at	ROMVARS.ideVars0+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   145                                  
   146                                  %ifdef MODULE_8BIT_IDE_ADVANCED
   147 0000005E 00<rept>00              	at	ROMVARS.ideVars1+IDEVARS.bXTCFcontrolRegister,	db	XTCF_8BIT_PIO_MODE
   148 00000066 000A                    	at	ROMVARS.ideVars1+IDEVARS.bDevice,				db	DEVICE_8BIT_XTCF_PIO8
   149 00000068 001D                    	at	ROMVARS.ideVars1+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   150 0000006A 00<rept>1D              	at	ROMVARS.ideVars1+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   151                                  %else
   152                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   153                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   154                                  %endif
   155                                  
   156 00000070 00<rept>1D              	at	ROMVARS.ideVars2+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   157 0000007C 00<rept>1D              	at	ROMVARS.ideVars2+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   158                                  
   159 00000082 00<rept>1D              	at	ROMVARS.ideVars3+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   160 0000008E 00<rept>1D              	at	ROMVARS.ideVars3+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
   161                                  
   162                                  %ifdef MODULE_SERIAL
   163                                  	at	ROMVARS.ideVarsSerialAuto+IDEVARS.bDevice,		db	DEVICE_SERIAL_PORT
   164                                  %endif
   165                                  %endif
   166 00000094 00<rept>                iend
   167                                  
   168                                  	; Strings are first to avoid them moving unnecessarily when code is turned on and off with %ifdef's
   169                                  	; since some groups of strings need to be on the same 256-byte page.
   170                                  	;
   171                                  %ifdef MODULE_STRINGS_COMPRESSED
   172                                  	%define STRINGSCOMPRESSED_STRINGS
   173                                  	%include "StringsCompressed.asm"
     1                              <1> ;;;======================================================================
     2                              <1> ;;;
     3                              <1> ;;; This file is generated by StringsCompress.pl from source in Strings.asm
     4                              <1> ;;; DO NOT EDIT DIRECTLY - See the makefile for how to rebuild this file.
     5                              <1> ;;; This file only needs to be rebuilt if Strings.asm is changed.
     6                              <1> ;;;
     7                              <1> ;;;======================================================================
     8                              <1> 
     9                              <1> %ifdef STRINGSCOMPRESSED_STRINGS
    10                              <1> 
    11                              <1> ; Project name	:	XTIDE Universal BIOS
    12                              <1> ; Description	:	Strings and equates for BIOS messages.
    13                              <1> 
    14                              <1> ;
    15                              <1> ; XTIDE Universal BIOS and Associated Tools
    16                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
    17                              <1> ;
    18                              <1> ; This program is free software; you can redistribute it and/or modify
    19                              <1> ; it under the terms of the GNU General Public License as published by
    20                              <1> ; the Free Software Foundation; either version 2 of the License, or
    21                              <1> ; (at your option) any later version.
    22                              <1> ;
    23                              <1> ; This program is distributed in the hope that it will be useful,
    24                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    25                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    26                              <1> ; GNU General Public License for more details.
    27                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    28                              <1> ;
    29                              <1> 
    30                              <1> %ifdef MODULE_STRINGS_COMPRESSED_PRECOMPRESS
    31                              <1> %include "Display.inc"
    32                              <1> %endif
    33                              <1> 
    34                              <1> ; Section containing code
    35                              <1> SECTION .text
    36                              <1> 
    37                              <1> ; The following strings are used by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
    38                              <1> ; To support an optimization in that code, these strings must start on the same 256 byte page,
    39                              <1> ; which is checked at assembly time below.
    40                              <1> ;
    41                              <1> g_szDetectStart:
    42                              <1> g_szDetectMaster:		; db	"Master",NULL
    43                              <1>                  		; db	 4dh,  61h,  73h,  74h,  65h,  72h,  00h    ; uncompressed
    44 00000099 5367797A6BB8        <1>                  		  db	 53h,  67h,  79h,  7ah,  6bh, 0b8h          ; compressed
    45                              <1> 
    46                              <1> g_szDetectSlave:		; db	"Slave ",NULL
    47                              <1>                 		; db	 53h,  6ch,  61h,  76h,  65h,  20h,  00h    ; uncompressed
    48 0000009F 5972677C6B00        <1>                 		  db	 59h,  72h,  67h,  7ch,  6bh,  00h          ; compressed
    49                              <1> 
    50                              <1> g_szDetectOuter:		; db	"%s at %s: ",NULL
    51                              <1>                 		; db	 25h,  73h,  20h,  61h,  74h,  20h,  25h,  73h,  3ah,  20h,  00h    ; uncompressed
    52 000000A5 3D2067FA3D4000      <1>                 		  db	 3dh,  20h,  67h, 0fah,  3dh,  40h,  00h                            ; compressed
    53                              <1> 
    54                              <1> %ifdef MODULE_SERIAL
    55                              <1> g_szDetectCOM:			; db	"COM%c%s",NULL
    56                              <1>               			; db	 43h,  4fh,  4dh,  25h,  63h,  25h,  73h,  00h    ; uncompressed
    57                              <1>               			  db	 49h,  55h,  53h,  3ch,  1dh                      ; compressed
    58                              <1> 
    59                              <1> g_szDetectCOMAuto:		; db	" Detect",NULL
    60                              <1>                   		; db	 20h,  44h,  65h,  74h,  65h,  63h,  74h,  00h    ; uncompressed
    61                              <1>                   		  db	 20h,  4ah,  6bh,  7ah,  6bh,  69h, 0bah          ; compressed
    62                              <1> 
    63                              <1> g_szDetectCOMSmall:		; db	"/%u%u00",NULL					; IDE Master at COM1/9600:
    64                              <1>                    		; db	 2fh,  25h,  75h,  25h,  75h,  30h,  30h,  00h    ; uncompressed
    65                              <1>                    		  db	 2ah,  35h,  35h,  33h,  13h                      ; compressed
    66                              <1> 
    67                              <1> g_szDetectCOMLarge:		; db	"/%u.%uK",NULL					; IDE Master at COM1/19.2K:
    68                              <1>                    		; db	 2fh,  25h,  75h,  2eh,  25h,  75h,  4bh,  00h    ; uncompressed
    69                              <1>                    		  db	 2ah,  35h,  29h,  35h,  91h                      ; compressed
    70                              <1> 
    71                              <1> %endif
    72                              <1> g_szDetectEnd:
    73                              <1> g_szDetectPort:			; db	"%x",NULL						; IDE Master at 1F0h:
    74                              <1>                			; db	 25h,  78h,  00h    ; uncompressed
    75 000000AC 17                  <1>                			  db	 17h                ; compressed
    76                              <1> 
    77                              <1> 
    78                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    79                              <1> %if ((g_szDetectEnd-$$) & 0xff00) <> ((g_szDetectStart-$$) & 0xff00)
    80                              <1> %error "g_szDetect* strings must start on the same 256 byte page, required by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP.  Please move this block up or down within Strings.asm"
    81                              <1> %endif
    82                              <1> %endif
    83                              <1> 
    84                              <1> 
    85                              <1> ; POST drive detection strings
    86                              <1> g_szDashForZero:	; db	"- ",NULL	; Required by Display Library
    87                              <1>                 	; db	 2dh,  20h,  00h    ; uncompressed
    88 000000AD 2800                <1>                 	  db	 28h,  00h          ; compressed
    89                              <1> 
    90                              <1> g_szRomAt:			; db	LF,CR
    91                              <1>           			; db	 0ah,  0dh    ; uncompressed
    92 000000AF 39                  <1>           			  db	 39h          ; compressed
    93                              <1> 
    94                              <1> 	; db	"%s @ %x",LF,CR						; -=XTIDE ... =- @ Segment
    95                              <1> 	; db	 25h,  73h,  20h,  40h,  20h,  25h,  78h,  0ah,  0dh    ; uncompressed
    96 000000B0 3D20C63739          <1> 	  db	 3dh,  20h, 0c6h,  37h,  39h                            ; compressed
    97                              <1> 
    98                              <1> 	; db	"%s",LF,CR							; version string
    99                              <1> 	; db	 25h,  73h,  0ah,  0dh    ; uncompressed
   100 000000B5 3D39                <1> 	  db	 3dh,  39h                ; compressed
   101                              <1> 
   102                              <1> 	; db	"Released under GNU GPL v2",LF,CR
   103                              <1> 	; db	 52h,  65h,  6ch,  65h,  61h,  73h,  65h,  64h,  20h,  75h,  6eh,  64h,  65h,  72h,  20h,  47h,  4eh,  55h,  20h,  47h,  50h,  4ch,  20h,  76h,  32h,  0ah,  0dh    ; uncompressed
   104 000000B7 586B726B67796BEA7B- <1> 	  db	 58h,  6bh,  72h,  6bh,  67h,  79h,  6bh, 0eah,  7bh,  74h,  6ah,  6bh, 0f8h,  4dh,  54h, 0dbh,  4dh,  56h, 0d2h,  7ch,  2ch,  39h                                  ; compressed
   104 000000C0 746A6BF84D54DB4D56- <1>
   104 000000C9 D27C2C39            <1>
   105                              <1> 
   106                              <1> 	; db	LF,CR,NULL
   107                              <1> 	; db	 0ah,  0dh,  00h    ; uncompressed
   108 000000CD 19                  <1> 	  db	 19h                ; compressed
   109                              <1> 
   110                              <1> %ifdef MODULE_BOOT_MENU
   111                              <1> g_szBootMenuTitle:	; db	"%s%c",LF,CR						; -=XTIDE ... =- and null (eaten)
   112                              <1>                   	; db	 25h,  73h,  25h,  63h,  0ah,  0dh    ; uncompressed
   113 000000CE 3D3C39              <1>                   	  db	 3dh,  3ch,  39h                      ; compressed
   114                              <1> 
   115                              <1> 	; db	"%s",NULL							; version string
   116                              <1> 	; db	 25h,  73h,  00h    ; uncompressed
   117 000000D1 1D                  <1> 	  db	 1dh                ; compressed
   118                              <1> 
   119                              <1> %endif
   120                              <1> g_szDriveName:		; db	"%z",LF,CR,NULL
   121                              <1>               		; db	 25h,  7ah,  0ah,  0dh,  00h    ; uncompressed
   122 000000D2 3E19                <1>               		  db	 3eh,  19h                      ; compressed
   123                              <1> 
   124                              <1> 
   125                              <1> 
   126                              <1> ; Boot loader strings
   127                              <1> g_szTryToBoot:			; db	"Booting %c",ANGLE_QUOTE_RIGHT,"%c",LF,CR,NULL
   128                              <1>               			; db	 42h,  6fh,  6fh,  74h,  69h,  6eh,  67h,  20h,  25h,  63h, 0afh,  25h,  63h,  0ah,  0dh,  00h    ; uncompressed
   129 000000D4 4875757A6F74ED3C24- <1>               			  db	 48h,  75h,  75h,  7ah,  6fh,  74h, 0edh,  3ch,  24h,  3ch,  19h                                  ; compressed
   129 000000DD 3C19                <1>
   130                              <1> 
   131                              <1> g_szBootSectorNotFound:	; db	"Boot sector " 			; String fall through...
   132                              <1>                        	; db	 42h,  6fh,  6fh,  74h,  20h,  73h,  65h,  63h,  74h,  6fh,  72h,  20h    ; uncompressed
   133 000000DF 487575FA796B697A75- <1>                        	  db	 48h,  75h,  75h, 0fah,  79h,  6bh,  69h,  7ah,  75h, 0f8h                ; compressed
   133 000000E8 F8                  <1>
   134                              <1> 
   135                              <1> g_szNotFound:			; db	"not found",LF,CR,NULL
   136                              <1>              			; db	 6eh,  6fh,  74h,  20h,  66h,  6fh,  75h,  6eh,  64h,  0ah,  0dh,  00h    ; uncompressed
   137 000000E9 7475FA6C757B746A19  <1>              			  db	 74h,  75h, 0fah,  6ch,  75h,  7bh,  74h,  6ah,  19h                      ; compressed
   138                              <1> 
   139                              <1> g_szReadError:			; db	"Error %x!",LF,CR,NULL
   140                              <1>               			; db	 45h,  72h,  72h,  6fh,  72h,  20h,  25h,  78h,  21h,  0ah,  0dh,  00h    ; uncompressed
   141 000000F2 4B787875F8372519    <1>               			  db	 4bh,  78h,  78h,  75h, 0f8h,  37h,  25h,  19h                            ; compressed
   142                              <1> 
   143                              <1> 
   144                              <1> 
   145                              <1> %ifdef MODULE_HOTKEYS
   146                              <1> ; Hotkey Bar strings
   147                              <1> g_szFDD:				; db	"FDD [%c]",NULL			; "FDD [A]"
   148                              <1>         				; db	 46h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
   149 000000FA 4C4ACA613CA3        <1>         				  db	 4ch,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
   150                              <1> 
   151                              <1> g_szHDD:				; db	"HDD [%c]",NULL			; "HDD [C]"
   152                              <1>         				; db	 48h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
   153 00000100 4E4ACA613CA3        <1>         				  db	 4eh,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
   154                              <1> 
   155                              <1> %ifdef MODULE_BOOT_MENU
   156                              <1> g_szBootMenu:			; db	"BootMnu%c",NULL		; "BootMnu", location of %c doesn't matter
   157                              <1>              			; db	 42h,  6fh,  6fh,  74h,  4dh,  6eh,  75h,  25h,  63h,  00h    ; uncompressed
   158 00000106 4875757A53747B1C    <1>              			  db	 48h,  75h,  75h,  7ah,  53h,  74h,  7bh,  1ch                ; compressed
   159                              <1> 
   160                              <1> %endif ; MODULE_BOOT_MENU
   161                              <1> g_szHotkey:				; db	"%A%c%c%A%s%A ",NULL	; "CHDD [A] ", "F2BootMnu " or "F8RomBoot "
   162                              <1>            				; db	 25h,  41h,  25h,  63h,  25h,  63h,  25h,  41h,  25h,  73h,  25h,  41h,  20h,  00h    ; uncompressed
   163 0000010E 3B3C3C3B3D3B00      <1>            				  db	 3bh,  3ch,  3ch,  3bh,  3dh,  3bh,  00h                                              ; compressed
   164                              <1> 
   165                              <1> %ifdef MODULE_SERIAL
   166                              <1> g_szHotComDetect:		; db	"ComDtct%c",NULL		; "ComDtct", location of %c doesn't matter
   167                              <1>                  		; db	 43h,  6fh,  6dh,  44h,  74h,  63h,  74h,  25h,  63h,  00h    ; uncompressed
   168                              <1>                  		  db	 49h,  75h,  73h,  4ah,  7ah,  69h,  7ah,  1ch                ; compressed
   169                              <1> 
   170                              <1> %endif ; MODULE_SERIAL
   171                              <1> %endif ; MODULE_HOTKEYS
   172                              <1> 
   173                              <1> %ifdef MODULE_BOOT_MENU
   174                              <1> g_szRomBootDash:		; db	" -  "					; String fall through to g_szRomBoot
   175                              <1>                 		; db	 20h,  2dh,  20h,  20h    ; uncompressed
   176 00000115 20282020            <1>                 		  db	 20h,  28h,  20h,  20h    ; compressed
   177                              <1> 
   178                              <1> %endif
   179                              <1> %ifdef MODULE_HOTKEYS OR MODULE_BOOT_MENU
   180                              <1> g_szRomBoot:			; db	"Rom%cBoot",NULL		; "RomBoot" or "Rom Boot"
   181                              <1>             			; db	 52h,  6fh,  6dh,  25h,  63h,  42h,  6fh,  6fh,  74h,  00h    ; uncompressed
   182 00000119 5875733C487575BA    <1>             			  db	 58h,  75h,  73h,  3ch,  48h,  75h,  75h, 0bah                ; compressed
   183                              <1> 
   184                              <1> %endif
   185                              <1> 
   186                              <1> 
   187                              <1> %ifdef MODULE_BOOT_MENU
   188                              <1> ; Boot Menu Floppy Disk strings
   189                              <1> ;
   190                              <1> ; The following strings are used by BootMenuPrint_RefreshInformation
   191                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
   192                              <1> ; which is checked at assembly time below.
   193                              <1> ;
   194                              <1> g_szFddStart:
   195                              <1> g_szFddUnknown:		; db	"Unknown",NULL
   196                              <1>                		; db	 55h,  6eh,  6bh,  6eh,  6fh,  77h,  6eh,  00h    ; uncompressed
   197 00000121 5B747174757DB4      <1>                		  db	 5bh,  74h,  71h,  74h,  75h,  7dh, 0b4h          ; compressed
   198                              <1> 
   199                              <1> g_szFddSizeOr:		; db	"5",ONE_QUARTER,QUOTATION_MARK," or 3",ONE_HALF,QUOTATION_MARK," DD",NULL
   200                              <1>               		; db	 35h, 0ach,  22h,  20h,  6fh,  72h,  20h,  33h, 0abh,  22h,  20h,  44h,  44h,  00h    ; uncompressed
   201 00000128 2E21262075F82D2226- <1>               		  db	 2eh,  21h,  26h,  20h,  75h, 0f8h,  2dh,  22h,  26h,  20h,  4ah,  8ah                ; compressed
   201 00000131 204A8A              <1>
   202                              <1> 
   203                              <1> g_szFddSize:		; db	"%s",QUOTATION_MARK,", %u kiB",NULL	; 3", 1440 kiB
   204                              <1>             		; db	 25h,  73h,  22h,  2ch,  20h,  25h,  75h,  20h,  6bh,  69h,  42h,  00h    ; uncompressed
   205 00000134 3D2627203520716F88  <1>             		  db	 3dh,  26h,  27h,  20h,  35h,  20h,  71h,  6fh,  88h                      ; compressed
   206                              <1> 
   207                              <1> g_szFddThreeHalf:	; db	"3",ONE_HALF,NULL
   208                              <1>                  	; db	 33h, 0abh,  00h    ; uncompressed
   209 0000013D 2D02                <1>                  	  db	 2dh,  02h          ; compressed
   210                              <1> 
   211                              <1> g_szFddEnd:
   212                              <1> g_szFddFiveQuarter:	; db	"5",ONE_QUARTER,NULL
   213                              <1>                    	; db	 35h, 0ach,  00h    ; uncompressed
   214 0000013F 2E01                <1>                    	  db	 2eh,  01h          ; compressed
   215                              <1> 
   216                              <1> 
   217                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   218                              <1> %if ((g_szFddStart-$$) & 0xff00) <> ((g_szFddEnd-$$) & 0xff00)
   219                              <1> %error "g_szFdd* strings must start on the same 256 byte page, required by the BootMenuPrint_RefreshInformation routines for floppy drives.  Please move this block up or down within Strings.asm"
   220                              <1> %endif
   221                              <1> %endif
   222                              <1> 
   223                              <1> 
   224                              <1> g_szAddressingModes:
   225                              <1> g_szNORMAL:		; db	"NORMAL",NULL
   226                              <1>            		; db	 4eh,  4fh,  52h,  4dh,  41h,  4ch,  00h    ; uncompressed
   227 00000141 545558534792        <1>            		  db	 54h,  55h,  58h,  53h,  47h,  92h          ; compressed
   228                              <1> 
   229                              <1> g_szLARGE:		; db	"LARGE ",NULL
   230                              <1>           		; db	 4ch,  41h,  52h,  47h,  45h,  20h,  00h    ; uncompressed
   231 00000147 5247584D4B00        <1>           		  db	 52h,  47h,  58h,  4dh,  4bh,  00h          ; compressed
   232                              <1> 
   233                              <1> g_szLBA:		; db	"LBA   ",NULL
   234                              <1>         		; db	 4ch,  42h,  41h,  20h,  20h,  20h,  00h    ; uncompressed
   235 0000014D 5248C72000          <1>         		  db	 52h,  48h, 0c7h,  20h,  00h                ; compressed
   236                              <1> 
   237                              <1> g_szAddressingModes_Displacement equ (g_szLARGE - g_szAddressingModes)
   238                              <1> ;
   239                              <1> ; Ensure that addressing modes are correctly spaced in memory
   240                              <1> ;
   241                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   242                              <1> %if g_szNORMAL <> g_szAddressingModes
   243                              <1> %error "g_szAddressingModes Displacement Incorrect 1"
   244                              <1> %endif
   245                              <1> %if g_szLARGE <> g_szNORMAL + g_szAddressingModes_Displacement
   246                              <1> %error "g_szAddressingModes Displacement Incorrect 2"
   247                              <1> %endif
   248                              <1> %if g_szLBA <> g_szLARGE + g_szAddressingModes_Displacement
   249                              <1> %error "g_szAddressingModes Displacement Incorrect 3"
   250                              <1> %endif
   251                              <1> %endif
   252                              <1> 
   253                              <1> 
   254                              <1> g_szDeviceTypeValues:
   255                              <1> g_szDeviceTypeValues_16bit:		; db	" 16",NULL
   256                              <1>                            		; db	 20h,  31h,  36h,  00h    ; uncompressed
   257 00000152 202B0F              <1>                            		  db	 20h,  2bh,  0fh          ; compressed
   258                              <1> 
   259                              <1> g_szDeviceTypeValues_32bit:		; db	" 32",NULL
   260                              <1>                            		; db	 20h,  33h,  32h,  00h    ; uncompressed
   261 00000155 202D0C              <1>                            		  db	 20h,  2dh,  0ch          ; compressed
   262                              <1> 
   263                              <1> g_szDeviceTypeValues_8bit:		; db	"  8",NULL
   264                              <1>                           		; db	 20h,  20h,  38h,  00h    ; uncompressed
   265 00000158 202010              <1>                           		  db	 20h,  20h,  10h          ; compressed
   266                              <1> 
   267                              <1> g_szDeviceTypeValues_XTIDEr1:	; db	"D8 ",NULL	; Dual 8-bit
   268                              <1>                              	; db	 44h,  38h,  20h,  00h    ; uncompressed
   269 0000015B 4A3000              <1>                              	  db	 4ah,  30h,  00h          ; compressed
   270                              <1> 
   271                              <1> g_szDeviceTypeValues_XTIDEr2:	; db	"X8 ",NULL	; A0<->A3 swapped 8-bit
   272                              <1>                              	; db	 58h,  38h,  20h,  00h    ; uncompressed
   273 0000015E 5E3000              <1>                              	  db	 5eh,  30h,  00h          ; compressed
   274                              <1> 
   275                              <1> g_szDeviceTypeValues_XTCFpio8:	; db	"T8 ",NULL	; True 8-bit
   276                              <1>                               	; db	 54h,  38h,  20h,  00h    ; uncompressed
   277 00000161 5A3000              <1>                               	  db	 5ah,  30h,  00h          ; compressed
   278                              <1> 
   279                              <1> g_szDeviceTypeValues_XTCFdma:	; db	"8MA",NULL	; DMA 8-bit
   280                              <1>                              	; db	 38h,  4dh,  41h,  00h    ; uncompressed
   281 00000164 305387              <1>                              	  db	 30h,  53h,  87h          ; compressed
   282                              <1> 
   283                              <1> g_szDeviceTypeValues_XTCFmem:	; db	"M8 ",NULL	; Memory Mapped 8-bit
   284                              <1>                              	; db	 4dh,  38h,  20h,  00h    ; uncompressed
   285 00000167 533000              <1>                              	  db	 53h,  30h,  00h          ; compressed
   286                              <1> 
   287                              <1> g_szDeviceTypeValues_JrIde:		; db	"M8 ",NULL
   288                              <1>                            		; db	 4dh,  38h,  20h,  00h    ; uncompressed
   289 0000016A 533000              <1>                            		  db	 53h,  30h,  00h          ; compressed
   290                              <1> 
   291                              <1> g_szDeviceTypeValues_Serial:	; db	"SER",NULL
   292                              <1>                             	; db	 53h,  45h,  52h,  00h    ; uncompressed
   293 0000016D 594B98              <1>                             	  db	 59h,  4bh,  98h          ; compressed
   294                              <1> 
   295                              <1> 
   296                              <1> g_szDeviceTypeValues_Displacement equ (g_szDeviceTypeValues_32bit - g_szDeviceTypeValues)
   297                              <1> ;
   298                              <1> ; Ensure that device type strings are correctly spaced in memory
   299                              <1> ;
   300                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   301                              <1> %if g_szDeviceTypeValues_16bit <> g_szDeviceTypeValues
   302                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 1"
   303                              <1> %endif
   304                              <1> %if g_szDeviceTypeValues_32bit <> g_szDeviceTypeValues_16bit + g_szDeviceTypeValues_Displacement
   305                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
   306                              <1> %endif
   307                              <1> %if g_szDeviceTypeValues_8bit <> g_szDeviceTypeValues_32bit + g_szDeviceTypeValues_Displacement
   308                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
   309                              <1> %endif
   310                              <1> %if g_szDeviceTypeValues_XTIDEr1 <> g_szDeviceTypeValues_8bit + g_szDeviceTypeValues_Displacement
   311                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 3"
   312                              <1> %endif
   313                              <1> %if g_szDeviceTypeValues_XTIDEr2 <> g_szDeviceTypeValues_XTIDEr1 + g_szDeviceTypeValues_Displacement
   314                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 4"
   315                              <1> %endif
   316                              <1> %if g_szDeviceTypeValues_XTCFpio8 <> g_szDeviceTypeValues_XTIDEr2 + g_szDeviceTypeValues_Displacement
   317                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 5"
   318                              <1> %endif
   319                              <1> %if g_szDeviceTypeValues_XTCFdma <> g_szDeviceTypeValues_XTCFpio8 + g_szDeviceTypeValues_Displacement
   320                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 6"
   321                              <1> %endif
   322                              <1> %if g_szDeviceTypeValues_XTCFmem <> g_szDeviceTypeValues_XTCFdma + g_szDeviceTypeValues_Displacement
   323                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 7"
   324                              <1> %endif
   325                              <1> %if g_szDeviceTypeValues_JrIde <> g_szDeviceTypeValues_XTCFmem + g_szDeviceTypeValues_Displacement
   326                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 8"
   327                              <1> %endif
   328                              <1> %if g_szDeviceTypeValues_Serial <> g_szDeviceTypeValues_JrIde + g_szDeviceTypeValues_Displacement
   329                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 9"
   330                              <1> %endif
   331                              <1> %endif
   332                              <1> 
   333                              <1> 
   334                              <1> g_szSelectionTimeout:	; db	DOUBLE_BOTTOM_LEFT_CORNER,DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL,"%ASelection in %2-u s",NULL
   335                              <1>                      	; db	0c8h, 0b5h,  25h,  41h,  53h,  65h,  6ch,  65h,  63h,  74h,  69h,  6fh,  6eh,  20h,  69h,  6eh,  20h,  25h,  32h,  2dh,  75h,  20h,  73h,  00h    ; uncompressed
   336 00000170 31323B596B726B697A- <1>                      	  db	 31h,  32h,  3bh,  59h,  6bh,  72h,  6bh,  69h,  7ah,  6fh,  75h, 0f4h,  6fh, 0f4h,  3ah,  20h, 0b9h                                              ; compressed
   336 00000179 6F75F46FF43A20B9    <1>
   337                              <1> 
   338                              <1> 
   339                              <1> 
   340                              <1> ; Boot Menu information strings
   341                              <1> g_szCapacity:			; db	"Capacity : %s",NULL
   342                              <1>              			; db	 43h,  61h,  70h,  61h,  63h,  69h,  74h,  79h,  20h,  3ah,  20h,  25h,  73h,  00h    ; uncompressed
   343 00000181 49677667696F7AFFC0- <1>              			  db	 49h,  67h,  76h,  67h,  69h,  6fh,  7ah, 0ffh, 0c0h,  1dh                            ; compressed
   343 0000018A 1D                  <1>
   344                              <1> 
   345                              <1> g_szCapacityNum:		; db	"%5-u.%u %ciB",NULL
   346                              <1>                 		; db	 25h,  35h,  2dh,  75h,  2eh,  25h,  75h,  20h,  25h,  63h,  69h,  42h,  00h    ; uncompressed
   347 0000018B 362935203C6F88      <1>                 		  db	 36h,  29h,  35h,  20h,  3ch,  6fh,  88h                                        ; compressed
   348                              <1> 
   349                              <1> g_szInformation:		; db	"%s",LF,CR
   350                              <1>                 		; db	 25h,  73h,  0ah,  0dh    ; uncompressed
   351 00000192 3D39                <1>                 		  db	 3dh,  39h                ; compressed
   352                              <1> 
   353                              <1> 	; db	"Addr. ",SINGLE_VERTICAL,"Block",SINGLE_VERTICAL,"Bus",SINGLE_VERTICAL,"IRQ",SINGLE_VERTICAL,"Reset",LF,CR
   354                              <1> 	; db	 41h,  64h,  64h,  72h,  2eh,  20h, 0b3h,  42h,  6ch,  6fh,  63h,  6bh, 0b3h,  42h,  75h,  73h, 0b3h,  49h,  52h,  51h, 0b3h,  52h,  65h,  73h,  65h,  74h,  0ah,  0dh    ; uncompressed
   355 00000194 476A6A782920234872- <1> 	  db	 47h,  6ah,  6ah,  78h,  29h,  20h,  23h,  48h,  72h,  75h,  69h,  71h,  23h,  48h,  7bh,  79h,  23h,  4fh,  58h,  57h,  23h,  58h,  6bh,  79h,  6bh,  7ah,  39h          ; compressed
   355 0000019D 75697123487B79234F- <1>
   355 000001A6 585723586B796B7A39  <1>
   356                              <1> 
   357                              <1> 	; db	"%s",SINGLE_VERTICAL,"%5-u",SINGLE_VERTICAL,"%s",SINGLE_VERTICAL," %2-I",SINGLE_VERTICAL,"%5-x",NULL
   358                              <1> 	; db	 25h,  73h, 0b3h,  25h,  35h,  2dh,  75h, 0b3h,  25h,  73h, 0b3h,  20h,  25h,  32h,  2dh,  49h, 0b3h,  25h,  35h,  2dh,  78h,  00h    ; uncompressed
   359 000001AF 3D2336233D23203423- <1> 	  db	 3dh,  23h,  36h,  23h,  3dh,  23h,  20h,  34h,  23h,  18h                                                                            ; compressed
   359 000001B8 18                  <1>
   360                              <1> 
   361                              <1> 
   362                              <1> 
   363                              <1> ; Boot Menu menuitem strings
   364                              <1> ;
   365                              <1> ; The following strings are used by BootMenuPrint_* routines.
   366                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
   367                              <1> ; which is checked at assembly time below.
   368                              <1> ;
   369                              <1> g_szDriveNumSpace:		; db	" "							; leading space, used if drive number is less than 0fh
   370                              <1>                   		; db	 20h    ; uncompressed
   371 000001B9 20                  <1>                   		  db	 20h    ; compressed
   372                              <1> 
   373                              <1> ; must come immediately before g_szDriveNum!
   374                              <1> g_szBootMenuPrintStart:
   375                              <1> g_szDriveNum:			; db	"%x %s",NULL
   376                              <1>              			; db	 25h,  78h,  20h,  25h,  73h,  00h    ; uncompressed
   377 000001BA 37201D              <1>              			  db	 37h,  20h,  1dh                      ; compressed
   378                              <1> 
   379                              <1> g_szDriveNumBNSpace:	; db	" "							; leading space, used if drive number is less than 0fh
   380                              <1>                     	; db	 20h    ; uncompressed
   381 000001BD 20                  <1>                     	  db	 20h    ; compressed
   382                              <1> 
   383                              <1> ; must come immediately before g_szDriveNumBOOTNFO!
   384                              <1> g_szDriveNumBOOTNFO:	; db	"%x %z",NULL
   385                              <1>                     	; db	 25h,  78h,  20h,  25h,  7ah,  00h    ; uncompressed
   386 000001BE 37201E              <1>                     	  db	 37h,  20h,  1eh                      ; compressed
   387                              <1> 
   388                              <1> g_szFloppyDrv:			; db	"Floppy Drive %c",NULL
   389                              <1>               			; db	 46h,  6ch,  6fh,  70h,  70h,  79h,  20h,  44h,  72h,  69h,  76h,  65h,  20h,  25h,  63h,  00h    ; uncompressed
   390 000001C1 4C72757676FF4A786F- <1>               			  db	 4ch,  72h,  75h,  76h,  76h, 0ffh,  4ah,  78h,  6fh,  7ch, 0ebh,  1ch                            ; compressed
   390 000001CA 7CEB1C              <1>
   391                              <1> 
   392                              <1> g_szBootMenuPrintEnd:
   393                              <1> g_szForeignHD:			; db	"Foreign Hard Disk",NULL
   394                              <1>               			; db	 46h,  6fh,  72h,  65h,  69h,  67h,  6eh,  20h,  48h,  61h,  72h,  64h,  20h,  44h,  69h,  73h,  6bh,  00h    ; uncompressed
   395 000001CD 4C75786B6F6DF44E67- <1>               			  db	 4ch,  75h,  78h,  6bh,  6fh,  6dh, 0f4h,  4eh,  67h,  78h, 0eah,  4ah,  6fh,  79h, 0b1h                      ; compressed
   395 000001D6 78EA4A6F79B1        <1>
   396                              <1> 
   397                              <1> 
   398                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   399                              <1> %if ((g_szBootMenuPrintStart-$$) & 0xff00) <> ((g_szBootMenuPrintEnd-$$) & 0xff00)
   400                              <1> %error "g_szBootMenuPrint* strings must start on the same 256 byte page, required by the BootMenuPrint_* routines.  Please move this block up or down within Strings.asm"
   401                              <1> %endif
   402                              <1> %if g_szDriveNumSpace+1 != g_szDriveNum || g_szDriveNumBNSpace+1 != g_szDriveNumBOOTNFO
   403                              <1> %error "g_szDriveNumSpace or g_szDriveNumBNSpace are out of position"
   404                              <1> %endif
   405                              <1> %endif
   406                              <1> 
   407                              <1> %endif ; MODULE_BOOT_MENU
   408                              <1> 
   409                              <1> 
   410                              <1> ;------------------------------------------------------------------------------------------
   411                              <1> ;
   412                              <1> ; Tables for StringsCompress.pl
   413                              <1> ;
   414                              <1> ; Items can be added and removed from this table as needed, with the following rules:
   415                              <1> ;  * Formats follow the special characters.  But other than that, order makes no difference.
   416                              <1> ;  * Some of the formats require "even" and "odd" numbering.  Even tells the code that
   417                              <1> ;    it is a "number-" format, otherwise it doesn't interpret a number first.  The easiest
   418                              <1> ;    way to maintain this is to move one of the "n/a" items to/from the front of the format
   419                              <1> ;    list to maintain the even/odd.
   420                              <1> ;  * Values do not need to remain consistent across versions.  This table is only used
   421                              <1> ;    internally to this file.
   422                              <1> ;  * There can only be 32 of these (0-31).
   423                              <1> ;  * Keeping the list short is good - this translates to a table in the compressed version.
   424                              <1> ;    An error will be reported if a character or format is no longer being used by any
   425                              <1> ;    strings above.
   426                              <1> ;  * Please keep items sequential for ease of further editing.
   427                              <1> ;
   428                              <1> ;$translate{ord(' ')} = 0;    [StringsCompress Processed]
   429                              <1> ;$translate{172}      = 1;     # ONE_QUARTER    [StringsCompress Processed]
   430                              <1> ;$translate{171}      = 2;     # ONE_HALF    [StringsCompress Processed]
   431                              <1> ;$translate{179}      = 3;     # SINGLE_VERTICAL    [StringsCompress Processed]
   432                              <1> ;$translate{175}      = 4;     # ANGLE_QUOTE_RIGHT    [StringsCompress Processed]
   433                              <1> ;$translate{ord('!')} = 5;    [StringsCompress Processed]
   434                              <1> ;$translate{ord('"')} = 6;    [StringsCompress Processed]
   435                              <1> ;$translate{ord(',')} = 7;    [StringsCompress Processed]
   436                              <1> ;$translate{ord('-')} = 8;    [StringsCompress Processed]
   437                              <1> ;$translate{ord('.')} = 9;    [StringsCompress Processed]
   438                              <1> ;$translate{ord('/')} = 10;    [StringsCompress Processed]
   439                              <1> ;$translate{ord('1')} = 11;    [StringsCompress Processed]
   440                              <1> ;$translate{ord('2')} = 12;    [StringsCompress Processed]
   441                              <1> ;$translate{ord('3')} = 13;    [StringsCompress Processed]
   442                              <1> ;$translate{ord('5')} = 14;    [StringsCompress Processed]
   443                              <1> ;$translate{ord('6')} = 15;    [StringsCompress Processed]
   444                              <1> ;$translate{ord('8')} = 16;    [StringsCompress Processed]
   445                              <1> ;$translate{200}      = 17;    # DOUBLE_BOTTOM_LEFT_CORNER    [StringsCompress Processed]
   446                              <1> ;$translate{181}      = 18;    # DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL    [StringsCompress Processed]
   447                              <1> ;$translate{ord('0')} = 19;    [StringsCompress Processed]
   448                              <1> ;
   449                              <1> ; Formats begin immediately after the last Translated character (they are in the same table)
   450                              <1> ;
   451                              <1> ;$format_begin = 20;    [StringsCompress Processed]
   452                              <1> ;
   453                              <1> ;$format{"2-I"} = 20;        # must be even    [StringsCompress Processed]
   454                              <1> ;$format{"u"}   = 21;        # must be odd    [StringsCompress Processed]
   455                              <1> ;$format{"5-u"} = 22;        # must be even    [StringsCompress Processed]
   456                              <1> ;$format{"x"}   = 23;        # must be odd    [StringsCompress Processed]
   457                              <1> ;$format{"5-x"} = 24;        # must be even    [StringsCompress Processed]
   458                              <1> ;$format{"nl"}  = 25;        # n/a    [StringsCompress Processed]
   459                              <1> ;$format{"2-u"} = 26;        # must be even    [StringsCompress Processed]
   460                              <1> ;$format{"A"}   = 27;        # n/a    [StringsCompress Processed]
   461                              <1> ;$format{"c"}   = 28;        # n/a    [StringsCompress Processed]
   462                              <1> ;$format{"s"}   = 29;        # n/a, normal string from DS    [StringsCompress Processed]
   463                              <1> ;$format{"z"}   = 30;        # n/a, boot string from BDA    [StringsCompress Processed]
   464                              <1> ;
   465                              <1> ; NOTE: The last $format cannot exceed 31 (stored in a 5-bit quantity).
   466                              <1> ;
   467                              <1> ; Starting point for the "normal" range, typically around 0x40 to cover upper and lower case
   468                              <1> ; letters.  If lower case 'z' is not used, 0x3a can be a good choice as it adds ':' to the
   469                              <1> ; front end.
   470                              <1> ;
   471                              <1> ;$normal_base = 0x3a;    [StringsCompress Processed]
   472                              <1> ;
   473                              <1> ; End of StringsCompress.pl information
   474                              <1> ;
   475                              <1> ;;; end of input stream
   476                              <1> 
   477                              <1> %endif ; STRINGSCOMPRESSED_STRINGS
   478                              <1> 
   479                              <1> %ifdef STRINGSCOMPRESSED_TABLES
   480                              <1> 
   481                              <1> StringsCompressed_NormalBase     equ   58
   482                              <1> 
   483                              <1> StringsCompressed_FormatsBegin   equ   20
   484                              <1> 
   485                              <1> StringsCompressed_TranslatesAndFormats:
   486                              <1>         db     32  ; 0
   487                              <1>         db     172  ; 1
   488                              <1>         db     171  ; 2
   489                              <1>         db     179  ; 3
   490                              <1>         db     175  ; 4
   491                              <1>         db     33  ; 5
   492                              <1>         db     34  ; 6
   493                              <1>         db     44  ; 7
   494                              <1>         db     45  ; 8
   495                              <1>         db     46  ; 9
   496                              <1>         db     47  ; 10
   497                              <1>         db     49  ; 11
   498                              <1>         db     50  ; 12
   499                              <1>         db     51  ; 13
   500                              <1>         db     53  ; 14
   501                              <1>         db     54  ; 15
   502                              <1>         db     56  ; 16
   503                              <1>         db     200  ; 17
   504                              <1>         db     181  ; 18
   505                              <1>         db     48  ; 19
   506                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I)    ; 20
   507                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u)    ; 21
   508                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u)    ; 22
   509                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x)    ; 23
   510                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x)    ; 24
   511                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl)    ; 25
   512                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u)    ; 26
   513                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A)    ; 27
   514                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c)    ; 28
   515                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s)    ; 29
   516                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z)    ; 30
   517                              <1> 
   518                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   519                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_I || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I > 255
   520                              <1> %error "DisplayFormatCompressed_Format_2_I is out of range of DisplayFormatCompressed_BaseFormatOffset"
   521                              <1> %endif
   522                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u > 255
   523                              <1> %error "DisplayFormatCompressed_Format_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
   524                              <1> %endif
   525                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u > 255
   526                              <1> %error "DisplayFormatCompressed_Format_5_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
   527                              <1> %endif
   528                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x > 255
   529                              <1> %error "DisplayFormatCompressed_Format_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
   530                              <1> %endif
   531                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x > 255
   532                              <1> %error "DisplayFormatCompressed_Format_5_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
   533                              <1> %endif
   534                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_nl || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl > 255
   535                              <1> %error "DisplayFormatCompressed_Format_nl is out of range of DisplayFormatCompressed_BaseFormatOffset"
   536                              <1> %endif
   537                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u > 255
   538                              <1> %error "DisplayFormatCompressed_Format_2_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
   539                              <1> %endif
   540                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_A || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A > 255
   541                              <1> %error "DisplayFormatCompressed_Format_A is out of range of DisplayFormatCompressed_BaseFormatOffset"
   542                              <1> %endif
   543                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_c || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c > 255
   544                              <1> %error "DisplayFormatCompressed_Format_c is out of range of DisplayFormatCompressed_BaseFormatOffset"
   545                              <1> %endif
   546                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_s || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s > 255
   547                              <1> %error "DisplayFormatCompressed_Format_s is out of range of DisplayFormatCompressed_BaseFormatOffset"
   548                              <1> %endif
   549                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_z || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z > 255
   550                              <1> %error "DisplayFormatCompressed_Format_z is out of range of DisplayFormatCompressed_BaseFormatOffset"
   551                              <1> %endif
   552                              <1> %endif
   553                              <1> 
   554                              <1> ;; translated usage stats
   555                              <1> ;; 33:1
   556                              <1> ;; 32:34
   557                              <1> ;; 181:1
   558                              <1> ;; 53:2
   559                              <1> ;; 48:2
   560                              <1> ;; 200:1
   561                              <1> ;; 46:3
   562                              <1> ;; 179:8
   563                              <1> ;; 44:1
   564                              <1> ;; 50:2
   565                              <1> ;; 51:3
   566                              <1> ;; 47:2
   567                              <1> ;; 172:2
   568                              <1> ;; 34:3
   569                              <1> ;; 49:1
   570                              <1> ;; 56:7
   571                              <1> ;; 45:2
   572                              <1> ;; 175:1
   573                              <1> ;; 171:2
   574                              <1> ;; 54:1
   575                              <1> ;; total translated: 20
   576                              <1> 
   577                              <1> ;; format usage stats
   578                              <1> ;; A:4
   579                              <1> ;; 2-u:1
   580                              <1> ;; 5-u:2
   581                              <1> ;; x:5
   582                              <1> ;; s:14
   583                              <1> ;; 5-x:1
   584                              <1> ;; nl:12
   585                              <1> ;; 2-I:1
   586                              <1> ;; u:6
   587                              <1> ;; c:13
   588                              <1> ;; z:2
   589                              <1> ;; total format: 11
   590                              <1> 
   591                              <1> ;; alphabet usage stats
   592                              <1> ;; 58,::2
   593                              <1> ;; 59,;:
   594                              <1> ;; 60,<:
   595                              <1> ;; 61,=:
   596                              <1> ;; 62,>:
   597                              <1> ;; 63,?:
   598                              <1> ;; 64,@:1
   599                              <1> ;; 65,A:5
   600                              <1> ;; 66,B:9
   601                              <1> ;; 67,C:3
   602                              <1> ;; 68,D:11
   603                              <1> ;; 69,E:3
   604                              <1> ;; 70,F:3
   605                              <1> ;; 71,G:3
   606                              <1> ;; 72,H:2
   607                              <1> ;; 73,I:1
   608                              <1> ;; 74,J:
   609                              <1> ;; 75,K:1
   610                              <1> ;; 76,L:4
   611                              <1> ;; 77,M:7
   612                              <1> ;; 78,N:2
   613                              <1> ;; 79,O:2
   614                              <1> ;; 80,P:1
   615                              <1> ;; 81,Q:1
   616                              <1> ;; 82,R:7
   617                              <1> ;; 83,S:3
   618                              <1> ;; 84,T:1
   619                              <1> ;; 85,U:2
   620                              <1> ;; 86,V:
   621                              <1> ;; 87,W:
   622                              <1> ;; 88,X:1
   623                              <1> ;; 89,Y:
   624                              <1> ;; 90,Z:
   625                              <1> ;; 91,[:2
   626                              <1> ;; 92,\:
   627                              <1> ;; 93,]:2
   628                              <1> ;; 94,^:
   629                              <1> ;; 95,_:
   630                              <1> ;; 96,`:
   631                              <1> ;; 97,a:7
   632                              <1> ;; 98,b:
   633                              <1> ;; 99,c:6
   634                              <1> ;; 100,d:6
   635                              <1> ;; 101,e:15
   636                              <1> ;; 102,f:1
   637                              <1> ;; 103,g:2
   638                              <1> ;; 104,h:
   639                              <1> ;; 105,i:9
   640                              <1> ;; 106,j:
   641                              <1> ;; 107,k:4
   642                              <1> ;; 108,l:5
   643                              <1> ;; 109,m:2
   644                              <1> ;; 110,n:11
   645                              <1> ;; 111,o:20
   646                              <1> ;; 112,p:3
   647                              <1> ;; 113,q:
   648                              <1> ;; 114,r:11
   649                              <1> ;; 115,s:7
   650                              <1> ;; 116,t:15
   651                              <1> ;; 117,u:4
   652                              <1> ;; 118,v:3
   653                              <1> ;; 119,w:1
   654                              <1> ;; 120,x:
   655                              <1> ;; 121,y:2
   656                              <1> ;; alphabet used count: 45
   657                              <1> %endif ; STRINGSCOMPRESSED_TABLES
   658                              <1> 
   174                                  %else
   175                                  	%include "Strings.asm"			; For BIOS message strings
   176                                  %endif
   177                                  
   178                                  	; Libraries, data, Initialization and drive detection
   179                                  
   180                                  	%include "AssemblyLibrary.asm"
     1                              <1> ; Project name	:	Assembly Library
     2                              <1> ; Description	:	Assembly Library main file. This is the only file that
     3                              <1> ;					needs to be included.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools 
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ; 
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.		
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> ; Section containing code
    22                              <1> SECTION .text
    23                              <1> 
    24                              <1> %ifdef INCLUDE_DISPLAY_LIBRARY
    25                              <1>   %ifndef DISPLAY_JUMP_ALIGN
    26                              <1> 	%define DISPLAY_JUMP_ALIGN 1
    27                              <1>   %endif
    28                              <1> 	%include "CgaSnow.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for preventing CGA snow.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> ; Section containing code
    21                              <2> SECTION .text
    22                              <2> 
    23                              <2> ;--------------------------------------------------------------------
    24                              <2> ; CgaSnow_IsCgaPresent
    25                              <2> ;	Parameters:
    26                              <2> ;		DS:		BDA segment (zero)
    27                              <2> ;	Returns:
    28                              <2> ;		CF:		Set if CGA detected
    29                              <2> ;				Cleared if CGA not detected
    30                              <2> ;	Corrupts registers:
    31                              <2> ;		AX
    32                              <2> ;--------------------------------------------------------------------
    33                              <2> ALIGN DISPLAY_JUMP_ALIGN
    34                              <2> CgaSnow_IsCgaPresent:
    35 000001DC 813E6304D403        <2> 	cmp		WORD [BDA.wVidPort], CGA_STATUS_REGISTER - OFFSET_TO_CGA_STATUS_REGISTER
    36 000001E2 7509                <2> 	jne		SHORT .CgaNotFound
    37                              <2> 
    38                              <2> 	; All standard CGA modes use 25 rows but only EGA and later store it to BDA.
    39 000001E4 803E840419          <2> 	cmp		BYTE [BDA.bVidRows], 25
    40 000001E9 7D02                <2> 	jge		SHORT .CgaNotFound
    41 000001EB F9                  <2> 	stc
    42 000001EC C3                  <2> 	ret
    43                              <2> ALIGN DISPLAY_JUMP_ALIGN
    44                              <2> .CgaNotFound:
    45 000001ED F8                  <2> 	clc
    46 000001EE C3                  <2> 	ret
    47                              <2> 
    48                              <2> 
    49                              <2> ; CGA snow prevention must be kept optional to avoid unnecessary
    50                              <2> ; overhead when building programs meant for non-CGA systems.
    51                              <2> %ifdef ELIMINATE_CGA_SNOW
    52                              <2> 
    53                              <2> ;--------------------------------------------------------------------
    54                              <2> ; CgaSnow_Stosb
    55                              <2> ; CgaSnow_Stosw
    56                              <2> ;	Parameters:
    57                              <2> ;		AL:		Character to output
    58                              <2> ;		AH:		Attribute to output (CgaSnow_StoswWithoutCgaSnow only)
    59                              <2> ;		DS:		BDA segment (zero)
    60                              <2> ;		ES:DI:	Ptr to video memory where to output
    61                              <2> ;	Returns:
    62                              <2> ;		DI:		Incremented for next character
    63                              <2> ;	Corrupts registers:
    64                              <2> ;		AX, DX
    65                              <2> ;--------------------------------------------------------------------
    66                              <2> ALIGN DISPLAY_JUMP_ALIGN
    67                              <2> CgaSnow_Stosb:
    68                              <2> 	call	LoadCgaStatusRegisterAddressToDXifCgaPresent
    69                              <2> 	jz		SHORT .StosbWithoutWaitSinceUnknownPort
    70                              <2> 
    71                              <2> 	mov		ah, al
    72                              <2> 	cli				; Interrupt request would mess up timing
    73                              <2> 	WAIT_UNTIL_SAFE_CGA_WRITE
    74                              <2> 	mov		al, ah
    75                              <2> .StosbWithoutWaitSinceUnknownPort:
    76                              <2> 	stosb
    77                              <2> 	sti
    78                              <2> 	ret
    79                              <2> 
    80                              <2> ALIGN DISPLAY_JUMP_ALIGN
    81                              <2> CgaSnow_Stosw:
    82                              <2> 	push	bx
    83                              <2> 	call	LoadCgaStatusRegisterAddressToDXifCgaPresent
    84                              <2> 	jz		SHORT .StoswWithoutWaitSinceUnknownPort
    85                              <2> 
    86                              <2> 	xchg	bx, ax
    87                              <2> 	cli				; Interrupt request would mess up timing
    88                              <2> 	WAIT_UNTIL_SAFE_CGA_WRITE
    89                              <2> 	xchg	ax, bx
    90                              <2> .StoswWithoutWaitSinceUnknownPort:
    91                              <2> 	stosw
    92                              <2> 	sti
    93                              <2> 	pop		bx
    94                              <2> 	ret
    95                              <2> 
    96                              <2> 
    97                              <2> ;--------------------------------------------------------------------
    98                              <2> ; CgaSnow_RepMovsb
    99                              <2> ;	Parameters:
   100                              <2> ;		CX:		Number of characters to copy
   101                              <2> ;		DS:		BDA segment (zero)
   102                              <2> ;		ES:SI:	Ptr to video memory where to read from
   103                              <2> ;		ES:DI:	Ptr to video memory where to write to
   104                              <2> ;	Returns:
   105                              <2> ;		SI, DI:	Updated for next character
   106                              <2> ;	Corrupts registers:
   107                              <2> ;		AX, CX, DX
   108                              <2> ;--------------------------------------------------------------------
   109                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   110                              <2> 	%ifdef MODULE_STRINGS_COMPRESSED
   111                              <2> 		%define EXCLUDE
   112                              <2> 	%endif
   113                              <2> 	%ifdef MODULE_BOOT_MENU
   114                              <2> 		%undef EXCLUDE
   115                              <2> 	%endif
   116                              <2> %endif
   117                              <2> 
   118                              <2> %ifndef EXCLUDE
   119                              <2> ALIGN DISPLAY_JUMP_ALIGN
   120                              <2> CgaSnow_RepMovsb:
   121                              <2> 	call	LoadCgaStatusRegisterAddressToDXifCgaPresent
   122                              <2> 	jz		SHORT .RepMovsbWithoutWaitSinceUnknownPort
   123                              <2> 
   124                              <2> .MovsbNextByte:
   125                              <2> 	cli				; Interrupt request would mess up timing
   126                              <2> 	WAIT_UNTIL_SAFE_CGA_WRITE
   127                              <2> 	es movsb
   128                              <2> 	sti
   129                              <2> 	loop	.MovsbNextByte
   130                              <2> 	ret
   131                              <2> .RepMovsbWithoutWaitSinceUnknownPort:
   132                              <2> 	eSEG_STR rep, es, movsb
   133                              <2> 	ret
   134                              <2> %endif
   135                              <2> %undef EXCLUDE
   136                              <2> 
   137                              <2> 
   138                              <2> ;--------------------------------------------------------------------
   139                              <2> ; LoadCgaStatusRegisterAddressToDXifCgaPresent
   140                              <2> ;	Parameters:
   141                              <2> ;		DS:		BDA segment (zero)
   142                              <2> ;	Returns:
   143                              <2> ;		DX:		CGA Status Register Address
   144                              <2> ;		ZF:		Set if CGA not present
   145                              <2> ;				Cleared if CGA present
   146                              <2> ;	Corrupts registers:
   147                              <2> ;		Nothing
   148                              <2> ;--------------------------------------------------------------------
   149                              <2> ALIGN DISPLAY_JUMP_ALIGN
   150                              <2> LoadCgaStatusRegisterAddressToDXifCgaPresent:
   151                              <2> 	test	BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], FLG_CONTEXT_CGA
   152                              <2> 	jz		SHORT .NoCgaDetected
   153                              <2> 	mov		dx, CGA_STATUS_REGISTER
   154                              <2> ALIGN DISPLAY_JUMP_ALIGN, ret
   155                              <2> .NoCgaDetected:
   156                              <2> 	ret
   157                              <2> 
   158                              <2> 
   159                              <2> %endif ; ELIMINATE_CGA_SNOW
    29                              <1> 	%include "Display.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Display Library functions for CALL_DISPLAY_LIBRARY macro
     3                              <2> ;					that users should use to make library call.
     4                              <2> 
     5                              <2> ;
     6                              <2> ; XTIDE Universal BIOS and Associated Tools 
     7                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     8                              <2> ;
     9                              <2> ; This program is free software; you can redistribute it and/or modify
    10                              <2> ; it under the terms of the GNU General Public License as published by
    11                              <2> ; the Free Software Foundation; either version 2 of the License, or
    12                              <2> ; (at your option) any later version.
    13                              <2> ; 
    14                              <2> ; This program is distributed in the hope that it will be useful,
    15                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <2> ; GNU General Public License for more details.		
    18                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <2> ;		
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; DisplayFunctionFromDI
    26                              <2> ;	Parameters:
    27                              <2> ;		DI:		Function to call (DISPLAY_LIB.functionName)
    28                              <2> ;		Others:	Depends on function to call (DX cannot be parameter)
    29                              <2> ;	Returns:
    30                              <2> ;		Depends on function to call
    31                              <2> ;	Corrupts registers:
    32                              <2> ;		AX (unless used as a return register), DI
    33                              <2> ;--------------------------------------------------------------------
    34                              <2> ALIGN DISPLAY_JUMP_ALIGN
    35                              <2> Display_FunctionFromDI:
    36 000001EF 06                  <2> 	push	es
    37 000001F0 1E                  <2> 	push	ds
    38 000001F1 52                  <2> 	push	dx
    39                              <2> 
    40 000001F2 FC                  <2> 	cld
    41                              <2> 	LOAD_BDA_SEGMENT_TO	ds, dx
    41                              <3> %ifndef USE_186
    41 000001F3 31D2                <3>  xor %2, %2
    41 000001F5 8EDA                <3>  mov %1, %2
    41                              <3> %elifidn %3, !
    41                              <3>  xor %2, %2
    41                              <3>  mov %1, %2
    41                              <3> %else
    41                              <3>  push BYTE 0
    41                              <3>  pop %1
    41                              <3> %endif
    42 000001F7 89FA                <2> 	mov		dx, di
    43 000001F9 C43E5404            <2> 	les		di, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
    44 000001FD FFD2                <2> 	call	dx
    45 000001FF 893E5404            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], di
    46                              <2> 
    47 00000203 5A                  <2> 	pop		dx
    48 00000204 1F                  <2> 	pop		ds
    49 00000205 07                  <2> 	pop		es
    50 00000206 C3                  <2> 	ret
    51                              <2> 
    52                              <2> ;--------------------------------------------------------------------
    53                              <2> ; Display_FormatNullTerminatedStringFromCSSI
    54                              <2> ;	Parameters:
    55                              <2> ;		Same as DisplayPrint_FormattedNullTerminatedStringFromCSSI
    56                              <2> ;	Returns:
    57                              <2> ;		Stack variables will be cleaned
    58                              <2> ;	Corrupts registers:
    59                              <2> ;		AX
    60                              <2> ;--------------------------------------------------------------------
    61                              <2> ALIGN DISPLAY_JUMP_ALIGN
    62                              <2> Display_FormatNullTerminatedStringFromCSSI:
    63 00000207 58                  <2> 	pop		ax					; Discard return address to inside Display_FunctionFromDI
    64 00000208 E86601              <2> 	call	DisplayPrint_FormattedNullTerminatedStringFromCSSI
    65 0000020B 893E5404            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], di
    66                              <2> 
    67 0000020F 5A                  <2> 	pop		dx
    68 00000210 1F                  <2> 	pop		ds
    69 00000211 07                  <2> 	pop		es
    70                              <2> 
    71 00000212 58                  <2> 	pop		ax					; Pop return address
    72 00000213 89EC                <2> 	mov		sp, bp				; Clean stack variables
    73 00000215 FFE0                <2> 	jmp		ax
    74                              <2> 
    75                              <2> 
    76                              <2> 	%define InitializeDisplayContext						DisplayContext_Initialize
    77                              <2> 
    78                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    79                              <2> 	%define SetCharacterPointerFromBXAX						DisplayContext_SetCharacterPointerFromBXAX
    80                              <2> %endif
    81                              <2> 	%define SetCharOutputFunctionFromAXwithAttribFlagInBL	DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL
    82                              <2> 	%define SetCharacterOutputParameterFromAX				DisplayContext_SetCharacterOutputParameterFromAX
    83                              <2> 	%define SetCharacterAttributeFromAL						DisplayContext_SetCharacterAttributeFromAL
    84                              <2> 	%define SetCursorShapeFromAX							DisplayCursor_SetShapeFromAX
    85                              <2> 	%define SetCursorCoordinatesFromAX						DisplayCursor_SetCoordinatesFromAX
    86                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
    87                              <2> 	%define SetNewPageFromAL								DisplayPage_SetFromAL
    88                              <2> %endif
    89                              <2> 	%define SynchronizeDisplayContextToHardware				DisplayContext_SynchronizeToHardware
    90                              <2> 
    91                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    92                              <2> 	%define GetCharacterPointerToBXAX						DisplayContext_GetCharacterPointerToBXAX
    93                              <2> %endif
    94                              <2> 	%define GetSoftwareCoordinatesToAX						DisplayCursor_GetSoftwareCoordinatesToAX
    95                              <2> 	%define GetColumnsToALandRowsToAH						DisplayPage_GetColumnsToALandRowsToAH
    96                              <2> 
    97                              <2> 	%define FormatNullTerminatedStringFromCSSI				Display_FormatNullTerminatedStringFromCSSI
    98                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    99                              <2> 	%define PrintSignedWordFromAXWithBaseInBX				DisplayPrint_SignedWordFromAXWithBaseInBX
   100                              <2> %endif
   101                              <2> 	%define PrintWordFromAXwithBaseInBX						DisplayPrint_WordFromAXWithBaseInBX
   102                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
   103                              <2> 	%define PrintQWordFromSSBPwithBaseInBX					DisplayPrint_QWordFromSSBPwithBaseInBX
   104                              <2> %endif
   105                              <2> 	%define PrintCharBufferFromBXSIwithLengthInCX			DisplayPrint_CharacterBufferFromBXSIwithLengthInCX
   106                              <2> 	%define PrintNullTerminatedStringFromBXSI				DisplayPrint_NullTerminatedStringFromBXSI
   107                              <2> 	%define PrintNullTerminatedStringFromCSSI				DisplayPrint_NullTerminatedStringFromCSSI
   108                              <2> 	%define PrintRepeatedCharacterFromALwithCountInCX		DisplayPrint_RepeatCharacterFromALwithCountInCX
   109                              <2> 	%define PrintCharacterFromAL							DisplayPrint_CharacterFromAL
   110                              <2> 	%define PrintNewlineCharacters							DisplayPrint_Newline
   111                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   112                              <2> 	%define ClearAreaWithHeightInAHandWidthInAL				DisplayPrint_ClearAreaWithHeightInAHandWidthInAL
   113                              <2> %endif
   114                              <2> 	%define ClearScreenWithCharInALandAttrInAH				DisplayPrint_ClearScreenWithCharInALandAttributeInAH
   115                              <2> 
    30                              <1> 	%include "DisplayCharOut.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for outputting characters to video memory.
     3                              <2> ;					These functions are meant to be called by Display_CharacterFromAL
     4                              <2> ;					and Display_RepeatCharacterFromAL using function pointer
     5                              <2> ;					stored in DISPLAY_CONTEXT.
     6                              <2> 
     7                              <2> ;
     8                              <2> ; XTIDE Universal BIOS and Associated Tools 
     9                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
    10                              <2> ;
    11                              <2> ; This program is free software; you can redistribute it and/or modify
    12                              <2> ; it under the terms of the GNU General Public License as published by
    13                              <2> ; the Free Software Foundation; either version 2 of the License, or
    14                              <2> ; (at your option) any later version.
    15                              <2> ; 
    16                              <2> ; This program is distributed in the hope that it will be useful,
    17                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <2> ; GNU General Public License for more details.		
    20                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    21                              <2> ;		
    22                              <2> 
    23                              <2> ; Section containing code
    24                              <2> SECTION .text
    25                              <2> 
    26                              <2> ;--------------------------------------------------------------------
    27                              <2> ; DisplayCharOut_TeletypeOutputWithAttribute
    28                              <2> ; DisplayCharOut_TeletypeOutput
    29                              <2> ;	Parameters:
    30                              <2> ;		AL:		Character to output
    31                              <2> ;		AH:		Attribute to output
    32                              <2> ;		DS:		BDA segment (zero)
    33                              <2> ;		ES:DI:	Ptr to video memory where to output
    34                              <2> ;	Returns:
    35                              <2> ;		DI:		Incremented for next character
    36                              <2> ;	Corrupts registers:
    37                              <2> ;		AX, DX
    38                              <2> ;--------------------------------------------------------------------
    39                              <2> ALIGN DISPLAY_JUMP_ALIGN
    40                              <2> DisplayCharOut_TeletypeOutputWithAttribute:
    41 00000217 3C20                <2> 	cmp		al, ' '							; Printable character?
    42 00000219 7206                <2> 	jb		SHORT DisplayCharOut_BiosTeletypeOutput
    43                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosw
    43                              <3> %ifdef ELIMINATE_CGA_SNOW
    43                              <3>  %ifidn %1, stosb
    43                              <3>  call CgaSnow_Stosb
    43                              <3>  %elifidn %1, stosw
    43                              <3>  call CgaSnow_Stosw
    43                              <3>  %elifidn %1, rep movsb
    43                              <3>  call CgaSnow_RepMovsb
    43                              <3>  %else
    43                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
    43                              <3>  %endif
    43                              <3> %else
    43                              <3>  %ifidn %1, rep movsb
    43                              <3>  eSEG_STR rep, es, movsb
    43                              <3>  %else
    43 0000021B AB                  <3>  %1
    43                              <3>  %endif
    43                              <3> %endif
    44 0000021C C3                  <2> 	ret
    45                              <2> 
    46                              <2> ALIGN DISPLAY_JUMP_ALIGN
    47                              <2> DisplayCharOut_TeletypeOutput:
    48 0000021D 3C20                <2> 	cmp		al, ' '							; Printable character?
    49 0000021F 731A                <2> 	jae		SHORT DisplayCharOut_Character
    50                              <2> 	; Fall to DisplayCharOut_BiosTeletypeOutput
    51                              <2> 
    52                              <2> ;--------------------------------------------------------------------
    53                              <2> ; DisplayCharOut_BiosTeletypeOutput
    54                              <2> ;	Parameters:
    55                              <2> ;		AL:		Control character
    56                              <2> ;		DS:		BDA segment (zero)
    57                              <2> ;		ES:DI:	Ptr to video memory where to output
    58                              <2> ;	Returns:
    59                              <2> ;		DI:		Incremented for next character
    60                              <2> ;	Corrupts registers:
    61                              <2> ;		AX, DX
    62                              <2> ;--------------------------------------------------------------------
    63                              <2> ALIGN DISPLAY_JUMP_ALIGN
    64                              <2> DisplayCharOut_BiosTeletypeOutput:
    65 00000221 50                  <2> 	push	ax
    66 00000222 E82301              <2> 	call	DisplayCursor_SynchronizeCoordinatesToHardware
    67 00000225 58                  <2> 	pop		ax
    68                              <2> 
    69                              <2> 	; Output character with BIOS
    70 00000226 53                  <2> 	push	bx
    71 00000227 B40E                <2> 	mov		ah, TELETYPE_OUTPUT
    72 00000229 8A3E6204            <2> 	mov		bh, [VIDEO_BDA.bActivePage]
    73 0000022D CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
    74 0000022F 5B                  <2> 	pop		bx
    75                              <2> 
    76 00000230 E8F100              <2> 	call	DisplayCursor_GetHardwareCoordinatesToAX
    77 00000233 E9C900              <2> 	jmp		DisplayCursor_SetCoordinatesFromAX
    78                              <2> 
    79                              <2> 
    80                              <2> ;--------------------------------------------------------------------
    81                              <2> ; DisplayCharOut_Attribute
    82                              <2> ; DisplayCharOut_Character
    83                              <2> ; DisplayCharOut_CharacterWithAttribute
    84                              <2> ;	Parameters:
    85                              <2> ;		AL:		Character to output
    86                              <2> ;		AH:		Attribute to output
    87                              <2> ;		DS:		BDA segment (zero)
    88                              <2> ;		ES:DI:	Ptr to video memory where to output
    89                              <2> ;	Returns:
    90                              <2> ;		DI:		Incremented for next character
    91                              <2> ;	Corrupts registers:
    92                              <2> ;		AX, DX
    93                              <2> ;--------------------------------------------------------------------
    94                              <2> ALIGN DISPLAY_JUMP_ALIGN
    95                              <2> DisplayCharOut_Attribute:
    96 00000236 86C4                <2> 	xchg	al, ah				; Swap character and attribute
    97 00000238 47                  <2> 	inc		di					; Skip character
    98                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosb
    98                              <3> %ifdef ELIMINATE_CGA_SNOW
    98                              <3>  %ifidn %1, stosb
    98                              <3>  call CgaSnow_Stosb
    98                              <3>  %elifidn %1, stosw
    98                              <3>  call CgaSnow_Stosw
    98                              <3>  %elifidn %1, rep movsb
    98                              <3>  call CgaSnow_RepMovsb
    98                              <3>  %else
    98                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
    98                              <3>  %endif
    98                              <3> %else
    98                              <3>  %ifidn %1, rep movsb
    98                              <3>  eSEG_STR rep, es, movsb
    98                              <3>  %else
    98 00000239 AA                  <3>  %1
    98                              <3>  %endif
    98                              <3> %endif
    99 0000023A C3                  <2> 	ret
   100                              <2> 
   101                              <2> ALIGN DISPLAY_JUMP_ALIGN
   102                              <2> DisplayCharOut_Character:
   103                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosb
   103                              <3> %ifdef ELIMINATE_CGA_SNOW
   103                              <3>  %ifidn %1, stosb
   103                              <3>  call CgaSnow_Stosb
   103                              <3>  %elifidn %1, stosw
   103                              <3>  call CgaSnow_Stosw
   103                              <3>  %elifidn %1, rep movsb
   103                              <3>  call CgaSnow_RepMovsb
   103                              <3>  %else
   103                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
   103                              <3>  %endif
   103                              <3> %else
   103                              <3>  %ifidn %1, rep movsb
   103                              <3>  eSEG_STR rep, es, movsb
   103                              <3>  %else
   103 0000023B AA                  <3>  %1
   103                              <3>  %endif
   103                              <3> %endif
   104 0000023C 47                  <2> 	inc		di					; Skip attribute
   105 0000023D C3                  <2> 	ret
   106                              <2> 
   107                              <2> ALIGN DISPLAY_JUMP_ALIGN
   108                              <2> DisplayCharOut_CharacterWithAttribute:
   109                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosw
   109                              <3> %ifdef ELIMINATE_CGA_SNOW
   109                              <3>  %ifidn %1, stosb
   109                              <3>  call CgaSnow_Stosb
   109                              <3>  %elifidn %1, stosw
   109                              <3>  call CgaSnow_Stosw
   109                              <3>  %elifidn %1, rep movsb
   109                              <3>  call CgaSnow_RepMovsb
   109                              <3>  %else
   109                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
   109                              <3>  %endif
   109                              <3> %else
   109                              <3>  %ifidn %1, rep movsb
   109                              <3>  eSEG_STR rep, es, movsb
   109                              <3>  %else
   109 0000023E AB                  <3>  %1
   109                              <3>  %endif
   109                              <3> %endif
   110 0000023F C3                  <2> 	ret
   111                              <2> 
   112                              <2> 
   113                              <2> ;--------------------------------------------------------------------
   114                              <2> ; DisplayCharOut_WriteCharacterToBuffer
   115                              <2> ;	Parameters:
   116                              <2> ;		AL:		Character to output
   117                              <2> ;		DS:		BDA segment (zero)
   118                              <2> ;		ES:DI:	Ptr to destination string buffer
   119                              <2> ;		DISPLAY_CONTEXT.wCharOutParam:	Characters left in buffer
   120                              <2> ;	Returns:
   121                              <2> ;		ES:DI:	Updated for next character
   122                              <2> ;	Corrupts registers:
   123                              <2> ;		AX, DX
   124                              <2> ;--------------------------------------------------------------------
   125                              <2> ALIGN DISPLAY_JUMP_ALIGN
   126                              <2> DisplayCharOut_WriteCharacterToBuffer:
   127 00000240 833E5A0400          <2> 	cmp		WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam], BYTE 0
   128 00000245 7405                <2> 	je		SHORT .BufferFull
   129 00000247 AA                  <2> 	stosb
   130 00000248 FF0E5A04            <2> 	dec		WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam]
   131                              <2> .BufferFull:
   132 0000024C C3                  <2> 	ret
    31                              <1> 	%include "DisplayContext.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for managing display context.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> ; Section containing code
    21                              <2> SECTION .text
    22                              <2> 
    23                              <2> ;--------------------------------------------------------------------
    24                              <2> ; DisplayContext_Initialize
    25                              <2> ;	Parameters:
    26                              <2> ;		DS:		BDA segment (zero)
    27                              <2> ;	Returns:
    28                              <2> ;		Nothing
    29                              <2> ;	Corrupts registers:
    30                              <2> ;		AX, DX, DI
    31                              <2> ;--------------------------------------------------------------------
    32                              <2> ALIGN DISPLAY_JUMP_ALIGN
    33                              <2> DisplayContext_Initialize:
    34 0000024D C7065804[1702]      <2> 	mov		WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fnCharOut], DEFAULT_CHARACTER_OUTPUT
    35 00000253 C6065E0407          <2> 	mov		BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], SCREEN_BACKGROUND_ATTRIBUTE
    36 00000258 E89200              <2> 	call	DisplayCursor_GetDefaultCursorShapeToAX
    37 0000025B A35C04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCursorShape], ax
    38                              <2> 	; Fall to .DetectAndSetDisplaySegment
    39                              <2> 
    40                              <2> ;--------------------------------------------------------------------
    41                              <2> ; .DetectAndSetDisplaySegment
    42                              <2> ;	Parameters:
    43                              <2> ;		DS:		BDA segment (zero)
    44                              <2> ;	Returns:
    45                              <2> ;		Nothing
    46                              <2> ;	Corrupts registers:
    47                              <2> ;		AX, DX
    48                              <2> ;--------------------------------------------------------------------
    49                              <2> .DetectAndSetDisplaySegment:
    50 0000025E B800B8              <2> 	mov		ax, COLOR_TEXT_SEGMENT
    51 00000261 803E490407          <2> 	cmp		BYTE [VIDEO_BDA.bMode], MDA_TEXT_MODE
    52                              <2> 	eCMOVE	ah, MONO_TEXT_SEGMENT >> 8
    52                              <3>  eCMOVZ %1, %2
    52 00000266 7502                <4>  jnz SHORT %%Return
    52 00000268 B4B0                <4>  mov %1, %2
    52                              <4> %%Return:
    53 0000026A A35604              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition+2], ax
    54                              <2> 	; Fall to .InitializeFlags
    55                              <2> 
    56                              <2> ;--------------------------------------------------------------------
    57                              <2> ; .InitializeFlags
    58                              <2> ;	Parameters:
    59                              <2> ;		DS:		BDA segment (zero)
    60                              <2> ;	Returns:
    61                              <2> ;		Nothing
    62                              <2> ;	Corrupts registers:
    63                              <2> ;		AX, DX
    64                              <2> ;--------------------------------------------------------------------
    65                              <2> .InitializeFlags:
    66 0000026D B201                <2> 	mov		dl, FLG_CONTEXT_ATTRIBUTES
    67 0000026F E86AFF              <2> 	call	CgaSnow_IsCgaPresent
    68 00000272 7303                <2> 	jnc		SHORT .DoNotSetCgaFlag
    69 00000274 80CA02              <2> 	or		dl, FLG_CONTEXT_CGA
    70                              <2> .DoNotSetCgaFlag:
    71 00000277 88165F04            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], dl
    72                              <2> 	; Fall to .InitializeCursor
    73                              <2> 
    74                              <2> ;--------------------------------------------------------------------
    75                              <2> ; .InitializeCursor
    76                              <2> ;	Parameters:
    77                              <2> ;		DS:		BDA segment (zero)
    78                              <2> ;	Returns:
    79                              <2> ;		Nothing
    80                              <2> ;	Corrupts registers:
    81                              <2> ;		AX, DX
    82                              <2> ;--------------------------------------------------------------------
    83                              <2> .InitializeCursor:
    84 0000027B E8A600              <2> 	call	DisplayCursor_GetHardwareCoordinatesToAX	; Coordinates before init
    85 0000027E E87E00              <2> 	call	DisplayCursor_SetCoordinatesFromAX			; Cursor to Display Context
    86                              <2> 	; Fall to DisplayContext_SynchronizeToHardware
    87                              <2> 
    88                              <2> ;--------------------------------------------------------------------
    89                              <2> ; DisplayContext_SynchronizeToHardware
    90                              <2> ;	Parameters:
    91                              <2> ;		DS:		BDA segment (zero)
    92                              <2> ;	Returns:
    93                              <2> ;		Nothing
    94                              <2> ;	Corrupts registers:
    95                              <2> ;		AX, DX
    96                              <2> ;--------------------------------------------------------------------
    97                              <2> ALIGN DISPLAY_JUMP_ALIGN
    98                              <2> DisplayContext_SynchronizeToHardware:
    99 00000281 E8D900              <2> 	call	DisplayPage_SynchronizeToHardware
   100 00000284 E8AB00              <2> 	call	DisplayCursor_SynchronizeShapeToHardware
   101 00000287 E9BE00              <2> 	jmp		DisplayCursor_SynchronizeCoordinatesToHardware
   102                              <2> 
   103                              <2> 
   104                              <2> ;--------------------------------------------------------------------
   105                              <2> ; DisplayContext_Push
   106                              <2> ; DisplayContext_Pop
   107                              <2> ;	Parameters:
   108                              <2> ;		Nothing
   109                              <2> ;	Returns:
   110                              <2> ;		Nothing
   111                              <2> ;	Corrupts registers:
   112                              <2> ;		AX, DI
   113                              <2> ;--------------------------------------------------------------------
   114                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   115                              <2> 	%ifndef MODULE_BOOT_MENU
   116                              <2> 		%define EXCLUDE
   117                              <2> 	%endif
   118                              <2> %endif
   119                              <2> 
   120                              <2> %ifndef EXCLUDE
   121                              <2> ALIGN DISPLAY_JUMP_ALIGN
   122                              <2> DisplayContext_Push:
   123 0000028A 8CDF                <2> 	mov		di, ds					; Backup DS
   124                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax
   124                              <3> %ifndef USE_186
   124 0000028C 31C0                <3>  xor %2, %2
   124 0000028E 8ED8                <3>  mov %1, %2
   124                              <3> %elifidn %3, !
   124                              <3>  xor %2, %2
   124                              <3>  mov %1, %2
   124                              <3> %else
   124                              <3>  push BYTE 0
   124                              <3>  pop %1
   124                              <3> %endif
   125 00000290 58                  <2> 	pop		ax						; Pop return address
   126                              <2> 
   127                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   128                              <2> 	%assign i 0
   129                              <2> 	%rep DISPLAY_CONTEXT_size / 2
   130                              <2> 		push	WORD [VIDEO_BDA.displayContext + i]
   131                              <2> 	%assign i i+2
   132                              <2> 	%endrep
   132 00000291 FF365404            <3>  push WORD [VIDEO_BDA.displayContext + i]
   132                              <3>  %assign i i+2
   132 00000295 FF365604            <3>  push WORD [VIDEO_BDA.displayContext + i]
   132                              <3>  %assign i i+2
   132 00000299 FF365804            <3>  push WORD [VIDEO_BDA.displayContext + i]
   132                              <3>  %assign i i+2
   132 0000029D FF365A04            <3>  push WORD [VIDEO_BDA.displayContext + i]
   132                              <3>  %assign i i+2
   132 000002A1 FF365C04            <3>  push WORD [VIDEO_BDA.displayContext + i]
   132                              <3>  %assign i i+2
   132 000002A5 FF365E04            <3>  push WORD [VIDEO_BDA.displayContext + i]
   132                              <3>  %assign i i+2
   133                              <2> %endif
   134                              <2> 
   135 000002A9 8EDF                <2> 	mov		ds, di					; Restore DS
   136 000002AB FFE0                <2> 	jmp		ax
   137                              <2> 
   138                              <2> 
   139                              <2> ALIGN DISPLAY_JUMP_ALIGN
   140                              <2> DisplayContext_Pop:
   141 000002AD 8CDF                <2> 	mov		di, ds					; Backup DS
   142                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax
   142                              <3> %ifndef USE_186
   142 000002AF 31C0                <3>  xor %2, %2
   142 000002B1 8ED8                <3>  mov %1, %2
   142                              <3> %elifidn %3, !
   142                              <3>  xor %2, %2
   142                              <3>  mov %1, %2
   142                              <3> %else
   142                              <3>  push BYTE 0
   142                              <3>  pop %1
   142                              <3> %endif
   143 000002B3 58                  <2> 	pop		ax						; Pop return address
   144                              <2> 
   145                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   146                              <2> 	%assign i DISPLAY_CONTEXT_size-2
   147                              <2> 	%rep DISPLAY_CONTEXT_size / 2
   148                              <2> 		pop		WORD [VIDEO_BDA.displayContext + i]
   149                              <2> 	%assign i i-2
   150                              <2> 	%endrep
   150 000002B4 8F065E04            <3>  pop WORD [VIDEO_BDA.displayContext + i]
   150                              <3>  %assign i i-2
   150 000002B8 8F065C04            <3>  pop WORD [VIDEO_BDA.displayContext + i]
   150                              <3>  %assign i i-2
   150 000002BC 8F065A04            <3>  pop WORD [VIDEO_BDA.displayContext + i]
   150                              <3>  %assign i i-2
   150 000002C0 8F065804            <3>  pop WORD [VIDEO_BDA.displayContext + i]
   150                              <3>  %assign i i-2
   150 000002C4 8F065604            <3>  pop WORD [VIDEO_BDA.displayContext + i]
   150                              <3>  %assign i i-2
   150 000002C8 8F065404            <3>  pop WORD [VIDEO_BDA.displayContext + i]
   150                              <3>  %assign i i-2
   151                              <2> %endif
   152                              <2> 
   153 000002CC 50                  <2> 	push	ax						; Push return address
   154 000002CD 52                  <2> 	push	dx
   155 000002CE E8B0FF              <2> 	call	DisplayContext_SynchronizeToHardware
   156 000002D1 5A                  <2> 	pop		dx
   157 000002D2 8EDF                <2> 	mov		ds, di					; Restore DS
   158 000002D4 C3                  <2> 	ret
   159                              <2> %endif ; EXCLUDE
   160                              <2> %undef EXCLUDE
   161                              <2> 
   162                              <2> 
   163                              <2> ;--------------------------------------------------------------------
   164                              <2> ; DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   165                              <2> ;	Parameters:
   166                              <2> ;		CX:		Off screen buffer length in characters
   167                              <2> ;		ES:BX:	Ptr to off screen buffer
   168                              <2> ;	Returns:
   169                              <2> ;		Nothing
   170                              <2> ;	Corrupts registers:
   171                              <2> ;		AX, DI
   172                              <2> ;--------------------------------------------------------------------
   173                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   174                              <2> ALIGN DISPLAY_JUMP_ALIGN
   175                              <2> DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX:
   176                              <2> 	push	ds
   177                              <2> 
   178                              <2> 	LOAD_BDA_SEGMENT_TO	ds, di
   179                              <2> 	xchg	ax, bx
   180                              <2> 	mov		bx, es
   181                              <2> 	call	DisplayContext_SetCharacterPointerFromBXAX	; ES:DI now has the pointer
   182                              <2> 
   183                              <2> 	mov		bl, ATTRIBUTES_NOT_USED
   184                              <2> 	mov		ax, BUFFER_OUTPUT_WITH_CHAR_ONLY
   185                              <2> 	call	DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL
   186                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam], cx
   187                              <2> 
   188                              <2> 	mov		bx, di
   189                              <2> 	pop		ds
   190                              <2> 	ret
   191                              <2> %endif ; EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   192                              <2> 
   193                              <2> 
   194                              <2> ;--------------------------------------------------------------------
   195                              <2> ; DisplayContext_SetCharacterPointerFromBXAX
   196                              <2> ;	Parameters:
   197                              <2> ;		BX:AX:	Ptr to destination for next character to output
   198                              <2> ;		DS:		BDA segment (zero)
   199                              <2> ;	Returns:
   200                              <2> ;		ES:DI:	Pointer that was in BX:AX
   201                              <2> ;	Corrupts registers:
   202                              <2> ;		AX
   203                              <2> ;--------------------------------------------------------------------
   204                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   205                              <2> ALIGN DISPLAY_JUMP_ALIGN
   206                              <2> DisplayContext_SetCharacterPointerFromBXAX:
   207                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], ax
   208                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition+2], bx
   209                              <2> 	xchg	di, ax
   210                              <2> 	mov		es, bx
   211                              <2> 	ret
   212                              <2> %endif
   213                              <2> 
   214                              <2> 
   215                              <2> ;--------------------------------------------------------------------
   216                              <2> ; DisplayContext_GetCharacterPointerToBXAX
   217                              <2> ;	Parameters:
   218                              <2> ;		DS:		BDA segment (zero)
   219                              <2> ;	Returns:
   220                              <2> ;		BX:AX:	Ptr to destination for next character to output
   221                              <2> ;	Corrupts registers:
   222                              <2> ;		Nothing
   223                              <2> ;--------------------------------------------------------------------
   224                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   225                              <2> ALIGN DISPLAY_JUMP_ALIGN
   226                              <2> DisplayContext_GetCharacterPointerToBXAX:
   227                              <2> 	mov		ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
   228                              <2> 	mov		bx, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition+2]
   229                              <2> 	ret
   230                              <2> %endif
   231                              <2> 
   232                              <2> 
   233                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   234                              <2> 	%ifndef MODULE_BOOT_MENU
   235                              <2> 		%define EXCLUDE
   236                              <2> 	%endif
   237                              <2> %endif
   238                              <2> ;--------------------------------------------------------------------
   239                              <2> ; DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL
   240                              <2> ;	Parameters:
   241                              <2> ;		AX:		Offset to character output function
   242                              <2> ;		BL:		Attribute Flag
   243                              <2> ;		DS:		BDA segment (zero)
   244                              <2> ;	Returns:
   245                              <2> ;		Nothing
   246                              <2> ;	Corrupts registers:
   247                              <2> ;		BL
   248                              <2> ;--------------------------------------------------------------------
   249                              <2> %ifndef EXCLUDE	; 1 of 3
   250                              <2> ALIGN DISPLAY_JUMP_ALIGN
   251                              <2> DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL:
   252 000002D5 80E301              <2> 	and		bl, FLG_CONTEXT_ATTRIBUTES
   253 000002D8 80265F04FE          <2> 	and		BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], ~FLG_CONTEXT_ATTRIBUTES
   254 000002DD 081E5F04            <2> 	or		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], bl
   255 000002E1 A35804              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fnCharOut], ax
   256 000002E4 C3                  <2> 	ret
   257                              <2> %endif
   258                              <2> 
   259                              <2> 
   260                              <2> ;--------------------------------------------------------------------
   261                              <2> ; DisplayContext_SetCharacterAttributeFromAL
   262                              <2> ;	Parameters:
   263                              <2> ;		AL:		Character attribute
   264                              <2> ;		DS:		BDA segment (zero)
   265                              <2> ;	Returns:
   266                              <2> ;		Nothing
   267                              <2> ;	Corrupts registers:
   268                              <2> ;		Nothing
   269                              <2> ;--------------------------------------------------------------------
   270                              <2> %ifndef EXCLUDE	; 2 of 3
   271                              <2> ALIGN DISPLAY_JUMP_ALIGN
   272                              <2> DisplayContext_SetCharacterAttributeFromAL:
   273 000002E5 A25E04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], al
   274 000002E8 C3                  <2> 	ret
   275                              <2> %endif
   276                              <2> 
   277                              <2> 
   278                              <2> ;--------------------------------------------------------------------
   279                              <2> ; DisplayContext_SetCharacterOutputParameterFromAX
   280                              <2> ;	Parameters:
   281                              <2> ;		AX:		Parameter for Character Output function
   282                              <2> ;		DS:		BDA segment (zero)
   283                              <2> ;	Returns:
   284                              <2> ;		Nothing
   285                              <2> ;	Corrupts registers:
   286                              <2> ;		Nothing
   287                              <2> ;--------------------------------------------------------------------
   288                              <2> %ifndef EXCLUDE	; 3 of 3
   289                              <2> ALIGN DISPLAY_JUMP_ALIGN
   290                              <2> DisplayContext_SetCharacterOutputParameterFromAX:
   291 000002E9 A35A04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam], ax
   292 000002EC C3                  <2> 	ret
   293                              <2> %endif
   294                              <2> 
   295                              <2> %undef EXCLUDE
   296                              <2> 
   297                              <2> 
   298                              <2> ;--------------------------------------------------------------------
   299                              <2> ; DisplayContext_GetCharacterOutputParameterToDX
   300                              <2> ;	Parameters:
   301                              <2> ;		DS:		BDA segment (zero)
   302                              <2> ;	Returns:
   303                              <2> ;		DX:		User parameter for Character Output function
   304                              <2> ;	Corrupts registers:
   305                              <2> ;		Nothing
   306                              <2> ;--------------------------------------------------------------------
   307                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
   308                              <2> ALIGN DISPLAY_JUMP_ALIGN
   309                              <2> DisplayContext_GetCharacterOutputParameterToDX:
   310                              <2> 	mov		dx, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam]
   311                              <2> 	ret
   312                              <2> %endif
   313                              <2> 
   314                              <2> 
   315                              <2> ;--------------------------------------------------------------------
   316                              <2> ; DisplayContext_GetCharacterOffsetToAXfromByteOffsetInAX
   317                              <2> ;	Parameters:
   318                              <2> ;		AX:		Offset in bytes from some character to another
   319                              <2> ;		DS:		BDA segment (zero)
   320                              <2> ;	Returns:
   321                              <2> ;		AX:		Offset in characters from some character to another
   322                              <2> ;	Corrupts registers:
   323                              <2> ;		Nothing
   324                              <2> ;--------------------------------------------------------------------
   325                              <2> %ifndef MODULE_STRINGS_COMPRESSED
   326                              <2> ALIGN DISPLAY_JUMP_ALIGN
   327                              <2> DisplayContext_GetCharacterOffsetToAXfromByteOffsetInAX:
   328                              <2> 	test	BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], FLG_CONTEXT_ATTRIBUTES
   329                              <2> 	jz		SHORT ReturnOffsetInAX
   330                              <2> 	sar		ax, 1		; BYTE count to WORD count
   331                              <2> 	ret
   332                              <2> %endif
   333                              <2> 
   334                              <2> 
   335                              <2> ;--------------------------------------------------------------------
   336                              <2> ; DisplayContext_GetByteOffsetToAXfromCharacterOffsetInAX
   337                              <2> ;	Parameters:
   338                              <2> ;		AX:		Offset in characters from some character to another
   339                              <2> ;		DS:		BDA segment (zero)
   340                              <2> ;	Returns:
   341                              <2> ;		AX:		Offset in bytes from some character to another
   342                              <2> ;	Corrupts registers:
   343                              <2> ;		Nothing
   344                              <2> ;--------------------------------------------------------------------
   345                              <2> %ifndef MODULE_STRINGS_COMPRESSED
   346                              <2> ALIGN DISPLAY_JUMP_ALIGN
   347                              <2> DisplayContext_GetByteOffsetToAXfromCharacterOffsetInAX:
   348                              <2> 	test	BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], FLG_CONTEXT_ATTRIBUTES
   349                              <2> 	jz		SHORT ReturnOffsetInAX
   350                              <2> 	sal		ax, 1		; WORD count to BYTE count
   351                              <2> ALIGN DISPLAY_JUMP_ALIGN, ret
   352                              <2> ReturnOffsetInAX:
   353                              <2> 	ret
   354                              <2> %endif
    32                              <1> 	%include "DisplayCursor.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for managing display cursor.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> ; Section containing code
    21                              <2> SECTION .text
    22                              <2> 
    23                              <2> ;--------------------------------------------------------------------
    24                              <2> ; DisplayCursor_GetDefaultCursorShapeToAX
    25                              <2> ;	Parameters:
    26                              <2> ;		DS:		BDA segment (zero)
    27                              <2> ;	Returns:
    28                              <2> ;		AX:		Default text mode cursor shape
    29                              <2> ;	Corrupts registers:
    30                              <2> ;		Nothing
    31                              <2> ;--------------------------------------------------------------------
    32                              <2> ALIGN DISPLAY_JUMP_ALIGN
    33                              <2> DisplayCursor_GetDefaultCursorShapeToAX:
    34 000002ED B80706              <2> 	mov		ax, CURSOR_NORMAL_COLOR				; CGA, EGA, VGA cursor
    35 000002F0 803E490407          <2> 	cmp		BYTE [VIDEO_BDA.bMode], MDA_TEXT_MODE
    36                              <2> 	eCMOVE	ax, CURSOR_NORMAL_MDA				; MDA cursor
    36                              <3>  eCMOVZ %1, %2
    36 000002F5 7503                <4>  jnz SHORT %%Return
    36 000002F7 B80C0B              <4>  mov %1, %2
    36                              <4> %%Return:
    37 000002FA C3                  <2> 	ret
    38                              <2> 
    39                              <2> 
    40                              <2> ;--------------------------------------------------------------------
    41                              <2> ; DisplayCursor_SetShapeFromAX
    42                              <2> ;	Parameters:
    43                              <2> ;		AX:		Cursor shape (AH=Start scan line, AL=End scan line)
    44                              <2> ;		DS:		BDA segment (zero)
    45                              <2> ;	Returns:
    46                              <2> ;		Nothing
    47                              <2> ;	Corrupts registers:
    48                              <2> ;		Nothing
    49                              <2> ;--------------------------------------------------------------------
    50                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    51                              <2> 	%ifndef MODULE_BOOT_MENU
    52                              <2> 		%define EXCLUDE
    53                              <2> 	%endif
    54                              <2> %endif
    55                              <2> 
    56                              <2> %ifndef EXCLUDE
    57                              <2> ALIGN DISPLAY_JUMP_ALIGN
    58                              <2> DisplayCursor_SetShapeFromAX:
    59 000002FB A35C04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCursorShape], ax
    60 000002FE C3                  <2> 	ret
    61                              <2> %endif
    62                              <2> %undef EXCLUDE
    63                              <2> 
    64                              <2> 
    65                              <2> ;--------------------------------------------------------------------
    66                              <2> ; DisplayCursor_SetCoordinatesFromAX
    67                              <2> ;	Parameters:
    68                              <2> ;		AL:		Cursor column (X-coordinate)
    69                              <2> ;		AH:		Cursor row (Y-coordinate)
    70                              <2> ;		DS:		BDA segment (zero)
    71                              <2> ;	Returns:
    72                              <2> ;		DI:		Offset to cursor location in video RAM
    73                              <2> ;	Corrupts registers:
    74                              <2> ;		AX, DX
    75                              <2> ;--------------------------------------------------------------------
    76                              <2> ALIGN DISPLAY_JUMP_ALIGN
    77                              <2> DisplayCursor_SetCoordinatesFromAX:
    78 000002FF 92                  <2> 	xchg	dx, ax
    79 00000300 A14A04              <2> 	mov		ax, [VIDEO_BDA.wColumns]		; Column count, 40 or 80
    80 00000303 F6E6                <2> 	mul		dh								; AX = Column count * row index
    81 00000305 30F6                <2> 	xor		dh, dh
    82 00000307 01D0                <2> 	add		ax, dx							; Add column offset
    83                              <2> 	eSHL_IM	ax, 1							; Convert to WORD offset
    83                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    83                              <3> %ifdef USE_386
    83                              <3>  %if %2 = 1
    83                              <3>  add %1, %1
    83                              <3>  %else
    83                              <3>  eSHIFT_IM %1, %2, shl
    83                              <3>  %endif
    83                              <3> %else
    83                              <3>  eSHIFT_IM %1, %2, shl
    83                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    83                              <4> %ifndef USE_186
    83                              <4>  %ifidni %1, cl
    83                              <4>  times %2 %3 %1, 1
    83                              <4>  %elifidni %1, ch
    83                              <4>  times %2 %3 %1, 1
    83                              <4>  %elifidni %1, cx
    83                              <4>  times %2 %3 %1, 1
    83                              <4>  %else
    83                              <4>  %if %2 > 3
    83                              <4>  push cx
    83                              <4>  mov cl, %2
    83                              <4>  %3 %1, cl
    83                              <4>  pop cx
    83                              <4>  %else
    83 00000309 D1E0                <4>  times %2 %3 %1, 1
    83                              <4>  %endif
    83                              <4>  %endif
    83                              <4> 
    83                              <4> %else
    83                              <4>  %3 %1, %2
    83                              <4> %endif
    83                              <4> %endif
    83                              <3> %endif
    83                              <3> %endif
    84 0000030B 03064E04            <2> 	add		ax, [VIDEO_BDA.wPageOffset]		; AX = Video RAM offset
    85 0000030F A35404              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], ax
    86 00000312 97                  <2> 	xchg	di, ax
    87 00000313 C3                  <2> 	ret
    88                              <2> 
    89                              <2> 
    90                              <2> ;--------------------------------------------------------------------
    91                              <2> ; DisplayCursor_GetSoftwareCoordinatesToAX
    92                              <2> ;	Parameters:
    93                              <2> ;		AX:		Offset to cursor location in selected page
    94                              <2> ;		DS:		BDA segment (zero)
    95                              <2> ;	Returns:
    96                              <2> ;		AL:		Cursor column (X-coordinate)
    97                              <2> ;		AH:		Cursor row (Y-coordinate)
    98                              <2> ;	Corrupts registers:
    99                              <2> ;		Nothing
   100                              <2> ;--------------------------------------------------------------------
   101                              <2> ALIGN DISPLAY_JUMP_ALIGN
   102                              <2> DisplayCursor_GetSoftwareCoordinatesToAX:
   103 00000314 A15404              <2> 	mov		ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
   104 00000317 2B064E04            <2> 	sub		ax, [VIDEO_BDA.wPageOffset]
   105 0000031B D1E8                <2> 	shr		ax, 1							; WORD offset to character offset
   106 0000031D F6364A04            <2> 	div		BYTE [VIDEO_BDA.wColumns]		; AL = full rows, AH = column index for last row
   107 00000321 86C4                <2> 	xchg	al, ah
   108 00000323 C3                  <2> 	ret
   109                              <2> 
   110                              <2> 
   111                              <2> ;--------------------------------------------------------------------
   112                              <2> ; DisplayCursor_GetHardwareCoordinatesToAX
   113                              <2> ;	Parameters:
   114                              <2> ;		DS:		BDA segment (zero)
   115                              <2> ;	Returns:
   116                              <2> ;		AL:		Hardware cursor column (X-coordinate)
   117                              <2> ;		AH:		Hardware cursor row (Y-coordinate)
   118                              <2> ;	Corrupts registers:
   119                              <2> ;		DX
   120                              <2> ;--------------------------------------------------------------------
   121                              <2> ALIGN DISPLAY_JUMP_ALIGN
   122                              <2> DisplayCursor_GetHardwareCoordinatesToAX:
   123 00000324 51                  <2> 	push	cx
   124 00000325 53                  <2> 	push	bx
   125                              <2> 
   126 00000326 B403                <2> 	mov		ah, GET_CURSOR_POSITION_AND_SIZE
   127 00000328 8A3E6204            <2> 	mov		bh, [VIDEO_BDA.bActivePage]
   128 0000032C CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
   129 0000032E 92                  <2> 	xchg	ax, dx
   130                              <2> 
   131 0000032F 5B                  <2> 	pop		bx
   132 00000330 59                  <2> 	pop		cx
   133 00000331 C3                  <2> 	ret
   134                              <2> 
   135                              <2> 
   136                              <2> ;--------------------------------------------------------------------
   137                              <2> ; DisplayCursor_SynchronizeShapeToHardware
   138                              <2> ;	Parameters:
   139                              <2> ;		DS:		BDA segment (zero)
   140                              <2> ;	Returns:
   141                              <2> ;		Nothing
   142                              <2> ;	Corrupts registers:
   143                              <2> ;		AX, DX
   144                              <2> ;--------------------------------------------------------------------
   145                              <2> ALIGN DISPLAY_JUMP_ALIGN
   146                              <2> DisplayCursor_SynchronizeShapeToHardware:
   147 00000332 8B165C04            <2> 	mov		dx, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCursorShape]
   148                              <2> 	; Fall to .SetHardwareCursorShapeFromDX
   149                              <2> 
   150                              <2> ;--------------------------------------------------------------------
   151                              <2> ; .SetHardwareCursorShapeFromDX
   152                              <2> ;	Parameters:
   153                              <2> ;		DX:		Cursor shape
   154                              <2> ;		DS:		BDA segment (zero)
   155                              <2> ;	Returns:
   156                              <2> ;		Nothing
   157                              <2> ;	Corrupts registers:
   158                              <2> ;		AX
   159                              <2> ;--------------------------------------------------------------------
   160                              <2> .SetHardwareCursorShapeFromDX:
   161 00000336 3B166004            <2> 	cmp		dx, [VIDEO_BDA.wCursorShape]
   162 0000033A 740B                <2> 	je		SHORT .Return					; Return if no changes
   163 0000033C 51                  <2> 	push	cx
   164 0000033D 89D1                <2> 	mov		cx, dx							; BIOS wants cursor shape in CX
   165 0000033F A04904              <2> 	mov		al, [VIDEO_BDA.bMode]			; Load video mode to prevent lock ups on some BIOSes
   166 00000342 B401                <2> 	mov		ah, SET_TEXT_MODE_CURSOR_SHAPE
   167 00000344 CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
   168 00000346 59                  <2> 	pop		cx
   169                              <2> .Return:
   170 00000347 C3                  <2> 	ret
   171                              <2> 
   172                              <2> 
   173                              <2> ;--------------------------------------------------------------------
   174                              <2> ; DisplayCursor_SynchronizeCoordinatesToHardware
   175                              <2> ;	Parameters:
   176                              <2> ;		DS:		BDA segment (zero)
   177                              <2> ;	Returns:
   178                              <2> ;		Nothing
   179                              <2> ;	Corrupts registers:
   180                              <2> ;		AX, DX
   181                              <2> ;--------------------------------------------------------------------
   182                              <2> ALIGN DISPLAY_JUMP_ALIGN
   183                              <2> DisplayCursor_SynchronizeCoordinatesToHardware:
   184 00000348 E8C9FF              <2> 	call	DisplayCursor_GetSoftwareCoordinatesToAX
   185                              <2> 	; Fall to .SetHardwareCursorCoordinatesFromAX
   186                              <2> 
   187                              <2> ;--------------------------------------------------------------------
   188                              <2> ; .SetHardwareCursorCoordinatesFromAX
   189                              <2> ;	Parameters:
   190                              <2> ;		AL:		Cursor column (X-coordinate)
   191                              <2> ;		AH:		Cursor row (Y-coordinate)
   192                              <2> ;		DS:		BDA segment (zero)
   193                              <2> ;	Returns:
   194                              <2> ;		Nothing
   195                              <2> ;	Corrupts registers:
   196                              <2> ;		AX, DX
   197                              <2> ;--------------------------------------------------------------------
   198                              <2> .SetHardwareCursorCoordinatesFromAX:
   199 0000034B 53                  <2> 	push	bx
   200 0000034C 92                  <2> 	xchg	dx, ax							; BIOS wants coordinates in DX
   201 0000034D B402                <2> 	mov		ah, SET_CURSOR_POSITION
   202 0000034F 8A3E6204            <2> 	mov		bh, [VIDEO_BDA.bActivePage]
   203 00000353 CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
   204 00000355 5B                  <2> 	pop		bx
   205 00000356 C3                  <2> 	ret
    33                              <1> 	%include "DisplayPage.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for managing display page.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools 
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ; 
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.		
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> ; Section containing code
    21                              <2> SECTION .text
    22                              <2> 
    23                              <2> ;--------------------------------------------------------------------
    24                              <2> ; DisplayPage_SetFromAL
    25                              <2> ;	Parameters:
    26                              <2> ;		AL:		New display page
    27                              <2> ;		DS:		BDA segment (zero)
    28                              <2> ;	Returns:
    29                              <2> ;		Nothing
    30                              <2> ;	Corrupts registers:
    31                              <2> ;		AX, DX
    32                              <2> ;--------------------------------------------------------------------
    33                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
    34                              <2> ALIGN DISPLAY_JUMP_ALIGN
    35                              <2> DisplayPage_SetFromAL:
    36                              <2> 	xor		ah, ah
    37                              <2> 	mul		WORD [VIDEO_BDA.wBytesPerPage]		; AX = Offset to page
    38                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], ax
    39                              <2> 	ret
    40                              <2> %endif
    41                              <2> 
    42                              <2> 
    43                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    44                              <2> 	%define EXCLUDE
    45                              <2> 	%ifdef MODULE_HOTKEYS
    46                              <2> 		%undef EXCLUDE
    47                              <2> 	%endif
    48                              <2> 	%ifdef MODULE_BOOT_MENU
    49                              <2> 		%undef EXCLUDE
    50                              <2> 	%endif
    51                              <2> %endif
    52                              <2> 
    53                              <2> %ifndef EXCLUDE		
    54                              <2> ;--------------------------------------------------------------------
    55                              <2> ; DisplayPage_GetColumnsToALandRowsToAH
    56                              <2> ;	Parameters:
    57                              <2> ;		DS:		BDA segment (zero)
    58                              <2> ;	Returns:
    59                              <2> ;		AL:		Number of columns in selected text mode
    60                              <2> ;		AH:		Number of rows in selected text mode
    61                              <2> ;	Corrupts registers:
    62                              <2> ;		Nothing
    63                              <2> ;--------------------------------------------------------------------
    64                              <2> ALIGN DISPLAY_JUMP_ALIGN
    65                              <2> DisplayPage_GetColumnsToALandRowsToAH:
    66 00000357 A04A04              <2> 	mov		al, [VIDEO_BDA.wColumns]		; 40 or 80
    67 0000035A B419                <2> 	mov		ah, 25							; Always 25 rows on standard text modes
    68 0000035C C3                  <2> 	ret
    69                              <2> %endif
    70                              <2> %undef EXCLUDE		
    71                              <2> 
    72                              <2> ;--------------------------------------------------------------------
    73                              <2> ; DisplayPage_SynchronizeToHardware
    74                              <2> ;	Parameters:
    75                              <2> ;		DS:		BDA segment (zero)
    76                              <2> ;	Returns:
    77                              <2> ;		Nothing
    78                              <2> ;	Corrupts registers:
    79                              <2> ;		AX, DX
    80                              <2> ;--------------------------------------------------------------------
    81                              <2> ALIGN DISPLAY_JUMP_ALIGN
    82                              <2> DisplayPage_SynchronizeToHardware:
    83 0000035D 31D2                <2> 	xor		dx, dx
    84 0000035F A15404              <2> 	mov		ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
    85 00000362 F7364C04            <2> 	div		WORD [VIDEO_BDA.wBytesPerPage]	; AX = Page
    86                              <2> 
    87 00000366 3A066204            <2> 	cmp		al, [VIDEO_BDA.bActivePage]
    88 0000036A 7404                <2> 	je		SHORT .Return					; Same page, no need to synchronize
    89 0000036C B405                <2> 	mov		ah, SELECT_ACTIVE_DISPLAY_PAGE
    90 0000036E CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
    91                              <2> .Return:
    92 00000370 C3                  <2> 	ret
    34                              <1> 	%include "DisplayPrint.asm"					; must come before DisplayFormat/DisplayFormatCompressed
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for display output.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> ; Section containing code
    21                              <2> SECTION .text
    22                              <2> 
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; Supports following formatting types:
    26                              <2> ;	%a		Specifies attribute for next character
    27                              <2> ;	%A		Specifies attribute for remaining string (or until next %A)
    28                              <2> ;	%d		Prints signed 16-bit decimal integer
    29                              <2> ;	%u		Prints unsigned 16-bit decimal integer
    30                              <2> ;	%x		Prints 16-bit hexadecimal integer
    31                              <2> ;	%s		Prints string (from CS segment)
    32                              <2> ;	%S		Prints string (far pointer)
    33                              <2> ;	%c		Prints character
    34                              <2> ;	%t		Prints character number of times (character needs to be pushed first, then repeat times)
    35                              <2> ;	%%		Prints '%' character (no parameter pushed)
    36                              <2> ;
    37                              <2> ;	Any placeholder can be set to minimum length by specifying
    38                              <2> ;	minimum number of characters. For example %8d would append spaces
    39                              <2> ;	after integer so that at least 8 characters would be printed.
    40                              <2> ;
    41                              <2> ;	When placing '-' after number, then spaces will be used for prepending.
    42                              <2> ;	For example %8-d would prepend integer with spaces so that at least
    43                              <2> ;	8 characters would be printed.
    44                              <2> ;
    45                              <2> ; DisplayPrint_FormattedNullTerminatedStringFromCSSI
    46                              <2> ;	Parameters:
    47                              <2> ;		BP:		SP before pushing parameters
    48                              <2> ;		DS:		BDA segment (zero)
    49                              <2> ;		CS:SI:	Pointer to string to format
    50                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
    51                              <2> ;		Stack:	Parameters for formatting placeholders.
    52                              <2> ;				Parameter for first placeholder must be pushed first.
    53                              <2> ;				Low word must pushed first for placeholders requiring
    54                              <2> ;				32-bit parameters (two words).
    55                              <2> ;	Returns:
    56                              <2> ;		DI:		Updated offset to video RAM
    57                              <2> ;	Corrupts registers:
    58                              <2> ;		AX, DX
    59                              <2> ;--------------------------------------------------------------------
    60                              <2> ALIGN DISPLAY_JUMP_ALIGN
    61                              <2> DisplayPrint_FormattedNullTerminatedStringFromCSSI:
    62 00000371 55                  <2> 	push	bp
    63 00000372 56                  <2> 	push	si
    64 00000373 51                  <2> 	push	cx
    65 00000374 53                  <2> 	push	bx
    66 00000375 FF365E04            <2> 	push	WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute]
    67                              <2> 
    68 00000379 4D                  <2> 	dec		bp					; Point BP to...
    69 0000037A 4D                  <2> 	dec		bp					; ...first stack parameter
    70 0000037B E89A00              <2> 	call	DisplayFormat_ParseCharacters
    71                              <2> 
    72                              <2> 	; Pop original character attribute
    73 0000037E 58                  <2> 	pop		ax
    74 0000037F A25E04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], al
    75                              <2> 
    76 00000382 5B                  <2> 	pop		bx
    77 00000383 59                  <2> 	pop		cx
    78 00000384 5E                  <2> 	pop		si
    79 00000385 5D                  <2> 	pop		bp
    80                              <2> 
    81 00000386 C3                  <2> 	ret
    82                              <2> 
    83                              <2> 
    84                              <2> ;--------------------------------------------------------------------
    85                              <2> ; DisplayPrint_SignedWordFromAXWithBaseInBX
    86                              <2> ;	Parameters:
    87                              <2> ;		AX:		Word to display
    88                              <2> ;		BX:		Integer base (binary=2, octal=8, decimal=10, hexadecimal=16)
    89                              <2> ;		DS:		BDA segment (zero)
    90                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
    91                              <2> ;	Returns:
    92                              <2> ;		DI:		Updated offset to video RAM
    93                              <2> ;	Corrupts registers:
    94                              <2> ;		AX, DX
    95                              <2> ;--------------------------------------------------------------------
    96                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    97                              <2> ALIGN DISPLAY_JUMP_ALIGN
    98                              <2> DisplayPrint_SignedWordFromAXWithBaseInBX:
    99                              <2> 	test	ax, ax
   100                              <2> 	jns		SHORT DisplayPrint_WordFromAXWithBaseInBX
   101                              <2> 
   102                              <2> 	push	ax
   103                              <2> 	mov		al, '-'
   104                              <2> 	call	DisplayPrint_CharacterFromAL
   105                              <2> 	pop		ax
   106                              <2> 	neg		ax
   107                              <2> 	; Fall to DisplayPrint_WordFromAXWithBaseInBX
   108                              <2> %endif
   109                              <2> 
   110                              <2> 
   111                              <2> ;--------------------------------------------------------------------
   112                              <2> ; DisplayPrint_WordFromAXWithBaseInBX
   113                              <2> ;	Parameters:
   114                              <2> ;		AX:		Word to display
   115                              <2> ;		BX:		Integer base (binary=2, octal=8, decimal=10, hexadecimal=16)
   116                              <2> ;		DS:		BDA segment (zero)
   117                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   118                              <2> ;	Returns:
   119                              <2> ;		DI:		Updated offset to video RAM
   120                              <2> ;	Corrupts registers:
   121                              <2> ;		AX, DX
   122                              <2> ;--------------------------------------------------------------------
   123                              <2> %ifndef MODULE_STRINGS_COMPRESSED
   124                              <2> ALIGN DISPLAY_JUMP_ALIGN
   125                              <2> DisplayPrint_WordFromAXWithBaseInBX:
   126                              <2> 	push	cx
   127                              <2> 	push	bx
   128                              <2> 
   129                              <2> 	xor		cx, cx
   130                              <2> ALIGN DISPLAY_JUMP_ALIGN
   131                              <2> .DivideLoop:
   132                              <2> 	xor		dx, dx				; DX:AX now holds the integer
   133                              <2> 	div		bx					; Divide DX:AX by base
   134                              <2> 	push	dx					; Push remainder
   135                              <2> 	inc		cx					; Increment character count
   136                              <2> 	test	ax, ax				; All divided?
   137                              <2> 	jnz		SHORT .DivideLoop	;  If not, loop
   138                              <2> 
   139                              <2> PrintAllPushedDigits:
   140                              <2> 	mov		bx, g_rgcDigitToCharacter
   141                              <2> ALIGN DISPLAY_JUMP_ALIGN
   142                              <2> .PrintNextDigit:
   143                              <2> 	pop		ax					; Pop digit
   144                              <2> 	cs xlatb
   145                              <2> 	call	DisplayPrint_CharacterFromAL
   146                              <2> 	loop	.PrintNextDigit
   147                              <2> 
   148                              <2> 	pop		bx
   149                              <2> 	pop		cx
   150                              <2> 	ret
   151                              <2> 
   152                              <2> g_rgcDigitToCharacter:	db	"0123456789ABCDEF"
   153                              <2> 
   154                              <2> %endif ; MODULE_STRINGS_COMPRESSED
   155                              <2> 
   156                              <2> ;--------------------------------------------------------------------
   157                              <2> ; DisplayPrint_QWordFromSSBPwithBaseInBX
   158                              <2> ;	Parameters:
   159                              <2> ;		SS:BP:	QWord to display
   160                              <2> ;		BX:		Integer base (binary=2, octal=8, decimal=10, hexadecimal=16)
   161                              <2> ;		DS:		BDA segment (zero)
   162                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   163                              <2> ;	Returns:
   164                              <2> ;		DI:		Updated offset to video RAM
   165                              <2> ;	Corrupts registers:
   166                              <2> ;		AX, DX, [SS:BP]
   167                              <2> ;--------------------------------------------------------------------
   168                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
   169                              <2> ALIGN DISPLAY_JUMP_ALIGN
   170                              <2> DisplayPrint_QWordFromSSBPwithBaseInBX:
   171                              <2> 	push	cx
   172                              <2> 	push	bx
   173                              <2> 
   174                              <2> 	mov		cx, bx				; CX = Integer base
   175                              <2> 	xor		bx, bx				; BX = Character count
   176                              <2> ALIGN DISPLAY_JUMP_ALIGN
   177                              <2> .DivideLoop:
   178                              <2> 	call	Math_DivQWatSSBPbyCX; Divide by base
   179                              <2> 	push	dx					; Push remainder
   180                              <2> 	inc		bx					; Increment character count
   181                              <2> 	cmp		WORD [bp], BYTE 0	; All divided?
   182                              <2> 	jne		SHORT .DivideLoop	;  If not, loop
   183                              <2> 	mov		cx, bx				; Character count to CX
   184                              <2> 	jmp		SHORT PrintAllPushedDigits
   185                              <2> %endif
   186                              <2> 
   187                              <2> 
   188                              <2> ;--------------------------------------------------------------------
   189                              <2> ; DisplayPrint_CharacterBufferFromBXSIwithLengthInCX
   190                              <2> ;	Parameters:
   191                              <2> ;		CX:		Buffer length (characters)
   192                              <2> ;		BX:SI:	Ptr to NULL terminated string
   193                              <2> ;		DS:		BDA segment (zero)
   194                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   195                              <2> ;	Returns:
   196                              <2> ;		DI:		Updated offset to video RAM
   197                              <2> ;	Corrupts registers:
   198                              <2> ;		AX, DX
   199                              <2> ;--------------------------------------------------------------------
   200                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   201                              <2> ALIGN DISPLAY_JUMP_ALIGN
   202                              <2> DisplayPrint_CharacterBufferFromBXSIwithLengthInCX:
   203                              <2> 	jcxz	.NothingToPrintSinceZeroLength
   204                              <2> 	push	si
   205                              <2> 	push	cx
   206                              <2> 
   207                              <2> ALIGN DISPLAY_JUMP_ALIGN
   208                              <2> .PrintNextCharacter:
   209                              <2> 	mov		ds, bx
   210                              <2> 	lodsb
   211                              <2> 	LOAD_BDA_SEGMENT_TO	ds, dx
   212                              <2> 	call	DisplayPrint_CharacterFromAL
   213                              <2> 	loop	.PrintNextCharacter
   214                              <2> 
   215                              <2> 	pop		cx
   216                              <2> 	pop		si
   217                              <2> .NothingToPrintSinceZeroLength:
   218                              <2> 	ret
   219                              <2> %endif
   220                              <2> 
   221                              <2> 
   222                              <2> ;--------------------------------------------------------------------
   223                              <2> ; DisplayPrint_ClearScreenWithCharInALandAttributeInAH
   224                              <2> ;	Parameters:
   225                              <2> ;		AL:		Character to clear with
   226                              <2> ;		AH:		Attribute to clear with
   227                              <2> ;		DS:		BDA segment (zero)
   228                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   229                              <2> ;	Returns:
   230                              <2> ;		Nothing
   231                              <2> ;	Corrupts registers:
   232                              <2> ;		AX, DX
   233                              <2> ;--------------------------------------------------------------------
   234                              <2> %ifdef INCLUDE_MENU_LIBRARY
   235                              <2> ALIGN DISPLAY_JUMP_ALIGN
   236                              <2> DisplayPrint_ClearScreenWithCharInALandAttributeInAH:
   237 00000387 57                  <2> 	push	di
   238 00000388 51                  <2> 	push	cx
   239                              <2> 
   240 00000389 91                  <2> 	xchg	cx, ax
   241 0000038A 31C0                <2> 	xor		ax, ax
   242 0000038C E870FF              <2> 	call	DisplayCursor_SetCoordinatesFromAX		; Updates DI
   243 0000038F E8C5FF              <2> 	call	DisplayPage_GetColumnsToALandRowsToAH
   244 00000392 F6E4                <2> 	mul		ah		; AX = AL*AH = Characters on screen
   245 00000394 91                  <2> 	xchg	cx, ax	; AX = Char+Attr, CX = WORDs to store
   246 00000395 F3AB                <2> 	rep stosw
   247                              <2> 
   248 00000397 59                  <2> 	pop		cx
   249 00000398 5F                  <2> 	pop		di
   250 00000399 893E5404            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], di
   251 0000039D C3                  <2> 	ret
   252                              <2> %endif
   253                              <2> 
   254                              <2> 
   255                              <2> ;--------------------------------------------------------------------
   256                              <2> ; DisplayPrint_ClearAreaWithHeightInAHandWidthInAL
   257                              <2> ;	Parameters:
   258                              <2> ;		AH:		Area height
   259                              <2> ;		AL:		Area width
   260                              <2> ;		DS:		BDA segment (zero)
   261                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   262                              <2> ;	Returns:
   263                              <2> ;		DI:		Updated offset to video RAM
   264                              <2> ;	Corrupts registers:
   265                              <2> ;		AX, DX
   266                              <2> ;--------------------------------------------------------------------
   267                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   268                              <2> ALIGN DISPLAY_JUMP_ALIGN
   269                              <2> DisplayPrint_ClearAreaWithHeightInAHandWidthInAL:
   270                              <2> 	push	si
   271                              <2> 	push	cx
   272                              <2> 	push	bx
   273                              <2> 
   274                              <2> 	xchg	bx, ax							; Area size to BX
   275                              <2> 	call	DisplayCursor_GetSoftwareCoordinatesToAX
   276                              <2> 	xchg	si, ax							; Software (Y,X) coordinates now in SI
   277                              <2> 	xor		cx, cx
   278                              <2> 
   279                              <2> ALIGN DISPLAY_JUMP_ALIGN
   280                              <2> .ClearRowLoop:
   281                              <2> 	mov		cl, bl							; Area width now in CX
   282                              <2> 	mov		al, SCREEN_BACKGROUND_CHARACTER
   283                              <2> 	call	DisplayPrint_RepeatCharacterFromALwithCountInCX
   284                              <2> 
   285                              <2> 	xchg	ax, si							; Coordinates to AX
   286                              <2> 	inc		ah								; Increment row
   287                              <2> 	mov		si, ax
   288                              <2> 	call	DisplayCursor_SetCoordinatesFromAX
   289                              <2> 	dec		bh								; Decrement rows left
   290                              <2> 	jnz		SHORT .ClearRowLoop
   291                              <2> 
   292                              <2> 	pop		bx
   293                              <2> 	pop		cx
   294                              <2> 	pop		si
   295                              <2> 	ret
   296                              <2> %endif
   297                              <2> 
   298                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   299                              <2> 	%define EXCLUDE
   300                              <2> 	%ifdef MODULE_HOTKEYS
   301                              <2> 		%undef EXCLUDE
   302                              <2> 	%endif
   303                              <2> 	%ifdef MODULE_BOOT_MENU
   304                              <2> 		%undef EXCLUDE
   305                              <2> 	%endif
   306                              <2> %endif
   307                              <2> 
   308                              <2> %ifndef EXCLUDE
   309                              <2> ;--------------------------------------------------------------------
   310                              <2> ; DisplayPrint_RepeatCharacterFromALwithCountInCX
   311                              <2> ;	Parameters:
   312                              <2> ;		AL:		Character to display
   313                              <2> ;		CX:		Repeat count
   314                              <2> ;		DS:		BDA segment (zero)
   315                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   316                              <2> ;	Returns:
   317                              <2> ;		DI:		Updated offset to video RAM
   318                              <2> ;	Corrupts registers:
   319                              <2> ;		DX
   320                              <2> ;--------------------------------------------------------------------
   321                              <2> ALIGN DISPLAY_JUMP_ALIGN
   322                              <2> DisplayPrint_RepeatCharacterFromALwithCountInCX:
   323 0000039E E309                <2> 	jcxz	.NothingToRepeat
   324 000003A0 51                  <2> 	push	cx
   325                              <2> 
   326                              <2> ALIGN DISPLAY_JUMP_ALIGN
   327                              <2> .RepeatCharacter:
   328 000003A1 50                  <2> 	push	ax
   329 000003A2 E80E00              <2> 	call	DisplayPrint_CharacterFromAL
   330 000003A5 58                  <2> 	pop		ax
   331 000003A6 E2F9                <2> 	loop	.RepeatCharacter
   332                              <2> 
   333 000003A8 59                  <2> 	pop		cx
   334                              <2> .NothingToRepeat:
   335 000003A9 C3                  <2> 	ret
   336                              <2> %endif
   337                              <2> %undef EXCLUDE
   338                              <2> 
   339                              <2> ;--------------------------------------------------------------------
   340                              <2> ; DisplayPrint_NullTerminatedStringFromCSSI
   341                              <2> ;	Parameters:
   342                              <2> ;		CS:SI:	Ptr to NULL terminated string
   343                              <2> ;		DS:		BDA segment (zero)
   344                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   345                              <2> ;	Returns:
   346                              <2> ;		DI:		Updated offset to video RAM
   347                              <2> ;	Corrupts registers:
   348                              <2> ;		AX, DX
   349                              <2> ;--------------------------------------------------------------------
   350                              <2> %ifndef MODULE_STRINGS_COMPRESSED
   351                              <2> ;;;
   352                              <2> ;;; Take care when using this routine with compressed strings (which is why it is disabled).
   353                              <2> ;;; All strings in CSSI should go through the DisplayFormatCompressed code to be decoded.
   354                              <2> ;;;
   355                              <2> ALIGN DISPLAY_JUMP_ALIGN
   356                              <2> DisplayPrint_NullTerminatedStringFromCSSI:
   357                              <2> 	push	bx
   358                              <2> 	mov		bx, cs
   359                              <2> 	call	DisplayPrint_NullTerminatedStringFromBXSI
   360                              <2> 	pop		bx
   361                              <2> 	ret
   362                              <2> %endif
   363                              <2> 
   364                              <2> 
   365                              <2> ;;;
   366                              <2> ;;; Note that the following routines need to be at the bottom of this file
   367                              <2> ;;; to accomodate short jumps from the next file (DisplayFormat/DisplayFormatCompressed)
   368                              <2> ;;;
   369                              <2> 
   370                              <2> ;--------------------------------------------------------------------
   371                              <2> ; DisplayPrint_Newline
   372                              <2> ;	Parameters:
   373                              <2> ;		DS:		BDA segment (zero)
   374                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   375                              <2> ;	Returns:
   376                              <2> ;		DI:		Updated offset to video RAM
   377                              <2> ;	Corrupts registers:
   378                              <2> ;		AX, DX
   379                              <2> ;--------------------------------------------------------------------
   380                              <2> %ifdef MODULE_STRINGS_COMPRESSED
   381                              <2> ALIGN DISPLAY_JUMP_ALIGN
   382                              <2> DisplayPrint_Newline_FormatAdjustBP:
   383 000003AA 45                  <2> 	inc		bp					; we didn't need a parameter after all, readjust BP
   384 000003AB 45                  <2> 	inc		bp
   385                              <2> 	; fall through to DisplayPrint_Newline
   386                              <2> %endif
   387                              <2> 
   388                              <2> ALIGN DISPLAY_JUMP_ALIGN
   389                              <2> DisplayPrint_Newline:
   390 000003AC B00A                <2> 	mov		al, LF
   391 000003AE E80200              <2> 	call	DisplayPrint_CharacterFromAL
   392 000003B1 B00D                <2> 	mov		al, CR
   393                              <2> 	; Fall to DisplayPrint_CharacterFromAL
   394                              <2> 
   395                              <2> ;--------------------------------------------------------------------
   396                              <2> ; DisplayPrint_CharacterFromAL
   397                              <2> ;	Parameters:
   398                              <2> ;		AL:		Character to display
   399                              <2> ;               Zero value is ignored (no character is printed)
   400                              <2> ;		DS:		BDA segment (zero)
   401                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   402                              <2> ;	Returns:
   403                              <2> ;		DI:		Updated offset to video RAM
   404                              <2> ;	Corrupts registers:
   405                              <2> ;		AX, DX
   406                              <2> ;--------------------------------------------------------------------
   407                              <2> ALIGN DISPLAY_JUMP_ALIGN
   408                              <2> DisplayPrint_CharacterFromAL:
   409 000003B3 84C0                <2> 	test	al, al
   410 000003B5 741C                <2> 	jz		DisplayPrint_Ret
   411                              <2> 
   412 000003B7 8A265E04            <2> 	mov		ah, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute]
   413 000003BB FF265804            <2> 	jmp		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fnCharOut]
   414                              <2> 
   415                              <2> 
   416                              <2> ;--------------------------------------------------------------------
   417                              <2> ; DisplayPrint_NullTerminatedStringFromBXSI
   418                              <2> ;	Parameters:
   419                              <2> ;		DS:		BDA segment (zero)
   420                              <2> ;		BX:SI:	Ptr to NULL terminated string
   421                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   422                              <2> ;	Returns:
   423                              <2> ;		DI:		Updated offset to video RAM
   424                              <2> ;	Corrupts registers:
   425                              <2> ;		AX, DX
   426                              <2> ;--------------------------------------------------------------------
   427                              <2> ALIGN DISPLAY_JUMP_ALIGN
   428                              <2> DisplayPrint_NullTerminatedStringFromBXSI:
   429 000003BF 56                  <2> 	push	si
   430 000003C0 51                  <2> 	push	cx
   431                              <2> 
   432 000003C1 31C9                <2> 	xor		cx, cx
   433                              <2> ALIGN DISPLAY_JUMP_ALIGN
   434                              <2> .PrintNextCharacter:
   435 000003C3 8EDB                <2> 	mov		ds, bx				; String segment to DS
   436 000003C5 AC                  <2> 	lodsb
   437 000003C6 8ED9                <2> 	mov		ds, cx				; BDA segment to DS
   438 000003C8 84C0                <2> 	test	al, al				; NULL?
   439 000003CA 7405                <2> 	jz		SHORT .EndOfString
   440 000003CC E8E4FF              <2> 	call	DisplayPrint_CharacterFromAL
   441 000003CF EBF2                <2> 	jmp		SHORT .PrintNextCharacter
   442                              <2> 
   443                              <2> ALIGN DISPLAY_JUMP_ALIGN
   444                              <2> .EndOfString:
   445 000003D1 59                  <2> 	pop		cx
   446 000003D2 5E                  <2> 	pop		si
   447                              <2> 
   448                              <2> DisplayPrint_Ret:				; random ret to jump to
   449 000003D3 C3                  <2> 	ret
   450                              <2> 
    35                              <1> %ifdef MODULE_STRINGS_COMPRESSED
    36                              <1> 	%include "DisplayFormatCompressed.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for displaying formatted strings.
     3                              <2> ;					** Compressed Strings edition **
     4                              <2> ;					This is a plug replacement for DisplayFormat.asm,
     5                              <2> ;					working instead with precompiled and slightly compressed strings.
     6                              <2> 
     7                              <2> ;
     8                              <2> ; XTIDE Universal BIOS and Associated Tools
     9                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
    10                              <2> ;
    11                              <2> ; This program is free software; you can redistribute it and/or modify
    12                              <2> ; it under the terms of the GNU General Public License as published by
    13                              <2> ; the Free Software Foundation; either version 2 of the License, or
    14                              <2> ; (at your option) any later version.
    15                              <2> ;
    16                              <2> ; This program is distributed in the hope that it will be useful,
    17                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <2> ; GNU General Public License for more details.
    20                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    21                              <2> ;
    22                              <2> 
    23                              <2> ;=============================================================================================
    24                              <2> ;
    25                              <2> ; Strings are compressed in a simple manner:
    26                              <2> ;	1. The two most common characters, space and null, are removed
    27                              <2> ;	2. Format specifiers are reduced to a single byte, including length information
    28                              <2> ;
    29                              <2> ; Format of bytes in the string are:
    30                              <2> ;     01 xxxxxx     Character in x plus StringsCompressed_NormalBase
    31                              <2> ;     10 xxxxxx     Character in x plus StringsCompressed_NormalBase, followed by a null (last character)
    32                              <2> ;     11 xxxxxx     Character in x plus StringsCompressed_NormalBase, followed by a space
    33                              <2> ;     00 1 yyyyy    Character/Format in lookup table StringsCopmressed_TranslatesAndFormats
    34                              <2> ;     00 0 yyyyy    Character/Format in lookup table StringsCompressed_TranslatesAndFormats, followed by a null
    35                              <2> ;
    36                              <2> ; StringsCompressed_NormalBase is defined by the compressor, but is usually around 0x40,
    37                              <2> ; which gives a range of 0x40 to 0x7f, or roughly the upper and lower case letters.
    38                              <2> ;
    39                              <2> ; StringsCompressed_TranslatesAndFormats is a lookup table with the first few bytes being translation
    40                              <2> ; characters, and the last few bytes being format jump offsets from DisplayFormatCompressed_BaseFormatOffset.
    41                              <2> ; The dividing line is defined by StringsCompressed_FormatsBegin
    42                              <2> ;
    43                              <2> ; The assignments of the first two bits above is not by accident.  The translates/format branch is 00
    44                              <2> ; which is easy to test for.  The '01' for "normal" (no null or space) and '001' for translates/format "normal"
    45                              <2> ; match, allowing the translates/format codes to be shifted left by 1 and then tested with the same instructions.
    46                              <2> ;
    47                              <2> ; It is always possible to say that a null character follows the current character - thus there is
    48                              <2> ; no way (nor need) to specify a zero character.
    49                              <2> ;
    50                              <2> ; Note that this code is optimized for size, not speed.  Since this code is used only during initialization
    51                              <2> ; and only for the user interface, small performance hits should not be noticed.  It will seem odd to do so
    52                              <2> ; much "preload", just in case a branch is taken, but that is cheaper (in size) than adding additional branches.
    53                              <2> ;
    54                              <2> 
    55                              <2> ; Section containing code
    56                              <2> SECTION .text
    57                              <2> 
    58                              <2> ;--------------------------------------------------------------------
    59                              <2> ; Format Handlers
    60                              <2> ;
    61                              <2> ; Names of format handlers are DisplayFormatCompressed_Format_* where * is
    62                              <2> ; replaced with the format code after the '%' in the original string,
    63                              <2> ; with '-' replaced with '_'.
    64                              <2> ;
    65                              <2> ;	Parameters:
    66                              <2> ;		DS:		BDA segment (zero)
    67                              <2> ;		AX:     Parameter to Format
    68                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
    69                              <2> ;	Returns:
    70                              <2> ;		DI:		Updated offset to video RAM
    71                              <2> ;	Corrupts registers:
    72                              <2> ;		AX, BX, CX, DX, SI
    73                              <2> ;--------------------------------------------------------------------
    74                              <2> 
    75                              <2> ;
    76                              <2> ; The following routines do not need any pre or post processing and can be jumped to directly.
    77                              <2> ; Note that they need to be within 256 bytes of DisplayFormatCompressed_BaseFormatOffset
    78                              <2> ;
    79                              <2> %define DisplayFormatCompressed_Format_c DisplayPrint_CharacterFromAL
    80                              <2> %define DisplayFormatCompressed_Format_nl DisplayPrint_Newline_FormatAdjustBP
    81                              <2> %define DisplayFormatCompressed_Format_s DisplayFormat_ParseCharacters_FromAX
    82                              <2> 
    83                              <2> DisplayFormatCompressed_Format_A:
    84 000003D4 A25E04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], al
    85                              <2> DisplayFormatCompressed_ret:			; jump target for other routines who need a "ret"
    86 000003D7 C3                  <2> 	ret
    87                              <2> 
    88                              <2> DisplayFormatCompressed_Format_z:
    89 000003D8 31DB                <2> 	xor		bx, bx
    90 000003DA 96                  <2> 	xchg	si, ax
    91 000003DB EBE2                <2> 	jmp		short DisplayPrint_NullTerminatedStringFromBXSI
    92                              <2> 
    93                              <2> DisplayFormatCompressed_Format_x:
    94                              <2> DisplayFormatCompressed_Format_5_x:
    95 000003DD BE1000              <2> 	mov		si,16						; hex output, change base to 16
    96 000003E0 BB6804              <2> 	mov		bx,(04<<8) + 'h'	        ; 4 bytes, with postfix character 'h' to emit
    97                              <2> 										; (note that the count includes the 'h')
    98 000003E3 EB09                <2> 	jmp		DisplayFormatCompressed_Format_u
    99                              <2> 
   100                              <2> DisplayFormatCompressed_Format_2_I:
   101 000003E5 BE[AD00]            <2> 	mov		si,g_szDashForZero			; preload dash string in case we jump
   102 000003E8 85C0                <2> 	test	ax,ax						; if parameter equals zero, emit dash string instead
   103 000003EA 742C                <2> 	jz		DisplayFormat_ParseCharacters
   104                              <2> 	; fall through
   105                              <2> 
   106                              <2> DisplayFormatCompressed_Format_2_u:
   107 000003EC B702                <2> 	mov		bh,2						; only two characters (instead of the default 5)
   108                              <2> 	; fall through
   109                              <2> 
   110                              <2> DisplayFormatCompressed_Format_u:
   111                              <2> DisplayFormatCompressed_Format_5_u:
   112 000003EE 53                  <2> 	push	bx							; push postfix character - either a zero (default) or a 'h'
   113 000003EF 88FB                <2> 	mov		bl,bh						; preserve character count for .PrintLoop
   114                              <2> 
   115                              <2> .DivLoop:
   116 000003F1 31D2                <2> 	xor		dx, dx						; Zero DX for division
   117 000003F3 F7F6                <2> 	div		si							; DX:AX / 10 => AX=quot, DX=rem
   118 000003F5 52                  <2>  	push	dx							; Push digit
   119                              <2> 
   120 000003F6 FECF                <2> 	dec		bh
   121 000003F8 75F7                <2> 	jnz		.DivLoop
   122                              <2> 
   123                              <2> .PrintLoop:
   124 000003FA 58                  <2> 	pop		ax							; Pop digit, postfix character on last iteration
   125                              <2> 
   126 000003FB FECB                <2> 	dec		bl							; on second to last iteration, emit digit whether it is zero or not
   127 000003FD 740D                <2> 	jz		.PrintDigit
   128                              <2> 
   129 000003FF 78B2                <2> 	js		short DisplayPrint_CharacterFromAL	; on last iteration, emit postfix character
   130                              <2> 												; if it is zero, DisplayPrint_CharacterFromAL will not emit
   131                              <2> 
   132 00000401 08C7                <2> 	or		bh, al						; skip leading zeros, bh keeps track if we have emitted anything non-zero
   133 00000403 7507                <2> 	jnz		.PrintDigit					; note that bh starts at zero, from the loop above
   134                              <2> 
   135 00000405 F6C502              <2> 	test	ch,2						; are we padding with leading spaces?
   136 00000408 75F0                <2> 	jnz		.PrintLoop					; test the even/odd of the format byte in the string
   137                              <2> 
   138 0000040A B089                <2> 	mov		al, 89h						; emit space
   139                              <2> 
   140                              <2> .PrintDigit:
   141 0000040C 3C0A                <2> 	cmp		al, 10						; Convert binary digit in AL to ASCII hex digit ('0'-'9' or 'A'-'F')
   142 0000040E 1C69                <2> 	sbb		al, 69h
   143 00000410 2F                  <2> 	das
   144                              <2> 
   145 00000411 E89FFF              <2> 	call	DisplayPrint_CharacterFromAL
   146                              <2> 
   147 00000414 EBE4                <2> 	jmp		.PrintLoop
   148                              <2> 
   149                              <2> 
   150                              <2> ;--------------------------------------------------------------------
   151                              <2> ; DisplayFormat_ParseCharacters
   152                              <2> ;	Parameters:
   153                              <2> ;		DS:		BDA segment (zero)
   154                              <2> ;		SS:BP:	Pointer to first format parameter (-=2 updates to next parameter)
   155                              <2> ;		CS:SI:	Pointer to string to format
   156                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
   157                              <2> ;	Returns:
   158                              <2> ;		CS:SI:	Ptr to end of format string (ptr to one past NULL)
   159                              <2> ;		DI:		Updated offset to video RAM
   160                              <2> ;	Corrupts registers:
   161                              <2> ;		AX, BX, CX, DX, BP
   162                              <2> ;--------------------------------------------------------------------
   163                              <2> 
   164                              <2> DisplayFormatCompressed_BaseFormatOffset:
   165                              <2> 
   166                              <2> DisplayFormat_ParseCharacters_FromAX:
   167 00000416 89C6                <2> 	mov		si,ax
   168                              <2> 	; fall through to DisplayFormat_ParseCharacters
   169                              <2> 
   170                              <2> ALIGN DISPLAY_JUMP_ALIGN
   171                              <2> DisplayFormat_ParseCharacters:
   172                              <2> ;
   173                              <2> ; This routine is used to output all strings from the ROM.  The strings in ROMVARS are not compressed,
   174                              <2> ; and must be handled differently.
   175                              <2> ;
   176 00000418 83FE7F              <2> 	cmp		si,byte 07fh		; well within the boundaries of ROMVARS_size
   177 0000041B 8CCB                <2> 	mov		bx,cs				; preload bx with cs in case we take the following jump
   178 0000041D 72A0                <2> 	jb		short DisplayPrint_NullTerminatedStringFromBXSI
   179                              <2> 
   180                              <2> .decode:
   181 0000041F 2EAC                <2> 	cs lodsb					; load next byte of the string
   182                              <2> 
   183 00000421 88C5                <2> 	mov		ch,al				; save a copy for later processing of high order bits
   184                              <2> 
   185 00000423 A8C0                <2> 	test	al,0c0h				; check for translation/format character
   186 00000425 7414                <2> 	jz		DisplayFormatCompressed_TranslatesAndFormats
   187                              <2> 
   188 00000427 243F                <2> 	and		al,03fh								; "Normal" character, mask off high order bits
   189 00000429 043A                <2> 	add		al,StringsCompressed_NormalBase		; and add character offset (usually around 0x40)
   190                              <2> 
   191                              <2> .output:
   192 0000042B E885FF              <2> 	call 	DisplayPrint_CharacterFromAL
   193                              <2> 
   194                              <2> .process_after_output:
   195                              <2> 	eSHL_IM	ch,1								; check high order bits for end of string or space
   195                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   195                              <3> %ifdef USE_386
   195                              <3>  %if %2 = 1
   195                              <3>  add %1, %1
   195                              <3>  %else
   195                              <3>  eSHIFT_IM %1, %2, shl
   195                              <3>  %endif
   195                              <3> %else
   195                              <3>  eSHIFT_IM %1, %2, shl
   195                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   195                              <4> %ifndef USE_186
   195                              <4>  %ifidni %1, cl
   195                              <4>  times %2 %3 %1, 1
   195                              <4>  %elifidni %1, ch
   195 0000042E D0E5                <4>  times %2 %3 %1, 1
   195                              <4>  %elifidni %1, cx
   195                              <4>  times %2 %3 %1, 1
   195                              <4>  %else
   195                              <4>  %if %2 > 3
   195                              <4>  push cx
   195                              <4>  mov cl, %2
   195                              <4>  %3 %1, cl
   195                              <4>  pop cx
   195                              <4>  %else
   195                              <4>  times %2 %3 %1, 1
   195                              <4>  %endif
   195                              <4>  %endif
   195                              <4> 
   195                              <4> %else
   195                              <4>  %3 %1, %2
   195                              <4> %endif
   195                              <4> %endif
   195                              <3> %endif
   195                              <3> %endif
   196 00000430 79A5                <2> 	jns		short DisplayFormatCompressed_ret
   197 00000432 73EB                <2> 	jnc		.decode
   198 00000434 B020                <2> 	mov		al,' '
   199 00000436 E87AFF              <2> 	call	DisplayPrint_CharacterFromAL
   200 00000439 EBE4                <2> 	jmp		.decode
   201                              <2> 
   202                              <2> 
   203                              <2> ALIGN DISPLAY_JUMP_ALIGN
   204                              <2> DisplayFormatCompressed_TranslatesAndFormats:
   205                              <2> ;
   206                              <2> ; This routine is here (above DisplayFormat_ParseCharacters) to reduce the amount of code between
   207                              <2> ; DisplayFormatCompressed_BaseFormatOffset and jump targets (must fit in 256 bytes)
   208                              <2> ;
   209                              <2> 	eSHL_IM	ch,1				; setup ch for later testing of null in .process_after_output
   209                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   209                              <3> %ifdef USE_386
   209                              <3>  %if %2 = 1
   209                              <3>  add %1, %1
   209                              <3>  %else
   209                              <3>  eSHIFT_IM %1, %2, shl
   209                              <3>  %endif
   209                              <3> %else
   209                              <3>  eSHIFT_IM %1, %2, shl
   209                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   209                              <4> %ifndef USE_186
   209                              <4>  %ifidni %1, cl
   209                              <4>  times %2 %3 %1, 1
   209                              <4>  %elifidni %1, ch
   209 0000043B D0E5                <4>  times %2 %3 %1, 1
   209                              <4>  %elifidni %1, cx
   209                              <4>  times %2 %3 %1, 1
   209                              <4>  %else
   209                              <4>  %if %2 > 3
   209                              <4>  push cx
   209                              <4>  mov cl, %2
   209                              <4>  %3 %1, cl
   209                              <4>  pop cx
   209                              <4>  %else
   209                              <4>  times %2 %3 %1, 1
   209                              <4>  %endif
   209                              <4>  %endif
   209                              <4> 
   209                              <4> %else
   209                              <4>  %3 %1, %2
   209                              <4> %endif
   209                              <4> %endif
   209                              <3> %endif
   209                              <3> %endif
   210 0000043D 83E01F              <2> 	and		ax,0001fh			; also clears AH for addition with BX and DX below
   211                              <2> 
   212 00000440 BB[790A]            <2> 	mov		bx,StringsCompressed_TranslatesAndFormats	; calculate offset of translation/formats offset byte
   213 00000443 01C3                <2> 	add		bx,ax
   214                              <2> 
   215 00000445 3C14                <2> 	cmp		al,StringsCompressed_FormatsBegin			; determine if this is a translation or a format
   216                              <2> 
   217 00000447 2E8A07              <2> 	mov		al,[cs:bx]									; fetch translation/formats byte
   218                              <2> 
   219 0000044A 72DF                <2> 	jb		DisplayFormat_ParseCharacters.output		; check if this a translation or a format
   220                              <2> 														; if it is translation, output and postprocess for eos
   221                              <2> 														; note that the flags for this conditional jump were
   222                              <2> 														; set with the cmp al,StringsCompressed_FormatsBegin
   223                              <2> 
   224 0000044C BA[1604]            <2> 	mov		dx,DisplayFormatCompressed_BaseFormatOffset   ; calculate address to jump to for format handler
   225 0000044F 29C2                <2> 	sub		dx,ax
   226                              <2> 
   227 00000451 8B4600              <2> 	mov		ax,[bp]				; preload ax with parameter
   228 00000454 4D                  <2> 	dec		bp					; if no parameter is needed (format 'nl' for example),
   229 00000455 4D                  <2> 	dec		bp					; the format handler can reincrement bp
   230                              <2> 
   231 00000456 BB0005              <2> 	mov		bx,0500h			; preload bh with 5 decimal places for numeric output
   232                              <2> 								; bl is zero, indicating not to output a 'h' (default base 10)
   233                              <2> 
   234 00000459 56                  <2> 	push	si					; preserve si and cx, in the case of outputing a string
   235 0000045A 51                  <2> 	push	cx
   236                              <2> 
   237 0000045B BE0A00              <2> 	mov		si,10				; preload si with 10 for numeric output (default base 10)
   238                              <2> 
   239 0000045E FFD2                <2> 	call	dx					; call the format routine
   240                              <2> 
   241 00000460 59                  <2> 	pop		cx					; restore cx and si
   242 00000461 5E                  <2> 	pop		si
   243                              <2> 
   244 00000462 EBCA                <2> 	jmp		DisplayFormat_ParseCharacters.process_after_output	; continue postprocessing, check for end of string
   245                              <2> 
    37                              <1> %else
    38                              <1> 	%include "DisplayFormat.asm"
    39                              <1> %endif
    40                              <1> %endif
    41                              <1> 
    42                              <1> %ifdef INCLUDE_FILE_LIBRARY
    43                              <1> 	%include "Directory.asm"
    44                              <1> 	%include "DosCritical.asm"
    45                              <1> 	%include "Drive.asm"
    46                              <1> 	%include "FileIO.asm"
    47                              <1> %endif
    48                              <1> 
    49                              <1> %ifdef INCLUDE_KEYBOARD_LIBRARY
    50                              <1>   %ifndef KEYBOARD_JUMP_ALIGN
    51                              <1> 	%define KEYBOARD_JUMP_ALIGN 1
    52                              <1>   %endif
    53                              <1> 	%include "Keyboard.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for managing keyboard.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools 
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ; 
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.		
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 		
    20                              <2> 
    21                              <2> BUFFER_SIZE_FOR_WORD_INPUT		EQU		6	; 5 chars + NULL
    22                              <2> 
    23                              <2> ; Section containing code
    24                              <2> SECTION .text
    25                              <2> 
    26                              <2> ;--------------------------------------------------------------------
    27                              <2> ; Reads user inputted word.
    28                              <2> ; Function returns when ENTER or ESC will be pressed.
    29                              <2> ;
    30                              <2> ; Keyboard_ReadUserInputtedWordWhilePrinting
    31                              <2> ;	Parameters
    32                              <2> ;		BX:		Numeric base (10 or 16)
    33                              <2> ;	Returns:
    34                              <2> ;		AX:		User inputted word
    35                              <2> ;		ZF:		Set if user cancellation
    36                              <2> ;	Corrupts registers:
    37                              <2> ;		DX
    38                              <2> ;--------------------------------------------------------------------
    39                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    40                              <2> ALIGN KEYBOARD_JUMP_ALIGN
    41                              <2> Keyboard_ReadUserInputtedWordWhilePrinting:
    42                              <2> 	push	ds
    43                              <2> 	push	si
    44                              <2> 	push	cx
    45                              <2> 
    46                              <2> 	mov		cx, BUFFER_SIZE_FOR_WORD_INPUT
    47                              <2> 	call	Memory_ReserveCXbytesFromStackToDSSI
    48                              <2> 
    49                              <2> 	call	Char_GetFilterFunctionToDXforNumericBaseInBX
    50                              <2> 	call	Registers_ExchangeDSSIwithESDI
    51                              <2> 	call	Keyboard_ReadUserInputtedStringToESDIWhilePrinting
    52                              <2> 	call	Registers_ExchangeDSSIwithESDI	; Does not modify FLAGS
    53                              <2> 	jz		SHORT .CancelledByUser
    54                              <2> 
    55                              <2> 	call	String_ConvertWordToAXfromStringInDSSIwithBaseInBX
    56                              <2> .CancelledByUser:
    57                              <2> 	add		sp, BYTE BUFFER_SIZE_FOR_WORD_INPUT
    58                              <2> 	test	cx, cx							; Set ZF if string length is zero
    59                              <2> 	pop		cx
    60                              <2> 	pop		si
    61                              <2> 	pop		ds
    62                              <2> 	ret
    63                              <2> %endif
    64                              <2> 
    65                              <2> 
    66                              <2> ;--------------------------------------------------------------------
    67                              <2> ; Reads user inputted string to buffer. Character filter is
    68                              <2> ; supported to ignore unwanted characters.
    69                              <2> ; Function returns when ENTER or ESC will be pressed.
    70                              <2> ;
    71                              <2> ; Keyboard_ReadUserInputtedStringToESDIWhilePrinting
    72                              <2> ;	Parameters:
    73                              <2> ;		CX:		Buffer size (with NULL)
    74                              <2> ;		ES:DI:	Ptr to destination buffer
    75                              <2> ;		CS:DX:	Ptr to character filter function:
    76                              <2> ;					Parameters:
    77                              <2> ;						AL:		Character inputted by user
    78                              <2> ;					Returns:
    79                              <2> ;						CF:		Set if character is accepted
    80                              <2> ;								Cleared if character is rejected
    81                              <2> ;					Corrupts registers:
    82                              <2> ;						Nothing
    83                              <2> ;	Returns:
    84                              <2> ;		CX:		String length in characters (without NULL)
    85                              <2> ;		ZF:		Set if user cancellation
    86                              <2> ;	Corrupts registers:
    87                              <2> ;		AX
    88                              <2> ;--------------------------------------------------------------------
    89                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    90                              <2> ALIGN KEYBOARD_JUMP_ALIGN
    91                              <2> Keyboard_ReadUserInputtedStringToESDIWhilePrinting:
    92                              <2> 	push	di
    93                              <2> 	push	si
    94                              <2> 	push	bx
    95                              <2> 	call	.PrepareDisplayContextForKeyboardInput
    96                              <2> 	jcxz	.ReturnAfterUpdatingZF
    97                              <2> 
    98                              <2> 	xor		bx, bx								; Zero character counter
    99                              <2> 	dec		cx									; Decrement buffer size for NULL
   100                              <2> 	cld
   101                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   102                              <2> .GetCharacterFromUser:
   103                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary	; Get ASCII to AL
   104                              <2> 	call	.ProcessControlCharacter
   105                              <2> 	jz		SHORT .TerminateStringWithNULL
   106                              <2> 	jc		SHORT .PlayBellForRejectedCharacter
   107                              <2> 	call	dx									; Filter character
   108                              <2> 	jnc		SHORT .PlayBellForRejectedCharacter
   109                              <2> 	inc		bx									; Increment number of characters stored
   110                              <2> 	stosb										; Store from AL to ES:DI
   111                              <2> 	call	Keyboard_PrintInputtedCharacter
   112                              <2> 	loop	.GetCharacterFromUser
   113                              <2> .PlayBellForRejectedCharacter:
   114                              <2> 	cmp		al, BS								; No bell for backspace
   115                              <2> 	je		SHORT .GetCharacterFromUser
   116                              <2> 	call	Keyboard_PlayBellForUnwantedKeystroke
   117                              <2> 	jmp		SHORT .GetCharacterFromUser
   118                              <2> 
   119                              <2> .TerminateStringWithNULL:
   120                              <2> 	stosb										; Terminate string with NULL
   121                              <2> 	mov		cx, bx								; String length now in CX
   122                              <2> 
   123                              <2> .ReturnAfterUpdatingZF:
   124                              <2> 	CALL_DISPLAY_LIBRARY PopDisplayContext
   125                              <2> 	test	cx, cx								; Clear or set ZF
   126                              <2> 	pop		bx
   127                              <2> 	pop		si
   128                              <2> 	pop		di
   129                              <2> 	ret
   130                              <2> 
   131                              <2> ;--------------------------------------------------------------------
   132                              <2> ; .PrepareDisplayContextForKeyboardInput
   133                              <2> ;	Parameters:
   134                              <2> ;		Nothing
   135                              <2> ;	Returns:
   136                              <2> ;		Nothing (Display context pushed to stack)
   137                              <2> ;	Corrupts registers:
   138                              <2> ;		AX, BX, SI
   139                              <2> ;--------------------------------------------------------------------
   140                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   141                              <2> .PrepareDisplayContextForKeyboardInput:
   142                              <2> 	pop		bx					; Pop return address to BX
   143                              <2> 	mov		si, di
   144                              <2> 
   145                              <2> 	CALL_DISPLAY_LIBRARY PushDisplayContext
   146                              <2> 	call	DisplayCursor_GetDefaultCursorShapeToAX
   147                              <2> 	CALL_DISPLAY_LIBRARY SetCursorShapeFromAX
   148                              <2> 	CALL_DISPLAY_LIBRARY SynchronizeDisplayContextToHardware
   149                              <2> 
   150                              <2> 	mov		di, si
   151                              <2> 	jmp		bx
   152                              <2> 
   153                              <2> 
   154                              <2> ;--------------------------------------------------------------------
   155                              <2> ; .ProcessControlCharacter
   156                              <2> ;	Parameters:
   157                              <2> ;		AL:		Character inputted by user
   158                              <2> ;		CX:		Number of bytes left in buffer
   159                              <2> ;		BX:		Total number of characters inputted
   160                              <2> ;		ES:DI:	Ptr where to store next character
   161                              <2> ;	Returns:
   162                              <2> ;		AL:		Character inputted by user or NULL if end of input
   163                              <2> ;		BX:		Cleared if user cancellation
   164                              <2> ;		ZF:		Set if user has ended or cancelled key input
   165                              <2> ;		CF:		Set if character is rejected
   166                              <2> ;	Corrupts registers:
   167                              <2> ;		AH
   168                              <2> ;--------------------------------------------------------------------
   169                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   170                              <2> .ProcessControlCharacter:
   171                              <2> 	cmp		al, CR								; ENTER to terminate string?
   172                              <2> 	je		SHORT .EndCharacterInput
   173                              <2> 	cmp		al, ESC								; Cancel input?
   174                              <2> 	je		SHORT .CancelCharacterInput
   175                              <2> 	cmp		al, BS								; Backspace?
   176                              <2> 	je		SHORT .Backspace
   177                              <2> 	jcxz	.RejectCharacter
   178                              <2> 	clc											; Clear CF (ZF is already cleared)
   179                              <2> 	ret
   180                              <2> 
   181                              <2> .Backspace:
   182                              <2> 	test	bx, bx								; At the beginning?
   183                              <2> 	jz		SHORT .RejectCharacter
   184                              <2> 	inc		cx									; Increment bytes left
   185                              <2> 	dec		bx									; Decrement characters inputted
   186                              <2> 	dec		di
   187                              <2> 	call	Keyboard_PrintBackspace
   188                              <2> 	mov		al, BS								; Restore character
   189                              <2> .RejectCharacter:
   190                              <2> 	test	al, al								; Clear ZF...
   191                              <2> 	stc											; ...and set CF
   192                              <2> 	ret
   193                              <2> 
   194                              <2> .CancelCharacterInput:
   195                              <2> 	xor		bx, bx
   196                              <2> .EndCharacterInput:
   197                              <2> 	xor		al, al								; Set ZF and clear CF
   198                              <2> 	ret
   199                              <2> %endif ; EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   200                              <2> 
   201                              <2> 
   202                              <2> ;--------------------------------------------------------------------
   203                              <2> ; Keyboard_PrintBackspace
   204                              <2> ;	Parameters:
   205                              <2> ;		Nothing
   206                              <2> ;	Returns:
   207                              <2> ;		Nothing
   208                              <2> ;	Corrupts registers:
   209                              <2> ;		AX
   210                              <2> ;--------------------------------------------------------------------
   211                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   212                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   213                              <2> Keyboard_PrintBackspace:
   214                              <2> 	mov		al, BS
   215                              <2> 	call	Keyboard_PrintInputtedCharacter
   216                              <2> 	mov		al, ' '
   217                              <2> 	call	Keyboard_PrintInputtedCharacter
   218                              <2> 	mov		al, BS
   219                              <2> 	jmp		SHORT Keyboard_PrintInputtedCharacter
   220                              <2> %endif
   221                              <2> 
   222                              <2> 
   223                              <2> ;--------------------------------------------------------------------
   224                              <2> ; Keyboard_PlayBellForUnwantedKeystroke
   225                              <2> ;	Parameters:
   226                              <2> ;		Nothing
   227                              <2> ;	Returns:
   228                              <2> ;		Nothing
   229                              <2> ;	Corrupts registers:
   230                              <2> ;		AX
   231                              <2> ;--------------------------------------------------------------------
   232                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   233                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   234                              <2> Keyboard_PlayBellForUnwantedKeystroke:
   235                              <2> 	mov		al, BELL
   236                              <2> 	; Fall to Keyboard_PrintInputtedCharacter
   237                              <2> %endif
   238                              <2> 
   239                              <2> ;--------------------------------------------------------------------
   240                              <2> ; Keyboard_PrintInputtedCharacter
   241                              <2> ;	Parameters:
   242                              <2> ;		AL:		Character inputted by user
   243                              <2> ;	Returns:
   244                              <2> ;		Nothing
   245                              <2> ;	Corrupts registers:
   246                              <2> ;		AX
   247                              <2> ;--------------------------------------------------------------------
   248                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   249                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   250                              <2> Keyboard_PrintInputtedCharacter:
   251                              <2> 	push	di
   252                              <2> 	CALL_DISPLAY_LIBRARY PrintCharacterFromAL
   253                              <2> 	CALL_DISPLAY_LIBRARY SynchronizeDisplayContextToHardware	; Hardware cursor
   254                              <2> 	pop		di
   255                              <2> 	ret
   256                              <2> %endif
   257                              <2> 
   258                              <2> 
   259                              <2> ;--------------------------------------------------------------------
   260                              <2> ; Keyboard_RemoveAllKeystrokesFromBuffer
   261                              <2> ;	Parameters:
   262                              <2> ;		Nothing
   263                              <2> ;	Returns:
   264                              <2> ;		Nothing
   265                              <2> ;	Corrupts registers:
   266                              <2> ;		AX
   267                              <2> ;--------------------------------------------------------------------
   268                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS	; Only used when debugging
   269                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   270                              <2> Keyboard_RemoveAllKeystrokesFromBuffer:
   271                              <2> 	call	Keyboard_GetKeystrokeToAX
   272                              <2> 	jnz		SHORT Keyboard_RemoveAllKeystrokesFromBuffer
   273                              <2> 	ret
   274                              <2> %endif
   275                              <2> 
   276                              <2> 
   277                              <2> ;--------------------------------------------------------------------
   278                              <2> ; Keyboard_GetKeystrokeToAX
   279                              <2> ; Keyboard_GetKeystrokeToAXandLeaveItToBuffer
   280                              <2> ; Keyboard_GetKeystrokeToAXandWaitIfNecessary
   281                              <2> ;	Parameters:
   282                              <2> ;		Nothing
   283                              <2> ;	Returns:
   284                              <2> ;		AL:		ASCII character (if keystroke available)
   285                              <2> ;		AH:		BIOS scan code (if keystroke available)
   286                              <2> ;		ZF:		Set if no keystroke available
   287                              <2> ;				Cleared if keystroke available
   288                              <2> ;	Corrupts registers:
   289                              <2> ;		Nothing
   290                              <2> ;--------------------------------------------------------------------
   291                              <2> 
   292                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   293                              <2> 	%define EXCLUDE
   294                              <2> 	%ifdef MODULE_HOTKEYS
   295                              <2> 		%undef EXCLUDE
   296                              <2> 	%endif
   297                              <2> 	%ifdef MODULE_BOOT_MENU
   298                              <2> 		%undef EXCLUDE
   299                              <2> 	%endif
   300                              <2> %endif
   301                              <2> 		
   302                              <2> %ifndef EXCLUDE
   303                              <2> 
   304                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   305                              <2> Keyboard_GetKeystrokeToAXandLeaveItToBuffer:
   306 00000464 B401                <2> 	mov		ah, CHECK_FOR_KEYSTROKE
   307 00000466 CD16                <2> 	int		BIOS_KEYBOARD_INTERRUPT_16h
   308 00000468 C3                  <2> 	ret
   309                              <2> 		
   310                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   311                              <2> Keyboard_GetKeystrokeToAX:
   312 00000469 E8F8FF              <2> 	call	Keyboard_GetKeystrokeToAXandLeaveItToBuffer
   313 0000046C 7406                <2> 	jz		SHORT Keyboard_GetKeystrokeToAXReturn
   314                              <2> 	; Fall to Keyboard_GetKeystrokeToAXandWaitIfNecessary
   315                              <2> ALIGN KEYBOARD_JUMP_ALIGN
   316                              <2> Keyboard_GetKeystrokeToAXandWaitIfNecessary:
   317 0000046E 30E4                <2> 	xor		ah, ah						; GET_KEYSTROKE
   318 00000470 CD16                <2> 	int		BIOS_KEYBOARD_INTERRUPT_16h
   319 00000472 85C0                <2> 	test	ax, ax						; Clear ZF
   320                              <2> Keyboard_GetKeystrokeToAXReturn:
   321 00000474 C3                  <2> 	ret
   322                              <2> 		
   323                              <2> %endif
   324                              <2> %undef EXCLUDE
    54                              <1> %endif
    55                              <1> 
    56                              <1> %ifdef INCLUDE_MENU_LIBRARY
    57                              <1>   %ifndef MENU_JUMP_ALIGN
    58                              <1> 	%define MENU_JUMP_ALIGN 1
    59                              <1>   %endif
    60                              <1> 	%include "CharOutLineSplitter.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for splitting menu lines during character output.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; CharOutLineSplitter_PrepareForPrintingTextLines
    26                              <2> ;	Parameters:
    27                              <2> ;		SS:BP:	Ptr to MENU
    28                              <2> ;	Returns:
    29                              <2> ;		Nothing
    30                              <2> ;	Corrupts registers:
    31                              <2> ;		AX, DX, DI
    32                              <2> ;--------------------------------------------------------------------
    33                              <2> ALIGN MENU_JUMP_ALIGN
    34                              <2> CharOutLineSplitter_PrepareForPrintingTextLines:
    35                              <2> 	; Get first text line column offset to DX
    36 00000475 E81300              <2> 	call	CharOutLineSplitter_GetFirstBorderLineColumnOffsetToAX
    37 00000478 0404                <2> 	add		al, MENU_TEXT_COLUMN_OFFSET<<1
    38 0000047A 92                  <2> 	xchg	dx, ax
    39                              <2> 
    40                              <2> 	; Get last text line column offset to AX
    41 0000047B E8C602              <2> 	call	MenuLocation_GetMaxTextLineLengthToAX
    42                              <2> 	eSHL_IM	ax, 1			; Characters to BYTEs
    42                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    42                              <3> %ifdef USE_386
    42                              <3>  %if %2 = 1
    42                              <3>  add %1, %1
    42                              <3>  %else
    42                              <3>  eSHIFT_IM %1, %2, shl
    42                              <3>  %endif
    42                              <3> %else
    42                              <3>  eSHIFT_IM %1, %2, shl
    42                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    42                              <4> %ifndef USE_186
    42                              <4>  %ifidni %1, cl
    42                              <4>  times %2 %3 %1, 1
    42                              <4>  %elifidni %1, ch
    42                              <4>  times %2 %3 %1, 1
    42                              <4>  %elifidni %1, cx
    42                              <4>  times %2 %3 %1, 1
    42                              <4>  %else
    42                              <4>  %if %2 > 3
    42                              <4>  push cx
    42                              <4>  mov cl, %2
    42                              <4>  %3 %1, cl
    42                              <4>  pop cx
    42                              <4>  %else
    42 0000047E D1E0                <4>  times %2 %3 %1, 1
    42                              <4>  %endif
    42                              <4>  %endif
    42                              <4> 
    42                              <4> %else
    42                              <4>  %3 %1, %2
    42                              <4> %endif
    42                              <4> %endif
    42                              <3> %endif
    42                              <3> %endif
    43 00000480 01D0                <2> 	add		ax, dx
    44                              <2> 
    45 00000482 92                  <2> 	xchg	ax, dx			; AL = First text line column offset
    46 00000483 88D4                <2> 	mov		ah, dl			; AH = Last text line column offset
    47                              <2> 	JMP_DISPLAY_LIBRARY SetCharacterOutputParameterFromAX
    47                              <3>  %ifidn %1, PushDisplayContext
    47                              <3>  jmp DisplayContext_Push
    47                              <3>  %elifidn %1, PopDisplayContext
    47                              <3>  call DisplayContext_Pop
    47                              <3>  ret
    47                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    47                              <3>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    47                              <3>  %elifidn %1, FormatNullTerminatedStringFromCSSI
    47                              <3>  mov di, %1
    47                              <3>  call Display_FunctionFromDI
    47                              <3>  ret
    47                              <3>  %else
    47 00000485 BF[E902]            <3>  mov di, %1
    47 00000488 E964FD              <3>  jmp Display_FunctionFromDI
    47                              <3>  %endif
    48                              <2> 
    49                              <2> 
    50                              <2> ;--------------------------------------------------------------------
    51                              <2> ; CharOutLineSplitter_GetFirstBorderLineColumnOffsetToAX
    52                              <2> ;	Parameters:
    53                              <2> ;		SS:BP:	Ptr to MENU
    54                              <2> ;	Returns:
    55                              <2> ;		AX:		Offset to end of text line (first border area character)
    56                              <2> ;	Corrupts registers:
    57                              <2> ;		Nothing
    58                              <2> ;--------------------------------------------------------------------
    59                              <2> ALIGN MENU_JUMP_ALIGN
    60                              <2> CharOutLineSplitter_GetFirstBorderLineColumnOffsetToAX:
    61 0000048B E88402              <2> 	call	MenuLocation_GetTitleBordersTopLeftCoordinatesToAX
    62 0000048E 30E4                <2> 	xor		ah, ah
    63                              <2> 	eSHL_IM	ax, 1
    63                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    63                              <3> %ifdef USE_386
    63                              <3>  %if %2 = 1
    63                              <3>  add %1, %1
    63                              <3>  %else
    63                              <3>  eSHIFT_IM %1, %2, shl
    63                              <3>  %endif
    63                              <3> %else
    63                              <3>  eSHIFT_IM %1, %2, shl
    63                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    63                              <4> %ifndef USE_186
    63                              <4>  %ifidni %1, cl
    63                              <4>  times %2 %3 %1, 1
    63                              <4>  %elifidni %1, ch
    63                              <4>  times %2 %3 %1, 1
    63                              <4>  %elifidni %1, cx
    63                              <4>  times %2 %3 %1, 1
    63                              <4>  %else
    63                              <4>  %if %2 > 3
    63                              <4>  push cx
    63                              <4>  mov cl, %2
    63                              <4>  %3 %1, cl
    63                              <4>  pop cx
    63                              <4>  %else
    63 00000490 D1E0                <4>  times %2 %3 %1, 1
    63                              <4>  %endif
    63                              <4>  %endif
    63                              <4> 
    63                              <4> %else
    63                              <4>  %3 %1, %2
    63                              <4> %endif
    63                              <4> %endif
    63                              <3> %endif
    63                              <3> %endif
    64 00000492 C3                  <2> 	ret
    65                              <2> 
    66                              <2> 
    67                              <2> ;--------------------------------------------------------------------
    68                              <2> ; CharOutLineSplitter_IsCursorAtTheEndOfTextLine
    69                              <2> ;	Parameters:
    70                              <2> ;		DS:		BDA segment (zero)
    71                              <2> ;		ES:DI:	Ptr to cursor location in video memory
    72                              <2> ;	Returns:
    73                              <2> ;		CF:		Set if end of text line
    74                              <2> ;				Clear if more characters fit on current text line
    75                              <2> ;	Corrupts registers:
    76                              <2> ;		DX
    77                              <2> ;--------------------------------------------------------------------
    78                              <2> ALIGN MENU_JUMP_ALIGN
    79                              <2> CharOutLineSplitter_IsCursorAtTheEndOfTextLine:
    80 00000493 50                  <2> 	push	ax
    81                              <2> 
    82 00000494 8A164A04            <2> 	mov		dl, [VIDEO_BDA.wColumns]
    83                              <2> 	eSHL_IM	dl, 1			; DX = bytes per row
    83                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    83                              <3> %ifdef USE_386
    83                              <3>  %if %2 = 1
    83                              <3>  add %1, %1
    83                              <3>  %else
    83                              <3>  eSHIFT_IM %1, %2, shl
    83                              <3>  %endif
    83                              <3> %else
    83                              <3>  eSHIFT_IM %1, %2, shl
    83                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    83                              <4> %ifndef USE_186
    83                              <4>  %ifidni %1, cl
    83                              <4>  times %2 %3 %1, 1
    83                              <4>  %elifidni %1, ch
    83                              <4>  times %2 %3 %1, 1
    83                              <4>  %elifidni %1, cx
    83                              <4>  times %2 %3 %1, 1
    83                              <4>  %else
    83                              <4>  %if %2 > 3
    83                              <4>  push cx
    83                              <4>  mov cl, %2
    83                              <4>  %3 %1, cl
    83                              <4>  pop cx
    83                              <4>  %else
    83 00000498 D0E2                <4>  times %2 %3 %1, 1
    83                              <4>  %endif
    83                              <4>  %endif
    83                              <4> 
    83                              <4> %else
    83                              <4>  %3 %1, %2
    83                              <4> %endif
    83                              <4> %endif
    83                              <3> %endif
    83                              <3> %endif
    84 0000049A 89F8                <2> 	mov		ax, di
    85 0000049C F6F2                <2> 	div		dl				; AL = row index, AH = column index
    86 0000049E 38265B04            <2> 	cmp		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam+1], ah
    87                              <2> 
    88 000004A2 58                  <2> 	pop		ax
    89 000004A3 C3                  <2> 	ret
    90                              <2> 
    91                              <2> 
    92                              <2> ;--------------------------------------------------------------------
    93                              <2> ; CharOutLineSplitter_MovePartialWordToNewTextLine
    94                              <2> ;	Parameters:
    95                              <2> ;		AL:		Character to output
    96                              <2> ;		AH:		Attribute to output
    97                              <2> ;		DS:		BDA segment (zero)
    98                              <2> ;		ES:DI:	Ptr to end of text line in video memory
    99                              <2> ;	Returns:
   100                              <2> ;		DI:		Updated to next character for new text line
   101                              <2> ;	Corrupts registers:
   102                              <2> ;		AX, DX
   103                              <2> ;--------------------------------------------------------------------
   104                              <2> ALIGN MENU_JUMP_ALIGN
   105                              <2> CharOutLineSplitter_MovePartialWordToNewTextLine:
   106 000004A4 56                  <2> 	push	si
   107 000004A5 51                  <2> 	push	cx
   108 000004A6 50                  <2> 	push	ax
   109                              <2> 	; Fall to .GetOffsetToPartialWordToSIandSizeToCX
   110                              <2> 
   111                              <2> ;--------------------------------------------------------------------
   112                              <2> ; .GetOffsetToPartialWordToSIandSizeToCX
   113                              <2> ;	Parameters:
   114                              <2> ;		ES:DI:	Ptr to space before border character
   115                              <2> ;	Returns:
   116                              <2> ;		CX:		Number of bytes that needs to be moved
   117                              <2> ;		ES:SI:	Ptr to beginning of partial word that needs to be moved to new line
   118                              <2> ;	Corrupts registers:
   119                              <2> ;		Nothing
   120                              <2> ;--------------------------------------------------------------------
   121                              <2> .GetOffsetToPartialWordToSIandSizeToCX:
   122 000004A7 89F9                <2> 	mov		cx, di
   123 000004A9 89FE                <2> 	mov		si, di
   124                              <2> ALIGN MENU_JUMP_ALIGN
   125                              <2> .ScanNextCharacter:		; Space will always be found since one comes after border
   126 000004AB 4E                  <2> 	dec		si
   127 000004AC 4E                  <2> 	dec		si
   128 000004AD 26803C20            <2> 	cmp		BYTE [es:si], ' '
   129 000004B1 75F8                <2> 	jne		SHORT .ScanNextCharacter
   130 000004B3 46                  <2> 	inc		si
   131 000004B4 46                  <2> 	inc		si			; SI now points one past space
   132 000004B5 29F1                <2> 	sub		cx, si
   133                              <2> 	; Fall to .ChangeLine
   134                              <2> 
   135                              <2> ;--------------------------------------------------------------------
   136                              <2> ; .ChangeLine
   137                              <2> ;	Parameters:
   138                              <2> ;		Nothing
   139                              <2> ;	Returns:
   140                              <2> ;		Nothing
   141                              <2> ;	Corrupts registers:
   142                              <2> ;		AX, DX
   143                              <2> ;--------------------------------------------------------------------
   144                              <2> .ChangeLine:
   145 000004B7 E8AA01              <2> 	call	MenuCharOut_PrintLFCRandAdjustOffsetForStartOfLine
   146 000004BA E316                <2> 	jcxz	.ReturnFromMovePartialWordToNewTextLine
   147                              <2> 	; Fall to .MovePartialWordFromPreviousLineInESSItoNewLineInESDIwithSizeInCX
   148                              <2> 
   149                              <2> ;--------------------------------------------------------------------
   150                              <2> ; .MovePartialWordFromPreviousLineInESSItoNewLineInESDIwithSizeInCX
   151                              <2> ;	Parameters:
   152                              <2> ;		CX:		Number of BYTEs in partial word
   153                              <2> ;		DS:		BDA segment (zero)
   154                              <2> ;		ES:SI:	Ptr to partial word on previous line
   155                              <2> ;		ES:DI:	Ptr to new empty line
   156                              <2> ;	Returns:
   157                              <2> ;		ES:DI:	Ptr where to store next character
   158                              <2> ;	Corrupts registers:
   159                              <2> ;		AX, CX, DX, SI
   160                              <2> ;--------------------------------------------------------------------
   161                              <2> .MovePartialWordFromPreviousLineInESSItoNewLineInESDIwithSizeInCX:
   162 000004BC 56                  <2> 	push	si
   163 000004BD 51                  <2> 	push	cx
   164                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN rep movsb
   164                              <3> %ifdef ELIMINATE_CGA_SNOW
   164                              <3>  %ifidn %1, stosb
   164                              <3>  call CgaSnow_Stosb
   164                              <3>  %elifidn %1, stosw
   164                              <3>  call CgaSnow_Stosw
   164                              <3>  %elifidn %1, rep movsb
   164                              <3>  call CgaSnow_RepMovsb
   164                              <3>  %else
   164                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
   164                              <3>  %endif
   164                              <3> %else
   164                              <3>  %ifidn %1, rep movsb
   164                              <3>  eSEG_STR rep, es, movsb
   164                              <4> %ifndef USE_186
   164                              <4>  %%Loop:
   164 000004BE F3                  <4>  %1
   164 000004BF 26                  <4>  %2
   164 000004C0 A4                  <4>  %3
   164 000004C1 E302                <4>  jcxz %%End
   164 000004C3 EBF9                <4>  jmp SHORT %%Loop
   164                              <4>  %%End:
   164                              <4> %else
   164                              <4>  %2
   164                              <4>  %1 %3
   164                              <4> %endif
   164                              <3>  %else
   164                              <3>  %1
   164                              <3>  %endif
   164                              <3> %endif
   165 000004C5 59                  <2> 	pop		cx
   166 000004C6 5E                  <2> 	pop		si
   167                              <2> 
   168 000004C7 87FE                <2> 	xchg	di, si
   169 000004C9 D1E9                <2> 	shr		cx, 1		; Bytes to characters
   170 000004CB B020                <2> 	mov		al, ' '
   171 000004CD E8CEFE              <2> 	call	DisplayPrint_RepeatCharacterFromALwithCountInCX
   172 000004D0 89F7                <2> 	mov		di, si
   173                              <2> 
   174                              <2> .ReturnFromMovePartialWordToNewTextLine:
   175 000004D2 58                  <2> 	pop		ax
   176 000004D3 59                  <2> 	pop		cx
   177 000004D4 5E                  <2> 	pop		si
   178 000004D5 C3                  <2> 	ret
    61                              <1> 	%include "Menu.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Menu Library functions for CALL_MENU_LIBRARY macro
     3                              <2> ;					that users should use to make library call.
     4                              <2> 
     5                              <2> ;
     6                              <2> ; XTIDE Universal BIOS and Associated Tools 
     7                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     8                              <2> ;
     9                              <2> ; This program is free software; you can redistribute it and/or modify
    10                              <2> ; it under the terms of the GNU General Public License as published by
    11                              <2> ; the Free Software Foundation; either version 2 of the License, or
    12                              <2> ; (at your option) any later version.
    13                              <2> ; 
    14                              <2> ; This program is distributed in the hope that it will be useful,
    15                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <2> ; GNU General Public License for more details.		
    18                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <2> ;
    20                              <2> 		
    21                              <2> 
    22                              <2> ; Section containing code
    23                              <2> SECTION .text
    24                              <2> 
    25                              <2> ;--------------------------------------------------------------------
    26                              <2> ; MenuFunctionFromDI
    27                              <2> ;	Parameters:
    28                              <2> ;		DI:		Function to call (MENU_LIB.functionName)
    29                              <2> ;		BP:		Menu handle
    30                              <2> ;		Others:	Depends on function to call
    31                              <2> ;	Returns:
    32                              <2> ;		Depends on function to call
    33                              <2> ;	Corrupts registers:
    34                              <2> ;		AX (unless used as a return register), DI
    35                              <2> ;--------------------------------------------------------------------
    36                              <2> ALIGN MENU_JUMP_ALIGN
    37                              <2> Menu_FunctionFromDI:
    38 000004D6 56                  <2> 	push	si
    39 000004D7 52                  <2> 	push	dx
    40 000004D8 51                  <2> 	push	cx
    41 000004D9 53                  <2> 	push	bx
    42 000004DA FFD7                <2> 	call	di
    43 000004DC 5B                  <2> 	pop		bx
    44 000004DD 59                  <2> 	pop		cx
    45 000004DE 5A                  <2> 	pop		dx
    46 000004DF 5E                  <2> 	pop		si
    47 000004E0 C3                  <2> 	ret
    48                              <2> 
    49                              <2> 
    50                              <2> 	%define DisplayWithHandlerInBXandUserDataInDXAX			MenuInit_DisplayMenuWithHandlerInBXandUserDataInDXAX
    51                              <2> 	;%define Close											MenuInit_CloseMenuWindow				; Special case in CALL_MENU_LIBRARY
    52                              <2> 	%define RefreshWindow									MenuInit_RefreshMenuWindow
    53                              <2> 
    54                              <2> 	;%define SetUserDataFromDSSI							MenuInit_SetUserDataFromDSSI			; Special case in CALL_MENU_LIBRARY
    55                              <2> 	;%define GetUserDataToDSSI								MenuInit_GetUserDataToDSSI				; Special case in CALL_MENU_LIBRARY
    56                              <2> 
    57                              <2> 	;%define SetTitleHeightFromAL							MenuInit_SetTitleHeightFromAL			; Special case in CALL_MENU_LIBRARY
    58                              <2> 	%define ClearTitleArea									MenuText_ClearTitleArea
    59                              <2> 	%define RefreshTitle									MenuText_RefreshTitle
    60                              <2> 
    61                              <2> 	%define HighlightItemFromAX								MenuInit_HighlightItemFromAX
    62                              <2> 	;%define SetTotalItemsFromAX							MenuInit_SetTotalItemsFromAX			; Special case in CALL_MENU_LIBRARY
    63                              <2> 	%define RefreshItemFromAX								MenuText_RefreshItemFromAX
    64                              <2> 
    65                              <2> 	;%define SetInformationHeightFromAL						MenuInit_SetInformationHeightFromAL		; Special case in CALL_MENU_LIBRARY
    66                              <2> 	%define ClearInformationArea							MenuText_ClearInformationArea
    67                              <2> 	%define RefreshInformation								MenuText_RefreshInformation
    68                              <2> 
    69                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
    70                              <2> 	%define StartSelectionTimeoutWithTicksInAX				MenuTime_StartSelectionTimeoutWithTicksInAX
    71                              <2> %endif
    72                              <2> 
    73                              <2> %ifdef INCLUDE_MENU_DIALOGS
    74                              <2> 	%define StartProgressTaskWithIoInDSSIandParamInDXAX		DialogProgress_StartProgressTaskWithIoInDSSIandParamInDXAX
    75                              <2> 	%define SetProgressValueFromAX							DialogProgress_SetProgressValueFromAX
    76                              <2> 
    77                              <2> 	%define DisplayMessageWithInputInDSSI					DialogMessage_DisplayMessageWithInputInDSSI
    78                              <2> 	%define GetSelectionToAXwithInputInDSSI					DialogSelection_GetSelectionToAXwithInputInDSSI
    79                              <2> 	%define GetWordWithIoInDSSI								DialogWord_GetWordWithIoInDSSI
    80                              <2> 	%define GetStringWithIoInDSSI							DialogString_GetStringWithIoInDSSI
    81                              <2> 	%define GetFileNameWithIoInDSSI							DialogFile_GetFileNameWithIoInDSSI
    82                              <2> 	%define GetDriveWithIoInDSSI							DialogDrive_GetDriveWithIoInDSSI
    83                              <2> %endif
    84                              <2> 
    62                              <1> 	%include "MenuAttributes.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Finds suitable character attribute for
     3                              <2> ;					color, B/W and monochrome displays.
     4                              <2> 
     5                              <2> ;
     6                              <2> ; XTIDE Universal BIOS and Associated Tools
     7                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     8                              <2> ;
     9                              <2> ; This program is free software; you can redistribute it and/or modify
    10                              <2> ; it under the terms of the GNU General Public License as published by
    11                              <2> ; the Free Software Foundation; either version 2 of the License, or
    12                              <2> ; (at your option) any later version.
    13                              <2> ;
    14                              <2> ; This program is distributed in the hope that it will be useful,
    15                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <2> ; GNU General Public License for more details.
    18                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <2> ;
    20                              <2> 
    21                              <2> 
    22                              <2> ; Struct containing border characters for different types of menu window lines
    23                              <2> struc ATTRIBUTE_CHARS
    24 00000000 <res 00000001>      <2> 	.cBordersAndBackground	resb	1
    25 00000001 <res 00000001>      <2> 	.cShadow				resb	1
    26                              <2> 	.cTitle:
    27 00000002 <res 00000001>      <2> 	.cInformation			resb	1
    28 00000003 <res 00000001>      <2> 	.cItem					resb	1
    29 00000004 <res 00000001>      <2> 	.cHighlightedItem		resb	1
    30 00000005 <res 00000001>      <2> 	.cHurryTimeout			resb	1
    31 00000006 <res 00000001>      <2> 	.cNormalTimeout			resb	1
    32                              <2> endstruc
    33                              <2> 
    34                              <2> 
    35                              <2> ; Section containing code
    36                              <2> SECTION .text
    37                              <2> 
    38                              <2> ;--------------------------------------------------------------------
    39                              <2> ; MenuAttribute_SetToDisplayContextFromTypeInSI
    40                              <2> ;	Parameters
    41                              <2> ;		SI:		Attribute type (from ATTRIBUTE_CHARS)
    42                              <2> ;	Returns:
    43                              <2> ;		Nothing
    44                              <2> ;	Corrupts registers:
    45                              <2> ;		AX, SI, DI
    46                              <2> ;--------------------------------------------------------------------
    47                              <2> ALIGN MENU_JUMP_ALIGN
    48                              <2> MenuAttribute_SetToDisplayContextFromTypeInSI:
    49 000004E1 E80600              <2> 	call	MenuAttribute_GetToAXfromTypeInSI
    50                              <2> 	JMP_DISPLAY_LIBRARY SetCharacterAttributeFromAL
    50                              <3>  %ifidn %1, PushDisplayContext
    50                              <3>  jmp DisplayContext_Push
    50                              <3>  %elifidn %1, PopDisplayContext
    50                              <3>  call DisplayContext_Pop
    50                              <3>  ret
    50                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    50                              <3>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    50                              <3>  %elifidn %1, FormatNullTerminatedStringFromCSSI
    50                              <3>  mov di, %1
    50                              <3>  call Display_FunctionFromDI
    50                              <3>  ret
    50                              <3>  %else
    50 000004E4 BF[E502]            <3>  mov di, %1
    50 000004E7 E905FD              <3>  jmp Display_FunctionFromDI
    50                              <3>  %endif
    51                              <2> 
    52                              <2> 
    53                              <2> ;--------------------------------------------------------------------
    54                              <2> ; MenuAttribute_GetToAXfromTypeInSI
    55                              <2> ;	Parameters
    56                              <2> ;		SI:		Attribute type (from ATTRIBUTE_CHARS)
    57                              <2> ;	Returns:
    58                              <2> ;		AX:		Wanted attribute
    59                              <2> ;	Corrupts registers:
    60                              <2> ;		SI
    61                              <2> ;--------------------------------------------------------------------
    62                              <2> ALIGN MENU_JUMP_ALIGN
    63                              <2> MenuAttribute_GetToAXfromTypeInSI:
    64 000004EA 1E                  <2> 	push	ds
    65                              <2> 
    66                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax, !
    66                              <3> %ifndef USE_186
    66 000004EB 31C0                <3>  xor %2, %2
    66 000004ED 8ED8                <3>  mov %1, %2
    66                              <3> %elifidn %3, !
    66                              <3>  xor %2, %2
    66                              <3>  mov %1, %2
    66                              <3> %else
    66                              <3>  push BYTE 0
    66                              <3>  pop %1
    66                              <3> %endif
    67 000004EF A04904              <2> 	mov		al, [VIDEO_BDA.bMode]		; Load BIOS display mode (0, 1, 2, 3 or 7)
    68 000004F2 3C07                <2> 	cmp		al, 7
    69 000004F4 740A                <2> 	je		SHORT .LoadMonoAttribute
    70 000004F6 A801                <2> 	test	al, 1						; Even modes (0 and 2) are B/W
    71 000004F8 750C                <2> 	jnz		SHORT .LoadColorAttribute
    72                              <2> 
    73                              <2> .LoadBlackAndWhiteAttribute:
    74 000004FA 81C6[1505]          <2> 	add		si, .rgcBlackAndWhiteAttributes
    75 000004FE EB0A                <2> 	jmp		SHORT .LoadAttributeAndReturn
    76                              <2> 
    77                              <2> ALIGN MENU_JUMP_ALIGN
    78                              <2> .LoadMonoAttribute:
    79 00000500 81C6[1C05]          <2> 	add		si, .rgcMonochromeAttributes
    80 00000504 EB04                <2> 	jmp		SHORT .LoadAttributeAndReturn
    81                              <2> 
    82                              <2> ALIGN MENU_JUMP_ALIGN
    83                              <2> .LoadColorAttribute:
    84 00000506 81C6[0E05]          <2> 	add		si, .rgcColorAttributes
    85                              <2> .LoadAttributeAndReturn:
    86 0000050A 2EAC                <2> 	cs lodsb							; Load from [CS:SI] to AL
    87                              <2> 
    88 0000050C 1F                  <2> 	pop		ds
    89 0000050D C3                  <2> 	ret
    90                              <2> 
    91                              <2> 
    92                              <2> .rgcColorAttributes:
    93                              <2> istruc ATTRIBUTE_CHARS
    94 0000050E 1E                  <2> 	at	ATTRIBUTE_CHARS.cBordersAndBackground,	db	COLOR_ATTRIBUTE(COLOR_YELLOW, COLOR_BLUE)
    95 0000050F 08                  <2> 	at	ATTRIBUTE_CHARS.cShadow,				db	COLOR_ATTRIBUTE(COLOR_GRAY, COLOR_BLACK)
    96 00000510 1F                  <2> 	at	ATTRIBUTE_CHARS.cTitle,					db	COLOR_ATTRIBUTE(COLOR_BRIGHT_WHITE, COLOR_BLUE)
    97 00000511 17                  <2> 	at	ATTRIBUTE_CHARS.cItem,					db	COLOR_ATTRIBUTE(COLOR_WHITE, COLOR_BLUE)
    98 00000512 3F                  <2> 	at	ATTRIBUTE_CHARS.cHighlightedItem,		db	COLOR_ATTRIBUTE(COLOR_BRIGHT_WHITE, COLOR_CYAN)
    99 00000513 94                  <2> 	at	ATTRIBUTE_CHARS.cHurryTimeout,			db	COLOR_ATTRIBUTE(COLOR_RED, COLOR_BLUE) | FLG_COLOR_BLINK
   100 00000514 12                  <2> 	at	ATTRIBUTE_CHARS.cNormalTimeout,			db	COLOR_ATTRIBUTE(COLOR_GREEN, COLOR_BLUE)
   101                              <2> iend
   102                              <2> 
   103                              <2> .rgcBlackAndWhiteAttributes:	; Only COLOR_WHITE, COLOR_BRIGHT_WHITE and COLOR_BLACK should be used
   104                              <2> istruc ATTRIBUTE_CHARS
   105 00000515 0F                  <2> 	at	ATTRIBUTE_CHARS.cBordersAndBackground,	db	COLOR_ATTRIBUTE(COLOR_BRIGHT_WHITE, COLOR_BLACK)
   106 00000516 08                  <2> 	at	ATTRIBUTE_CHARS.cShadow,				db	COLOR_ATTRIBUTE(COLOR_GRAY, COLOR_BLACK)
   107 00000517 0F                  <2> 	at	ATTRIBUTE_CHARS.cTitle,					db	COLOR_ATTRIBUTE(COLOR_BRIGHT_WHITE, COLOR_BLACK)
   108 00000518 07                  <2> 	at	ATTRIBUTE_CHARS.cItem,					db	COLOR_ATTRIBUTE(COLOR_WHITE, COLOR_BLACK)
   109 00000519 7F                  <2> 	at	ATTRIBUTE_CHARS.cHighlightedItem,		db	COLOR_ATTRIBUTE(COLOR_BRIGHT_WHITE, COLOR_WHITE)
   110 0000051A 8F                  <2> 	at	ATTRIBUTE_CHARS.cHurryTimeout,			db	COLOR_ATTRIBUTE(COLOR_BRIGHT_WHITE, COLOR_BLACK) | FLG_COLOR_BLINK
   111 0000051B 07                  <2> 	at	ATTRIBUTE_CHARS.cNormalTimeout,			db	COLOR_ATTRIBUTE(COLOR_WHITE, COLOR_BLACK)
   112                              <2> iend
   113                              <2> 
   114                              <2> .rgcMonochromeAttributes:
   115                              <2> istruc ATTRIBUTE_CHARS
   116 0000051C 0F                  <2> 	at	ATTRIBUTE_CHARS.cBordersAndBackground,	db	MONO_BRIGHT
   117 0000051D 78                  <2> 	at	ATTRIBUTE_CHARS.cShadow,				db	MONO_REVERSE_DARK
   118 0000051E 0F                  <2> 	at	ATTRIBUTE_CHARS.cTitle,					db	MONO_BRIGHT
   119 0000051F 07                  <2> 	at	ATTRIBUTE_CHARS.cItem,					db	MONO_NORMAL
   120 00000520 70                  <2> 	at	ATTRIBUTE_CHARS.cHighlightedItem,		db	MONO_REVERSE
   121 00000521 8F                  <2> 	at	ATTRIBUTE_CHARS.cHurryTimeout,			db	MONO_BRIGHT_BLINK
   122 00000522 07                  <2> 	at	ATTRIBUTE_CHARS.cNormalTimeout,			db	MONO_NORMAL
   123                              <2> iend
    63                              <1> 	%include "MenuBorders.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for drawing menu borders.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> 
    21                              <2> ; Struct containing border characters for different types of menu window lines
    22                              <2> struc BORDER_CHARS
    23 00000000 <res 00000001>      <2> 	.cLeft		resb	1
    24 00000001 <res 00000001>      <2> 	.cMiddle	resb	1
    25 00000002 <res 00000001>      <2> 	.cRight		resb	1
    26                              <2> endstruc
    27                              <2> 
    28                              <2> 
    29                              <2> ; Section containing code
    30                              <2> SECTION .text
    31                              <2> 
    32                              <2> ;--------------------------------------------------------------------
    33                              <2> ; MenuBorders_RefreshAll
    34                              <2> ;	Parameters
    35                              <2> ;		SS:BP:	Ptr to MENU
    36                              <2> ;	Returns:
    37                              <2> ;		Nothing
    38                              <2> ;	Corrupts registers:
    39                              <2> ;		AX, BX, CX, DX, SI, DI
    40                              <2> ;--------------------------------------------------------------------
    41                              <2> ALIGN MENU_JUMP_ALIGN
    42                              <2> MenuBorders_RefreshAll:
    43                              <2> %ifndef USE_186
    44 00000523 E82300              <2> 	call	MenuBorders_AdjustDisplayContextForDrawingBorders
    45 00000526 E84300              <2> 	call	MenuBorders_GetNumberOfMiddleCharactersToDX
    46 00000529 E84900              <2> 	call	RefreshTitleBorders
    47 0000052C E85A00              <2> 	call	RefreshItemBorders
    48 0000052F E84D00              <2> 	call	RefreshInformationBorders
    49 00000532 E86F00              <2> 	call	DrawBottomBorderLine
    50 00000535 E98500              <2> 	jmp		DrawBottomShadowLine
    51                              <2> %else
    52                              <2> 	push	DrawBottomShadowLine
    53                              <2> 	push	DrawBottomBorderLine
    54                              <2> 	push	RefreshInformationBorders
    55                              <2> 	push	RefreshItemBorders
    56                              <2> 	push	RefreshTitleBorders
    57                              <2> 	push	MenuBorders_GetNumberOfMiddleCharactersToDX
    58                              <2> 	jmp		MenuBorders_AdjustDisplayContextForDrawingBorders
    59                              <2> %endif
    60                              <2> 
    61                              <2> 
    62                              <2> ;--------------------------------------------------------------------
    63                              <2> ; MenuBorders_RedrawBottomBorderLine
    64                              <2> ;	Parameters
    65                              <2> ;		SS:BP:	Ptr to MENU
    66                              <2> ;	Returns:
    67                              <2> ;		Nothing
    68                              <2> ;	Corrupts registers:
    69                              <2> ;		AX, BX, DX, SI, DI
    70                              <2> ;--------------------------------------------------------------------
    71                              <2> ALIGN MENU_JUMP_ALIGN
    72                              <2> MenuBorders_RedrawBottomBorderLine:
    73 00000538 E80E00              <2> 	call	MenuBorders_AdjustDisplayContextForDrawingBorders
    74 0000053B E8DD01              <2> 	call	MenuLocation_GetBottomBordersTopLeftCoordinatesToAX
    75                              <2> 	CALL_DISPLAY_LIBRARY SetCursorCoordinatesFromAX
    75                              <3>  %ifidn %1, PushDisplayContext
    75                              <3>  call DisplayContext_Push
    75                              <3>  %elifidn %1, PopDisplayContext
    75                              <3>  call DisplayContext_Pop
    75                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    75                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    75                              <3>  %else
    75 0000053E BF[FF02]            <3>  mov di, %1
    75 00000541 E8ABFC              <3>  call Display_FunctionFromDI
    75                              <3>  %endif
    76 00000544 E82500              <2> 	call	MenuBorders_GetNumberOfMiddleCharactersToDX
    77 00000547 EB5B                <2> 	jmp		SHORT DrawBottomBorderLine
    78                              <2> 
    79                              <2> 
    80                              <2> ;--------------------------------------------------------------------
    81                              <2> ; MenuBorders_RefreshItemBorders
    82                              <2> ;	Parameters
    83                              <2> ;		SS:BP:	Ptr to MENU
    84                              <2> ;	Returns:
    85                              <2> ;		Nothing
    86                              <2> ;	Corrupts registers:
    87                              <2> ;		AX, BX, CX, DX, SI, DI
    88                              <2> ;--------------------------------------------------------------------
    89                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    90                              <2> ALIGN MENU_JUMP_ALIGN
    91                              <2> MenuBorders_RefreshItemBorders:
    92                              <2> 	call	MenuBorders_AdjustDisplayContextForDrawingBorders
    93                              <2> 	call	MenuLocation_GetItemBordersTopLeftCoordinatesToAX
    94                              <2> 	CALL_DISPLAY_LIBRARY SetCursorCoordinatesFromAX
    95                              <2> 
    96                              <2> 	call	MenuBorders_GetNumberOfMiddleCharactersToDX
    97                              <2> 	jmp		SHORT RefreshItemBorders
    98                              <2> %endif
    99                              <2> 
   100                              <2> 
   101                              <2> ;--------------------------------------------------------------------
   102                              <2> ; MenuBorders_AdjustDisplayContextForDrawingBorders
   103                              <2> ;	Parameters
   104                              <2> ;		SS:BP:	Ptr to MENU
   105                              <2> ;	Returns:
   106                              <2> ;		Nothing
   107                              <2> ;	Corrupts registers:
   108                              <2> ;		AX, BX, SI, DI
   109                              <2> ;--------------------------------------------------------------------
   110                              <2> ALIGN MENU_JUMP_ALIGN
   111                              <2> MenuBorders_AdjustDisplayContextForDrawingBorders:
   112 00000549 B301                <2> 	mov		bl, ATTRIBUTES_ARE_USED
   113 0000054B B8[5D06]            <2> 	mov		ax, MenuCharOut_MenuTeletypeOutput
   114                              <2> 	CALL_DISPLAY_LIBRARY SetCharOutputFunctionFromAXwithAttribFlagInBL
   114                              <3>  %ifidn %1, PushDisplayContext
   114                              <3>  call DisplayContext_Push
   114                              <3>  %elifidn %1, PopDisplayContext
   114                              <3>  call DisplayContext_Pop
   114                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   114                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   114                              <3>  %else
   114 0000054E BF[D502]            <3>  mov di, %1
   114 00000551 E89BFC              <3>  call Display_FunctionFromDI
   114                              <3>  %endif
   115                              <2> 
   116 00000554 E834FF              <2> 	call	CharOutLineSplitter_GetFirstBorderLineColumnOffsetToAX
   117                              <2> 	CALL_DISPLAY_LIBRARY SetCharacterOutputParameterFromAX
   117                              <3>  %ifidn %1, PushDisplayContext
   117                              <3>  call DisplayContext_Push
   117                              <3>  %elifidn %1, PopDisplayContext
   117                              <3>  call DisplayContext_Pop
   117                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   117                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   117                              <3>  %else
   117 00000557 BF[E902]            <3>  mov di, %1
   117 0000055A E892FC              <3>  call Display_FunctionFromDI
   117                              <3>  %endif
   118                              <2> 
   119 0000055D E8B201              <2> 	call	MenuLocation_GetTitleBordersTopLeftCoordinatesToAX
   120                              <2> 	CALL_DISPLAY_LIBRARY SetCursorCoordinatesFromAX
   120                              <3>  %ifidn %1, PushDisplayContext
   120                              <3>  call DisplayContext_Push
   120                              <3>  %elifidn %1, PopDisplayContext
   120                              <3>  call DisplayContext_Pop
   120                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   120                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   120                              <3>  %else
   120 00000560 BF[FF02]            <3>  mov di, %1
   120 00000563 E889FC              <3>  call Display_FunctionFromDI
   120                              <3>  %endif
   121                              <2> 
   122 00000566 BE0000              <2> 	mov		si, ATTRIBUTE_CHARS.cBordersAndBackground
   123 00000569 E975FF              <2> 	jmp		MenuAttribute_SetToDisplayContextFromTypeInSI
   124                              <2> 
   125                              <2> 
   126                              <2> ;--------------------------------------------------------------------
   127                              <2> ; MenuBorders_GetNumberOfMiddleCharactersToDX
   128                              <2> ;	Parameters
   129                              <2> ;		SS:BP:	Ptr to MENU
   130                              <2> ;	Returns:
   131                              <2> ;		DX:		Number of middle border characters when drawing border lines
   132                              <2> ;	Corrupts registers:
   133                              <2> ;		Nothing
   134                              <2> ;--------------------------------------------------------------------
   135                              <2> ALIGN MENU_JUMP_ALIGN
   136                              <2> MenuBorders_GetNumberOfMiddleCharactersToDX:
   137                              <2> 	eMOVZX	dx, [bp+MENUINIT.bWidth]
   137                              <3> %ifndef USE_386
   137                              <3>  %ifidni %1, ax
   137                              <3>  mov al, %2
   137                              <3>  xor ah, ah
   137                              <3>  %elifidni %1, bx
   137                              <3>  mov bl, %2
   137                              <3>  xor bh, bh
   137                              <3>  %elifidni %1, cx
   137                              <3>  mov cl, %2
   137                              <3>  xor ch, ch
   137                              <3>  %elifidni %1, dx
   137 0000056C 8A5606              <3>  mov dl, %2
   137 0000056F 30F6                <3>  xor dh, dh
   137                              <3>  %else
   137                              <3>  push ax
   137                              <3>  mov al, %2
   137                              <3>  xor ah, ah
   137                              <3>  xchg ax, %1
   137                              <3>  pop ax
   137                              <3>  %endif
   137                              <3> 
   137                              <3> %else
   137                              <3>  movzx %1, %2
   137                              <3> %endif
   138 00000571 83EA03              <2> 	sub		dx, BYTE MENU_HORIZONTAL_BORDER_LINES
   139 00000574 C3                  <2> 	ret
   140                              <2> 
   141                              <2> 
   142                              <2> ;--------------------------------------------------------------------
   143                              <2> ; RefreshTitleBorders
   144                              <2> ;	Parameters
   145                              <2> ;		DX:		Number of times to repeat middle character
   146                              <2> ;		SS:BP:	Ptr to MENU
   147                              <2> ;	Returns:
   148                              <2> ;		Nothing
   149                              <2> ;	Corrupts registers:
   150                              <2> ;		AX, BX, CX, SI, DI
   151                              <2> ;--------------------------------------------------------------------
   152                              <2> ALIGN MENU_JUMP_ALIGN
   153                              <2> RefreshTitleBorders:
   154 00000575 E81F00              <2> 	call	DrawTopBorderLine
   155                              <2> 	eMOVZX	cx, [bp+MENUINIT.bTitleLines]
   155                              <3> %ifndef USE_386
   155                              <3>  %ifidni %1, ax
   155                              <3>  mov al, %2
   155                              <3>  xor ah, ah
   155                              <3>  %elifidni %1, bx
   155                              <3>  mov bl, %2
   155                              <3>  xor bh, bh
   155                              <3>  %elifidni %1, cx
   155 00000578 8A4E04              <3>  mov cl, %2
   155 0000057B 30ED                <3>  xor ch, ch
   155                              <3>  %elifidni %1, dx
   155                              <3>  mov dl, %2
   155                              <3>  xor dh, dh
   155                              <3>  %else
   155                              <3>  push ax
   155                              <3>  mov al, %2
   155                              <3>  xor ah, ah
   155                              <3>  xchg ax, %1
   155                              <3>  pop ax
   155                              <3>  %endif
   155                              <3> 
   155                              <3> %else
   155                              <3>  movzx %1, %2
   155                              <3> %endif
   156 0000057D EB10                <2> 	jmp		SHORT DrawTextBorderLinesByCXtimes
   157                              <2> 
   158                              <2> ;--------------------------------------------------------------------
   159                              <2> ; RefreshInformationBorders
   160                              <2> ;	Parameters
   161                              <2> ;		DX:		Number of times to repeat middle character
   162                              <2> ;		SS:BP:	Ptr to MENU
   163                              <2> ;	Returns:
   164                              <2> ;		Nothing
   165                              <2> ;	Corrupts registers:
   166                              <2> ;		AX, BX, CX, SI, DI
   167                              <2> ;--------------------------------------------------------------------
   168                              <2> ALIGN MENU_JUMP_ALIGN
   169                              <2> RefreshInformationBorders:
   170 0000057F E81D00              <2> 	call	DrawSeparationBorderLine
   171                              <2> 	eMOVZX	cx, [bp+MENUINIT.bInfoLines]
   171                              <3> %ifndef USE_386
   171                              <3>  %ifidni %1, ax
   171                              <3>  mov al, %2
   171                              <3>  xor ah, ah
   171                              <3>  %elifidni %1, bx
   171                              <3>  mov bl, %2
   171                              <3>  xor bh, bh
   171                              <3>  %elifidni %1, cx
   171 00000582 8A4E05              <3>  mov cl, %2
   171 00000585 30ED                <3>  xor ch, ch
   171                              <3>  %elifidni %1, dx
   171                              <3>  mov dl, %2
   171                              <3>  xor dh, dh
   171                              <3>  %else
   171                              <3>  push ax
   171                              <3>  mov al, %2
   171                              <3>  xor ah, ah
   171                              <3>  xchg ax, %1
   171                              <3>  pop ax
   171                              <3>  %endif
   171                              <3> 
   171                              <3> %else
   171                              <3>  movzx %1, %2
   171                              <3> %endif
   172 00000587 EB06                <2> 	jmp		SHORT DrawTextBorderLinesByCXtimes
   173                              <2> 
   174                              <2> ;--------------------------------------------------------------------
   175                              <2> ; RefreshItemBorders
   176                              <2> ;	Parameters
   177                              <2> ;		DX:		Number of times to repeat middle character
   178                              <2> ;		SS:BP:	Ptr to MENU
   179                              <2> ;	Returns:
   180                              <2> ;		Nothing
   181                              <2> ;	Corrupts registers:
   182                              <2> ;		AX, BX, CX, SI, DI
   183                              <2> ;--------------------------------------------------------------------
   184                              <2> ALIGN MENU_JUMP_ALIGN
   185                              <2> RefreshItemBorders:
   186 00000589 E81300              <2> 	call	DrawSeparationBorderLine
   187 0000058C E8D202              <2> 	call	MenuScrollbars_GetMaxVisibleItemsOnPageToCX
   188                              <2> 	; Fall to DrawTextBorderLinesByCXtimes
   189                              <2> 
   190                              <2> ;--------------------------------------------------------------------
   191                              <2> ; DrawTextBorderLinesByCXtimes
   192                              <2> ;	Parameters
   193                              <2> ;		CX:		Number of border lines to draw
   194                              <2> ;		DX:		Number of times to repeat middle character
   195                              <2> ;		SS:BP:	Ptr to MENU
   196                              <2> ;	Returns:
   197                              <2> ;		Nothing
   198                              <2> ;	Corrupts registers:
   199                              <2> ;		AX, CX, SI, DI
   200                              <2> ;--------------------------------------------------------------------
   201                              <2> DrawTextBorderLinesByCXtimes:
   202 0000058F E305                <2> 	jcxz	.NoBorderLinesToDraw
   203                              <2> ALIGN MENU_JUMP_ALIGN
   204                              <2> .DrawBordersWithFunctionInBX:
   205 00000591 E83E00              <2> 	call	DrawTextBorderLine
   206 00000594 E2FB                <2> 	loop	.DrawBordersWithFunctionInBX
   207                              <2> .NoBorderLinesToDraw:
   208 00000596 C3                  <2> 	ret
   209                              <2> 
   210                              <2> 
   211                              <2> ;--------------------------------------------------------------------
   212                              <2> ; DrawTopBorderLine
   213                              <2> ; DrawSeparationBorderLine
   214                              <2> ; DrawBottomBorderLine
   215                              <2> ; DrawTimeoutCounterOverBottomBorderLine
   216                              <2> ; DrawBottomShadowLine
   217                              <2> ; DrawTextBorderLine
   218                              <2> ;	Parameters
   219                              <2> ;		DX:		Number of times to repeat middle character
   220                              <2> ;		SS:BP:	Ptr to MENU
   221                              <2> ;	Returns:
   222                              <2> ;		Nothing
   223                              <2> ;	Corrupts registers:
   224                              <2> ;		AX, SI, DI
   225                              <2> ;--------------------------------------------------------------------
   226                              <2> ALIGN MENU_JUMP_ALIGN
   227                              <2> DrawTopBorderLine:
   228 00000597 BE[4206]            <2> 	mov		si, g_rgbTopBorderCharacters
   229 0000059A E86600              <2> 	call	PrintBorderCharactersFromCSSI
   230 0000059D EB41                <2> 	jmp		SHORT PrintNewlineToEndBorderLine
   231                              <2> 
   232                              <2> ALIGN MENU_JUMP_ALIGN
   233                              <2> DrawSeparationBorderLine:
   234 0000059F BE[4506]            <2> 	mov		si, g_rgbSeparationBorderCharacters
   235 000005A2 EB31                <2> 	jmp		SHORT PrintBorderCharactersFromCSSIandShadowCharacter
   236                              <2> 
   237                              <2> ALIGN MENU_JUMP_ALIGN
   238                              <2> DrawBottomBorderLine:
   239 000005A4 BE[4806]            <2> 	mov		si, g_rgbBottomBorderCharacters
   240 000005A7 F6460E08            <2> 	test	BYTE [bp+MENU.bFlags], FLG_MENU_TIMEOUT_COUNTDOWN
   241 000005AB 7428                <2> 	jz		SHORT PrintBorderCharactersFromCSSIandShadowCharacter
   242                              <2> 
   243 000005AD E87000              <2> 	call	DrawTimeoutCounterString
   244 000005B0 83EA13              <2> 	sub		dx, BYTE MENU_TIMEOUT_STRING_CHARACTERS
   245 000005B3 BE[4B06]            <2> 	mov		si, g_BottomBorderWithTimeoutCharacters
   246 000005B6 E81C00              <2> 	call	PrintBorderCharactersFromCSSIandShadowCharacter
   247 000005B9 83C213              <2> 	add		dx, BYTE MENU_TIMEOUT_STRING_CHARACTERS
   248 000005BC C3                  <2> 	ret
   249                              <2> 
   250                              <2> ALIGN MENU_JUMP_ALIGN
   251                              <2> DrawBottomShadowLine:
   252                              <2> 	CALL_DISPLAY_LIBRARY GetSoftwareCoordinatesToAX
   252                              <3>  %ifidn %1, PushDisplayContext
   252                              <3>  call DisplayContext_Push
   252                              <3>  %elifidn %1, PopDisplayContext
   252                              <3>  call DisplayContext_Pop
   252                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   252                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   252                              <3>  %else
   252 000005BD BF[1403]            <3>  mov di, %1
   252 000005C0 E82CFC              <3>  call Display_FunctionFromDI
   252                              <3>  %endif
   253 000005C3 40                  <2> 	inc		ax			; Move one column left
   254                              <2> 	CALL_DISPLAY_LIBRARY SetCursorCoordinatesFromAX
   254                              <3>  %ifidn %1, PushDisplayContext
   254                              <3>  call DisplayContext_Push
   254                              <3>  %elifidn %1, PopDisplayContext
   254                              <3>  call DisplayContext_Pop
   254                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   254                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   254                              <3>  %else
   254 000005C4 BF[FF02]            <3>  mov di, %1
   254 000005C7 E825FC              <3>  call Display_FunctionFromDI
   254                              <3>  %endif
   255 000005CA 42                  <2> 	inc		dx			; Increment repeat count...
   256 000005CB 42                  <2> 	inc		dx			; ...for both corner characters
   257 000005CC E81700              <2> 	call	PrintShadowCharactersByDXtimes
   258 000005CF 4A                  <2> 	dec		dx			; Restore...
   259 000005D0 4A                  <2> 	dec		dx			; ...DX
   260 000005D1 C3                  <2> 	ret
   261                              <2> 
   262                              <2> ALIGN MENU_JUMP_ALIGN
   263                              <2> DrawTextBorderLine:
   264 000005D2 BE[4E06]            <2> 	mov		si, g_rgbTextBorderCharacters
   265                              <2> 	; Fall to PrintBorderCharactersFromCSSIandShadowCharacter
   266                              <2> 
   267                              <2> ;--------------------------------------------------------------------
   268                              <2> ; PrintBorderCharactersFromCSSIandShadowCharacter
   269                              <2> ;	Parameters
   270                              <2> ;		DX:		Number of times to repeat middle character
   271                              <2> ;		CS:SI:	Ptr to BORDER_CHARS
   272                              <2> ;		SS:BP:	Ptr to MENU
   273                              <2> ;	Returns:
   274                              <2> ;		Nothing
   275                              <2> ;	Corrupts registers:
   276                              <2> ;		AX, SI, DI
   277                              <2> ;--------------------------------------------------------------------
   278                              <2> ALIGN MENU_JUMP_ALIGN
   279                              <2> PrintBorderCharactersFromCSSIandShadowCharacter:
   280 000005D5 E82B00              <2> 	call	PrintBorderCharactersFromCSSI
   281 000005D8 52                  <2> 	push	dx
   282 000005D9 BA0100              <2> 	mov		dx, 1
   283 000005DC E80700              <2> 	call	PrintShadowCharactersByDXtimes
   284 000005DF 5A                  <2> 	pop		dx
   285                              <2> 	; Fall to PrintNewlineToEndBorderLine
   286                              <2> 
   287                              <2> ;--------------------------------------------------------------------
   288                              <2> ; PrintNewlineToEndBorderLine
   289                              <2> ;	Parameters
   290                              <2> ;		SS:BP:	Ptr to MENU
   291                              <2> ;	Returns:
   292                              <2> ;		Nothing
   293                              <2> ;	Corrupts registers:
   294                              <2> ;		AX, DI
   295                              <2> ;--------------------------------------------------------------------
   296                              <2> ALIGN MENU_JUMP_ALIGN
   297                              <2> PrintNewlineToEndBorderLine:
   298                              <2> 	JMP_DISPLAY_LIBRARY PrintNewlineCharacters
   298                              <3>  %ifidn %1, PushDisplayContext
   298                              <3>  jmp DisplayContext_Push
   298                              <3>  %elifidn %1, PopDisplayContext
   298                              <3>  call DisplayContext_Pop
   298                              <3>  ret
   298                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   298                              <3>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   298                              <3>  %elifidn %1, FormatNullTerminatedStringFromCSSI
   298                              <3>  mov di, %1
   298                              <3>  call Display_FunctionFromDI
   298                              <3>  ret
   298                              <3>  %else
   298 000005E0 BF[AC03]            <3>  mov di, %1
   298 000005E3 E909FC              <3>  jmp Display_FunctionFromDI
   298                              <3>  %endif
   299                              <2> 
   300                              <2> 
   301                              <2> ;--------------------------------------------------------------------
   302                              <2> ; PrintShadowCharactersByDXtimes
   303                              <2> ;	Parameters
   304                              <2> ;		DX:		Number of shadow characters to print
   305                              <2> ;		SS:BP:	Ptr to MENU
   306                              <2> ;	Returns:
   307                              <2> ;		Nothing
   308                              <2> ;	Corrupts registers:
   309                              <2> ;		AX, SI, DI
   310                              <2> ;--------------------------------------------------------------------
   311                              <2> ALIGN MENU_JUMP_ALIGN
   312                              <2> PrintShadowCharactersByDXtimes:
   313                              <2> 	CALL_DISPLAY_LIBRARY PushDisplayContext
   313                              <3>  %ifidn %1, PushDisplayContext
   313 000005E6 E8A1FC              <3>  call DisplayContext_Push
   313                              <3>  %elifidn %1, PopDisplayContext
   313                              <3>  call DisplayContext_Pop
   313                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   313                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   313                              <3>  %else
   313                              <3>  mov di, %1
   313                              <3>  call Display_FunctionFromDI
   313                              <3>  %endif
   314                              <2> 
   315 000005E9 BE0100              <2> 	mov		si, ATTRIBUTE_CHARS.cShadow
   316 000005EC E8F2FE              <2> 	call	MenuAttribute_SetToDisplayContextFromTypeInSI
   317                              <2> 
   318 000005EF 53                  <2> 	push	bx
   319 000005F0 B301                <2> 	mov		bl, ATTRIBUTES_ARE_USED
   320 000005F2 B8[3602]            <2> 	mov		ax, FAST_OUTPUT_WITH_ATTRIBUTE_ONLY
   321                              <2> 	CALL_DISPLAY_LIBRARY SetCharOutputFunctionFromAXwithAttribFlagInBL
   321                              <3>  %ifidn %1, PushDisplayContext
   321                              <3>  call DisplayContext_Push
   321                              <3>  %elifidn %1, PopDisplayContext
   321                              <3>  call DisplayContext_Pop
   321                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   321                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   321                              <3>  %else
   321 000005F5 BF[D502]            <3>  mov di, %1
   321 000005F8 E8F4FB              <3>  call Display_FunctionFromDI
   321                              <3>  %endif
   322 000005FB 5B                  <2> 	pop		bx
   323                              <2> 
   324 000005FC E81600              <2> 	call	MenuBorders_PrintMultipleBorderCharactersFromAL	; AL does not matter
   325                              <2> 
   326                              <2> 	JMP_DISPLAY_LIBRARY PopDisplayContext
   326                              <3>  %ifidn %1, PushDisplayContext
   326                              <3>  jmp DisplayContext_Push
   326                              <3>  %elifidn %1, PopDisplayContext
   326 000005FF E8ABFC              <3>  call DisplayContext_Pop
   326 00000602 C3                  <3>  ret
   326                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   326                              <3>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   326                              <3>  %elifidn %1, FormatNullTerminatedStringFromCSSI
   326                              <3>  mov di, %1
   326                              <3>  call Display_FunctionFromDI
   326                              <3>  ret
   326                              <3>  %else
   326                              <3>  mov di, %1
   326                              <3>  jmp Display_FunctionFromDI
   326                              <3>  %endif
   327                              <2> 
   328                              <2> 
   329                              <2> ;--------------------------------------------------------------------
   330                              <2> ; PrintBorderCharactersFromCSSI
   331                              <2> ;	Parameters
   332                              <2> ;		DX:		Number of times to repeat middle character
   333                              <2> ;		CS:SI:	Ptr to BORDER_CHARS
   334                              <2> ;		SS:BP:	Ptr to MENU
   335                              <2> ;	Returns:
   336                              <2> ;		Nothing
   337                              <2> ;	Corrupts registers:
   338                              <2> ;		AX, SI, DI
   339                              <2> ;--------------------------------------------------------------------
   340                              <2> ALIGN MENU_JUMP_ALIGN
   341                              <2> PrintBorderCharactersFromCSSI:
   342 00000603 2EAC                <2> 	cs lodsb		; Load from [cs:si+BORDER_CHARS.cLeft] to AL
   343 00000605 E80700              <2> 	call	MenuBorders_PrintSingleBorderCharacterFromAL
   344                              <2> 
   345 00000608 2EAC                <2> 	cs lodsb		; Load from [cs:si+BORDER_CHARS.cMiddle] to AL
   346 0000060A E80800              <2> 	call	MenuBorders_PrintMultipleBorderCharactersFromAL
   347                              <2> 
   348 0000060D 2EAC                <2> 	cs lodsb		; Load from [cs:si+BORDER_CHARS.cRight] to AL
   349                              <2> 	; Fall to MenuBorders_PrintSingleBorderCharacterFromAL
   350                              <2> 
   351                              <2> ;--------------------------------------------------------------------
   352                              <2> ; MenuBorders_PrintSingleBorderCharacterFromAL
   353                              <2> ; MenuBorders_PrintMultipleBorderCharactersFromAL
   354                              <2> ;	Parameters
   355                              <2> ;		AL:		Character to print
   356                              <2> ;		DX:		Repeat count (MenuBorders_PrintMultipleBorderCharactersFromAL)
   357                              <2> ;		SS:BP:	Ptr to MENU
   358                              <2> ;	Returns:
   359                              <2> ;		Nothing
   360                              <2> ;	Corrupts registers:
   361                              <2> ;		AX, DI
   362                              <2> ;--------------------------------------------------------------------
   363                              <2> ALIGN MENU_JUMP_ALIGN
   364                              <2> MenuBorders_PrintSingleBorderCharacterFromAL:
   365                              <2> 	JMP_DISPLAY_LIBRARY PrintCharacterFromAL
   365                              <3>  %ifidn %1, PushDisplayContext
   365                              <3>  jmp DisplayContext_Push
   365                              <3>  %elifidn %1, PopDisplayContext
   365                              <3>  call DisplayContext_Pop
   365                              <3>  ret
   365                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   365                              <3>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   365                              <3>  %elifidn %1, FormatNullTerminatedStringFromCSSI
   365                              <3>  mov di, %1
   365                              <3>  call Display_FunctionFromDI
   365                              <3>  ret
   365                              <3>  %else
   365 0000060F BF[B303]            <3>  mov di, %1
   365 00000612 E9DAFB              <3>  jmp Display_FunctionFromDI
   365                              <3>  %endif
   366                              <2> 
   367                              <2> ALIGN MENU_JUMP_ALIGN
   368                              <2> MenuBorders_PrintMultipleBorderCharactersFromAL:
   369 00000615 51                  <2> 	push	cx
   370 00000616 89D1                <2> 	mov		cx, dx
   371                              <2> 	CALL_DISPLAY_LIBRARY PrintRepeatedCharacterFromALwithCountInCX
   371                              <3>  %ifidn %1, PushDisplayContext
   371                              <3>  call DisplayContext_Push
   371                              <3>  %elifidn %1, PopDisplayContext
   371                              <3>  call DisplayContext_Pop
   371                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   371                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   371                              <3>  %else
   371 00000618 BF[9E03]            <3>  mov di, %1
   371 0000061B E8D1FB              <3>  call Display_FunctionFromDI
   371                              <3>  %endif
   372 0000061E 59                  <2> 	pop		cx
   373 0000061F C3                  <2> 	ret
   374                              <2> 
   375                              <2> 
   376                              <2> ;--------------------------------------------------------------------
   377                              <2> ; DrawTimeoutCounterString
   378                              <2> ;	Parameters
   379                              <2> ;		SS:BP:	Ptr to MENU
   380                              <2> ;	Returns:
   381                              <2> ;		Nothing
   382                              <2> ;	Corrupts registers:
   383                              <2> ;		AX, SI, DI
   384                              <2> ;--------------------------------------------------------------------
   385                              <2> ALIGN MENU_JUMP_ALIGN
   386                              <2> DrawTimeoutCounterString:
   387 00000620 E86103              <2> 	call	MenuTime_GetTimeoutSecondsLeftToAX
   388                              <2> 	; Fall to .PrintTimeoutStringWithSecondsInAX
   389                              <2> 
   390                              <2> ;--------------------------------------------------------------------
   391                              <2> ; .PrintTimeoutStringWithSecondsInAX
   392                              <2> ;	Parameters
   393                              <2> ;		AX:		Seconds to print
   394                              <2> ;		SS:BP:	Ptr to MENU
   395                              <2> ;	Returns:
   396                              <2> ;		Nothing
   397                              <2> ;	Corrupts registers:
   398                              <2> ;		AX, SI, DI
   399                              <2> ;--------------------------------------------------------------------
   400                              <2> .PrintTimeoutStringWithSecondsInAX:
   401                              <2> 	; Get attribute to AX
   402 00000623 97                  <2> 	xchg	di, ax
   403 00000624 BE0600              <2> 	mov		si, ATTRIBUTE_CHARS.cNormalTimeout
   404 00000627 83FF03              <2> 	cmp		di, BYTE MENU_TIMEOUT_SECONDS_FOR_HURRY
   405                              <2> 	eCMOVB	si, ATTRIBUTE_CHARS.cHurryTimeout
   405 0000062A 7303                <3>  jnb SHORT %%Return
   405 0000062C BE0500              <3>  mov %1, %2
   405                              <3> %%Return:
   406 0000062F E8B8FE              <2> 	call	MenuAttribute_GetToAXfromTypeInSI
   407                              <2> 
   408 00000632 55                  <2> 	push	bp
   409 00000633 89E5                <2> 	mov		bp, sp
   410 00000635 BE[7001]            <2> 	mov		si, g_szSelectionTimeout
   411 00000638 50                  <2> 	push	ax			; Push attribute
   412 00000639 57                  <2> 	push	di			; Push seconds
   413                              <2> 	CALL_DISPLAY_LIBRARY FormatNullTerminatedStringFromCSSI
   413                              <3>  %ifidn %1, PushDisplayContext
   413                              <3>  call DisplayContext_Push
   413                              <3>  %elifidn %1, PopDisplayContext
   413                              <3>  call DisplayContext_Pop
   413                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   413                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   413                              <3>  %else
   413 0000063A BF[0702]            <3>  mov di, %1
   413 0000063D E8AFFB              <3>  call Display_FunctionFromDI
   413                              <3>  %endif
   414 00000640 5D                  <2> 	pop		bp
   415 00000641 C3                  <2> 	ret
   416                              <2> 
   417                              <2> ; Lookup tables for border characters
   418                              <2> g_rgbTopBorderCharacters:
   419                              <2> istruc BORDER_CHARS
   420 00000642 C9                  <2> 	at	BORDER_CHARS.cLeft,		db	DOUBLE_TOP_LEFT_CORNER
   421 00000643 CD                  <2> 	at	BORDER_CHARS.cMiddle,	db	DOUBLE_HORIZONTAL
   422 00000644 BB                  <2> 	at	BORDER_CHARS.cRight,	db	DOUBLE_TOP_RIGHT_CORNER
   423                              <2> iend
   424                              <2> 
   425                              <2> g_rgbSeparationBorderCharacters:
   426                              <2> istruc BORDER_CHARS
   427 00000645 C7                  <2> 	at	BORDER_CHARS.cLeft,		db	DOUBLE_VERTICAL_TO_RIGHT_SINGLE
   428 00000646 C4                  <2> 	at	BORDER_CHARS.cMiddle,	db	SINGLE_HORIZONTAL
   429 00000647 B6                  <2> 	at	BORDER_CHARS.cRight,	db	DOUBLE_VERTICAL_TO_LEFT_SINGLE
   430                              <2> iend
   431                              <2> 
   432                              <2> g_rgbBottomBorderCharacters:
   433                              <2> istruc BORDER_CHARS
   434 00000648 C8                  <2> 	at	BORDER_CHARS.cLeft,		db	DOUBLE_BOTTOM_LEFT_CORNER
   435 00000649 CD                  <2> 	at	BORDER_CHARS.cMiddle,	db	DOUBLE_HORIZONTAL
   436 0000064A BC                  <2> 	at	BORDER_CHARS.cRight,	db	DOUBLE_BOTTOM_RIGHT_CORNER
   437                              <2> iend
   438                              <2> 
   439                              <2> g_BottomBorderWithTimeoutCharacters:
   440                              <2> istruc BORDER_CHARS
   441 0000064B C6                  <2> 	at	BORDER_CHARS.cLeft,		db	DOUBLE_RIGHT_HORIZONTAL_TO_SINGLE_VERTICAL
   442 0000064C CD                  <2> 	at	BORDER_CHARS.cMiddle,	db	DOUBLE_HORIZONTAL
   443 0000064D BC                  <2> 	at	BORDER_CHARS.cRight,	db	DOUBLE_BOTTOM_RIGHT_CORNER
   444                              <2> iend
   445                              <2> 
   446                              <2> g_rgbTextBorderCharacters:
   447                              <2> istruc BORDER_CHARS
   448 0000064E BA                  <2> 	at	BORDER_CHARS.cLeft,		db	DOUBLE_VERTICAL
   449 0000064F 20                  <2> 	at	BORDER_CHARS.cMiddle,	db	' '
   450 00000650 BA                  <2> 	at	BORDER_CHARS.cRight,	db	DOUBLE_VERTICAL
   451                              <2> iend
    64                              <1> 	%include "MenuCharOut.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Character out function for printing withing menu window.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools 
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ; 
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.		
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 		
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; MenuCharOut_MenuTeletypeOutputWithAutomaticLineChange
    26                              <2> ; MenuCharOut_MenuTeletypeOutput
    27                              <2> ;	Parameters:
    28                              <2> ;		AL:		Character to output
    29                              <2> ;		AH:		Attribute to output
    30                              <2> ;		DS:		BDA segment (zero)
    31                              <2> ;		ES:DI:	Ptr to video memory where to output
    32                              <2> ;		[DISPLAY_CONTEXT.wCharOutParam]:
    33                              <2> ;				Low byte  = First column offset (after CR)
    34                              <2> ;				High byte = Last column offset (when using automatic line change)
    35                              <2> ;	Returns:
    36                              <2> ;		DI:		Incremented for next character
    37                              <2> ;	Corrupts registers:
    38                              <2> ;		AX, DX
    39                              <2> ;--------------------------------------------------------------------
    40                              <2> ALIGN MENU_JUMP_ALIGN
    41                              <2> MenuCharOut_MenuTeletypeOutputWithAutomaticLineChange:
    42 00000651 E83FFE              <2> 	call	CharOutLineSplitter_IsCursorAtTheEndOfTextLine
    43 00000654 7307                <2> 	jnc		SHORT MenuCharOut_MenuTeletypeOutput
    44 00000656 3C20                <2> 	cmp		al, ' '
    45 00000658 721B                <2> 	jb		SHORT ReturnSinceNoNeedToStartLineWithControlCharacter
    46 0000065A E847FE              <2> 	call	CharOutLineSplitter_MovePartialWordToNewTextLine
    47                              <2> 	; Fall to MenuCharOut_MenuTextTeletypeOutputWithAttribute
    48                              <2> 
    49                              <2> ALIGN MENU_JUMP_ALIGN
    50                              <2> MenuCharOut_MenuTeletypeOutput:
    51 0000065D 3C0D                <2> 	cmp		al, CR
    52 0000065F 7408                <2> 	je		SHORT PrintCRandAdjustOffsetForStartOfLine
    53 00000661 E9B3FB              <2> 	jmp		DisplayCharOut_TeletypeOutputWithAttribute
    54                              <2> 
    55                              <2> 
    56                              <2> ;--------------------------------------------------------------------
    57                              <2> ; MenuCharOut_PrintLFCRandAdjustOffsetForStartOfLine
    58                              <2> ; PrintCRandAdjustOffsetForStartOfLine
    59                              <2> ;	Parameters:
    60                              <2> ;		DS:		BDA segment (zero)
    61                              <2> ;		ES:DI:	Ptr to cursor location
    62                              <2> ;		[DISPLAY_CONTEXT.wCharOutParam]:
    63                              <2> ;				Low byte  = First column offset (after CR)
    64                              <2> ;				High byte = Last column offset (when using automatic line change)
    65                              <2> ;	Returns:
    66                              <2> ;		ES:DI:	Ptr to beginning of new line
    67                              <2> ;	Corrupts registers:
    68                              <2> ;		AX, DX
    69                              <2> ;--------------------------------------------------------------------
    70                              <2> ALIGN MENU_JUMP_ALIGN
    71                              <2> MenuCharOut_PrintLFCRandAdjustOffsetForStartOfLine:
    72 00000664 B00A                <2> 	mov		al, LF
    73 00000666 E8B8FB              <2> 	call	DisplayCharOut_BiosTeletypeOutput
    74                              <2> 	; Fall to PrintCRandAdjustOffsetForStartOfLine
    75                              <2> 
    76                              <2> ALIGN MENU_JUMP_ALIGN
    77                              <2> PrintCRandAdjustOffsetForStartOfLine:
    78 00000669 B00D                <2> 	mov		al, CR
    79 0000066B E8B3FB              <2> 	call	DisplayCharOut_BiosTeletypeOutput
    80                              <2> 	eMOVZX	ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam]
    80                              <3> %ifndef USE_386
    80                              <3>  %ifidni %1, ax
    80 0000066E A05A04              <3>  mov al, %2
    80 00000671 30E4                <3>  xor ah, ah
    80                              <3>  %elifidni %1, bx
    80                              <3>  mov bl, %2
    80                              <3>  xor bh, bh
    80                              <3>  %elifidni %1, cx
    80                              <3>  mov cl, %2
    80                              <3>  xor ch, ch
    80                              <3>  %elifidni %1, dx
    80                              <3>  mov dl, %2
    80                              <3>  xor dh, dh
    80                              <3>  %else
    80                              <3>  push ax
    80                              <3>  mov al, %2
    80                              <3>  xor ah, ah
    80                              <3>  xchg ax, %1
    80                              <3>  pop ax
    80                              <3>  %endif
    80                              <3> 
    80                              <3> %else
    80                              <3>  movzx %1, %2
    80                              <3> %endif
    81 00000673 01C7                <2> 	add		di, ax
    82                              <2> ReturnSinceNoNeedToStartLineWithControlCharacter:
    83 00000675 C3                  <2> 	ret
    65                              <1> 	%include "MenuEvent.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for initializing menu system.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; MenuEvent_InitializeMenuinit
    26                              <2> ;	Parameters
    27                              <2> ;		SS:BP:	Ptr to MENU
    28                              <2> ;	Returns:
    29                              <2> ;		DS:SI:	Ptr to MENU with MENUINIT initialized from user handler
    30                              <2> ;		CF:		Set if event processed
    31                              <2> ;				Cleared if event not processed
    32                              <2> ;	Corrupts registers:
    33                              <2> ;		AX, BX, DX
    34                              <2> ;--------------------------------------------------------------------
    35                              <2> ALIGN MENU_JUMP_ALIGN
    36                              <2> MenuEvent_InitializeMenuinit:
    37 00000676 16                  <2> 	push	ss
    38 00000677 1F                  <2> 	pop		ds
    39 00000678 89EE                <2> 	mov		si, bp
    40 0000067A B300                <2> 	mov		bl, MENUEVENT_InitializeMenuinitFromDSSI
    41 0000067C EB25                <2> 	jmp		SHORT MenuEvent_SendFromBX
    42                              <2> 
    43                              <2> 
    44                              <2> ;--------------------------------------------------------------------
    45                              <2> ; MenuEvent_ExitMenu
    46                              <2> ;	Parameters
    47                              <2> ;		SS:BP:	Ptr to MENU
    48                              <2> ;	Returns:
    49                              <2> ;		CF:		Set to exit from menu
    50                              <2> ;				Cleared to cancel exit
    51                              <2> ;	Corrupts registers:
    52                              <2> ;		AX, BX, DX
    53                              <2> ;--------------------------------------------------------------------
    54                              <2> %ifndef MENU_NO_ESC
    55                              <2> ALIGN MENU_JUMP_ALIGN
    56                              <2> MenuEvent_ExitMenu:
    57                              <2> 	mov		bl, MENUEVENT_ExitMenu
    58                              <2> 	jmp		SHORT MenuEvent_SendFromBX
    59                              <2> %endif
    60                              <2> 
    61                              <2> 
    62                              <2> %ifdef MENUEVENT_IDLEPROCESSING_ENABLE
    63                              <2> ;--------------------------------------------------------------------
    64                              <2> ; MenuEvent_IdleProcessing
    65                              <2> ;	Parameters
    66                              <2> ;		SS:BP:	Ptr to MENU
    67                              <2> ;	Returns:
    68                              <2> ;		CF:		Set if event processed
    69                              <2> ;				Cleared if event not processed
    70                              <2> ;	Corrupts registers:
    71                              <2> ;		AX, BX, DX
    72                              <2> ;--------------------------------------------------------------------
    73                              <2> ALIGN MENU_JUMP_ALIGN
    74                              <2> MenuEvent_IdleProcessing:
    75                              <2> 	mov		bl, MENUEVENT_IdleProcessing
    76                              <2> 	jmp		SHORT MenuEvent_SendFromBX
    77                              <2> %endif
    78                              <2> 
    79                              <2> ;--------------------------------------------------------------------
    80                              <2> ; MenuEvent_RefreshTitle
    81                              <2> ; MenuEvent_RefreshInformation
    82                              <2> ;	Parameters
    83                              <2> ;		SS:BP:	Ptr to MENU
    84                              <2> ;		Cursor will be positioned to beginning of window
    85                              <2> ;	Returns:
    86                              <2> ;		CF:		Set if event processed
    87                              <2> ;				Cleared if event not processed
    88                              <2> ;	Corrupts registers:
    89                              <2> ;		AX, CX, BX, DX
    90                              <2> ;--------------------------------------------------------------------
    91                              <2> ALIGN MENU_JUMP_ALIGN
    92                              <2> MenuEvent_RefreshTitle:
    93 0000067E B3D2                <2> 	mov		bl, MENUEVENT_RefreshTitle
    94                              <2> 	SKIP2B	cx	; mov cx, <next instruction>
    94                              <3>  %ifidni %1, f
    94                              <3>  db 03Dh
    94                              <3> 
    94                              <3>  %elifidni %1, ax
    94                              <3>  db 0B8h
    94                              <3>  %elifidni %1, cx
    94 00000680 B9                  <3>  db 0B9h
    94                              <3>  %elifidni %1, dx
    94                              <3>  db 0BAh
    94                              <3>  %elifidni %1, bx
    94                              <3>  db 0BBh
    94                              <3>  %elifidni %1, sp
    94                              <3>  db 0BCh
    94                              <3>  %elifidni %1, bp
    94                              <3>  db 0BDh
    94                              <3>  %elifidni %1, si
    94                              <3>  db 0BEh
    94                              <3>  %elifidni %1, di
    94                              <3>  db 0BFh
    94                              <3>  %else
    94                              <3>  %error "Invalid parameter passed to SKIP2B"
    94                              <3>  %endif
    95                              <2> 
    96                              <2> MenuEvent_RefreshInformation:
    97 00000681 B3DA                <2> 	mov		bl, MENUEVENT_RefreshInformation
    98 00000683 8B4E02              <2> 	mov		cx, [bp+MENUINIT.wHighlightedItem]
    99 00000686 EB1B                <2> 	jmp		SHORT MenuEvent_SendFromBX
   100                              <2> 
   101                              <2> 
   102                              <2> ;--------------------------------------------------------------------
   103                              <2> ; MenuEvent_RefreshItemFromCX
   104                              <2> ;	Parameters
   105                              <2> ;		CX:		Index of item to refresh
   106                              <2> ;		SS:BP:	Ptr to MENU
   107                              <2> ;		Cursor has been positioned to the beginning of item line
   108                              <2> ;	Returns:
   109                              <2> ;		CF:		Set if event processed
   110                              <2> ;				Cleared if event not processed
   111                              <2> ;	Corrupts registers:
   112                              <2> ;		AX, BX, DX
   113                              <2> ;--------------------------------------------------------------------
   114                              <2> ALIGN MENU_JUMP_ALIGN
   115                              <2> MenuEvent_RefreshItemFromCX:
   116 00000688 B39A                <2> 	mov		bl, MENUEVENT_RefreshItemFromCX
   117 0000068A EB17                <2> 	jmp		SHORT MenuEvent_SendFromBX
   118                              <2> 
   119                              <2> 
   120                              <2> ;--------------------------------------------------------------------
   121                              <2> ; MenuEvent_HighlightItemFromCX
   122                              <2> ;	Parameters
   123                              <2> ;		CX:		Index of item to highlight
   124                              <2> ;		SS:BP:	Ptr to MENU
   125                              <2> ;	Returns:
   126                              <2> ;		Nothing
   127                              <2> ;	Corrupts registers:
   128                              <2> ;		AX, BX, DX, SI, DI
   129                              <2> ;--------------------------------------------------------------------
   130                              <2> ALIGN MENU_JUMP_ALIGN
   131                              <2> MenuEvent_HighlightItemFromCX:
   132 0000068C 89CA                <2> 	mov		dx, cx
   133 0000068E 875602              <2> 	xchg	dx, [bp+MENUINIT.wHighlightedItem]
   134 00000691 52                  <2> 	push	dx
   135                              <2> 
   136 00000692 B339                <2> 	mov		bl, MENUEVENT_ItemHighlightedFromCX
   137 00000694 E80C00              <2> 	call	MenuEvent_SendFromBX
   138                              <2> 
   139 00000697 58                  <2> 	pop		ax
   140 00000698 E82C02              <2> 	call	MenuText_RefreshItemFromAX
   141 0000069B 8B4602              <2> 	mov		ax, [bp+MENUINIT.wHighlightedItem]
   142 0000069E E92602              <2> 	jmp		MenuText_RefreshItemFromAX
   143                              <2> 
   144                              <2> 
   145                              <2> ;--------------------------------------------------------------------
   146                              <2> ; MenuEvent_KeyStrokeInAX
   147                              <2> ;	Parameters
   148                              <2> ;		AL:		ASCII character for the key
   149                              <2> ;		AH:		Keyboard library scan code for the key
   150                              <2> ;		SS:BP:	Ptr to MENU
   151                              <2> ;	Returns:
   152                              <2> ;		CF:		Set if event processed
   153                              <2> ;				Cleared if event not processed
   154                              <2> ;	Corrupts registers:
   155                              <2> ;		AX, BX, DX
   156                              <2> ;--------------------------------------------------------------------
   157                              <2> %ifdef MENUEVENT_KeyStrokeInAX
   158                              <2> ALIGN MENU_JUMP_ALIGN
   159                              <2> MenuEvent_KeyStrokeInAX:
   160                              <2> 	mov		bl, MENUEVENT_KeyStrokeInAX
   161                              <2> 	SKIP2B	dx	; mov dx, <next instruction>
   162                              <2> %endif
   163                              <2> 
   164                              <2> ;--------------------------------------------------------------------
   165                              <2> ; MenuEvent_ItemSelectedFromCX
   166                              <2> ;	Parameters
   167                              <2> ;		CX:		Index of selected item
   168                              <2> ;		SS:BP:	Ptr to MENU
   169                              <2> ;	Returns:
   170                              <2> ;		CF:		Set if event processed
   171                              <2> ;				Cleared if event not processed
   172                              <2> ;	Corrupts registers:
   173                              <2> ;		AX, BX, DX
   174                              <2> ;--------------------------------------------------------------------
   175                              <2> MenuEvent_ItemSelectedFromCX:
   176 000006A1 B395                <2> 	mov		bl, MENUEVENT_ItemSelectedFromCX
   177                              <2> 	; Fall to MenuEvent_SendFromBX
   178                              <2> 
   179                              <2> 
   180                              <2> ;--------------------------------------------------------------------
   181                              <2> ; MenuEvent_SendFromBX
   182                              <2> ;	Parameters
   183                              <2> ;		BL:					Menu event to send
   184                              <2> ;		SS:BP:				Ptr to MENU
   185                              <2> ;		Other registers:	Event specific parameters
   186                              <2> ;	Returns:
   187                              <2> ;		AX, DX:				Event specific return values
   188                              <2> ;		CF:					Set if event processed
   189                              <2> ;							Cleared if event not processed
   190                              <2> ;	Corrupts registers:
   191                              <2> ;		BX
   192                              <2> ;--------------------------------------------------------------------
   193                              <2> ALIGN MENU_JUMP_ALIGN
   194                              <2> MenuEvent_SendFromBX:
   195 000006A3 06                  <2> 	push	es
   196 000006A4 1E                  <2> 	push	ds
   197 000006A5 57                  <2> 	push	di
   198 000006A6 56                  <2> 	push	si
   199 000006A7 51                  <2> 	push	cx
   200 000006A8 30FF                <2> 	xor		bh, bh
   201 000006AA FF5608              <2> 	call	[bp+MENU.fnEventHandler]
   202 000006AD 59                  <2> 	pop		cx
   203 000006AE 5E                  <2> 	pop		si
   204 000006AF 5F                  <2> 	pop		di
   205 000006B0 1F                  <2> 	pop		ds
   206 000006B1 07                  <2> 	pop		es
   207 000006B2 C3                  <2> 	ret
    66                              <1> 	%include "MenuInit.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for initializing menu system.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools 
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ; 
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.		
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 				
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; MenuInit_DisplayMenuWithHandlerInBXandUserDataInDXAX
    26                              <2> ;	Parameters
    27                              <2> ;		DX:AX:	User specified data
    28                              <2> ;		BX:		Menu event handler
    29                              <2> ;	Returns:
    30                              <2> ;		AX:		Index of selected item or NO_ITEM_SELECTED
    31                              <2> ;	Corrupts registers:
    32                              <2> ;		All except segments
    33                              <2> ;--------------------------------------------------------------------
    34                              <2> ALIGN MENU_JUMP_ALIGN
    35                              <2> MenuInit_DisplayMenuWithHandlerInBXandUserDataInDXAX:
    36 000006B3 06                  <2> 	push	es
    37 000006B4 1E                  <2> 	push	ds
    38 000006B5 91                  <2> 	xchg	cx, ax			; Backup user data
    39                              <2> 	CALL_DISPLAY_LIBRARY	PushDisplayContext
    39                              <3>  %ifidn %1, PushDisplayContext
    39 000006B6 E8D1FB              <3>  call DisplayContext_Push
    39                              <3>  %elifidn %1, PopDisplayContext
    39                              <3>  call DisplayContext_Pop
    39                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    39                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    39                              <3>  %else
    39                              <3>  mov di, %1
    39                              <3>  call Display_FunctionFromDI
    39                              <3>  %endif
    40                              <2> 
    41                              <2> 	; Create MENU struct to stack
    42 000006B9 B81400              <2> 	mov		ax, MENU_size
    43                              <2> 	eENTER_STRUCT	ax
    43 000006BC 55                  <3>  push bp
    43 000006BD 29C4                <3>  sub sp, %1
    43 000006BF 89E5                <3>  mov bp, sp
    44 000006C1 91                  <2> 	xchg	ax, cx			; Restore user data to AX
    45 000006C2 E83E03              <2> 	call	Memory_ZeroSSBPwithSizeInCX
    46                              <2> 
    47                              <2> 	; Display menu
    48 000006C5 E80E00              <2> 	call	MenuInit_EnterMenuWithHandlerInBXandUserDataInDXAX
    49                              <2> 
    50                              <2> 	; Get menu selection and destroy menu variables from stack
    51 000006C8 8B5602              <2> 	mov		dx, [bp+MENUINIT.wHighlightedItem]
    52                              <2> 	eLEAVE_STRUCT	MENU_size
    52 000006CB 83C414              <3>  add sp, %1
    52 000006CE 5D                  <3>  pop bp
    53                              <2> 
    54                              <2> 	CALL_DISPLAY_LIBRARY	PopDisplayContext
    54                              <3>  %ifidn %1, PushDisplayContext
    54                              <3>  call DisplayContext_Push
    54                              <3>  %elifidn %1, PopDisplayContext
    54 000006CF E8DBFB              <3>  call DisplayContext_Pop
    54                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    54                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    54                              <3>  %else
    54                              <3>  mov di, %1
    54                              <3>  call Display_FunctionFromDI
    54                              <3>  %endif
    55 000006D2 92                  <2> 	xchg	ax, dx			; Return highlighted item in AX
    56 000006D3 1F                  <2> 	pop		ds
    57 000006D4 07                  <2> 	pop		es
    58 000006D5 C3                  <2> 	ret
    59                              <2> 
    60                              <2> 
    61                              <2> ;--------------------------------------------------------------------
    62                              <2> ; EnterMenuWithHandlerInBXandUserDataInDXAX
    63                              <2> ;	Parameters
    64                              <2> ;		DX:AX:	User specified data
    65                              <2> ;		BX:		Menu event handler
    66                              <2> ;		SS:BP:	Ptr to MENU
    67                              <2> ;	Returns:
    68                              <2> ;		Nothing
    69                              <2> ;	Corrupts registers:
    70                              <2> ;		All, except SS:BP
    71                              <2> ;--------------------------------------------------------------------
    72                              <2> ALIGN MENU_JUMP_ALIGN
    73                              <2> MenuInit_EnterMenuWithHandlerInBXandUserDataInDXAX:
    74 000006D6 895E08              <2> 	mov		[bp+MENU.fnEventHandler], bx
    75 000006D9 89460A              <2> 	mov		[bp+MENU.dwUserData], ax
    76 000006DC 89560C              <2> 	mov		[bp+MENU.dwUserData+2], dx
    77                              <2> 
    78 000006DF B80020              <2> 	mov		ax, CURSOR_HIDDEN
    79                              <2> 	CALL_DISPLAY_LIBRARY SetCursorShapeFromAX
    79                              <3>  %ifidn %1, PushDisplayContext
    79                              <3>  call DisplayContext_Push
    79                              <3>  %elifidn %1, PopDisplayContext
    79                              <3>  call DisplayContext_Pop
    79                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    79                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    79                              <3>  %else
    79 000006E2 BF[FB02]            <3>  mov di, %1
    79 000006E5 E807FB              <3>  call Display_FunctionFromDI
    79                              <3>  %endif
    80 000006E8 E88BFF              <2> 	call	MenuEvent_InitializeMenuinit	; User initialization
    81                              <2> %ifndef USE_186
    82 000006EB E80200              <2> 	call	MenuInit_RefreshMenuWindow
    83 000006EE EB5D                <2> 	jmp		MenuLoop_Enter
    84                              <2> %else
    85                              <2> 	push	MenuLoop_Enter
    86                              <2> 	; Fall to MenuInit_RefreshMenuWindow
    87                              <2> %endif
    88                              <2> 
    89                              <2> 
    90                              <2> ;--------------------------------------------------------------------
    91                              <2> ; MenuInit_RefreshMenuWindow
    92                              <2> ;	Parameters
    93                              <2> ;		SS:BP:	Ptr to MENU
    94                              <2> ;	Returns:
    95                              <2> ;		Nothing
    96                              <2> ;	Corrupts registers:
    97                              <2> ;		AX, BX, CX, DX, SI, DI
    98                              <2> ;--------------------------------------------------------------------
    99                              <2> ALIGN MENU_JUMP_ALIGN
   100                              <2> MenuInit_RefreshMenuWindow:
   101 000006F0 E830FE              <2> 	call	MenuBorders_RefreshAll			; Draw borders
   102 000006F3 E89701              <2> 	call	MenuText_RefreshTitle			; Draw title strings
   103 000006F6 E8BF01              <2> 	call	MenuText_RefreshAllItems		; Draw item strings
   104 000006F9 E99D01              <2> 	jmp		MenuText_RefreshInformation		; Draw information strings
   105                              <2> 
   106                              <2> 
   107                              <2> ;--------------------------------------------------------------------
   108                              <2> ; MenuInit_CloseMenuIfExitEventAllows
   109                              <2> ;	Parameters
   110                              <2> ;		SS:BP:	Ptr to MENU
   111                              <2> ;	Returns:
   112                              <2> ;		Nothing
   113                              <2> ;	Corrupts registers:
   114                              <2> ;		AX, BX, DX
   115                              <2> ;--------------------------------------------------------------------
   116                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   117                              <2> ALIGN MENU_JUMP_ALIGN
   118                              <2> MenuInit_CloseMenuIfExitEventAllows:
   119                              <2> 	call	MenuEvent_ExitMenu
   120                              <2> 	jc		SHORT MenuInit_CloseMenuWindow
   121                              <2> 	ret
   122                              <2> %endif
   123                              <2> 
   124                              <2> 
   125                              <2> ;--------------------------------------------------------------------
   126                              <2> ; MenuInit_CloseMenuWindow
   127                              <2> ;	Parameters
   128                              <2> ;		SS:BP:	Ptr to MENU
   129                              <2> ;	Returns:
   130                              <2> ;		Nothing
   131                              <2> ;	Corrupts registers:
   132                              <2> ;		Nothing
   133                              <2> ;--------------------------------------------------------------------
   134                              <2> ALIGN MENU_JUMP_ALIGN
   135                              <2> MenuInit_CloseMenuWindow:
   136 000006FC 804E0E01            <2> 	or		BYTE [bp+MENU.bFlags], FLG_MENU_EXIT
   137 00000700 C3                  <2> 	ret
   138                              <2> 
   139                              <2> 		
   140                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS		
   141                              <2> ;--------------------------------------------------------------------
   142                              <2> ; MenuInit_HighlightItemFromAX
   143                              <2> ;	Parameters
   144                              <2> ;		AX:		Item to highlight
   145                              <2> ;		SS:BP:	Ptr to MENU
   146                              <2> ;	Returns:
   147                              <2> ;		Nothing
   148                              <2> ;	Corrupts registers:
   149                              <2> ;		AX, BX, CX, DX, SI, DI
   150                              <2> ;--------------------------------------------------------------------
   151                              <2> ALIGN MENU_JUMP_ALIGN
   152                              <2> MenuInit_HighlightItemFromAX:
   153                              <2> 	sub		ax, [bp+MENUINIT.wHighlightedItem]
   154                              <2> 	jmp		MenuScrollbars_MoveHighlightedItemByAX
   155                              <2> %endif
   156                              <2> 
   157                              <2> 		
   158                              <2> ;--------------------------------------------------------------------
   159                              <2> ; MenuInit_GetHighlightedItemToAX
   160                              <2> ;	Parameters
   161                              <2> ;		SS:BP:	Ptr to MENU
   162                              <2> ;	Returns:
   163                              <2> ;		AX:		Index of highlighted item or NO_ITEM_HIGHLIGHTED
   164                              <2> ;	Corrupts registers:
   165                              <2> ;		Nothing
   166                              <2> ;--------------------------------------------------------------------
   167                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   168                              <2> ALIGN MENU_JUMP_ALIGN
   169                              <2> MenuInit_GetHighlightedItemToAX:
   170                              <2> 	mov		ax, [bp+MENUINIT.wHighlightedItem]
   171                              <2> 	ret
   172                              <2> %endif
   173                              <2> 
   174                              <2> 
   175                              <2> ;--------------------------------------------------------------------
   176                              <2> ; MenuInit_SetTitleHeightFromAL
   177                              <2> ; MenuInit_SetInformationHeightFromAL
   178                              <2> ; MenuInit_SetTotalItemsFromAX
   179                              <2> ;	Parameters
   180                              <2> ;		AX/AL:	Parameter
   181                              <2> ;		SS:BP:		Ptr to MENU
   182                              <2> ;	Returns:
   183                              <2> ;		Nothing
   184                              <2> ;	Corrupts registers:
   185                              <2> ;		Nothing
   186                              <2> ;--------------------------------------------------------------------
   187                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   188                              <2> ALIGN MENU_JUMP_ALIGN
   189                              <2> MenuInit_SetTitleHeightFromAL:
   190                              <2> 	mov		[bp+MENUINIT.bTitleLines], al
   191                              <2> 	ret
   192                              <2> 
   193                              <2> ALIGN MENU_JUMP_ALIGN
   194                              <2> MenuInit_SetInformationHeightFromAL:
   195                              <2> 	mov		[bp+MENUINIT.bInfoLines], al
   196                              <2> 	ret
   197                              <2> 
   198                              <2> ALIGN MENU_JUMP_ALIGN
   199                              <2> MenuInit_SetTotalItemsFromAX:
   200                              <2> 	mov		[bp+MENUINIT.wItems], ax
   201                              <2> 	ret
   202                              <2> %endif
   203                              <2> 
   204                              <2> 
   205                              <2> ;--------------------------------------------------------------------
   206                              <2> ; MenuInit_SetUserDataFromDSSI
   207                              <2> ; MenuInit_GetUserDataToDSSI
   208                              <2> ;	Parameters
   209                              <2> ;		DS:SI:	User data (MenuInit_SetUserDataFromDSSI)
   210                              <2> ;		SS:BP:	Ptr to MENU
   211                              <2> ;	Returns:
   212                              <2> ;		DS:SI:	User data (MenuInit_GetUserDataToDSSI)
   213                              <2> ;	Corrupts registers:
   214                              <2> ;		Nothing
   215                              <2> ;--------------------------------------------------------------------
   216                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   217                              <2> ALIGN MENU_JUMP_ALIGN
   218                              <2> MenuInit_SetUserDataFromDSSI:
   219                              <2> 	mov		[bp+MENU.dwUserData], si
   220                              <2> 	mov		[bp+MENU.dwUserData+2], ds
   221                              <2> 	ret
   222                              <2> 
   223                              <2> ALIGN MENU_JUMP_ALIGN
   224                              <2> MenuInit_GetUserDataToDSSI:
   225                              <2> 	lds		si, [bp+MENU.dwUserData]
   226                              <2> 	ret
   227                              <2> %endif
    67                              <1> 	%include "MenuLocation.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for calculation menu window dimensions.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools 
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ; 
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.		
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 		
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; MenuLocation_GetTextCoordinatesToAXforItemInAX
    26                              <2> ;	Parameters
    27                              <2> ;		AX:		Item index
    28                              <2> ;		SS:BP:	Ptr to MENU
    29                              <2> ;	Returns:
    30                              <2> ;		AL:		Column (X)
    31                              <2> ;		AH:		Row (Y)
    32                              <2> ;	Corrupts registers:
    33                              <2> ;		Nothing
    34                              <2> ;--------------------------------------------------------------------
    35                              <2> ALIGN MENU_JUMP_ALIGN
    36                              <2> MenuLocation_GetTextCoordinatesToAXforItemInAX:
    37 00000701 2B4612              <2> 	sub		ax, [bp+MENU.wFirstVisibleItem]		; Item to line
    38 00000704 86C4                <2> 	xchg	al, ah								; Line to AH, clear AL
    39 00000706 050201              <2> 	add		ax, (MENU_TEXT_ROW_OFFSET<<8) | MENU_TEXT_COLUMN_OFFSET
    40                              <2> 	SKIP2B	f	; cmp ax, <next instruction>
    40                              <3>  %ifidni %1, f
    40 00000709 3D                  <3>  db 03Dh
    40                              <3> 
    40                              <3>  %elifidni %1, ax
    40                              <3>  db 0B8h
    40                              <3>  %elifidni %1, cx
    40                              <3>  db 0B9h
    40                              <3>  %elifidni %1, dx
    40                              <3>  db 0BAh
    40                              <3>  %elifidni %1, bx
    40                              <3>  db 0BBh
    40                              <3>  %elifidni %1, sp
    40                              <3>  db 0BCh
    40                              <3>  %elifidni %1, bp
    40                              <3>  db 0BDh
    40                              <3>  %elifidni %1, si
    40                              <3>  db 0BEh
    40                              <3>  %elifidni %1, di
    40                              <3>  db 0BFh
    40                              <3>  %else
    40                              <3>  %error "Invalid parameter passed to SKIP2B"
    40                              <3>  %endif
    41                              <2> 	; Fall to MenuLocation_GetItemBordersTopLeftCoordinatesToAX
    42                              <2> 
    43                              <2> ;--------------------------------------------------------------------
    44                              <2> ; MenuLocation_GetItemBordersTopLeftCoordinatesToAX
    45                              <2> ; MenuLocation_GetTitleTextTopLeftCoordinatesToAX
    46                              <2> ; MenuLocation_GetTitleBordersTopLeftCoordinatesToAX
    47                              <2> ; MenuLocation_GetInformationTextTopLeftCoordinatesToAX
    48                              <2> ; MenuLocation_GetBottomBordersTopLeftCoordinatesToAX
    49                              <2> ;	Parameters
    50                              <2> ;		SS:BP:	Ptr to MENU
    51                              <2> ;	Returns:
    52                              <2> ;		AL:		Column (X)
    53                              <2> ;		AH:		Row (Y)
    54                              <2> ;	Corrupts registers:
    55                              <2> ;		Nothing
    56                              <2> ;--------------------------------------------------------------------
    57                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS		
    58                              <2> MenuLocation_GetItemBordersTopLeftCoordinatesToAX:
    59                              <2> %endif
    60 0000070A 31C0                <2> 	xor		ax, ax
    61 0000070C EB1B                <2> 	jmp		SHORT AddItemBordersTopLeftCoordinatesToAX
    62                              <2> 
    63                              <2> ALIGN MENU_JUMP_ALIGN
    64                              <2> MenuLocation_GetTitleTextTopLeftCoordinatesToAX:
    65 0000070E B80201              <2> 	mov		ax, (MENU_TEXT_ROW_OFFSET<<8) | MENU_TEXT_COLUMN_OFFSET
    66                              <2> 	SKIP2B	f	; cmp ax, <next instruction>
    66                              <3>  %ifidni %1, f
    66 00000711 3D                  <3>  db 03Dh
    66                              <3> 
    66                              <3>  %elifidni %1, ax
    66                              <3>  db 0B8h
    66                              <3>  %elifidni %1, cx
    66                              <3>  db 0B9h
    66                              <3>  %elifidni %1, dx
    66                              <3>  db 0BAh
    66                              <3>  %elifidni %1, bx
    66                              <3>  db 0BBh
    66                              <3>  %elifidni %1, sp
    66                              <3>  db 0BCh
    66                              <3>  %elifidni %1, bp
    66                              <3>  db 0BDh
    66                              <3>  %elifidni %1, si
    66                              <3>  db 0BEh
    66                              <3>  %elifidni %1, di
    66                              <3>  db 0BFh
    66                              <3>  %else
    66                              <3>  %error "Invalid parameter passed to SKIP2B"
    66                              <3>  %endif
    67                              <2> MenuLocation_GetTitleBordersTopLeftCoordinatesToAX:
    68 00000712 31C0                <2> 	xor		ax, ax
    69 00000714 EB17                <2> 	jmp		SHORT MenuLocation_AddTitleBordersTopLeftCoordinatesToAX
    70                              <2> 
    71                              <2> ALIGN MENU_JUMP_ALIGN
    72                              <2> MenuLocation_GetInformationTextTopLeftCoordinatesToAX:
    73 00000716 B80201              <2> 	mov		ax, (MENU_TEXT_ROW_OFFSET<<8) | MENU_TEXT_COLUMN_OFFSET
    74 00000719 EB06                <2> 	jmp		SHORT AddInformationBordersTopLeftCoordinatesToAX
    75                              <2> 
    76                              <2> ALIGN MENU_JUMP_ALIGN
    77                              <2> MenuLocation_GetBottomBordersTopLeftCoordinatesToAX:
    78 0000071B 31C0                <2> 	xor		ax, ax
    79                              <2> 	; Fall to .AddBottomBordersTopLeftCoordinatesToAX
    80                              <2> 
    81                              <2> ;--------------------------------------------------------------------
    82                              <2> ; .AddBottomBordersTopLeftCoordinatesToAX
    83                              <2> ; AddInformationBordersTopLeftCoordinatesToAX
    84                              <2> ; AddItemBordersTopLeftCoordinatesToAX
    85                              <2> ; MenuLocation_AddTitleBordersTopLeftCoordinatesToAX
    86                              <2> ;	Parameters
    87                              <2> ;		AX:		Zero of offset
    88                              <2> ;		SS:BP:	Ptr to MENU
    89                              <2> ;	Returns:
    90                              <2> ;		AL:		Column (X)
    91                              <2> ;		AH:		Row (Y)
    92                              <2> ;	Corrupts registers:
    93                              <2> ;		Nothing
    94                              <2> ;--------------------------------------------------------------------
    95                              <2> .AddBottomBordersTopLeftCoordinatesToAX:
    96 0000071D F9                  <2> 	stc							; Compensate for Information top border
    97 0000071E 126605              <2> 	adc		ah, [bp+MENUINIT.bInfoLines]
    98                              <2> ALIGN MENU_JUMP_ALIGN
    99                              <2> AddInformationBordersTopLeftCoordinatesToAX:
   100 00000721 51                  <2> 	push	cx
   101 00000722 E83C01              <2> 	call	MenuScrollbars_GetMaxVisibleItemsOnPageToCX
   102 00000725 41                  <2> 	inc		cx					; Compensate for Items top border
   103 00000726 00CC                <2> 	add		ah, cl
   104 00000728 59                  <2> 	pop		cx
   105                              <2> ALIGN MENU_JUMP_ALIGN
   106                              <2> AddItemBordersTopLeftCoordinatesToAX:
   107 00000729 F9                  <2> 	stc							; Compensate for Title top border
   108 0000072A 126604              <2> 	adc		ah, [bp+MENUINIT.bTitleLines]
   109                              <2> ALIGN MENU_JUMP_ALIGN
   110                              <2> MenuLocation_AddTitleBordersTopLeftCoordinatesToAX:
   111 0000072D 57                  <2> 	push	di
   112 0000072E 50                  <2> 	push	ax
   113                              <2> 	CALL_DISPLAY_LIBRARY GetColumnsToALandRowsToAH
   113                              <3>  %ifidn %1, PushDisplayContext
   113                              <3>  call DisplayContext_Push
   113                              <3>  %elifidn %1, PopDisplayContext
   113                              <3>  call DisplayContext_Pop
   113                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   113                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   113                              <3>  %else
   113 0000072F BF[5703]            <3>  mov di, %1
   113 00000732 E8BAFA              <3>  call Display_FunctionFromDI
   113                              <3>  %endif
   114 00000735 2A4606              <2> 	sub		al, [bp+MENUINIT.bWidth]
   115 00000738 2A6607              <2> 	sub		ah, [bp+MENUINIT.bHeight]
   116 0000073B D0E8                <2> 	shr		al, 1
   117 0000073D D0EC                <2> 	shr		ah, 1
   118 0000073F 5F                  <2> 	pop		di					; Old AX to DI
   119 00000740 01F8                <2> 	add		ax, di				; Add old AX to menu top left coordinates
   120 00000742 5F                  <2> 	pop		di
   121 00000743 C3                  <2> 	ret
   122                              <2> 
   123                              <2> 
   124                              <2> ;--------------------------------------------------------------------
   125                              <2> ; MenuLocation_GetMaxTextLineLengthToAX
   126                              <2> ;	Parameters
   127                              <2> ;		SS:BP:	Ptr to MENU
   128                              <2> ;	Returns:
   129                              <2> ;		AX:		Maximum text line length in characters
   130                              <2> ;	Corrupts registers:
   131                              <2> ;		Nothing
   132                              <2> ;--------------------------------------------------------------------
   133                              <2> ALIGN MENU_JUMP_ALIGN
   134                              <2> MenuLocation_GetMaxTextLineLengthToAX:
   135                              <2> 	eMOVZX	ax, [bp+MENUINIT.bWidth]
   135                              <3> %ifndef USE_386
   135                              <3>  %ifidni %1, ax
   135 00000744 8A4606              <3>  mov al, %2
   135 00000747 30E4                <3>  xor ah, ah
   135                              <3>  %elifidni %1, bx
   135                              <3>  mov bl, %2
   135                              <3>  xor bh, bh
   135                              <3>  %elifidni %1, cx
   135                              <3>  mov cl, %2
   135                              <3>  xor ch, ch
   135                              <3>  %elifidni %1, dx
   135                              <3>  mov dl, %2
   135                              <3>  xor dh, dh
   135                              <3>  %else
   135                              <3>  push ax
   135                              <3>  mov al, %2
   135                              <3>  xor ah, ah
   135                              <3>  xchg ax, %1
   135                              <3>  pop ax
   135                              <3>  %endif
   135                              <3> 
   135                              <3> %else
   135                              <3>  movzx %1, %2
   135                              <3> %endif
   136 00000749 83E805              <2> 	sub		ax, BYTE MENU_HORIZONTAL_BORDER_LINES + MENU_TEXT_COLUMN_OFFSET
   137 0000074C C3                  <2> 	ret
    68                              <1> 	%include "MenuLoop.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Menu loop for waiting keystrokes.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools 
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ; 
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.		
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 		
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; MenuLoop_Enter
    26                              <2> ;	Parameters
    27                              <2> ;		SS:BP:	Ptr to MENU
    28                              <2> ;	Returns:
    29                              <2> ;		Nothing
    30                              <2> ;	Corrupts registers:
    31                              <2> ;		AX, BX, CX, DX, SI, DI
    32                              <2> ;--------------------------------------------------------------------
    33                              <2> ALIGN MENU_JUMP_ALIGN
    34                              <2> MenuLoop_Enter:
    35 0000074D E80A00              <2> 	call	KeystrokeProcessing
    36 00000750 E80D00              <2> 	call	TimeoutProcessing
    37                              <2> %ifdef MENUEVENT_IDLEPROCESSING_ENABLE
    38                              <2> 	call	MenuEvent_IdleProcessing	; User idle processing
    39                              <2> %endif
    40 00000753 F6460E01            <2> 	test	BYTE [bp+MENU.bFlags], FLG_MENU_EXIT
    41 00000757 74F4                <2> 	jz		SHORT MenuLoop_Enter
    42 00000759 C3                  <2> 	ret
    43                              <2> 
    44                              <2> 
    45                              <2> ;--------------------------------------------------------------------
    46                              <2> ; KeystrokeProcessing
    47                              <2> ; TimeoutProcessing
    48                              <2> ;	Parameters
    49                              <2> ;		SS:BP:	Ptr to MENU
    50                              <2> ;	Returns:
    51                              <2> ;		Nothing
    52                              <2> ;	Corrupts registers:
    53                              <2> ;		All, except SS:BP
    54                              <2> ;--------------------------------------------------------------------
    55                              <2> ALIGN MENU_JUMP_ALIGN
    56                              <2> KeystrokeProcessing:
    57 0000075A E80CFD              <2> 	call	Keyboard_GetKeystrokeToAX
    58 0000075D 7508                <2> 	jnz		SHORT ProcessKeystrokeFromAX
    59                              <2> NoKeystrokeToProcess:
    60 0000075F C3                  <2> 	ret
    61                              <2> 
    62                              <2> ALIGN MENU_JUMP_ALIGN
    63                              <2> TimeoutProcessing:
    64 00000760 E80602              <2> 	call	MenuTime_UpdateSelectionTimeout
    65 00000763 73FA                <2> 	jnc		NoKeystrokeToProcess
    66 00000765 B00D                <2> 	mov		al, CR	; Fake ENTER to select item
    67                              <2> 	; Fall to ProcessKeystrokeFromAX
    68                              <2> 
    69                              <2> 
    70                              <2> ;--------------------------------------------------------------------
    71                              <2> ; ProcessKeystrokeFromAX
    72                              <2> ;	Parameters
    73                              <2> ;		AL:		ASCII character
    74                              <2> ;		AH:		BIOS scan code
    75                              <2> ;		SS:BP:	Ptr to MENU
    76                              <2> ;	Returns:
    77                              <2> ;		Nothing
    78                              <2> ;	Corrupts registers:
    79                              <2> ;		AX, BX, CX, DX, SI, DI
    80                              <2> ;--------------------------------------------------------------------
    81                              <2> ALIGN MENU_JUMP_ALIGN
    82                              <2> ProcessKeystrokeFromAX:
    83 00000767 91                  <2> 	xchg	cx, ax
    84 00000768 E8F101              <2> 	call	MenuTime_StopSelectionTimeout
    85 0000076B 91                  <2> 	xchg	ax, cx
    86 0000076C E80200              <2> 	call	.ProcessMenuSystemKeystrokeFromAX
    87                              <2> %ifdef MENUEVENT_KeyStrokeInAX
    88                              <2> 	jc		SHORT NoKeystrokeToProcess
    89                              <2> 	jmp		MenuEvent_KeyStrokeInAX
    90                              <2> %else
    91 0000076F EBEE                <2> 	jmp		SHORT NoKeystrokeToProcess
    92                              <2> %endif
    93                              <2> 		
    94                              <2> ;--------------------------------------------------------------------
    95                              <2> ; .ProcessMenuSystemKeystrokeFromAX
    96                              <2> ;	Parameters
    97                              <2> ;		AL:		ASCII character
    98                              <2> ;		AH:		BIOS scan code
    99                              <2> ;		SS:BP:	Ptr to MENU
   100                              <2> ;	Returns:
   101                              <2> ;		CF:		Set if keystroke processed
   102                              <2> ;				Cleared if keystroke not processed
   103                              <2> ;		AL:		ASCII character (if CF cleared)
   104                              <2> ;		AH:		BIOS scan code (if CF cleared)
   105                              <2> ;	Corrupts registers:
   106                              <2> ;		BX, CX, DX, SI, DI
   107                              <2> ;--------------------------------------------------------------------
   108                              <2> ALIGN MENU_JUMP_ALIGN
   109                              <2> .ProcessMenuSystemKeystrokeFromAX:
   110                              <2> %ifndef MENU_NO_ESC
   111                              <2> 	cmp		al, ESC
   112                              <2> 	je		SHORT .LeaveMenuWithoutSelectingItem
   113                              <2> %endif
   114 00000771 3C0D                <2> 	cmp		al, CR
   115 00000773 7407                <2> 	je		SHORT .SelectItem
   116                              <2> 
   117 00000775 F6460E04            <2> 	test	BYTE [bp+MENU.bFlags], FLG_MENU_USER_HANDLES_SCROLLING
   118 00000779 7409                <2> 	jz		SHORT MenuLoop_ProcessScrollingKeysFromAX
   119 0000077B C3                  <2> 	ret		; Return with CF cleared since keystroke not processed
   120                              <2> 
   121                              <2> %ifndef MENU_NO_ESC		
   122                              <2> ALIGN MENU_JUMP_ALIGN
   123                              <2> .LeaveMenuWithoutSelectingItem:
   124                              <2> 	call	MenuEvent_ExitMenu
   125                              <2> 	jnc		SHORT .CancelMenuExit
   126                              <2> 	call	MenuInit_CloseMenuWindow
   127                              <2> 	mov		WORD [bp+MENUINIT.wHighlightedItem], NO_ITEM_HIGHLIGHTED
   128                              <2> .CancelMenuExit:
   129                              <2> 	stc
   130                              <2> 	ret
   131                              <2> %endif
   132                              <2> 		
   133                              <2> ALIGN MENU_JUMP_ALIGN
   134                              <2> .SelectItem:
   135 0000077C 8B4E02              <2> 	mov		cx, [bp+MENUINIT.wHighlightedItem]
   136 0000077F E81FFF              <2> 	call	MenuEvent_ItemSelectedFromCX
   137 00000782 F9                  <2> 	stc
   138 00000783 C3                  <2> 	ret
   139                              <2> 
   140                              <2> 
   141                              <2> ;--------------------------------------------------------------------
   142                              <2> ; MenuLoop_ProcessScrollingKeysFromAX
   143                              <2> ;	Parameters
   144                              <2> ;		AL:		ASCII character
   145                              <2> ;		AH:		BIOS scan code
   146                              <2> ;		SS:BP:	Ptr to MENU
   147                              <2> ;	Returns:
   148                              <2> ;		CF:		Set if keystroke processed
   149                              <2> ;				Cleared if keystroke not processed
   150                              <2> ;		AL:		ASCII character (if CF cleared)
   151                              <2> ;		AH:		BIOS scan code (if CF cleared)
   152                              <2> ;	Corrupts registers:
   153                              <2> ;		BX, CX, DX, SI, DI
   154                              <2> ;--------------------------------------------------------------------
   155                              <2> ALIGN MENU_JUMP_ALIGN
   156                              <2> MenuLoop_ProcessScrollingKeysFromAX:
   157 00000784 86E0                <2> 	xchg	ah, al
   158 00000786 3C49                <2> 	cmp		al, MENU_KEY_PGUP
   159 00000788 7418                <2> 	je		SHORT .ChangeToPreviousPage
   160 0000078A 3C51                <2> 	cmp		al, MENU_KEY_PGDN
   161 0000078C 7428                <2> 	je		SHORT .ChangeToNextPage
   162 0000078E 3C47                <2> 	cmp		al, MENU_KEY_HOME
   163 00000790 741D                <2> 	je		SHORT .SelectFirstItem
   164 00000792 3C4F                <2> 	cmp		al, MENU_KEY_END
   165 00000794 742E                <2> 	je		SHORT .SelectLastItem
   166                              <2> 
   167 00000796 3C48                <2> 	cmp		al, MENU_KEY_UP
   168 00000798 7433                <2> 	je		SHORT .DecrementSelectedItem
   169 0000079A 3C50                <2> 	cmp		al, MENU_KEY_DOWN
   170 0000079C 7433                <2> 	je		SHORT .IncrementSelectedItem
   171 0000079E F8                  <2> 	clc		; Clear CF since keystroke not processed
   172 0000079F 86E0                <2> 	xchg	ah, al
   173 000007A1 C3                  <2> 	ret
   174                              <2> 
   175                              <2> ALIGN MENU_JUMP_ALIGN
   176                              <2> .ChangeToPreviousPage:
   177 000007A2 E8BC00              <2> 	call	MenuScrollbars_GetMaxVisibleItemsOnPageToCX
   178 000007A5 91                  <2> 	xchg	ax, cx
   179 000007A6 F7D8                <2> 	neg		ax
   180 000007A8 8B4E02              <2> 	mov		cx, [bp+MENUINIT.wHighlightedItem]
   181 000007AB 01C1                <2> 	add		cx, ax
   182 000007AD 7D24                <2> 	jge		SHORT .MoveHighlightedItemByAX	; No rotation for PgUp
   183                              <2> 	; Fall to .SelectFirstItem
   184                              <2> ALIGN MENU_JUMP_ALIGN
   185                              <2> .SelectFirstItem:
   186 000007AF 8B4602              <2> 	mov		ax, [bp+MENUINIT.wHighlightedItem]
   187 000007B2 F7D8                <2> 	neg		ax
   188 000007B4 EB1D                <2> 	jmp		SHORT .MoveHighlightedItemByAX
   189                              <2> 
   190                              <2> ALIGN MENU_JUMP_ALIGN
   191                              <2> .ChangeToNextPage:
   192 000007B6 E8A800              <2> 	call	MenuScrollbars_GetMaxVisibleItemsOnPageToCX
   193 000007B9 91                  <2> 	xchg	ax, cx
   194 000007BA 8B4E02              <2> 	mov		cx, [bp+MENUINIT.wHighlightedItem]
   195 000007BD 01C1                <2> 	add		cx, ax
   196 000007BF 3B4E00              <2> 	cmp		cx, [bp+MENUINIT.wItems]
   197 000007C2 720F                <2> 	jb		SHORT .MoveHighlightedItemByAX	; No rotation for PgDn
   198                              <2> 	; Fall to .SelectLastItem
   199                              <2> ALIGN MENU_JUMP_ALIGN
   200                              <2> .SelectLastItem:
   201 000007C4 F9                  <2> 	stc
   202 000007C5 8B4600              <2> 	mov		ax, [bp+MENUINIT.wItems]
   203 000007C8 1B4602              <2> 	sbb		ax, [bp+MENUINIT.wHighlightedItem]
   204 000007CB EB06                <2> 	jmp		SHORT .MoveHighlightedItemByAX
   205                              <2> 
   206                              <2> ALIGN MENU_JUMP_ALIGN
   207                              <2> .DecrementSelectedItem:
   208 000007CD B8FFFF              <2> 	mov		ax, -1
   209                              <2> 	SKIP2B	cx	; mov cx, <next instruction>
   209                              <3>  %ifidni %1, f
   209                              <3>  db 03Dh
   209                              <3> 
   209                              <3>  %elifidni %1, ax
   209                              <3>  db 0B8h
   209                              <3>  %elifidni %1, cx
   209 000007D0 B9                  <3>  db 0B9h
   209                              <3>  %elifidni %1, dx
   209                              <3>  db 0BAh
   209                              <3>  %elifidni %1, bx
   209                              <3>  db 0BBh
   209                              <3>  %elifidni %1, sp
   209                              <3>  db 0BCh
   209                              <3>  %elifidni %1, bp
   209                              <3>  db 0BDh
   209                              <3>  %elifidni %1, si
   209                              <3>  db 0BEh
   209                              <3>  %elifidni %1, di
   209                              <3>  db 0BFh
   209                              <3>  %else
   209                              <3>  %error "Invalid parameter passed to SKIP2B"
   209                              <3>  %endif
   210                              <2> .IncrementSelectedItem:
   211 000007D1 B001                <2> 	mov		al, 1	; AH is already 0
   212                              <2> ALIGN MENU_JUMP_ALIGN
   213                              <2> .MoveHighlightedItemByAX:
   214 000007D3 E82D00              <2> 	call	MenuScrollbars_MoveHighlightedItemByAX
   215 000007D6 F9                  <2> 	stc
   216 000007D7 C3                  <2> 	ret
    69                              <1> 	%include "MenuScrollbars.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for drawing scroll bars over menu borders.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; MenuScrollbars_AreScrollbarsNeeded
    26                              <2> ;	Parameters
    27                              <2> ;		SS:BP:	Ptr to MENU
    28                              <2> ;	Returns:
    29                              <2> ;		CF:		Set if scroll bars are needed
    30                              <2> ;				Cleared if no scroll bars needed
    31                              <2> ;	Corrupts registers:
    32                              <2> ;		AX
    33                              <2> ;--------------------------------------------------------------------
    34                              <2> ALIGN MENU_JUMP_ALIGN
    35                              <2> MenuScrollbars_AreScrollbarsNeeded:
    36 000007D8 91                  <2> 	xchg	ax, cx
    37 000007D9 E88500              <2> 	call	MenuScrollbars_GetMaxVisibleItemsOnPageToCX
    38 000007DC 3B4E00              <2> 	cmp		cx, [bp+MENUINIT.wItems]		; Set CF if max visible < total items
    39 000007DF 91                  <2> 	xchg	cx, ax
    40 000007E0 C3                  <2> 	ret
    41                              <2> 
    42                              <2> 
    43                              <2> ;--------------------------------------------------------------------
    44                              <2> ; MenuScrollbars_GetScrollCharacterToALForLineInDI
    45                              <2> ;	Parameters
    46                              <2> ;		DI:		Index of item line to draw
    47                              <2> ;		SS:BP:	Ptr to MENU
    48                              <2> ;	Returns:
    49                              <2> ;		AL:		Scroll track or thumb character
    50                              <2> ;	Corrupts registers:
    51                              <2> ;		AH, CX, DX
    52                              <2> ;--------------------------------------------------------------------
    53                              <2> ALIGN MENU_JUMP_ALIGN
    54                              <2> MenuScrollbars_GetScrollCharacterToALForLineInDI:
    55 000007E1 E87D00              <2> 	call	MenuScrollbars_GetMaxVisibleItemsOnPageToCX
    56                              <2> 	; Get first thumb line to AX
    57 000007E4 8B4612              <2> 	mov		ax, [bp+MENU.wFirstVisibleItem]
    58 000007E7 E81300              <2> 	call	.CalculateFirstOrLastThumbLineToAX
    59                              <2> 
    60 000007EA 39C7                <2> 	cmp		di, ax				; Before first thumb line?
    61 000007EC 7205                <2> 	jb		SHORT .ReturnTrackCharacter
    62 000007EE E80900              <2> 	call	.GetLastThumbLineToAX
    63 000007F1 39F8                <2> 	cmp		ax, di				; After last thumb line?
    64                              <2> ALIGN MENU_JUMP_ALIGN
    65                              <2> .ReturnTrackCharacter:
    66 000007F3 B0B1                <2> 	mov		al, SCROLL_TRACK_CHARACTER
    67 000007F5 7202                <2> 	jb		SHORT .Return
    68 000007F7 B0DB                <2> 	mov		al, SCROLL_THUMB_CHARACTER
    69                              <2> ALIGN MENU_JUMP_ALIGN, ret
    70                              <2> .Return:
    71 000007F9 C3                  <2> 	ret
    72                              <2> 
    73                              <2> ;--------------------------------------------------------------------
    74                              <2> ; .GetLastThumbLineToAX
    75                              <2> ;	Parameters
    76                              <2> ;		CX:		Max visible items on page
    77                              <2> ;		SS:BP:	Ptr to MENU
    78                              <2> ;	Returns:
    79                              <2> ;		AX:		Item line for last thumb character
    80                              <2> ;	Corrupts registers:
    81                              <2> ;		DX
    82                              <2> ;--------------------------------------------------------------------
    83                              <2> ALIGN MENU_JUMP_ALIGN
    84                              <2> .GetLastThumbLineToAX:
    85 000007FA E84E00              <2> 	call	MenuScrollbars_GetLastVisibleItemOnPageToAX
    86                              <2> 	; Fall to .CalculateFirstOrLastThumbLineToAX
    87                              <2> 
    88                              <2> ;--------------------------------------------------------------------
    89                              <2> ; .CalculateFirstOrLastThumbLineToAX
    90                              <2> ;	Parameters
    91                              <2> ;		AX:		Index of first or last visible item on page
    92                              <2> ;		CX:		Max visible items on page
    93                              <2> ;		SS:BP:	Ptr to MENU
    94                              <2> ;	Returns:
    95                              <2> ;		AX:		Item line for first thumb character
    96                              <2> ;	Corrupts registers:
    97                              <2> ;		DX
    98                              <2> ;--------------------------------------------------------------------
    99                              <2> ALIGN MENU_JUMP_ALIGN
   100                              <2> .CalculateFirstOrLastThumbLineToAX:
   101 000007FD F7E1                <2> 	mul		cx
   102 000007FF F77600              <2> 	div		WORD [bp+MENUINIT.wItems]
   103 00000802 C3                  <2> 	ret		; (Visible items on page * First visible item on page) / total items
   104                              <2> 
   105                              <2> 
   106                              <2> ;--------------------------------------------------------------------
   107                              <2> ; MenuScrollbars_MoveHighlightedItemByAX
   108                              <2> ;	Parameters
   109                              <2> ;		AX:		Signed offset to new item to be highlighted
   110                              <2> ;		SS:BP:	Ptr to MENU
   111                              <2> ;	Returns:
   112                              <2> ;		Nothing
   113                              <2> ;	Corrupts registers:
   114                              <2> ;		AX, BX, CX, DX, SI, DI
   115                              <2> ;--------------------------------------------------------------------
   116                              <2> ALIGN MENU_JUMP_ALIGN
   117                              <2> MenuScrollbars_MoveHighlightedItemByAX:
   118 00000803 8B4E02              <2> 	mov		cx, [bp+MENUINIT.wHighlightedItem]
   119 00000806 01C1                <2> 	add		cx, ax
   120                              <2> 	; Fall to .RotateItemInCX
   121                              <2> 
   122                              <2> ;--------------------------------------------------------------------
   123                              <2> ; .RotateItemInCX
   124                              <2> ;	Parameters
   125                              <2> ;		CX:		Possibly under of overflown item to be rotated
   126                              <2> ;		SS:BP:	Ptr to MENU
   127                              <2> ;	Returns:
   128                              <2> ;		CX:		Valid item index
   129                              <2> ;	Corrupts registers:
   130                              <2> ;		DX
   131                              <2> ;--------------------------------------------------------------------
   132                              <2> ;.RotateItemInCX:
   133 00000808 8B5600              <2> 	mov		dx, [bp+MENUINIT.wItems]
   134 0000080B 85C9                <2> 	test	cx, cx
   135 0000080D 7804                <2> 	js		SHORT .RotateNegativeItemInCX
   136 0000080F 29D1                <2> 	sub		cx, dx
   137 00000811 7302                <2> 	jae		SHORT .ScrollPageForNewItemInCX
   138                              <2> 
   139                              <2> ALIGN MENU_JUMP_ALIGN
   140                              <2> .RotateNegativeItemInCX:
   141 00000813 01D1                <2> 	add		cx, dx
   142                              <2> 	; Fall to .ScrollPageForNewItemInCX
   143                              <2> 
   144                              <2> ;--------------------------------------------------------------------
   145                              <2> ; .ScrollPageForNewItemInCX
   146                              <2> ;	Parameters
   147                              <2> ;		CX:		New item to be highlighted
   148                              <2> ;		SS:BP:	Ptr to MENU
   149                              <2> ;	Returns:
   150                              <2> ;		Nothing
   151                              <2> ;	Corrupts registers:
   152                              <2> ;		AX, BX, CX, DX, SI, DI
   153                              <2> ;--------------------------------------------------------------------
   154                              <2> ALIGN MENU_JUMP_ALIGN
   155                              <2> .ScrollPageForNewItemInCX:
   156 00000815 E82500              <2> 	call	MenuScrollbars_IsItemInCXonVisiblePage
   157 00000818 7220                <2> 	jc		SHORT .HighlightNewItemOnCX
   158                              <2> 
   159 0000081A 8B5612              <2> 	mov		dx, [bp+MENU.wFirstVisibleItem]
   160 0000081D 2B5602              <2> 	sub		dx, [bp+MENUINIT.wHighlightedItem]
   161                              <2> 
   162                              <2> 	; Get MaxFirstVisibleItem to AX
   163 00000820 51                  <2> 	push	cx
   164 00000821 E83D00              <2> 	call	MenuScrollbars_GetMaxVisibleItemsOnPageToCX
   165 00000824 8B4600              <2> 	mov		ax, [bp+MENUINIT.wItems]
   166 00000827 29C8                <2> 	sub		ax, cx
   167 00000829 59                  <2> 	pop		cx
   168                              <2> 
   169 0000082A 01CA                <2> 	add		dx, cx
   170 0000082C 7901                <2> 	jns		.DXisPositive
   171 0000082E 99                  <2> 	cwd		; This won't work if MaxFirstVisibleItem > 32767
   172                              <2> 
   173                              <2> ALIGN MENU_JUMP_ALIGN
   174                              <2> .DXisPositive:
   175 0000082F 39D0                <2> 	cmp		ax, dx
   176 00000831 7201                <2> 	jb		.AXisLessThanDX
   177 00000833 92                  <2> 	xchg	dx, ax
   178                              <2> 
   179                              <2> ALIGN MENU_JUMP_ALIGN
   180                              <2> .AXisLessThanDX:
   181 00000834 894612              <2> 	mov		[bp+MENU.wFirstVisibleItem], ax
   182 00000837 E87E00              <2> 	call	MenuText_RefreshAllItems
   183                              <2> 
   184                              <2> ALIGN MENU_JUMP_ALIGN
   185                              <2> .HighlightNewItemOnCX:
   186 0000083A E94FFE              <2> 	jmp		MenuEvent_HighlightItemFromCX
   187                              <2> 
   188                              <2> 
   189                              <2> ;--------------------------------------------------------------------
   190                              <2> ; MenuScrollbars_IsItemInCXonVisiblePage
   191                              <2> ;	Parameters
   192                              <2> ;		CX:		Item whose visibility is to be checked
   193                              <2> ;		SS:BP:	Ptr to MENU
   194                              <2> ;	Returns:
   195                              <2> ;		CF:		Set if item is on visible page
   196                              <2> ;				Cleared if item is not on visible page
   197                              <2> ;	Corrupts registers:
   198                              <2> ;		AX
   199                              <2> ;--------------------------------------------------------------------
   200                              <2> ALIGN MENU_JUMP_ALIGN
   201                              <2> MenuScrollbars_IsItemInCXonVisiblePage:
   202 0000083D 394E12              <2> 	cmp		[bp+MENU.wFirstVisibleItem], cx
   203 00000840 7708                <2> 	ja		SHORT .ItemIsNotVisible
   204                              <2> 
   205 00000842 E80600              <2> 	call	MenuScrollbars_GetLastVisibleItemOnPageToAX
   206 00000845 39C1                <2> 	cmp		cx, ax
   207 00000847 7701                <2> 	ja		SHORT .ItemIsNotVisible
   208 00000849 F9                  <2> 	stc		; Item is visible
   209                              <2> ALIGN MENU_JUMP_ALIGN, ret
   210                              <2> .ItemIsNotVisible:
   211 0000084A C3                  <2> 	ret
   212                              <2> 
   213                              <2> 
   214                              <2> ;--------------------------------------------------------------------
   215                              <2> ; MenuScrollbars_GetLastVisibleItemOnPageToAX
   216                              <2> ;	Parameters
   217                              <2> ;		SS:BP:	Ptr to MENU
   218                              <2> ;	Returns:
   219                              <2> ;		AX:		Index of last visible item on page
   220                              <2> ;	Corrupts registers:
   221                              <2> ;		Nothing
   222                              <2> ;--------------------------------------------------------------------
   223                              <2> ALIGN MENU_JUMP_ALIGN
   224                              <2> MenuScrollbars_GetLastVisibleItemOnPageToAX:
   225 0000084B 91                  <2> 	xchg	cx, ax
   226 0000084C E80600              <2> 	call	MenuScrollbars_GetActualVisibleItemsOnPageToCX
   227 0000084F 91                  <2> 	xchg	ax, cx
   228 00000850 48                  <2> 	dec		ax
   229 00000851 034612              <2> 	add		ax, [bp+MENU.wFirstVisibleItem]
   230 00000854 C3                  <2> 	ret
   231                              <2> 
   232                              <2> 
   233                              <2> ;--------------------------------------------------------------------
   234                              <2> ; MenuScrollbars_GetActualVisibleItemsOnPageToCX
   235                              <2> ;	Parameters
   236                              <2> ;		SS:BP:	Ptr to MENU
   237                              <2> ;	Returns:
   238                              <2> ;		CX:		Currently visible items
   239                              <2> ;	Corrupts registers:
   240                              <2> ;		Nothing
   241                              <2> ;--------------------------------------------------------------------
   242                              <2> ALIGN MENU_JUMP_ALIGN
   243                              <2> MenuScrollbars_GetActualVisibleItemsOnPageToCX:
   244 00000855 E80900              <2> 	call	MenuScrollbars_GetMaxVisibleItemsOnPageToCX
   245 00000858 3B4E00              <2> 	cmp		cx, [bp+MENUINIT.wItems]
   246 0000085B 7203                <2> 	jb		SHORT .Return
   247 0000085D 8B4E00              <2> 	mov		cx, [bp+MENUINIT.wItems]
   248                              <2> ALIGN MENU_JUMP_ALIGN, ret
   249                              <2> .Return:
   250 00000860 C3                  <2> 	ret
   251                              <2> 
   252                              <2> 
   253                              <2> ;--------------------------------------------------------------------
   254                              <2> ; MenuScrollbars_GetMaxVisibleItemsOnPageToCX
   255                              <2> ;	Parameters
   256                              <2> ;		SS:BP:	Ptr to MENU
   257                              <2> ;	Returns:
   258                              <2> ;		CX:		Maximum number of visible items
   259                              <2> ;	Corrupts registers:
   260                              <2> ;		Nothing
   261                              <2> ;--------------------------------------------------------------------
   262                              <2> ALIGN MENU_JUMP_ALIGN
   263                              <2> MenuScrollbars_GetMaxVisibleItemsOnPageToCX:
   264                              <2> 	eMOVZX	cx, [bp+MENUINIT.bHeight]
   264                              <3> %ifndef USE_386
   264                              <3>  %ifidni %1, ax
   264                              <3>  mov al, %2
   264                              <3>  xor ah, ah
   264                              <3>  %elifidni %1, bx
   264                              <3>  mov bl, %2
   264                              <3>  xor bh, bh
   264                              <3>  %elifidni %1, cx
   264 00000861 8A4E07              <3>  mov cl, %2
   264 00000864 30ED                <3>  xor ch, ch
   264                              <3>  %elifidni %1, dx
   264                              <3>  mov dl, %2
   264                              <3>  xor dh, dh
   264                              <3>  %else
   264                              <3>  push ax
   264                              <3>  mov al, %2
   264                              <3>  xor ah, ah
   264                              <3>  xchg ax, %1
   264                              <3>  pop ax
   264                              <3>  %endif
   264                              <3> 
   264                              <3> %else
   264                              <3>  movzx %1, %2
   264                              <3> %endif
   265 00000866 2A4E04              <2> 	sub		cl, [bp+MENUINIT.bTitleLines]
   266 00000869 2A4E05              <2> 	sub		cl, [bp+MENUINIT.bInfoLines]
   267 0000086C 80E905              <2> 	sub		cl, MENU_VERTICAL_BORDER_LINES
   268 0000086F C3                  <2> 	ret
    70                              <1> 	%include "MenuText.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for drawing menu texts by the user.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; MenuText_ClearTitleArea
    26                              <2> ; MenuText_ClearInformationArea
    27                              <2> ;	Parameters
    28                              <2> ;		SS:BP:	Ptr to MENU
    29                              <2> ;	Returns:
    30                              <2> ;		Nothing
    31                              <2> ;	Corrupts registers:
    32                              <2> ;		AX, BX, CX, DX, SI, DI
    33                              <2> ;--------------------------------------------------------------------
    34                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    35                              <2> ALIGN MENU_JUMP_ALIGN
    36                              <2> MenuText_ClearTitleArea:
    37                              <2> 	CALL_DISPLAY_LIBRARY PushDisplayContext		; Save cursor coordinates
    38                              <2> 	call	PrepareToDrawTitleArea
    39                              <2> 	mov		cl, [bp+MENUINIT.bTitleLines]
    40                              <2> 	jmp		SHORT MenuText_ClearInformationArea.ClearCLlinesOfText
    41                              <2> %endif
    42                              <2> 
    43                              <2> ALIGN MENU_JUMP_ALIGN
    44                              <2> MenuText_ClearInformationArea:
    45                              <2> 	CALL_DISPLAY_LIBRARY PushDisplayContext		; Save cursor coordinates
    45                              <3>  %ifidn %1, PushDisplayContext
    45 00000870 E817FA              <3>  call DisplayContext_Push
    45                              <3>  %elifidn %1, PopDisplayContext
    45                              <3>  call DisplayContext_Pop
    45                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    45                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    45                              <3>  %else
    45                              <3>  mov di, %1
    45                              <3>  call Display_FunctionFromDI
    45                              <3>  %endif
    46 00000873 E83700              <2> 	call	MenuText_PrepareToDrawInformationArea
    47 00000876 8A4E05              <2> 	mov		cl, [bp+MENUINIT.bInfoLines]
    48                              <2> .ClearCLlinesOfText:
    49 00000879 8A4606              <2> 	mov		al, [bp+MENUINIT.bWidth]
    50 0000087C 2C04                <2> 	sub		al, MENU_HORIZONTAL_BORDER_LINES+(MENU_TEXT_COLUMN_OFFSET/2)
    51 0000087E F6E1                <2> 	mul		cl
    52 00000880 91                  <2> 	xchg	cx, ax
    53 00000881 B020                <2> 	mov		al, ' '
    54                              <2> 	CALL_DISPLAY_LIBRARY PrintRepeatedCharacterFromALwithCountInCX
    54                              <3>  %ifidn %1, PushDisplayContext
    54                              <3>  call DisplayContext_Push
    54                              <3>  %elifidn %1, PopDisplayContext
    54                              <3>  call DisplayContext_Pop
    54                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    54                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    54                              <3>  %else
    54 00000883 BF[9E03]            <3>  mov di, %1
    54 00000886 E866F9              <3>  call Display_FunctionFromDI
    54                              <3>  %endif
    55                              <2> 	JMP_DISPLAY_LIBRARY PopDisplayContext
    55                              <3>  %ifidn %1, PushDisplayContext
    55                              <3>  jmp DisplayContext_Push
    55                              <3>  %elifidn %1, PopDisplayContext
    55 00000889 E821FA              <3>  call DisplayContext_Pop
    55 0000088C C3                  <3>  ret
    55                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    55                              <3>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    55                              <3>  %elifidn %1, FormatNullTerminatedStringFromCSSI
    55                              <3>  mov di, %1
    55                              <3>  call Display_FunctionFromDI
    55                              <3>  ret
    55                              <3>  %else
    55                              <3>  mov di, %1
    55                              <3>  jmp Display_FunctionFromDI
    55                              <3>  %endif
    56                              <2> 
    57                              <2> 
    58                              <2> ;--------------------------------------------------------------------
    59                              <2> ; MenuText_RefreshTitle
    60                              <2> ; MenuText_RefreshInformation
    61                              <2> ;	Parameters
    62                              <2> ;		SS:BP:	Ptr to MENU
    63                              <2> ;	Returns:
    64                              <2> ;		Nothing
    65                              <2> ;	Corrupts registers:
    66                              <2> ;		AX, BX, CX, DX, SI, DI
    67                              <2> ;--------------------------------------------------------------------
    68                              <2> ALIGN MENU_JUMP_ALIGN
    69                              <2> MenuText_RefreshTitle:
    70 0000088D 807E0400            <2> 	cmp		BYTE [bp+MENUINIT.bTitleLines], 0
    71 00000891 7433                <2> 	jz		SHORT NothingToRefresh
    72 00000893 E80F00              <2> 	call	PrepareToDrawTitleArea
    73 00000896 E9E5FD              <2> 	jmp		MenuEvent_RefreshTitle
    74                              <2> 
    75                              <2> ALIGN MENU_JUMP_ALIGN
    76                              <2> MenuText_RefreshInformation:
    77 00000899 807E0500            <2> 	cmp		BYTE [bp+MENUINIT.bInfoLines], 0
    78 0000089D 7427                <2> 	jz		SHORT NothingToRefresh
    79 0000089F E80B00              <2> 	call	MenuText_PrepareToDrawInformationArea
    80 000008A2 E9DCFD              <2> 	jmp		MenuEvent_RefreshInformation
    81                              <2> 
    82                              <2> ;--------------------------------------------------------------------
    83                              <2> ; PrepareToDrawTitleArea
    84                              <2> ; PrepareToDrawInformationArea
    85                              <2> ;	Parameters
    86                              <2> ;		SS:BP:	Ptr to MENU
    87                              <2> ;	Returns:
    88                              <2> ;		Nothing
    89                              <2> ;	Corrupts registers:
    90                              <2> ;		AX, BX, DX, SI, DI
    91                              <2> ;--------------------------------------------------------------------
    92                              <2> ALIGN MENU_JUMP_ALIGN
    93                              <2> PrepareToDrawTitleArea:
    94 000008A5 BE0200              <2> 	mov		si, ATTRIBUTE_CHARS.cTitle
    95 000008A8 E863FE              <2> 	call	MenuLocation_GetTitleTextTopLeftCoordinatesToAX
    96 000008AB EB06                <2> 	jmp		SHORT FinishPreparationsToDrawTitleOrInformationArea
    97                              <2> 
    98                              <2> ALIGN MENU_JUMP_ALIGN
    99                              <2> MenuText_PrepareToDrawInformationArea:
   100 000008AD BE0200              <2> 	mov		si, ATTRIBUTE_CHARS.cInformation
   101 000008B0 E863FE              <2> 	call	MenuLocation_GetInformationTextTopLeftCoordinatesToAX
   102                              <2> FinishPreparationsToDrawTitleOrInformationArea:
   103 000008B3 BA[5106]            <2> 	mov		dx, MenuCharOut_MenuTeletypeOutputWithAutomaticLineChange
   104 000008B6 EB31                <2> 	jmp		SHORT AdjustDisplayContextForDrawingTextsAtCoordsInAXwithAttrTypeInSIandCharOutFunctionInDX
   105                              <2> 
   106                              <2> 
   107                              <2> ;--------------------------------------------------------------------
   108                              <2> ; MenuText_RefreshAllItems
   109                              <2> ;	Parameters
   110                              <2> ;		SS:BP:	Ptr to MENU
   111                              <2> ;	Returns:
   112                              <2> ;		Nothing
   113                              <2> ;	Corrupts registers:
   114                              <2> ;		AX, BX, DX, SI, DI
   115                              <2> ;--------------------------------------------------------------------
   116                              <2> ALIGN MENU_JUMP_ALIGN
   117                              <2> MenuText_RefreshAllItems:
   118 000008B8 51                  <2> 	push	cx
   119                              <2> 
   120 000008B9 E899FF              <2> 	call	MenuScrollbars_GetActualVisibleItemsOnPageToCX
   121 000008BC 8B4612              <2> 	mov		ax, [bp+MENU.wFirstVisibleItem]
   122                              <2> ALIGN MENU_JUMP_ALIGN
   123                              <2> .ItemRefreshLoop:
   124 000008BF E80500              <2> 	call	MenuText_RefreshItemFromAX
   125 000008C2 40                  <2> 	inc		ax
   126 000008C3 E2FA                <2> 	loop	.ItemRefreshLoop
   127                              <2> 
   128 000008C5 59                  <2> 	pop		cx
   129                              <2> NothingToRefresh:
   130 000008C6 C3                  <2> 	ret
   131                              <2> 
   132                              <2> ;--------------------------------------------------------------------
   133                              <2> ; MenuText_RefreshItemFromAX
   134                              <2> ;	Parameters
   135                              <2> ;		AX:		Item to refresh
   136                              <2> ;		SS:BP:	Ptr to MENU
   137                              <2> ;	Returns:
   138                              <2> ;		Nothing
   139                              <2> ;	Corrupts registers:
   140                              <2> ;		BX, DX, SI, DI
   141                              <2> ;--------------------------------------------------------------------
   142                              <2> ALIGN MENU_JUMP_ALIGN
   143                              <2> MenuText_RefreshItemFromAX:
   144 000008C7 51                  <2> 	push	cx
   145 000008C8 50                  <2> 	push	ax
   146                              <2> 
   147 000008C9 91                  <2> 	xchg	cx, ax
   148 000008CA E870FF              <2> 	call	MenuScrollbars_IsItemInCXonVisiblePage
   149 000008CD 730C                <2> 	jnc		SHORT .InvalidItem
   150 000008CF E80C00              <2> 	call	MenuText_AdjustDisplayContextForDrawingItemFromCX
   151 000008D2 E82900              <2> 	call	ClearPreviousItem
   152 000008D5 E8B0FD              <2> 	call	MenuEvent_RefreshItemFromCX
   153 000008D8 E85000              <2> 	call	DrawScrollbarCharacterForItemInCXifNecessary
   154                              <2> .InvalidItem:
   155 000008DB 58                  <2> 	pop		ax
   156 000008DC 59                  <2> 	pop		cx
   157 000008DD C3                  <2> 	ret
   158                              <2> 
   159                              <2> ;--------------------------------------------------------------------
   160                              <2> ; MenuText_AdjustDisplayContextForDrawingItemFromCX
   161                              <2> ;	Parameters
   162                              <2> ;		CX:		Item to refresh
   163                              <2> ;		SS:BP:	Ptr to MENU
   164                              <2> ;	Returns:
   165                              <2> ;		Nothing
   166                              <2> ;	Corrupts registers:
   167                              <2> ;		AX, BX, DX, SI, DI
   168                              <2> ;--------------------------------------------------------------------
   169                              <2> ALIGN MENU_JUMP_ALIGN
   170                              <2> MenuText_AdjustDisplayContextForDrawingItemFromCX:
   171 000008DE 89C8                <2> 	mov		ax, cx
   172 000008E0 E83600              <2> 	call	GetItemTextAttributeTypeToSIforItemInCX
   173 000008E3 E81BFE              <2> 	call	MenuLocation_GetTextCoordinatesToAXforItemInAX
   174 000008E6 BA[5D06]            <2> 	mov		dx, MenuCharOut_MenuTeletypeOutput
   175                              <2> 	; Fall to AdjustDisplayContextForDrawingTextsAtCoordsInAXwithAttrTypeInSIandCharOutFunctionInDX
   176                              <2> 
   177                              <2> ;--------------------------------------------------------------------
   178                              <2> ; AdjustDisplayContextForDrawingTextsAtCoordsInAXwithAttrTypeInSIandCharOutFunctionInDX
   179                              <2> ;	Parameters
   180                              <2> ;		AX:		Cursor coordinates to set
   181                              <2> ;		DX:		Character output function
   182                              <2> ;		SI:		Attribute type (from ATTRIBUTE_CHARS)
   183                              <2> ;		SS:BP:	Ptr to MENU
   184                              <2> ;	Returns:
   185                              <2> ;		Nothing
   186                              <2> ;	Corrupts registers:
   187                              <2> ;		AX, BX, DX, SI, DI
   188                              <2> ;--------------------------------------------------------------------
   189                              <2> ALIGN MENU_JUMP_ALIGN
   190                              <2> AdjustDisplayContextForDrawingTextsAtCoordsInAXwithAttrTypeInSIandCharOutFunctionInDX:
   191                              <2> 	CALL_DISPLAY_LIBRARY SetCursorCoordinatesFromAX
   191                              <3>  %ifidn %1, PushDisplayContext
   191                              <3>  call DisplayContext_Push
   191                              <3>  %elifidn %1, PopDisplayContext
   191                              <3>  call DisplayContext_Pop
   191                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   191                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   191                              <3>  %else
   191 000008E9 BF[FF02]            <3>  mov di, %1
   191 000008EC E800F9              <3>  call Display_FunctionFromDI
   191                              <3>  %endif
   192                              <2> 
   193 000008EF 92                  <2> 	xchg	ax, dx
   194 000008F0 B301                <2> 	mov		bl, ATTRIBUTES_ARE_USED
   195                              <2> 	CALL_DISPLAY_LIBRARY SetCharOutputFunctionFromAXwithAttribFlagInBL
   195                              <3>  %ifidn %1, PushDisplayContext
   195                              <3>  call DisplayContext_Push
   195                              <3>  %elifidn %1, PopDisplayContext
   195                              <3>  call DisplayContext_Pop
   195                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   195                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   195                              <3>  %else
   195 000008F2 BF[D502]            <3>  mov di, %1
   195 000008F5 E8F7F8              <3>  call Display_FunctionFromDI
   195                              <3>  %endif
   196                              <2> 
   197 000008F8 E87AFB              <2> 	call	CharOutLineSplitter_PrepareForPrintingTextLines
   198 000008FB E9E3FB              <2> 	jmp		MenuAttribute_SetToDisplayContextFromTypeInSI
   199                              <2> 
   200                              <2> 
   201                              <2> ;--------------------------------------------------------------------
   202                              <2> ; ClearPreviousItem
   203                              <2> ;	Parameters
   204                              <2> ;		SS:BP:	Ptr to MENU
   205                              <2> ;	Returns:
   206                              <2> ;		Nothing
   207                              <2> ;	Corrupts registers:
   208                              <2> ;		AX, BX, DX, DI
   209                              <2> ;--------------------------------------------------------------------
   210                              <2> ALIGN MENU_JUMP_ALIGN
   211                              <2> ClearPreviousItem:
   212                              <2> 	CALL_DISPLAY_LIBRARY GetSoftwareCoordinatesToAX
   212                              <3>  %ifidn %1, PushDisplayContext
   212                              <3>  call DisplayContext_Push
   212                              <3>  %elifidn %1, PopDisplayContext
   212                              <3>  call DisplayContext_Pop
   212                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   212                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   212                              <3>  %else
   212 000008FE BF[1403]            <3>  mov di, %1
   212 00000901 E8EBF8              <3>  call Display_FunctionFromDI
   212                              <3>  %endif
   213 00000904 93                  <2> 	xchg	bx, ax
   214                              <2> 
   215 00000905 E864FC              <2> 	call	MenuBorders_GetNumberOfMiddleCharactersToDX
   216 00000908 83EA02              <2> 	sub		dx, BYTE MENU_TEXT_COLUMN_OFFSET
   217 0000090B 2EA0[4F06]          <2> 	mov		al, [cs:g_rgbTextBorderCharacters+BORDER_CHARS.cMiddle]
   218 0000090F E803FD              <2> 	call	MenuBorders_PrintMultipleBorderCharactersFromAL
   219                              <2> 
   220 00000912 93                  <2> 	xchg	ax, bx
   221                              <2> 	JMP_DISPLAY_LIBRARY SetCursorCoordinatesFromAX
   221                              <3>  %ifidn %1, PushDisplayContext
   221                              <3>  jmp DisplayContext_Push
   221                              <3>  %elifidn %1, PopDisplayContext
   221                              <3>  call DisplayContext_Pop
   221                              <3>  ret
   221                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   221                              <3>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   221                              <3>  %elifidn %1, FormatNullTerminatedStringFromCSSI
   221                              <3>  mov di, %1
   221                              <3>  call Display_FunctionFromDI
   221                              <3>  ret
   221                              <3>  %else
   221 00000913 BF[FF02]            <3>  mov di, %1
   221 00000916 E9D6F8              <3>  jmp Display_FunctionFromDI
   221                              <3>  %endif
   222                              <2> 
   223                              <2> 
   224                              <2> ;--------------------------------------------------------------------
   225                              <2> ; GetItemTextAttributeTypeToSIforItemInCX
   226                              <2> ;	Parameters
   227                              <2> ;		CX:		Item to refresh
   228                              <2> ;		SS:BP:	Ptr to MENU
   229                              <2> ;	Returns:
   230                              <2> ;		SI:		Text attribute type (ATTRIBUTE_CHARS)
   231                              <2> ;	Corrupts registers:
   232                              <2> ;		Nothing
   233                              <2> ;--------------------------------------------------------------------
   234                              <2> ALIGN MENU_JUMP_ALIGN
   235                              <2> GetItemTextAttributeTypeToSIforItemInCX:
   236 00000919 BE0300              <2> 	mov		si, ATTRIBUTE_CHARS.cItem
   237 0000091C F6460E02            <2> 	test	BYTE [bp+MENU.bFlags], FLG_MENU_NOHIGHLIGHT
   238 00000920 7508                <2> 	jnz		SHORT .ReturnAttributeTypeInSI
   239                              <2> 
   240 00000922 3B4E02              <2> 	cmp		cx, [bp+MENUINIT.wHighlightedItem]
   241 00000925 7503                <2> 	jne		SHORT .ReturnAttributeTypeInSI
   242 00000927 83EEFF              <2> 	sub		si, BYTE ATTRIBUTE_CHARS.cItem - ATTRIBUTE_CHARS.cHighlightedItem
   243                              <2> ALIGN MENU_JUMP_ALIGN, ret
   244                              <2> .ReturnAttributeTypeInSI:
   245 0000092A C3                  <2> 	ret
   246                              <2> 
   247                              <2> 
   248                              <2> ;--------------------------------------------------------------------
   249                              <2> ; DrawScrollbarCharacterForItemInCXifNecessary
   250                              <2> ;	Parameters
   251                              <2> ;		CX:		Item to refresh
   252                              <2> ;		SS:BP:	Ptr to MENU
   253                              <2> ;	Returns:
   254                              <2> ;		Nothing
   255                              <2> ;	Corrupts registers:
   256                              <2> ;		AX, CX, BX, DX, SI, DI
   257                              <2> ;--------------------------------------------------------------------
   258                              <2> ALIGN MENU_JUMP_ALIGN
   259                              <2> DrawScrollbarCharacterForItemInCXifNecessary:
   260 0000092B E8AAFE              <2> 	call	MenuScrollbars_AreScrollbarsNeeded
   261 0000092E 7201                <2> 	jc		SHORT .DrawScrollbarCharacter
   262 00000930 C3                  <2> 	ret
   263                              <2> 
   264                              <2> ALIGN MENU_JUMP_ALIGN
   265                              <2> .DrawScrollbarCharacter:
   266 00000931 E815FC              <2> 	call	MenuBorders_AdjustDisplayContextForDrawingBorders
   267 00000934 89C8                <2> 	mov		ax, cx
   268                              <2> 
   269 00000936 E8C8FD              <2> 	call	MenuLocation_GetTextCoordinatesToAXforItemInAX
   270 00000939 024606              <2> 	add		al, [bp+MENUINIT.bWidth]
   271 0000093C 2C04                <2> 	sub		al, MENU_TEXT_COLUMN_OFFSET*2
   272                              <2> 	CALL_DISPLAY_LIBRARY SetCursorCoordinatesFromAX
   272                              <3>  %ifidn %1, PushDisplayContext
   272                              <3>  call DisplayContext_Push
   272                              <3>  %elifidn %1, PopDisplayContext
   272                              <3>  call DisplayContext_Pop
   272                              <3>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   272                              <3>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   272                              <3>  %else
   272 0000093E BF[FF02]            <3>  mov di, %1
   272 00000941 E8ABF8              <3>  call Display_FunctionFromDI
   272                              <3>  %endif
   273                              <2> 
   274 00000944 89CF                <2> 	mov		di, cx
   275 00000946 2B7E12              <2> 	sub		di, [bp+MENU.wFirstVisibleItem]		; Item to line
   276 00000949 E895FE              <2> 	call	MenuScrollbars_GetScrollCharacterToALForLineInDI
   277 0000094C E9C0FC              <2> 	jmp		MenuBorders_PrintSingleBorderCharacterFromAL
    71                              <1> 	%include "MenuTime.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Menu timeouts other time related functions.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; MenuTime_StartSelectionTimeoutWithTicksInAX
    26                              <2> ;	Parameters
    27                              <2> ;		AX:		Timeout ticks
    28                              <2> ;		SS:BP:	Ptr to MENU
    29                              <2> ;	Returns:
    30                              <2> ;		Nothing
    31                              <2> ;	Corrupts registers:
    32                              <2> ;		AX, BX
    33                              <2> ;--------------------------------------------------------------------
    34                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
    35                              <2> ALIGN MENU_JUMP_ALIGN
    36                              <2> MenuTime_StartSelectionTimeoutWithTicksInAX:
    37 0000094F 1E                  <2> 	push	ds
    38 00000950 E84900              <2> 	call	PointDSBXtoTimeoutCounter
    39 00000953 E85C00              <2> 	call	TimerTicks_InitializeTimeoutFromAX
    40 00000956 804E0E08            <2> 	or		BYTE [bp+MENU.bFlags], FLG_MENU_TIMEOUT_COUNTDOWN
    41 0000095A 1F                  <2> 	pop		ds
    42 0000095B C3                  <2> 	ret
    43                              <2> %endif
    44                              <2> 
    45                              <2> 
    46                              <2> ;--------------------------------------------------------------------
    47                              <2> ; MenuTime_StopSelectionTimeout
    48                              <2> ;	Parameters
    49                              <2> ;		SS:BP:	Ptr to MENU
    50                              <2> ;	Returns:
    51                              <2> ;		Nothing
    52                              <2> ;	Corrupts registers:
    53                              <2> ;		AX, BX, DX, SI, DI
    54                              <2> ;--------------------------------------------------------------------
    55                              <2> ALIGN MENU_JUMP_ALIGN
    56                              <2> MenuTime_StopSelectionTimeout:
    57 0000095C F6460E08            <2> 	test	BYTE [bp+MENU.bFlags], FLG_MENU_TIMEOUT_COUNTDOWN
    58 00000960 7421                <2> 	jz		SHORT TimeoutAlreadyStopped
    59 00000962 80660EF7            <2> 	and		BYTE [bp+MENU.bFlags], ~FLG_MENU_TIMEOUT_COUNTDOWN
    60 00000966 E9CFFB              <2> 	jmp		MenuBorders_RedrawBottomBorderLine
    61                              <2> 
    62                              <2> 
    63                              <2> ;--------------------------------------------------------------------
    64                              <2> ; MenuTime_UpdateSelectionTimeout
    65                              <2> ;	Parameters
    66                              <2> ;		SS:BP:	Ptr to MENU
    67                              <2> ;	Returns:
    68                              <2> ;		CF:		Set if timeout
    69                              <2> ;				Cleared if time left
    70                              <2> ;	Corrupts registers:
    71                              <2> ;		AX, BX, SI, DI
    72                              <2> ;--------------------------------------------------------------------
    73                              <2> ALIGN MENU_JUMP_ALIGN
    74                              <2> MenuTime_UpdateSelectionTimeout:
    75 00000969 F6460E08            <2> 	test	BYTE [bp+MENU.bFlags], FLG_MENU_TIMEOUT_COUNTDOWN
    76 0000096D 7414                <2> 	jz		SHORT .ReturnSinceTimeoutDisabled
    77                              <2> 
    78 0000096F 1E                  <2> 	push	ds
    79 00000970 E82900              <2> 	call	PointDSBXtoTimeoutCounter
    80 00000973 E84400              <2> 	call	TimerTicks_GetTimeoutTicksLeftToAXfromDSBX
    81 00000976 1F                  <2> 	pop		ds
    82 00000977 7306                <2> 	jnc		SHORT .RedrawSinceNoTimeout
    83 00000979 80660EF7            <2> 	and		BYTE [bp+MENU.bFlags], ~FLG_MENU_TIMEOUT_COUNTDOWN
    84 0000097D F9                  <2> 	stc
    85 0000097E C3                  <2> 	ret
    86                              <2> 
    87                              <2> ALIGN MENU_JUMP_ALIGN
    88                              <2> .RedrawSinceNoTimeout:
    89 0000097F E8B6FB              <2> 	call	MenuBorders_RedrawBottomBorderLine
    90 00000982 F8                  <2> 	clc
    91                              <2> .ReturnSinceTimeoutDisabled:
    92                              <2> TimeoutAlreadyStopped:
    93 00000983 C3                  <2> 	ret
    94                              <2> 
    95                              <2> 
    96                              <2> ;--------------------------------------------------------------------
    97                              <2> ; MenuTime_GetTimeoutSecondsLeftToAX
    98                              <2> ;	Parameters
    99                              <2> ;		SS:BP:	Ptr to MENU
   100                              <2> ;	Returns:
   101                              <2> ;		AX:		Seconds until timeout
   102                              <2> ;	Corrupts registers:
   103                              <2> ;		Nothing
   104                              <2> ;--------------------------------------------------------------------
   105                              <2> ALIGN MENU_JUMP_ALIGN
   106                              <2> MenuTime_GetTimeoutSecondsLeftToAX:
   107 00000984 1E                  <2> 	push	ds
   108 00000985 52                  <2> 	push	dx
   109 00000986 51                  <2> 	push	cx
   110 00000987 53                  <2> 	push	bx
   111                              <2> 
   112 00000988 E81100              <2> 	call	PointDSBXtoTimeoutCounter
   113 0000098B E82C00              <2> 	call	TimerTicks_GetTimeoutTicksLeftToAXfromDSBX
   114 0000098E 7205                <2> 	jc		SHORT .TimeoutHasOccurredSoMakeSureTicksAreNotBelowZero
   115                              <2> 
   116 00000990 92                  <2> 	xchg	dx, ax
   117 00000991 E81700              <2> 	call	TimerTicks_GetSecondsToAXfromTicksInDX
   118                              <2> 	SKIP2B	dx
   118                              <3>  %ifidni %1, f
   118                              <3>  db 03Dh
   118                              <3> 
   118                              <3>  %elifidni %1, ax
   118                              <3>  db 0B8h
   118                              <3>  %elifidni %1, cx
   118                              <3>  db 0B9h
   118                              <3>  %elifidni %1, dx
   118 00000994 BA                  <3>  db 0BAh
   118                              <3>  %elifidni %1, bx
   118                              <3>  db 0BBh
   118                              <3>  %elifidni %1, sp
   118                              <3>  db 0BCh
   118                              <3>  %elifidni %1, bp
   118                              <3>  db 0BDh
   118                              <3>  %elifidni %1, si
   118                              <3>  db 0BEh
   118                              <3>  %elifidni %1, di
   118                              <3>  db 0BFh
   118                              <3>  %else
   118                              <3>  %error "Invalid parameter passed to SKIP2B"
   118                              <3>  %endif
   119                              <2> .TimeoutHasOccurredSoMakeSureTicksAreNotBelowZero:
   120 00000995 31C0                <2> 	xor		ax, ax
   121                              <2> 
   122 00000997 5B                  <2> 	pop		bx
   123 00000998 59                  <2> 	pop		cx
   124 00000999 5A                  <2> 	pop		dx
   125 0000099A 1F                  <2> 	pop		ds
   126 0000099B C3                  <2> 	ret
   127                              <2> 
   128                              <2> 
   129                              <2> ;--------------------------------------------------------------------
   130                              <2> ; PointDSBXtoTimeoutCounter
   131                              <2> ;	Parameters
   132                              <2> ;		SS:BP:	Ptr to MENU
   133                              <2> ;	Returns:
   134                              <2> ;		DS:BX:	Ptr to timeout counter
   135                              <2> ;	Corrupts registers:
   136                              <2> ;		Nothing
   137                              <2> ;--------------------------------------------------------------------
   138                              <2> ALIGN MENU_JUMP_ALIGN
   139                              <2> PointDSBXtoTimeoutCounter:
   140 0000099C 16                  <2> 	push	ss
   141 0000099D 1F                  <2> 	pop		ds
   142 0000099E 8D5E10              <2> 	lea		bx, [bp+MENU.wTimeoutCounter]
   143 000009A1 C3                  <2> 	ret
    72                              <1> 
    73                              <1> 	%ifdef INCLUDE_MENU_DIALOGS
    74                              <1> 		%include "Dialog.asm"
    75                              <1> 		%include "DialogDrive.asm"
    76                              <1> 		%include "DialogFile.asm"
    77                              <1> 		%include "DialogMessage.asm"
    78                              <1> 		%include "DialogProgress.asm"
    79                              <1> 		%include "DialogSelection.asm"
    80                              <1> 		%include "DialogString.asm"
    81                              <1> 		%include "DialogWord.asm"
    82                              <1> 		%include "ItemLineSplitter.asm"
    83                              <1> 		%include "StringsForDialogs.asm"
    84                              <1> 	%endif
    85                              <1> %endif
    86                              <1> 
    87                              <1> %ifdef INCLUDE_STRING_LIBRARY
    88                              <1>   %ifndef STRING_JUMP_ALIGN
    89                              <1> 	%define STRING_JUMP_ALIGN 1
    90                              <1>   %endif
    91                              <1> 	%include "Char.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for handling characters.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> ; Section containing code
    21                              <2> SECTION .text
    22                              <2> 
    23                              <2> ;--------------------------------------------------------------------
    24                              <2> ; This macro can only be used within this source file!!!
    25                              <2> ; IS_BETWEEN_IMMEDIATES
    26                              <2> ;	Parameters:
    27                              <2> ;		%1:		Value to check
    28                              <2> ;		%2:		First accepted value in range
    29                              <2> ;		%3:		Last accepted value in range
    30                              <2> ;	Returns:
    31                              <2> ;		CF:		Set if character in range
    32                              <2> ;				(Jumps to Char_CharIsNotValid if before range)
    33                              <2> ;	Corrupts registers:
    34                              <2> ;		Nothing
    35                              <2> ;--------------------------------------------------------------------
    36                              <2> %macro IS_BETWEEN_IMMEDIATES 3
    37                              <2> 	cmp		%1, %2
    38                              <2> 	jb		SHORT Char_CharIsNotValid
    39                              <2> 	cmp		%1, (%3)+1				; Set CF if %1 is lesser
    40                              <2> %endmacro
    41                              <2> 
    42                              <2> 
    43                              <2> ;--------------------------------------------------------------------
    44                              <2> ; Char_IsLowerCaseLetterInAL
    45                              <2> ;	Parameters:
    46                              <2> ;		AL:		Character to check
    47                              <2> ;	Returns:
    48                              <2> ;		CF:		Set if character is lower case letter ('a'...'z')
    49                              <2> ;				Cleared if character is not lower case letter
    50                              <2> ;	Corrupts registers:
    51                              <2> ;		Nothing
    52                              <2> ;--------------------------------------------------------------------
    53                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    54                              <2> 	%ifndef MODULE_HOTKEYS
    55                              <2> 		%define EXCLUDE
    56                              <2> 	%endif
    57                              <2> %endif
    58                              <2> 
    59                              <2> %ifndef EXCLUDE
    60                              <2> ALIGN STRING_JUMP_ALIGN
    61                              <2> Char_IsLowerCaseLetterInAL:
    62                              <2> 	IS_BETWEEN_IMMEDIATES al, 'a', 'z'
    62 000009A2 3C61                <3>  cmp %1, %2
    62 000009A4 7203                <3>  jb SHORT Char_CharIsNotValid
    62 000009A6 3C7B                <3>  cmp %1, (%3)+1
    63 000009A8 C3                  <2> 	ret
    64                              <2> %endif
    65                              <2> %undef EXCLUDE
    66                              <2> 
    67                              <2> 
    68                              <2> ;--------------------------------------------------------------------
    69                              <2> ; Char_IsUpperCaseLetterInAL
    70                              <2> ;	Parameters:
    71                              <2> ;		AL:		Character to check
    72                              <2> ;	Returns:
    73                              <2> ;		CF:		Set if character is upper case letter ('A'...'Z')
    74                              <2> ;				Cleared if character is not upper case letter
    75                              <2> ;	Corrupts registers:
    76                              <2> ;		Nothing
    77                              <2> ;--------------------------------------------------------------------
    78                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    79                              <2> ALIGN STRING_JUMP_ALIGN
    80                              <2> Char_IsUpperCaseLetterInAL:
    81                              <2> 	IS_BETWEEN_IMMEDIATES al, 'A', 'Z'
    82                              <2> 	ret
    83                              <2> %endif
    84                              <2> 
    85                              <2> 
    86                              <2> ;--------------------------------------------------------------------
    87                              <2> ; Char_IsHexadecimalDigitInAL
    88                              <2> ;	Parameters:
    89                              <2> ;		AL:		Character to check
    90                              <2> ;	Returns:
    91                              <2> ;		AL:		Character converted to lower case
    92                              <2> ;		CF:		Set if character is decimal digit ('0'...'F')
    93                              <2> ;				Cleared if character is not decimal digit
    94                              <2> ;	Corrupts registers:
    95                              <2> ;		Nothing
    96                              <2> ;--------------------------------------------------------------------
    97                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    98                              <2> ALIGN STRING_JUMP_ALIGN
    99                              <2> Char_IsHexadecimalDigitInAL:
   100                              <2> 	call	Char_IsDecimalDigitInAL
   101                              <2> 	jc		SHORT Char_CharIsValid
   102                              <2> 	call	Char_ALtoLowerCaseLetter
   103                              <2> 	IS_BETWEEN_IMMEDIATES al, 'a', 'f'
   104                              <2> 	ret
   105                              <2> %endif
   106                              <2> 
   107                              <2> 
   108                              <2> ;--------------------------------------------------------------------
   109                              <2> ; Char_IsDecimalDigitInAL
   110                              <2> ;	Parameters:
   111                              <2> ;		AL:		Character to check
   112                              <2> ;	Returns:
   113                              <2> ;		CF:		Set if character is decimal digit ('0'...'9')
   114                              <2> ;				Cleared if character is not decimal digit
   115                              <2> ;	Corrupts registers:
   116                              <2> ;		Nothing
   117                              <2> ;--------------------------------------------------------------------
   118                              <2> %ifndef MODULE_STRINGS_COMPRESSED
   119                              <2> ALIGN STRING_JUMP_ALIGN
   120                              <2> Char_IsDecimalDigitInAL:
   121                              <2> 	IS_BETWEEN_IMMEDIATES al, '0', '9'
   122                              <2> 	ret
   123                              <2> %endif
   124                              <2> 
   125                              <2> 
   126                              <2> ;--------------------------------------------------------------------
   127                              <2> ; Char_ConvertIntegerToALfromDigitInALwithBaseInBX
   128                              <2> ;	Parameters:
   129                              <2> ;		AL:		Character to convert
   130                              <2> ;		BX:		Numeric base (10 or 16)
   131                              <2> ;	Returns:
   132                              <2> ;		AL:		Character converted to integer
   133                              <2> ;		CF:		Set if character was valid
   134                              <2> ;				Cleared if character was invalid
   135                              <2> ;	Corrupts registers:
   136                              <2> ;		Nothing
   137                              <2> ;--------------------------------------------------------------------
   138                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   139                              <2> ALIGN STRING_JUMP_ALIGN
   140                              <2> Char_ConvertIntegerToALfromDigitInALwithBaseInBX:
   141                              <2> 	push	dx
   142                              <2> 	call	Char_GetFilterFunctionToDXforNumericBaseInBX
   143                              <2> 	call	dx						; Converts to lower case
   144                              <2> 	pop		dx
   145                              <2> 	jnc		SHORT Char_CharIsNotValid
   146                              <2> 
   147                              <2> 	cmp		al, '9'					; Decimal digit
   148                              <2> 	jbe		SHORT .ConvertToDecimalDigit
   149                              <2> 	sub		al, 'a'-'0'-10			; Convert to hexadecimal integer
   150                              <2> ALIGN STRING_JUMP_ALIGN
   151                              <2> .ConvertToDecimalDigit:
   152                              <2> 	sub		al, '0'					; Convert to decimal integer
   153                              <2> 	; Fall to Char_CharIsValid
   154                              <2> %endif
   155                              <2> 
   156                              <2> 
   157                              <2> ;--------------------------------------------------------------------
   158                              <2> ; Char_CharIsValid
   159                              <2> ; Char_CharIsNotValid
   160                              <2> ;	Parameters:
   161                              <2> ;		Nothing
   162                              <2> ;	Returns:
   163                              <2> ;		CF:		Set for Char_CharIsValid
   164                              <2> ;				Cleared for Char_CharIsNotValid
   165                              <2> ;	Corrupts registers:
   166                              <2> ;		Nothing
   167                              <2> ;--------------------------------------------------------------------
   168                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   169                              <2> ALIGN STRING_JUMP_ALIGN
   170                              <2> Char_CharIsValid:
   171                              <2> 	stc
   172                              <2> 	ret
   173                              <2> %endif
   174                              <2> 
   175                              <2> 
   176                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   177                              <2> 	%ifndef MODULE_HOTKEYS
   178                              <2> 		%define EXCLUDE
   179                              <2> 	%endif
   180                              <2> 	%ifndef MODULE_STRINGS_COMPRESSED
   181                              <2> 		%undef EXCLUDE
   182                              <2> 	%endif
   183                              <2> %endif
   184                              <2> 
   185                              <2> %ifndef EXCLUDE
   186                              <2> ALIGN STRING_JUMP_ALIGN
   187                              <2> Char_CharIsNotValid:
   188 000009A9 F8                  <2> 	clc
   189 000009AA C3                  <2> 	ret
   190                              <2> %endif
   191                              <2> %undef EXCLUDE
   192                              <2> 
   193                              <2> 
   194                              <2> ;--------------------------------------------------------------------
   195                              <2> ; Char_ALtoLowerCaseLetter
   196                              <2> ;	Parameters:
   197                              <2> ;		AL:		Character to convert
   198                              <2> ;	Returns:
   199                              <2> ;		AL:		Character with possible conversion
   200                              <2> ;	Corrupts registers:
   201                              <2> ;		Nothing
   202                              <2> ;--------------------------------------------------------------------
   203                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   204                              <2> ALIGN STRING_JUMP_ALIGN
   205                              <2> Char_ALtoLowerCaseLetter:
   206                              <2> 	call	Char_IsUpperCaseLetterInAL	; Is upper case character?
   207                              <2> 	jmp		SHORT Char_ALtoUpperCaseLetter.CheckCF
   208                              <2> %endif
   209                              <2> 
   210                              <2> 
   211                              <2> ;--------------------------------------------------------------------
   212                              <2> ; Char_ALtoUpperCaseLetter
   213                              <2> ;	Parameters:
   214                              <2> ;		AL:		Character to convert
   215                              <2> ;	Returns:
   216                              <2> ;		AL:		Character with possible conversion
   217                              <2> ;	Corrupts registers:
   218                              <2> ;		Nothing
   219                              <2> ;--------------------------------------------------------------------
   220                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   221                              <2> ALIGN STRING_JUMP_ALIGN
   222                              <2> Char_ALtoUpperCaseLetter:
   223                              <2> 	call	Char_IsLowerCaseLetterInAL	; Is lower case character?
   224                              <2> .CheckCF:
   225                              <2> 	jnc		SHORT Char_ChangeCaseInAL.Return
   226                              <2> 	; Fall to Char_ChangeCaseInAL
   227                              <2> %endif
   228                              <2> 
   229                              <2> 
   230                              <2> ;--------------------------------------------------------------------
   231                              <2> ; Char_ChangeCaseInAL
   232                              <2> ;	Parameters:
   233                              <2> ;		AL:		Character to convert (must be A-Z or a-z)
   234                              <2> ;	Returns:
   235                              <2> ;		AL:		Character converted
   236                              <2> ;	Corrupts registers:
   237                              <2> ;		Nothing
   238                              <2> ;--------------------------------------------------------------------
   239                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   240                              <2> Char_ChangeCaseInAL:
   241                              <2> 	xor		al, 32
   242                              <2> .Return:
   243                              <2> 	ret
   244                              <2> %endif
   245                              <2> 
   246                              <2> 
   247                              <2> ;--------------------------------------------------------------------
   248                              <2> ; Char_GetFilterFunctionToDXforNumericBaseInBX
   249                              <2> ;	Parameters
   250                              <2> ;		BX:		Numeric base (10 or 16)
   251                              <2> ;	Returns:
   252                              <2> ;		CS:DX:	Ptr to character filter function
   253                              <2> ;	Corrupts registers:
   254                              <2> ;		Nothing
   255                              <2> ;--------------------------------------------------------------------
   256                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   257                              <2> ALIGN STRING_JUMP_ALIGN
   258                              <2> Char_GetFilterFunctionToDXforNumericBaseInBX:
   259                              <2> 	mov		dx, Char_IsDecimalDigitInAL
   260                              <2> 	cmp		bl, 10
   261                              <2> 	je		SHORT .Return
   262                              <2> 	mov		dx, Char_IsHexadecimalDigitInAL
   263                              <2> .Return:
   264                              <2> 	ret
   265                              <2> %endif
    92                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    93                              <1> 		%include "String.asm"
    94                              <1> 		%include "StringProcess.asm"
    95                              <1> 	%endif
    96                              <1> %endif
    97                              <1> 
    98                              <1> %ifdef INCLUDE_SERIAL_LIBRARY
    99                              <1> 	%include "Serial.inc"
   100                              <1> %endif
   101                              <1> %ifdef INCLUDE_SERIALSERVER_LIBRARY
   102                              <1> 	%include "SerialServer.asm"
   103                              <1> 	%include "SerialServerScan.asm"
   104                              <1> 	%define INCLUDE_TIME_LIBRARY
   105                              <1> %endif
   106                              <1> 
   107                              <1> %ifdef INCLUDE_TIME_LIBRARY
   108                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   109                              <1> 		%include "Delay.asm"
   110                              <1> 		%ifndef EXCLUDE_FROM_XTIDECFG
   111                              <1> 			%include "SystemTimer.asm"
   112                              <1> 		%endif
   113                              <1> 	%endif
   114                              <1> 	%include "TimerTicks.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for system timer related operations.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> ; With a PIT input clock of 1193181.6666... Hz and a maximum
    21                              <2> ; 16 bit divisor of 65536 (if PIT programmed with 0) we get:
    22                              <2> ;
    23                              <2> ; Clock / Divisor = ~18.2065 ticks per second
    24                              <2> ; Clock * SecondsPerMinute / Divisor = ~1092 ticks per minute
    25                              <2> ; Clock * SecondsPerHour / Divisor = ~65543 ticks per hour
    26                              <2> ;
    27                              <2> ; Since 65543 can't fit in a 16 bit register we use the
    28                              <2> ; maximum possible instead and disregard the last ~8 ticks.
    29                              <2> 
    30                              <2> TICKS_PER_HOUR			EQU		65535
    31                              <2> TICKS_PER_MINUTE		EQU		1092
    32                              <2> TICKS_PER_SECOND		EQU		18
    33                              <2> 
    34                              <2> 
    35                              <2> ; Section containing code
    36                              <2> SECTION .text
    37                              <2> 
    38                              <2> ;--------------------------------------------------------------------
    39                              <2> ; TimerTicks_GetHoursToAXandRemainderTicksToDXfromTicksInDXAX
    40                              <2> ; TimerTicks_GetMinutesToAXandRemainderTicksToDXfromTicksInDX
    41                              <2> ; TimerTicks_GetSecondsToAXandRemainderTicksToDXfromTicksInDX
    42                              <2> ;	Parameters
    43                              <2> ;		DX(:AX):	Timer ticks to convert
    44                              <2> ;	Returns:
    45                              <2> ;		AX:			Hours, minutes or seconds
    46                              <2> ;		DX:			Remainder ticks
    47                              <2> ;	Corrupts registers:
    48                              <2> ;		CX
    49                              <2> ;--------------------------------------------------------------------
    50                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    51                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
    52                              <2> ALIGN JUMP_ALIGN
    53                              <2> TimerTicks_GetHoursToAXandRemainderTicksToDXfromTicksInDXAX:
    54                              <2> 	mov		cx, TICKS_PER_HOUR
    55                              <2> 	div		cx		; Divide DX:AX by CX, Hours to AX, remainder ticks to DX
    56                              <2> 	ret
    57                              <2> %endif ; EXCLUDE_FROM_XTIDECFG
    58                              <2> 
    59                              <2> ALIGN JUMP_ALIGN
    60                              <2> TimerTicks_GetMinutesToAXandRemainderTicksToDXfromTicksInDX:
    61                              <2> 	xor		ax, ax
    62                              <2> 	xchg	ax, dx	; Ticks now in DX:AX
    63                              <2> 	mov		cx, TICKS_PER_MINUTE
    64                              <2> 	div		cx		; Divide DX:AX by CX, Minutes to AX, remainder ticks to DX
    65                              <2> 	ret
    66                              <2> %endif ; EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    67                              <2> 
    68                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
    69                              <2> ALIGN JUMP_ALIGN
    70                              <2> TimerTicks_GetSecondsToAXandRemainderTicksToDXfromTicksInDX:
    71                              <2> 	; This procedure can handle at most 4607 ticks in DX (almost 256 seconds)
    72                              <2> 	; More than 4607 ticks will generate a divide overflow exception!
    73                              <2> 	xchg	ax, dx	; Ticks now in AX
    74                              <2> 	mov		cl, TICKS_PER_SECOND
    75                              <2> 	div		cl		; Divide AX by CL, Seconds to AL, remainder ticks to AH
    76                              <2> 	xor		dx, dx
    77                              <2> 	xchg	dl, ah	; Seconds in AX, remainder in DX
    78                              <2> 	ret
    79                              <2> %endif
    80                              <2> 
    81                              <2> 
    82                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    83                              <2> 	%ifndef MODULE_BOOT_MENU
    84                              <2> 		%define EXCLUDE
    85                              <2> 	%endif
    86                              <2> %endif
    87                              <2> ;--------------------------------------------------------------------
    88                              <2> ; TimerTicks_GetSecondsToAXfromTicksInDX
    89                              <2> ;	Parameters
    90                              <2> ;		DX:			Timer ticks to convert
    91                              <2> ;	Returns:
    92                              <2> ;		AX:			Seconds
    93                              <2> ;	Corrupts registers:
    94                              <2> ;		DX
    95                              <2> ;--------------------------------------------------------------------
    96                              <2> %ifndef EXCLUDE	; 1 of 3
    97                              <2> ALIGN JUMP_ALIGN
    98                              <2> TimerTicks_GetSecondsToAXfromTicksInDX:
    99 000009AB B8100E              <2> 	mov		ax, 3600	; Approximately 65536 / (Clock / Divisor)
   100 000009AE F7E2                <2> 	mul		dx
   101 000009B0 92                  <2> 	xchg	dx, ax
   102 000009B1 C3                  <2> 	ret
   103                              <2> %endif
   104                              <2> 
   105                              <2> 
   106                              <2> ;--------------------------------------------------------------------
   107                              <2> ; First tick might take 0...54.9 ms and remaining ticks
   108                              <2> ; will occur at 54.9 ms intervals. Use delay of two (or more) ticks to
   109                              <2> ; ensure at least 54.9 ms timeout.
   110                              <2> ;
   111                              <2> ; TimerTicks_InitializeTimeoutFromAX
   112                              <2> ;	Parameters:
   113                              <2> ;		AX:			Timeout ticks (54.9 ms) before timeout
   114                              <2> ;		DS:BX:		Ptr to timeout variable WORD
   115                              <2> ;	Returns:
   116                              <2> ;		[DS:BX]:	Initialized for TimerTicks_SetCarryIfTimeoutFromDSBX
   117                              <2> ;	Corrupts registers:
   118                              <2> ;		AX
   119                              <2> ;--------------------------------------------------------------------
   120                              <2> %ifndef EXCLUDE	; 2 of 3
   121                              <2> ALIGN JUMP_ALIGN
   122                              <2> TimerTicks_InitializeTimeoutFromAX:
   123 000009B2 8907                <2> 	mov		[bx], ax					; Store timeout ticks
   124 000009B4 E80E00              <2> 	call	TimerTicks_ReadFromBdaToAX
   125 000009B7 0107                <2> 	add		[bx], ax					; [bx] now contains end time for timeout
   126 000009B9 C3                  <2> 	ret
   127                              <2> %endif
   128                              <2> 
   129                              <2> 
   130                              <2> ;--------------------------------------------------------------------
   131                              <2> ; TimerTicks_GetTimeoutTicksLeftToAXfromDSBX
   132                              <2> ;	Parameters:
   133                              <2> ;		DS:BX:		Ptr to timeout variable WORD
   134                              <2> ;	Returns:
   135                              <2> ;		AX:			Number of ticks left before timeout
   136                              <2> ;		CF:			Set if timeout
   137                              <2> ;					Cleared if time left
   138                              <2> ;	Corrupts registers:
   139                              <2> ;		Nothing
   140                              <2> ;--------------------------------------------------------------------
   141                              <2> %ifndef EXCLUDE	; 3 of 3
   142                              <2> ALIGN JUMP_ALIGN
   143                              <2> TimerTicks_GetTimeoutTicksLeftToAXfromDSBX:
   144 000009BA 52                  <2> 	push	dx
   145 000009BB 8B17                <2> 	mov		dx, [bx]
   146 000009BD E80500              <2> 	call	TimerTicks_ReadFromBdaToAX
   147 000009C0 92                  <2> 	xchg	ax, dx
   148 000009C1 29D0                <2> 	sub		ax, dx		; AX = End time - current time
   149 000009C3 5A                  <2> 	pop		dx
   150 000009C4 C3                  <2> 	ret
   151                              <2> %endif
   152                              <2> 
   153                              <2> %undef EXCLUDE
   154                              <2> 
   155                              <2> 
   156                              <2> ;--------------------------------------------------------------------
   157                              <2> ; TimerTicks_GetElapsedToAXandResetDSBX
   158                              <2> ;	Parameters
   159                              <2> ;		DS:BX:		Ptr to WORD containing previous reset time
   160                              <2> ;	Returns:
   161                              <2> ;		AX:			54.9 ms ticks elapsed since last reset
   162                              <2> ;		[DS:BX]:	Reset to latest time
   163                              <2> ;	Corrupts registers:
   164                              <2> ;		Nothing
   165                              <2> ;--------------------------------------------------------------------
   166                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   167                              <2> ALIGN JUMP_ALIGN
   168                              <2> TimerTicks_GetElapsedToAXandResetDSBX:
   169                              <2> 	call	TimerTicks_ReadFromBdaToAX
   170                              <2> 	push	ax
   171                              <2> 	sub		ax, [bx]
   172                              <2> 	pop		WORD [bx]			; Latest time to [DS:BX]
   173                              <2> 	ret
   174                              <2> %endif
   175                              <2> 
   176                              <2> 
   177                              <2> ;--------------------------------------------------------------------
   178                              <2> ; TimerTicks_GetElapsedToAXfromDSBX
   179                              <2> ;	Parameters
   180                              <2> ;		DS:BX:		Ptr to WORD containing previous update time
   181                              <2> ;	Returns:
   182                              <2> ;		AX:			54.9 ms ticks elapsed since initializing [DS:BX]
   183                              <2> ;	Corrupts registers:
   184                              <2> ;		Nothing
   185                              <2> ;--------------------------------------------------------------------
   186                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   187                              <2> ALIGN JUMP_ALIGN
   188                              <2> TimerTicks_GetElapsedToAXfromDSBX:
   189                              <2> 	call	TimerTicks_ReadFromBdaToAX
   190                              <2> 	sub		ax, [bx]
   191                              <2> 	ret
   192                              <2> %endif
   193                              <2> 
   194                              <2> 
   195                              <2> ;--------------------------------------------------------------------
   196                              <2> ; TimerTicks_ReadFromBdaToAX
   197                              <2> ;	Parameters
   198                              <2> ;		Nothing
   199                              <2> ;	Returns:
   200                              <2> ;		AX:		System time in 54.9 ms ticks
   201                              <2> ;	Corrupts registers:
   202                              <2> ;		Nothing
   203                              <2> ;--------------------------------------------------------------------
   204                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   205                              <2> 	%ifndef MODULE_BOOT_MENU OR MODULE_HOTKEYS
   206                              <2> 		%define EXCLUDE
   207                              <2> 	%endif
   208                              <2> %endif
   209                              <2> 
   210                              <2> %ifndef EXCLUDE
   211                              <2> ALIGN JUMP_ALIGN
   212                              <2> TimerTicks_ReadFromBdaToAX:
   213 000009C5 1E                  <2> 	push	ds
   214                              <2> 
   215                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax
   215                              <3> %ifndef USE_186
   215 000009C6 31C0                <3>  xor %2, %2
   215 000009C8 8ED8                <3>  mov %1, %2
   215                              <3> %elifidn %3, !
   215                              <3>  xor %2, %2
   215                              <3>  mov %1, %2
   215                              <3> %else
   215                              <3>  push BYTE 0
   215                              <3>  pop %1
   215                              <3> %endif
   216 000009CA A16C04              <2> 	mov		ax, [BDA.dwTimerTicks]	; Read low WORD only
   217                              <2> 
   218 000009CD 1F                  <2> 	pop		ds
   219 000009CE C3                  <2> 	ret
   220                              <2> %endif
   221                              <2> %undef EXCLUDE
   115                              <1> %endif
   116                              <1> 
   117                              <1> %ifdef INCLUDE_UTIL_LIBRARY
   118                              <1>   %ifndef UTIL_SIZE_JUMP_ALIGN
   119                              <1> 	%define UTIL_SIZE_JUMP_ALIGN 1
   120                              <1>   %endif
   121                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   122                              <1> 		%include "Bit.asm"
   123                              <1> 	%endif
   124                              <1> 	%include "Math.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for register operations.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools 
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ; 
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.		
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;		
    19                              <2> 
    20                              <2> 
    21                              <2> ; Section containing code
    22                              <2> SECTION .text
    23                              <2> 
    24                              <2> ;--------------------------------------------------------------------
    25                              <2> ; Math_DivQWatSSBPbyCX
    26                              <2> ;	Parameters:
    27                              <2> ;		[SS:BP]:	64-bit unsigned divident
    28                              <2> ;		CX:			16-bit unsigned divisor
    29                              <2> ;	Returns:
    30                              <2> ;		[SS:BP]:	64-bit unsigned quotient
    31                              <2> ;		DX:			16-bit unsigned remainder
    32                              <2> ;	Corrupts registers:
    33                              <2> ;		AX
    34                              <2> ;--------------------------------------------------------------------
    35                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
    36                              <2> ALIGN JUMP_ALIGN
    37                              <2> Math_DivQWatSSBPbyCX:
    38                              <2> 	xor		dx, dx
    39                              <2> 	mov		ax, [bp+6]		; Load highest divident WORD to DX:AX
    40                              <2> 	div		cx
    41                              <2> 	mov		[bp+6], ax		; Store quotient
    42                              <2> 
    43                              <2> 	mov		ax, [bp+4]
    44                              <2> 	div		cx
    45                              <2> 	mov		[bp+4], ax
    46                              <2> 
    47                              <2> 	mov		ax, [bp+2]
    48                              <2> 	div		cx
    49                              <2> 	mov		[bp+2], ax
    50                              <2> 
    51                              <2> 	mov		ax, [bp]
    52                              <2> 	div		cx
    53                              <2> 	mov		[bp], ax
    54                              <2> 	ret
    55                              <2> %endif
    56                              <2> 
    57                              <2> 
    58                              <2> ;--------------------------------------------------------------------
    59                              <2> ; Math_DivDXAXbyCX
    60                              <2> ;	Parameters:
    61                              <2> ;		DX:AX:	32-bit unsigned divident
    62                              <2> ;		CX:		16-bit unsigned divisor
    63                              <2> ;	Returns:
    64                              <2> ;		DX:AX:	32-bit unsigned quotient
    65                              <2> ;		BX:		16-bit unsigned remainder
    66                              <2> ;	Corrupts registers:
    67                              <2> ;		Nothing
    68                              <2> ;--------------------------------------------------------------------
    69                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
    70                              <2> ALIGN JUMP_ALIGN
    71                              <2> Math_DivDXAXbyCX:
    72 000009CF 31DB                <2> 	xor		bx, bx
    73 000009D1 93                  <2> 	xchg	bx, ax
    74 000009D2 92                  <2> 	xchg	dx, ax
    75 000009D3 F7F1                <2> 	div		cx
    76 000009D5 93                  <2> 	xchg	ax, bx
    77 000009D6 F7F1                <2> 	div		cx
    78 000009D8 87D3                <2> 	xchg	dx, bx
    79 000009DA C3                  <2> 	ret
    80                              <2> %endif
   125                              <1> 	%include "Registers.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for register operations.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> ; Section containing code
    21                              <2> SECTION .text
    22                              <2> 
    23                              <2> ;--------------------------------------------------------------------
    24                              <2> ; Registers_ExchangeDSSIwithESDI
    25                              <2> ;	Parameters
    26                              <2> ;		Nothing
    27                              <2> ;	Returns:
    28                              <2> ;		DS:SI and ES:DI are exchanged.
    29                              <2> ;	Corrupts registers:
    30                              <2> ;		Nothing
    31                              <2> ;--------------------------------------------------------------------
    32                              <2> ALIGN JUMP_ALIGN
    33                              <2> Registers_ExchangeDSSIwithESDI:
    34 000009DB 1E                  <2> 	push	ds
    35 000009DC 06                  <2> 	push	es
    36 000009DD 1F                  <2> 	pop		ds
    37 000009DE 07                  <2> 	pop		es
    38 000009DF 87F7                <2> 	xchg	si, di
    39 000009E1 C3                  <2> 	ret
    40                              <2> 
    41                              <2> 
    42                              <2> ;--------------------------------------------------------------------
    43                              <2> ; Registers_CopySSBPtoESDI
    44                              <2> ; Registers_CopySSBPtoDSSI
    45                              <2> ; Registers_CopyDSSItoESDI
    46                              <2> ; Registers_CopyESDItoDSSI
    47                              <2> ;	Parameters
    48                              <2> ;		Nothing
    49                              <2> ;	Returns:
    50                              <2> ;		Copies farm pointer to different segment/pointer register pair
    51                              <2> ;	Corrupts registers:
    52                              <2> ;		Nothing
    53                              <2> ;--------------------------------------------------------------------
    54                              <2> %ifdef INCLUDE_MENU_LIBRARY
    55                              <2> ALIGN JUMP_ALIGN
    56                              <2> Registers_CopySSBPtoESDI:
    57                              <2> 	COPY_SSBP_TO_ESDI
    57 000009E2 16                  <3>  push ss
    57 000009E3 07                  <3>  pop es
    57 000009E4 89EF                <3>  mov di, bp
    58 000009E6 C3                  <2> 	ret
    59                              <2> %endif
    60                              <2> 
    61                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    62                              <2> ALIGN JUMP_ALIGN
    63                              <2> Registers_CopySSBPtoDSSI:
    64                              <2> 	COPY_SSBP_TO_DSSI
    65                              <2> 	ret
    66                              <2> 
    67                              <2> ALIGN JUMP_ALIGN
    68                              <2> Registers_CopyDSSItoESDI:
    69                              <2> 	COPY_DSSI_TO_ESDI
    70                              <2> 	ret
    71                              <2> 
    72                              <2> ALIGN JUMP_ALIGN
    73                              <2> Registers_CopyESDItoDSSI:
    74                              <2> 	COPY_ESDI_to_DSSI
    75                              <2> 	ret
    76                              <2> %endif
    77                              <2> 
    78                              <2> 
    79                              <2> ;--------------------------------------------------------------------
    80                              <2> ; Registers_NormalizeESSI
    81                              <2> ; Registers_NormalizeESDI
    82                              <2> ;	Parameters
    83                              <2> ;		DS:SI or ES:DI:	Ptr to normalize
    84                              <2> ;	Returns:
    85                              <2> ;		DS:SI or ES:DI:	Normalized pointer
    86                              <2> ;	Corrupts registers:
    87                              <2> ;		AX, CX
    88                              <2> ;
    89                              <2> ; Inline of NORMALIZE_FAR_POINTER so that we can share the last 2/3 of the
    90                              <2> ; routine with Registers_NormalizeFinish.
    91                              <2> ;
    92                              <2> ;--------------------------------------------------------------------
    93                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
    94                              <2> ALIGN JUMP_ALIGN
    95                              <2> Registers_NormalizeESSI:
    96                              <2> 	mov			cx, si
    97                              <2> 	and			si, byte 0fh
    98                              <2> 	jmp			Registers_NormalizeFinish
    99                              <2> 
   100                              <2> ALIGN JUMP_ALIGN
   101                              <2> Registers_NormalizeESDI:
   102                              <2> 	mov			cx, di
   103                              <2> 	and			di, byte 0fh
   104                              <2> ;;; fall-through
   105                              <2> 
   106                              <2> ALIGN JUMP_ALIGN
   107                              <2> Registers_NormalizeFinish:
   108                              <2> 	eSHR_IM		cx, 4
   109                              <2> 	mov			ax, es
   110                              <2> 	add			ax, cx
   111                              <2> 	mov			es, ax
   112                              <2> 	ret
   113                              <2> %endif
   114                              <2> 
   115                              <2> 
   116                              <2> ;--------------------------------------------------------------------
   117                              <2> ; Registers_SetZFifNullPointerInDSSI (commented to save bytes)
   118                              <2> ;	Parameters
   119                              <2> ;		DS:SI:	Far pointer
   120                              <2> ;	Returns:
   121                              <2> ;		ZF:		Set if NULL pointer in DS:SI
   122                              <2> ;	Corrupts registers:
   123                              <2> ;		Nothing
   124                              <2> ;--------------------------------------------------------------------
   125                              <2> ;ALIGN JUMP_ALIGN
   126                              <2> ;Registers_SetZFifNullPointerInDSSI:
   127                              <2> ;	push	ax
   128                              <2> ;	mov		ax, ds
   129                              <2> ;	or		ax, si
   130                              <2> ;	pop		ax
   131                              <2> ;	ret
   126                              <1> 	%include "Reboot.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for rebooting computer.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools 
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ; 
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.		
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;		
    19                              <2> 
    20                              <2> ; Section containing code
    21                              <2> SECTION .text
    22                              <2> 
    23                              <2> ;--------------------------------------------------------------------
    24                              <2> ; Reboot_ComputerWithBootFlagInAX
    25                              <2> ;	Parameters:
    26                              <2> ; 		AX:		Boot Flag
    27                              <2> ;	Returns:
    28                              <2> ;		Nothing, function never returns
    29                              <2> ;--------------------------------------------------------------------
    30                              <2> Reboot_ComputerWithBootFlagInAX:
    31                              <2> 	LOAD_BDA_SEGMENT_TO	ds, bx
    31                              <3> %ifndef USE_186
    31 000009E7 31DB                <3>  xor %2, %2
    31 000009E9 8EDB                <3>  mov %1, %2
    31                              <3> %elifidn %3, !
    31                              <3>  xor %2, %2
    31                              <3>  mov %1, %2
    31                              <3> %else
    31                              <3>  push BYTE 0
    31                              <3>  pop %1
    31                              <3> %endif
    32 000009EB A37204              <2> 	mov		[BDA.wBoot], ax			; Store boot flag
    33                              <2> 	; Fall to Reboot_AT
    34                              <2> 
    35                              <2> 
    36                              <2> ;--------------------------------------------------------------------
    37                              <2> ; Reboot_AT
    38                              <2> ;	Parameters:
    39                              <2> ; 		Nothing
    40                              <2> ;	Returns:
    41                              <2> ;		Nothing, function never returns
    42                              <2> ;--------------------------------------------------------------------
    43                              <2> Reboot_AT:
    44 000009EE B0FE                <2> 	mov		al, 0FEh				; System reset (AT+ keyboard controller)
    45 000009F0 E664                <2> 	out		64h, al					; Reset computer (AT+)
    46                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    47                              <2> 	%ifdef INCLUDE_TIME_LIBRARY
    48                              <2> 		mov		ax, 10
    49                              <2> 		call	Delay_MicrosecondsFromAX
    50                              <2> 	%else
    51                              <2> 		JMP_DELAY
    52                              <2> 	%endif
    53                              <2> %else
    54                              <2> 	JMP_DELAY
    54 000009F2 EB00                <3>  jmp SHORT %%NextInstruction
    54                              <3> %%NextInstruction:
    55                              <2> %endif
    56                              <2> 	; Fall to Reboot_XT
    57                              <2> 
    58                              <2> 
    59                              <2> ;--------------------------------------------------------------------
    60                              <2> ; Reboot_XT
    61                              <2> ;	Parameters:
    62                              <2> ; 		Nothing
    63                              <2> ;	Returns:
    64                              <2> ;		Nothing, function never returns
    65                              <2> ;--------------------------------------------------------------------
    66                              <2> Reboot_XT:
    67 000009F4 31C0                <2> 	xor		ax, ax
    68 000009F6 50                  <2> 	push	ax
    69 000009F7 9D                  <2> 	popf							; Clear FLAGS (disables interrupt)
    70 000009F8 8ED8                <2> 	mov		ds, ax
    71 000009FA 8EC0                <2> 	mov		es, ax
    72 000009FC 8ED0                <2> 	mov		ss, ax
    73 000009FE EA0000FFFF          <2> 	jmp		0FFFFh:0				; XT reset
   127                              <1> 	%include "Memory.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for memory access.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> ; Section containing code
    21                              <2> SECTION .text
    22                              <2> 
    23                              <2> ;--------------------------------------------------------------------
    24                              <2> ; OPTIMIZE_STRING_OPERATION
    25                              <2> ;	Parameters
    26                              <2> ;		%1:		Repeat instruction
    27                              <2> ;		%2:		String instruction without size (for example MOVS and not MOVSB or MOVSW)
    28                              <2> ;		CX:		Number of BYTEs to operate
    29                              <2> ;		DS:SI:	Ptr to source data
    30                              <2> ;		ES:DI:	Ptr to destination
    31                              <2> ;	Returns:
    32                              <2> ;		SI, DI:	Updated by number of bytes operated
    33                              <2> ;	Corrupts registers:
    34                              <2> ;		Nothing
    35                              <2> ;--------------------------------------------------------------------
    36                              <2> %macro OPTIMIZE_STRING_OPERATION 2
    37                              <2> 	push	cx
    38                              <2> 
    39                              <2> 	shr		cx, 1			; Operate with WORDs for performance
    40                              <2> 	jz	%%HandleRemainingByte
    41                              <2> 	%1		%2w
    42                              <2> %%HandleRemainingByte:
    43                              <2> 	jnc		SHORT %%OperationCompleted
    44                              <2> 	%2b
    45                              <2> 
    46                              <2> ALIGN JUMP_ALIGN
    47                              <2> %%OperationCompleted:
    48                              <2> 	pop		cx
    49                              <2> %endmacro
    50                              <2> 
    51                              <2> 
    52                              <2> ;--------------------------------------------------------------------
    53                              <2> ; Memory_CopyCXbytesFromDSSItoESDI
    54                              <2> ;	Parameters
    55                              <2> ;		CX:		Number of bytes to copy
    56                              <2> ;		DS:SI:	Ptr to source data
    57                              <2> ;		ES:DI:	Ptr to destination buffer
    58                              <2> ;	Returns:
    59                              <2> ;		SI, DI:	Updated by number of bytes copied
    60                              <2> ;	Corrupts registers:
    61                              <2> ;		Nothing
    62                              <2> ;--------------------------------------------------------------------
    63                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
    64                              <2> ALIGN JUMP_ALIGN
    65                              <2> Memory_CopyCXbytesFromDSSItoESDI:
    66                              <2> 	OPTIMIZE_STRING_OPERATION rep, movs
    67                              <2> 	ret
    68                              <2> %endif
    69                              <2> 
    70                              <2> 
    71                              <2> ;--------------------------------------------------------------------
    72                              <2> ; Memory_ZeroSSBPwithSizeInCX
    73                              <2> ;	Parameters
    74                              <2> ;		CX:		Number of bytes to zero
    75                              <2> ;		SS:BP:	Ptr to buffer to zero
    76                              <2> ;	Returns:
    77                              <2> ;		Nothing
    78                              <2> ;	Corrupts registers:
    79                              <2> ;		Nothing
    80                              <2> ;--------------------------------------------------------------------
    81                              <2> %ifdef INCLUDE_MENU_LIBRARY
    82                              <2> ALIGN JUMP_ALIGN
    83                              <2> Memory_ZeroSSBPwithSizeInCX:
    84 00000A03 06                  <2> 	push	es
    85 00000A04 57                  <2> 	push	di
    86 00000A05 50                  <2> 	push	ax
    87 00000A06 E8D9FF              <2> 	call	Registers_CopySSBPtoESDI
    88 00000A09 E80400              <2> 	call	Memory_ZeroESDIwithSizeInCX
    89 00000A0C 58                  <2> 	pop		ax
    90 00000A0D 5F                  <2> 	pop		di
    91 00000A0E 07                  <2> 	pop		es
    92 00000A0F C3                  <2> 	ret
    93                              <2> %endif
    94                              <2> 
    95                              <2> 		
    96                              <2> ;--------------------------------------------------------------------
    97                              <2> ; Memory_ZeroESDIwithSizeInCX
    98                              <2> ;	Parameters
    99                              <2> ;		CX:		Number of bytes to zero
   100                              <2> ;		ES:DI:	Ptr to destination buffer
   101                              <2> ;	Returns:
   102                              <2> ;		DI:		Updated by number of BYTEs stored
   103                              <2> ;	Corrupts registers:
   104                              <2> ;		AX
   105                              <2> ;--------------------------------------------------------------------
   106                              <2> ALIGN JUMP_ALIGN
   107                              <2> Memory_ZeroESDIwithSizeInCX:
   108 00000A10 31C0                <2> 	xor		ax, ax
   109                              <2> 	; Fall to Memory_StoreCXbytesFromAccumToESDI
   110                              <2> 
   111                              <2> ;--------------------------------------------------------------------
   112                              <2> ; Memory_StoreCXbytesFromAccumToESDI
   113                              <2> ;	Parameters
   114                              <2> ;		AX:		Word to use to fill buffer
   115                              <2> ;		CX:		Number of BYTEs to store
   116                              <2> ;		ES:DI:	Ptr to destination buffer
   117                              <2> ;	Returns:
   118                              <2> ;		DI:		Updated by number of BYTEs stored
   119                              <2> ;	Corrupts registers:
   120                              <2> ;		Nothing
   121                              <2> ;--------------------------------------------------------------------
   122                              <2> ALIGN JUMP_ALIGN
   123                              <2> Memory_StoreCXbytesFromAccumToESDI:
   124                              <2> 	OPTIMIZE_STRING_OPERATION rep, stos
   124 00000A12 51                  <3>  push cx
   124                              <3> 
   124 00000A13 D1E9                <3>  shr cx, 1
   124 00000A15 7402                <3>  jz %%HandleRemainingByte
   124 00000A17 F3AB                <3>  %1 %2w
   124                              <3> %%HandleRemainingByte:
   124 00000A19 7301                <3>  jnc SHORT %%OperationCompleted
   124 00000A1B AA                  <3>  %2b
   124                              <3> 
   124                              <3> ALIGN JUMP_ALIGN
   124                              <3> %%OperationCompleted:
   124 00000A1C 59                  <3>  pop cx
   125 00000A1D C3                  <2> 	ret
   126                              <2> 
   127                              <2> 
   128                              <2> ;--------------------------------------------------------------------
   129                              <2> ; Memory_ReserveCXbytesFromStackToDSSI
   130                              <2> ;	Parameters
   131                              <2> ;		CX:		Number of bytes to reserve
   132                              <2> ;	Returns:
   133                              <2> ;		DS:SI:	Ptr to reserved buffer
   134                              <2> ;	Corrupts registers:
   135                              <2> ;		AX
   136                              <2> ;--------------------------------------------------------------------
   137                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   138                              <2> ALIGN JUMP_ALIGN
   139                              <2> Memory_ReserveCXbytesFromStackToDSSI:
   140                              <2> 	pop		ax
   141                              <2> 	push	ss
   142                              <2> 	pop		ds
   143                              <2> 	sub		sp, cx
   144                              <2> 	mov		si, sp
   145                              <2> 	jmp		ax
   146                              <2> %endif
   147                              <2> 
   148                              <2> 
   149                              <2> ;--------------------------------------------------------------------
   150                              <2> ; Memory_SumCXbytesFromESSItoAL
   151                              <2> ;	Parameters
   152                              <2> ;		CX:		Number of bytes to sum (0=65536)
   153                              <2> ;		ES:SI:	Ptr to buffer containing the bytes to sum
   154                              <2> ;	Returns:
   155                              <2> ;		AL:		Sum of bytes
   156                              <2> ;		ZF:		Set if result is zero
   157                              <2> ;				Cleared if result is non-zero
   158                              <2> ;	Corrupts registers:
   159                              <2> ;		CX
   160                              <2> ;--------------------------------------------------------------------
   161                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
   162                              <2> ALIGN JUMP_ALIGN
   163                              <2> Memory_SumCXbytesFromESSItoAL:
   164 00000A1E 56                  <2> 	push	si
   165 00000A1F 4E                  <2> 	dec		si
   166 00000A20 30C0                <2> 	xor		al, al
   167                              <2> ALIGN JUMP_ALIGN
   168                              <2> .AddNextByteToAL:
   169 00000A22 46                  <2> 	inc		si
   170 00000A23 260204              <2> 	add		al, [es:si]
   171 00000A26 E2FA                <2> 	loop	.AddNextByteToAL
   172 00000A28 5E                  <2> 	pop		si
   173 00000A29 C3                  <2> 	ret
   174                              <2> %endif
   128                              <1> 	%include "Size.asm"
     1                              <2> ; Project name	:	Assembly Library
     2                              <2> ; Description	:	Functions for size calculations.
     3                              <2> 
     4                              <2> ;
     5                              <2> ; XTIDE Universal BIOS and Associated Tools
     6                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
     7                              <2> ;
     8                              <2> ; This program is free software; you can redistribute it and/or modify
     9                              <2> ; it under the terms of the GNU General Public License as published by
    10                              <2> ; the Free Software Foundation; either version 2 of the License, or
    11                              <2> ; (at your option) any later version.
    12                              <2> ;
    13                              <2> ; This program is distributed in the hope that it will be useful,
    14                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <2> ; GNU General Public License for more details.
    17                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <2> ;
    19                              <2> 
    20                              <2> %ifdef INCLUDE_MENU_LIBRARY
    21                              <2> struc BYTE_MULTIPLES
    22 00000000 <res 00000001>      <2> 	.B			resb	1
    23 00000001 <res 00000001>      <2> 	.kiB		resb	1
    24 00000002 <res 00000001>      <2> 	.MiB		resb	1
    25 00000003 <res 00000001>      <2> 	.GiB		resb	1
    26 00000004 <res 00000001>      <2> 	.TiB		resb	1
    27                              <2> endstruc
    28                              <2> 
    29                              <2> ; Section containing code
    30                              <2> SECTION .text
    31                              <2> 
    32                              <2> ;--------------------------------------------------------------------
    33                              <2> ; Size_GetSizeToAXAndCharToDLfromBXDXAXwithMagnitudeInCX
    34                              <2> ;	Parameters:
    35                              <2> ;		BX:DX:AX:	Size in magnitude
    36                              <2> ;		CX:			Magnitude in BYTE_MULTIPLES
    37                              <2> ;	Returns:
    38                              <2> ;		AX:			Size in magnitude
    39                              <2> ;		CX:			Tenths
    40                              <2> ;		DL:			Magnitude character:
    41                              <2> ;						'k' = *1024   B = kiB
    42                              <2> ;						'M' = *1024 kiB = MiB
    43                              <2> ;						'G' = *1024 MiB = GiB
    44                              <2> ;						'T' = *1024 GiB = TiB
    45                              <2> ;						'P' = *1024 TiB = PiB
    46                              <2> ;	Corrupts registers:
    47                              <2> ;		BX, DH
    48                              <2> ;--------------------------------------------------------------------
    49                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
    50                              <2> Size_GetSizeToAXAndCharToDLfromBXDXAXwithMagnitudeInCX:
    51                              <2> %ifndef USE_186		; If 8086/8088
    52 00000A2A 57                  <2> 	push	di
    53                              <2> %endif
    54 00000A2B 56                  <2> 	push	si
    55                              <2> 
    56                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
    57                              <2> .MagnitudeConversionLoop:
    58                              <2> 	ePUSH_T	di, .MagnitudeConversionLoop; DI corrupted only on 8086/8088 build
    58                              <3> %ifndef USE_186
    58                              <3>  %ifidni %2, 0
    58                              <3>  xor %1, %1
    58                              <3>  %else
    58 00000A2C BF[2C0A]            <3>  mov %1, %2
    58                              <3>  %endif
    58 00000A2F 57                  <3>  push %1
    58                              <3> 
    58                              <3> %else
    58                              <3>  push %2
    58                              <3> %endif
    59 00000A30 85DB                <2> 	test	bx, bx						; Bits 32...47 in use?
    60 00000A32 7529                <2> 	jnz		SHORT Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
    61 00000A34 85D2                <2> 	test	dx, dx						; Bits 16...31 in use?
    62 00000A36 7525                <2> 	jnz		SHORT Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
    63 00000A38 3D1027              <2> 	cmp		ax, 10000					; 5 digits needed?
    64 00000A3B 7320                <2> 	jae		SHORT Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
    65 00000A3D 83C402              <2> 	add		sp, BYTE 2					; Clean return address from stack
    66 00000A40 87F1                <2> 	xchg	si, cx						; CX = Remainder (0...1023), SI = Magnitude
    67                              <2> 
    68                              <2> 	; Convert remainder to tenths
    69 00000A42 93                  <2> 	xchg	bx, ax						; Store AX
    70 00000A43 B80500              <2> 	mov		ax, 5
    71 00000A46 F7E1                <2> 	mul		cx							; DX:AX = remainder * (10 / 2)
    72                              <2> %ifdef USE_186
    73                              <2> 	shr		ax, 9						; Divide AX by (1024 / 2)
    74                              <2> %else
    75 00000A48 D1E8                <2> 	shr		ax, 1
    76 00000A4A 88E0                <2> 	mov		al, ah
    77 00000A4C 98                  <2> 	cbw
    78                              <2> %endif
    79 00000A4D 91                  <2> 	xchg	cx, ax						; CX = tenths
    80 00000A4E 93                  <2> 	xchg	ax, bx
    81                              <2> 
    82                              <2> 	; Convert magnitude to character
    83 00000A4F 2E8A94[570A]        <2> 	mov		dl, [cs:si+.rgbMagnitudeToChar]
    84                              <2> 
    85 00000A54 5E                  <2> 	pop		si
    86                              <2> %ifndef USE_186
    87 00000A55 5F                  <2> 	pop		di
    88                              <2> %endif
    89 00000A56 C3                  <2> 	ret
    90 00000A57 206B4D475450        <2> .rgbMagnitudeToChar:	db	" kMGTP"
    91                              <2> %endif
    92                              <2> 
    93                              <2> ;--------------------------------------------------------------------
    94                              <2> ; Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
    95                              <2> ;	Parameters:
    96                              <2> ;		BX:DX:AX:	Size
    97                              <2> ;		CX:			Magnitude in BYTE_MULTIPLES
    98                              <2> ;	Returns:
    99                              <2> ;		BX:DX:AX:	Size in magnitude
   100                              <2> ;		SI:			Remainder (0...1023)
   101                              <2> ;		CX:			Magnitude in BYTE_MULTIPLES
   102                              <2> ;	Corrupts registers:
   103                              <2> ;		Nothing
   104                              <2> ;--------------------------------------------------------------------
   105                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
   106                              <2> Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX:
   107 00000A5D 51                  <2> 	push	cx
   108 00000A5E 31F6                <2> 	xor		si, si					; Zero remainder
   109 00000A60 B10A                <2> 	mov		cl, 10					; Divide by 1024
   110                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
   111                              <2> .ShiftLoop:
   112 00000A62 E80D00              <2> 	call	Size_DivideBXDXAXbyTwo
   113 00000A65 D1DE                <2> 	rcr		si, 1					; Update remainder
   114 00000A67 E2F9                <2> 	loop	.ShiftLoop
   115                              <2> 	eSHR_IM	si, 6					; Remainder to SI beginning
   115                              <3>  eSHIFT_IM %1, %2, shr
   115                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   115                              <4> %ifndef USE_186
   115                              <4>  %ifidni %1, cl
   115                              <4>  times %2 %3 %1, 1
   115                              <4>  %elifidni %1, ch
   115                              <4>  times %2 %3 %1, 1
   115                              <4>  %elifidni %1, cx
   115                              <4>  times %2 %3 %1, 1
   115                              <4>  %else
   115                              <4>  %if %2 > 3
   115 00000A69 51                  <4>  push cx
   115 00000A6A B106                <4>  mov cl, %2
   115 00000A6C D3EE                <4>  %3 %1, cl
   115 00000A6E 59                  <4>  pop cx
   115                              <4>  %else
   115                              <4>  times %2 %3 %1, 1
   115                              <4>  %endif
   115                              <4>  %endif
   115                              <4> 
   115                              <4> %else
   115                              <4>  %3 %1, %2
   115                              <4> %endif
   115                              <4> %endif
   116 00000A6F 59                  <2> 	pop		cx
   117 00000A70 41                  <2> 	inc		cx						; Increment magnitude
   118 00000A71 C3                  <2> 	ret
   119                              <2> 
   120                              <2> ;--------------------------------------------------------------------
   121                              <2> ; Size_ConvertSectorCountInBXDXAXtoKiB
   122                              <2> ; Size_DivideBXDXAXbyTwo
   123                              <2> ;	Parameters:
   124                              <2> ;		BX:DX:AX:	Total sector count
   125                              <2> ;	Returns:
   126                              <2> ;		BX:DX:AX:	Total size in kiB
   127                              <2> ;		CF:			Remainder from division
   128                              <2> ;	Corrupts registers:
   129                              <2> ;		Nothing
   130                              <2> ;--------------------------------------------------------------------
   131                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
   132                              <2> Size_ConvertSectorCountInBXDXAXtoKiB:	; unused entrypoint ok
   133                              <2> Size_DivideBXDXAXbyTwo:
   134 00000A72 D1EB                <2> 	shr		bx, 1					; Divide sector count by 2...
   135 00000A74 D1DA                <2> 	rcr		dx, 1					; ...to get disk size in...
   136 00000A76 D1D8                <2> 	rcr		ax, 1					; ...kiB
   137 00000A78 C3                  <2> 	ret
   129                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
   130                              <1> 		%include "Sort.asm"
   131                              <1> 	%endif
   132                              <1> %endif
   133                              <1> 
   181                                  
   182                                  	; String compression tables need to come after the AssemblyLibrary (since they depend on addresses
   183                                  	; established in the assembly library), and are unnecessary if strings are not compressed.
   184                                  	;
   185                                  %ifdef MODULE_STRINGS_COMPRESSED
   186                                  	%undef  STRINGSCOMPRESSED_STRINGS
   187                                  	%define STRINGSCOMPRESSED_TABLES
   188                                  	%include "StringsCompressed.asm"
     1                              <1> ;;;======================================================================
     2                              <1> ;;;
     3                              <1> ;;; This file is generated by StringsCompress.pl from source in Strings.asm
     4                              <1> ;;; DO NOT EDIT DIRECTLY - See the makefile for how to rebuild this file.
     5                              <1> ;;; This file only needs to be rebuilt if Strings.asm is changed.
     6                              <1> ;;;
     7                              <1> ;;;======================================================================
     8                              <1> 
     9                              <1> %ifdef STRINGSCOMPRESSED_STRINGS
    10                              <1> 
    11                              <1> ; Project name	:	XTIDE Universal BIOS
    12                              <1> ; Description	:	Strings and equates for BIOS messages.
    13                              <1> 
    14                              <1> ;
    15                              <1> ; XTIDE Universal BIOS and Associated Tools
    16                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
    17                              <1> ;
    18                              <1> ; This program is free software; you can redistribute it and/or modify
    19                              <1> ; it under the terms of the GNU General Public License as published by
    20                              <1> ; the Free Software Foundation; either version 2 of the License, or
    21                              <1> ; (at your option) any later version.
    22                              <1> ;
    23                              <1> ; This program is distributed in the hope that it will be useful,
    24                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    25                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    26                              <1> ; GNU General Public License for more details.
    27                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    28                              <1> ;
    29                              <1> 
    30                              <1> %ifdef MODULE_STRINGS_COMPRESSED_PRECOMPRESS
    31                              <1> %include "Display.inc"
    32                              <1> %endif
    33                              <1> 
    34                              <1> ; Section containing code
    35                              <1> SECTION .text
    36                              <1> 
    37                              <1> ; The following strings are used by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
    38                              <1> ; To support an optimization in that code, these strings must start on the same 256 byte page,
    39                              <1> ; which is checked at assembly time below.
    40                              <1> ;
    41                              <1> g_szDetectStart:
    42                              <1> g_szDetectMaster:		; db	"Master",NULL
    43                              <1>                  		; db	 4dh,  61h,  73h,  74h,  65h,  72h,  00h    ; uncompressed
    44                              <1>                  		  db	 53h,  67h,  79h,  7ah,  6bh, 0b8h          ; compressed
    45                              <1> 
    46                              <1> g_szDetectSlave:		; db	"Slave ",NULL
    47                              <1>                 		; db	 53h,  6ch,  61h,  76h,  65h,  20h,  00h    ; uncompressed
    48                              <1>                 		  db	 59h,  72h,  67h,  7ch,  6bh,  00h          ; compressed
    49                              <1> 
    50                              <1> g_szDetectOuter:		; db	"%s at %s: ",NULL
    51                              <1>                 		; db	 25h,  73h,  20h,  61h,  74h,  20h,  25h,  73h,  3ah,  20h,  00h    ; uncompressed
    52                              <1>                 		  db	 3dh,  20h,  67h, 0fah,  3dh,  40h,  00h                            ; compressed
    53                              <1> 
    54                              <1> %ifdef MODULE_SERIAL
    55                              <1> g_szDetectCOM:			; db	"COM%c%s",NULL
    56                              <1>               			; db	 43h,  4fh,  4dh,  25h,  63h,  25h,  73h,  00h    ; uncompressed
    57                              <1>               			  db	 49h,  55h,  53h,  3ch,  1dh                      ; compressed
    58                              <1> 
    59                              <1> g_szDetectCOMAuto:		; db	" Detect",NULL
    60                              <1>                   		; db	 20h,  44h,  65h,  74h,  65h,  63h,  74h,  00h    ; uncompressed
    61                              <1>                   		  db	 20h,  4ah,  6bh,  7ah,  6bh,  69h, 0bah          ; compressed
    62                              <1> 
    63                              <1> g_szDetectCOMSmall:		; db	"/%u%u00",NULL					; IDE Master at COM1/9600:
    64                              <1>                    		; db	 2fh,  25h,  75h,  25h,  75h,  30h,  30h,  00h    ; uncompressed
    65                              <1>                    		  db	 2ah,  35h,  35h,  33h,  13h                      ; compressed
    66                              <1> 
    67                              <1> g_szDetectCOMLarge:		; db	"/%u.%uK",NULL					; IDE Master at COM1/19.2K:
    68                              <1>                    		; db	 2fh,  25h,  75h,  2eh,  25h,  75h,  4bh,  00h    ; uncompressed
    69                              <1>                    		  db	 2ah,  35h,  29h,  35h,  91h                      ; compressed
    70                              <1> 
    71                              <1> %endif
    72                              <1> g_szDetectEnd:
    73                              <1> g_szDetectPort:			; db	"%x",NULL						; IDE Master at 1F0h:
    74                              <1>                			; db	 25h,  78h,  00h    ; uncompressed
    75                              <1>                			  db	 17h                ; compressed
    76                              <1> 
    77                              <1> 
    78                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    79                              <1> %if ((g_szDetectEnd-$$) & 0xff00) <> ((g_szDetectStart-$$) & 0xff00)
    80                              <1> %error "g_szDetect* strings must start on the same 256 byte page, required by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP.  Please move this block up or down within Strings.asm"
    81                              <1> %endif
    82                              <1> %endif
    83                              <1> 
    84                              <1> 
    85                              <1> ; POST drive detection strings
    86                              <1> g_szDashForZero:	; db	"- ",NULL	; Required by Display Library
    87                              <1>                 	; db	 2dh,  20h,  00h    ; uncompressed
    88                              <1>                 	  db	 28h,  00h          ; compressed
    89                              <1> 
    90                              <1> g_szRomAt:			; db	LF,CR
    91                              <1>           			; db	 0ah,  0dh    ; uncompressed
    92                              <1>           			  db	 39h          ; compressed
    93                              <1> 
    94                              <1> 	; db	"%s @ %x",LF,CR						; -=XTIDE ... =- @ Segment
    95                              <1> 	; db	 25h,  73h,  20h,  40h,  20h,  25h,  78h,  0ah,  0dh    ; uncompressed
    96                              <1> 	  db	 3dh,  20h, 0c6h,  37h,  39h                            ; compressed
    97                              <1> 
    98                              <1> 	; db	"%s",LF,CR							; version string
    99                              <1> 	; db	 25h,  73h,  0ah,  0dh    ; uncompressed
   100                              <1> 	  db	 3dh,  39h                ; compressed
   101                              <1> 
   102                              <1> 	; db	"Released under GNU GPL v2",LF,CR
   103                              <1> 	; db	 52h,  65h,  6ch,  65h,  61h,  73h,  65h,  64h,  20h,  75h,  6eh,  64h,  65h,  72h,  20h,  47h,  4eh,  55h,  20h,  47h,  50h,  4ch,  20h,  76h,  32h,  0ah,  0dh    ; uncompressed
   104                              <1> 	  db	 58h,  6bh,  72h,  6bh,  67h,  79h,  6bh, 0eah,  7bh,  74h,  6ah,  6bh, 0f8h,  4dh,  54h, 0dbh,  4dh,  56h, 0d2h,  7ch,  2ch,  39h                                  ; compressed
   105                              <1> 
   106                              <1> 	; db	LF,CR,NULL
   107                              <1> 	; db	 0ah,  0dh,  00h    ; uncompressed
   108                              <1> 	  db	 19h                ; compressed
   109                              <1> 
   110                              <1> %ifdef MODULE_BOOT_MENU
   111                              <1> g_szBootMenuTitle:	; db	"%s%c",LF,CR						; -=XTIDE ... =- and null (eaten)
   112                              <1>                   	; db	 25h,  73h,  25h,  63h,  0ah,  0dh    ; uncompressed
   113                              <1>                   	  db	 3dh,  3ch,  39h                      ; compressed
   114                              <1> 
   115                              <1> 	; db	"%s",NULL							; version string
   116                              <1> 	; db	 25h,  73h,  00h    ; uncompressed
   117                              <1> 	  db	 1dh                ; compressed
   118                              <1> 
   119                              <1> %endif
   120                              <1> g_szDriveName:		; db	"%z",LF,CR,NULL
   121                              <1>               		; db	 25h,  7ah,  0ah,  0dh,  00h    ; uncompressed
   122                              <1>               		  db	 3eh,  19h                      ; compressed
   123                              <1> 
   124                              <1> 
   125                              <1> 
   126                              <1> ; Boot loader strings
   127                              <1> g_szTryToBoot:			; db	"Booting %c",ANGLE_QUOTE_RIGHT,"%c",LF,CR,NULL
   128                              <1>               			; db	 42h,  6fh,  6fh,  74h,  69h,  6eh,  67h,  20h,  25h,  63h, 0afh,  25h,  63h,  0ah,  0dh,  00h    ; uncompressed
   129                              <1>               			  db	 48h,  75h,  75h,  7ah,  6fh,  74h, 0edh,  3ch,  24h,  3ch,  19h                                  ; compressed
   130                              <1> 
   131                              <1> g_szBootSectorNotFound:	; db	"Boot sector " 			; String fall through...
   132                              <1>                        	; db	 42h,  6fh,  6fh,  74h,  20h,  73h,  65h,  63h,  74h,  6fh,  72h,  20h    ; uncompressed
   133                              <1>                        	  db	 48h,  75h,  75h, 0fah,  79h,  6bh,  69h,  7ah,  75h, 0f8h                ; compressed
   134                              <1> 
   135                              <1> g_szNotFound:			; db	"not found",LF,CR,NULL
   136                              <1>              			; db	 6eh,  6fh,  74h,  20h,  66h,  6fh,  75h,  6eh,  64h,  0ah,  0dh,  00h    ; uncompressed
   137                              <1>              			  db	 74h,  75h, 0fah,  6ch,  75h,  7bh,  74h,  6ah,  19h                      ; compressed
   138                              <1> 
   139                              <1> g_szReadError:			; db	"Error %x!",LF,CR,NULL
   140                              <1>               			; db	 45h,  72h,  72h,  6fh,  72h,  20h,  25h,  78h,  21h,  0ah,  0dh,  00h    ; uncompressed
   141                              <1>               			  db	 4bh,  78h,  78h,  75h, 0f8h,  37h,  25h,  19h                            ; compressed
   142                              <1> 
   143                              <1> 
   144                              <1> 
   145                              <1> %ifdef MODULE_HOTKEYS
   146                              <1> ; Hotkey Bar strings
   147                              <1> g_szFDD:				; db	"FDD [%c]",NULL			; "FDD [A]"
   148                              <1>         				; db	 46h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
   149                              <1>         				  db	 4ch,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
   150                              <1> 
   151                              <1> g_szHDD:				; db	"HDD [%c]",NULL			; "HDD [C]"
   152                              <1>         				; db	 48h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
   153                              <1>         				  db	 4eh,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
   154                              <1> 
   155                              <1> %ifdef MODULE_BOOT_MENU
   156                              <1> g_szBootMenu:			; db	"BootMnu%c",NULL		; "BootMnu", location of %c doesn't matter
   157                              <1>              			; db	 42h,  6fh,  6fh,  74h,  4dh,  6eh,  75h,  25h,  63h,  00h    ; uncompressed
   158                              <1>              			  db	 48h,  75h,  75h,  7ah,  53h,  74h,  7bh,  1ch                ; compressed
   159                              <1> 
   160                              <1> %endif ; MODULE_BOOT_MENU
   161                              <1> g_szHotkey:				; db	"%A%c%c%A%s%A ",NULL	; "CHDD [A] ", "F2BootMnu " or "F8RomBoot "
   162                              <1>            				; db	 25h,  41h,  25h,  63h,  25h,  63h,  25h,  41h,  25h,  73h,  25h,  41h,  20h,  00h    ; uncompressed
   163                              <1>            				  db	 3bh,  3ch,  3ch,  3bh,  3dh,  3bh,  00h                                              ; compressed
   164                              <1> 
   165                              <1> %ifdef MODULE_SERIAL
   166                              <1> g_szHotComDetect:		; db	"ComDtct%c",NULL		; "ComDtct", location of %c doesn't matter
   167                              <1>                  		; db	 43h,  6fh,  6dh,  44h,  74h,  63h,  74h,  25h,  63h,  00h    ; uncompressed
   168                              <1>                  		  db	 49h,  75h,  73h,  4ah,  7ah,  69h,  7ah,  1ch                ; compressed
   169                              <1> 
   170                              <1> %endif ; MODULE_SERIAL
   171                              <1> %endif ; MODULE_HOTKEYS
   172                              <1> 
   173                              <1> %ifdef MODULE_BOOT_MENU
   174                              <1> g_szRomBootDash:		; db	" -  "					; String fall through to g_szRomBoot
   175                              <1>                 		; db	 20h,  2dh,  20h,  20h    ; uncompressed
   176                              <1>                 		  db	 20h,  28h,  20h,  20h    ; compressed
   177                              <1> 
   178                              <1> %endif
   179                              <1> %ifdef MODULE_HOTKEYS OR MODULE_BOOT_MENU
   180                              <1> g_szRomBoot:			; db	"Rom%cBoot",NULL		; "RomBoot" or "Rom Boot"
   181                              <1>             			; db	 52h,  6fh,  6dh,  25h,  63h,  42h,  6fh,  6fh,  74h,  00h    ; uncompressed
   182                              <1>             			  db	 58h,  75h,  73h,  3ch,  48h,  75h,  75h, 0bah                ; compressed
   183                              <1> 
   184                              <1> %endif
   185                              <1> 
   186                              <1> 
   187                              <1> %ifdef MODULE_BOOT_MENU
   188                              <1> ; Boot Menu Floppy Disk strings
   189                              <1> ;
   190                              <1> ; The following strings are used by BootMenuPrint_RefreshInformation
   191                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
   192                              <1> ; which is checked at assembly time below.
   193                              <1> ;
   194                              <1> g_szFddStart:
   195                              <1> g_szFddUnknown:		; db	"Unknown",NULL
   196                              <1>                		; db	 55h,  6eh,  6bh,  6eh,  6fh,  77h,  6eh,  00h    ; uncompressed
   197                              <1>                		  db	 5bh,  74h,  71h,  74h,  75h,  7dh, 0b4h          ; compressed
   198                              <1> 
   199                              <1> g_szFddSizeOr:		; db	"5",ONE_QUARTER,QUOTATION_MARK," or 3",ONE_HALF,QUOTATION_MARK," DD",NULL
   200                              <1>               		; db	 35h, 0ach,  22h,  20h,  6fh,  72h,  20h,  33h, 0abh,  22h,  20h,  44h,  44h,  00h    ; uncompressed
   201                              <1>               		  db	 2eh,  21h,  26h,  20h,  75h, 0f8h,  2dh,  22h,  26h,  20h,  4ah,  8ah                ; compressed
   202                              <1> 
   203                              <1> g_szFddSize:		; db	"%s",QUOTATION_MARK,", %u kiB",NULL	; 3", 1440 kiB
   204                              <1>             		; db	 25h,  73h,  22h,  2ch,  20h,  25h,  75h,  20h,  6bh,  69h,  42h,  00h    ; uncompressed
   205                              <1>             		  db	 3dh,  26h,  27h,  20h,  35h,  20h,  71h,  6fh,  88h                      ; compressed
   206                              <1> 
   207                              <1> g_szFddThreeHalf:	; db	"3",ONE_HALF,NULL
   208                              <1>                  	; db	 33h, 0abh,  00h    ; uncompressed
   209                              <1>                  	  db	 2dh,  02h          ; compressed
   210                              <1> 
   211                              <1> g_szFddEnd:
   212                              <1> g_szFddFiveQuarter:	; db	"5",ONE_QUARTER,NULL
   213                              <1>                    	; db	 35h, 0ach,  00h    ; uncompressed
   214                              <1>                    	  db	 2eh,  01h          ; compressed
   215                              <1> 
   216                              <1> 
   217                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   218                              <1> %if ((g_szFddStart-$$) & 0xff00) <> ((g_szFddEnd-$$) & 0xff00)
   219                              <1> %error "g_szFdd* strings must start on the same 256 byte page, required by the BootMenuPrint_RefreshInformation routines for floppy drives.  Please move this block up or down within Strings.asm"
   220                              <1> %endif
   221                              <1> %endif
   222                              <1> 
   223                              <1> 
   224                              <1> g_szAddressingModes:
   225                              <1> g_szNORMAL:		; db	"NORMAL",NULL
   226                              <1>            		; db	 4eh,  4fh,  52h,  4dh,  41h,  4ch,  00h    ; uncompressed
   227                              <1>            		  db	 54h,  55h,  58h,  53h,  47h,  92h          ; compressed
   228                              <1> 
   229                              <1> g_szLARGE:		; db	"LARGE ",NULL
   230                              <1>           		; db	 4ch,  41h,  52h,  47h,  45h,  20h,  00h    ; uncompressed
   231                              <1>           		  db	 52h,  47h,  58h,  4dh,  4bh,  00h          ; compressed
   232                              <1> 
   233                              <1> g_szLBA:		; db	"LBA   ",NULL
   234                              <1>         		; db	 4ch,  42h,  41h,  20h,  20h,  20h,  00h    ; uncompressed
   235                              <1>         		  db	 52h,  48h, 0c7h,  20h,  00h                ; compressed
   236                              <1> 
   237                              <1> g_szAddressingModes_Displacement equ (g_szLARGE - g_szAddressingModes)
   238                              <1> ;
   239                              <1> ; Ensure that addressing modes are correctly spaced in memory
   240                              <1> ;
   241                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   242                              <1> %if g_szNORMAL <> g_szAddressingModes
   243                              <1> %error "g_szAddressingModes Displacement Incorrect 1"
   244                              <1> %endif
   245                              <1> %if g_szLARGE <> g_szNORMAL + g_szAddressingModes_Displacement
   246                              <1> %error "g_szAddressingModes Displacement Incorrect 2"
   247                              <1> %endif
   248                              <1> %if g_szLBA <> g_szLARGE + g_szAddressingModes_Displacement
   249                              <1> %error "g_szAddressingModes Displacement Incorrect 3"
   250                              <1> %endif
   251                              <1> %endif
   252                              <1> 
   253                              <1> 
   254                              <1> g_szDeviceTypeValues:
   255                              <1> g_szDeviceTypeValues_16bit:		; db	" 16",NULL
   256                              <1>                            		; db	 20h,  31h,  36h,  00h    ; uncompressed
   257                              <1>                            		  db	 20h,  2bh,  0fh          ; compressed
   258                              <1> 
   259                              <1> g_szDeviceTypeValues_32bit:		; db	" 32",NULL
   260                              <1>                            		; db	 20h,  33h,  32h,  00h    ; uncompressed
   261                              <1>                            		  db	 20h,  2dh,  0ch          ; compressed
   262                              <1> 
   263                              <1> g_szDeviceTypeValues_8bit:		; db	"  8",NULL
   264                              <1>                           		; db	 20h,  20h,  38h,  00h    ; uncompressed
   265                              <1>                           		  db	 20h,  20h,  10h          ; compressed
   266                              <1> 
   267                              <1> g_szDeviceTypeValues_XTIDEr1:	; db	"D8 ",NULL	; Dual 8-bit
   268                              <1>                              	; db	 44h,  38h,  20h,  00h    ; uncompressed
   269                              <1>                              	  db	 4ah,  30h,  00h          ; compressed
   270                              <1> 
   271                              <1> g_szDeviceTypeValues_XTIDEr2:	; db	"X8 ",NULL	; A0<->A3 swapped 8-bit
   272                              <1>                              	; db	 58h,  38h,  20h,  00h    ; uncompressed
   273                              <1>                              	  db	 5eh,  30h,  00h          ; compressed
   274                              <1> 
   275                              <1> g_szDeviceTypeValues_XTCFpio8:	; db	"T8 ",NULL	; True 8-bit
   276                              <1>                               	; db	 54h,  38h,  20h,  00h    ; uncompressed
   277                              <1>                               	  db	 5ah,  30h,  00h          ; compressed
   278                              <1> 
   279                              <1> g_szDeviceTypeValues_XTCFdma:	; db	"8MA",NULL	; DMA 8-bit
   280                              <1>                              	; db	 38h,  4dh,  41h,  00h    ; uncompressed
   281                              <1>                              	  db	 30h,  53h,  87h          ; compressed
   282                              <1> 
   283                              <1> g_szDeviceTypeValues_XTCFmem:	; db	"M8 ",NULL	; Memory Mapped 8-bit
   284                              <1>                              	; db	 4dh,  38h,  20h,  00h    ; uncompressed
   285                              <1>                              	  db	 53h,  30h,  00h          ; compressed
   286                              <1> 
   287                              <1> g_szDeviceTypeValues_JrIde:		; db	"M8 ",NULL
   288                              <1>                            		; db	 4dh,  38h,  20h,  00h    ; uncompressed
   289                              <1>                            		  db	 53h,  30h,  00h          ; compressed
   290                              <1> 
   291                              <1> g_szDeviceTypeValues_Serial:	; db	"SER",NULL
   292                              <1>                             	; db	 53h,  45h,  52h,  00h    ; uncompressed
   293                              <1>                             	  db	 59h,  4bh,  98h          ; compressed
   294                              <1> 
   295                              <1> 
   296                              <1> g_szDeviceTypeValues_Displacement equ (g_szDeviceTypeValues_32bit - g_szDeviceTypeValues)
   297                              <1> ;
   298                              <1> ; Ensure that device type strings are correctly spaced in memory
   299                              <1> ;
   300                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   301                              <1> %if g_szDeviceTypeValues_16bit <> g_szDeviceTypeValues
   302                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 1"
   303                              <1> %endif
   304                              <1> %if g_szDeviceTypeValues_32bit <> g_szDeviceTypeValues_16bit + g_szDeviceTypeValues_Displacement
   305                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
   306                              <1> %endif
   307                              <1> %if g_szDeviceTypeValues_8bit <> g_szDeviceTypeValues_32bit + g_szDeviceTypeValues_Displacement
   308                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
   309                              <1> %endif
   310                              <1> %if g_szDeviceTypeValues_XTIDEr1 <> g_szDeviceTypeValues_8bit + g_szDeviceTypeValues_Displacement
   311                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 3"
   312                              <1> %endif
   313                              <1> %if g_szDeviceTypeValues_XTIDEr2 <> g_szDeviceTypeValues_XTIDEr1 + g_szDeviceTypeValues_Displacement
   314                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 4"
   315                              <1> %endif
   316                              <1> %if g_szDeviceTypeValues_XTCFpio8 <> g_szDeviceTypeValues_XTIDEr2 + g_szDeviceTypeValues_Displacement
   317                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 5"
   318                              <1> %endif
   319                              <1> %if g_szDeviceTypeValues_XTCFdma <> g_szDeviceTypeValues_XTCFpio8 + g_szDeviceTypeValues_Displacement
   320                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 6"
   321                              <1> %endif
   322                              <1> %if g_szDeviceTypeValues_XTCFmem <> g_szDeviceTypeValues_XTCFdma + g_szDeviceTypeValues_Displacement
   323                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 7"
   324                              <1> %endif
   325                              <1> %if g_szDeviceTypeValues_JrIde <> g_szDeviceTypeValues_XTCFmem + g_szDeviceTypeValues_Displacement
   326                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 8"
   327                              <1> %endif
   328                              <1> %if g_szDeviceTypeValues_Serial <> g_szDeviceTypeValues_JrIde + g_szDeviceTypeValues_Displacement
   329                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 9"
   330                              <1> %endif
   331                              <1> %endif
   332                              <1> 
   333                              <1> 
   334                              <1> g_szSelectionTimeout:	; db	DOUBLE_BOTTOM_LEFT_CORNER,DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL,"%ASelection in %2-u s",NULL
   335                              <1>                      	; db	0c8h, 0b5h,  25h,  41h,  53h,  65h,  6ch,  65h,  63h,  74h,  69h,  6fh,  6eh,  20h,  69h,  6eh,  20h,  25h,  32h,  2dh,  75h,  20h,  73h,  00h    ; uncompressed
   336                              <1>                      	  db	 31h,  32h,  3bh,  59h,  6bh,  72h,  6bh,  69h,  7ah,  6fh,  75h, 0f4h,  6fh, 0f4h,  3ah,  20h, 0b9h                                              ; compressed
   337                              <1> 
   338                              <1> 
   339                              <1> 
   340                              <1> ; Boot Menu information strings
   341                              <1> g_szCapacity:			; db	"Capacity : %s",NULL
   342                              <1>              			; db	 43h,  61h,  70h,  61h,  63h,  69h,  74h,  79h,  20h,  3ah,  20h,  25h,  73h,  00h    ; uncompressed
   343                              <1>              			  db	 49h,  67h,  76h,  67h,  69h,  6fh,  7ah, 0ffh, 0c0h,  1dh                            ; compressed
   344                              <1> 
   345                              <1> g_szCapacityNum:		; db	"%5-u.%u %ciB",NULL
   346                              <1>                 		; db	 25h,  35h,  2dh,  75h,  2eh,  25h,  75h,  20h,  25h,  63h,  69h,  42h,  00h    ; uncompressed
   347                              <1>                 		  db	 36h,  29h,  35h,  20h,  3ch,  6fh,  88h                                        ; compressed
   348                              <1> 
   349                              <1> g_szInformation:		; db	"%s",LF,CR
   350                              <1>                 		; db	 25h,  73h,  0ah,  0dh    ; uncompressed
   351                              <1>                 		  db	 3dh,  39h                ; compressed
   352                              <1> 
   353                              <1> 	; db	"Addr. ",SINGLE_VERTICAL,"Block",SINGLE_VERTICAL,"Bus",SINGLE_VERTICAL,"IRQ",SINGLE_VERTICAL,"Reset",LF,CR
   354                              <1> 	; db	 41h,  64h,  64h,  72h,  2eh,  20h, 0b3h,  42h,  6ch,  6fh,  63h,  6bh, 0b3h,  42h,  75h,  73h, 0b3h,  49h,  52h,  51h, 0b3h,  52h,  65h,  73h,  65h,  74h,  0ah,  0dh    ; uncompressed
   355                              <1> 	  db	 47h,  6ah,  6ah,  78h,  29h,  20h,  23h,  48h,  72h,  75h,  69h,  71h,  23h,  48h,  7bh,  79h,  23h,  4fh,  58h,  57h,  23h,  58h,  6bh,  79h,  6bh,  7ah,  39h          ; compressed
   356                              <1> 
   357                              <1> 	; db	"%s",SINGLE_VERTICAL,"%5-u",SINGLE_VERTICAL,"%s",SINGLE_VERTICAL," %2-I",SINGLE_VERTICAL,"%5-x",NULL
   358                              <1> 	; db	 25h,  73h, 0b3h,  25h,  35h,  2dh,  75h, 0b3h,  25h,  73h, 0b3h,  20h,  25h,  32h,  2dh,  49h, 0b3h,  25h,  35h,  2dh,  78h,  00h    ; uncompressed
   359                              <1> 	  db	 3dh,  23h,  36h,  23h,  3dh,  23h,  20h,  34h,  23h,  18h                                                                            ; compressed
   360                              <1> 
   361                              <1> 
   362                              <1> 
   363                              <1> ; Boot Menu menuitem strings
   364                              <1> ;
   365                              <1> ; The following strings are used by BootMenuPrint_* routines.
   366                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
   367                              <1> ; which is checked at assembly time below.
   368                              <1> ;
   369                              <1> g_szDriveNumSpace:		; db	" "							; leading space, used if drive number is less than 0fh
   370                              <1>                   		; db	 20h    ; uncompressed
   371                              <1>                   		  db	 20h    ; compressed
   372                              <1> 
   373                              <1> ; must come immediately before g_szDriveNum!
   374                              <1> g_szBootMenuPrintStart:
   375                              <1> g_szDriveNum:			; db	"%x %s",NULL
   376                              <1>              			; db	 25h,  78h,  20h,  25h,  73h,  00h    ; uncompressed
   377                              <1>              			  db	 37h,  20h,  1dh                      ; compressed
   378                              <1> 
   379                              <1> g_szDriveNumBNSpace:	; db	" "							; leading space, used if drive number is less than 0fh
   380                              <1>                     	; db	 20h    ; uncompressed
   381                              <1>                     	  db	 20h    ; compressed
   382                              <1> 
   383                              <1> ; must come immediately before g_szDriveNumBOOTNFO!
   384                              <1> g_szDriveNumBOOTNFO:	; db	"%x %z",NULL
   385                              <1>                     	; db	 25h,  78h,  20h,  25h,  7ah,  00h    ; uncompressed
   386                              <1>                     	  db	 37h,  20h,  1eh                      ; compressed
   387                              <1> 
   388                              <1> g_szFloppyDrv:			; db	"Floppy Drive %c",NULL
   389                              <1>               			; db	 46h,  6ch,  6fh,  70h,  70h,  79h,  20h,  44h,  72h,  69h,  76h,  65h,  20h,  25h,  63h,  00h    ; uncompressed
   390                              <1>               			  db	 4ch,  72h,  75h,  76h,  76h, 0ffh,  4ah,  78h,  6fh,  7ch, 0ebh,  1ch                            ; compressed
   391                              <1> 
   392                              <1> g_szBootMenuPrintEnd:
   393                              <1> g_szForeignHD:			; db	"Foreign Hard Disk",NULL
   394                              <1>               			; db	 46h,  6fh,  72h,  65h,  69h,  67h,  6eh,  20h,  48h,  61h,  72h,  64h,  20h,  44h,  69h,  73h,  6bh,  00h    ; uncompressed
   395                              <1>               			  db	 4ch,  75h,  78h,  6bh,  6fh,  6dh, 0f4h,  4eh,  67h,  78h, 0eah,  4ah,  6fh,  79h, 0b1h                      ; compressed
   396                              <1> 
   397                              <1> 
   398                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   399                              <1> %if ((g_szBootMenuPrintStart-$$) & 0xff00) <> ((g_szBootMenuPrintEnd-$$) & 0xff00)
   400                              <1> %error "g_szBootMenuPrint* strings must start on the same 256 byte page, required by the BootMenuPrint_* routines.  Please move this block up or down within Strings.asm"
   401                              <1> %endif
   402                              <1> %if g_szDriveNumSpace+1 != g_szDriveNum || g_szDriveNumBNSpace+1 != g_szDriveNumBOOTNFO
   403                              <1> %error "g_szDriveNumSpace or g_szDriveNumBNSpace are out of position"
   404                              <1> %endif
   405                              <1> %endif
   406                              <1> 
   407                              <1> %endif ; MODULE_BOOT_MENU
   408                              <1> 
   409                              <1> 
   410                              <1> ;------------------------------------------------------------------------------------------
   411                              <1> ;
   412                              <1> ; Tables for StringsCompress.pl
   413                              <1> ;
   414                              <1> ; Items can be added and removed from this table as needed, with the following rules:
   415                              <1> ;  * Formats follow the special characters.  But other than that, order makes no difference.
   416                              <1> ;  * Some of the formats require "even" and "odd" numbering.  Even tells the code that
   417                              <1> ;    it is a "number-" format, otherwise it doesn't interpret a number first.  The easiest
   418                              <1> ;    way to maintain this is to move one of the "n/a" items to/from the front of the format
   419                              <1> ;    list to maintain the even/odd.
   420                              <1> ;  * Values do not need to remain consistent across versions.  This table is only used
   421                              <1> ;    internally to this file.
   422                              <1> ;  * There can only be 32 of these (0-31).
   423                              <1> ;  * Keeping the list short is good - this translates to a table in the compressed version.
   424                              <1> ;    An error will be reported if a character or format is no longer being used by any
   425                              <1> ;    strings above.
   426                              <1> ;  * Please keep items sequential for ease of further editing.
   427                              <1> ;
   428                              <1> ;$translate{ord(' ')} = 0;    [StringsCompress Processed]
   429                              <1> ;$translate{172}      = 1;     # ONE_QUARTER    [StringsCompress Processed]
   430                              <1> ;$translate{171}      = 2;     # ONE_HALF    [StringsCompress Processed]
   431                              <1> ;$translate{179}      = 3;     # SINGLE_VERTICAL    [StringsCompress Processed]
   432                              <1> ;$translate{175}      = 4;     # ANGLE_QUOTE_RIGHT    [StringsCompress Processed]
   433                              <1> ;$translate{ord('!')} = 5;    [StringsCompress Processed]
   434                              <1> ;$translate{ord('"')} = 6;    [StringsCompress Processed]
   435                              <1> ;$translate{ord(',')} = 7;    [StringsCompress Processed]
   436                              <1> ;$translate{ord('-')} = 8;    [StringsCompress Processed]
   437                              <1> ;$translate{ord('.')} = 9;    [StringsCompress Processed]
   438                              <1> ;$translate{ord('/')} = 10;    [StringsCompress Processed]
   439                              <1> ;$translate{ord('1')} = 11;    [StringsCompress Processed]
   440                              <1> ;$translate{ord('2')} = 12;    [StringsCompress Processed]
   441                              <1> ;$translate{ord('3')} = 13;    [StringsCompress Processed]
   442                              <1> ;$translate{ord('5')} = 14;    [StringsCompress Processed]
   443                              <1> ;$translate{ord('6')} = 15;    [StringsCompress Processed]
   444                              <1> ;$translate{ord('8')} = 16;    [StringsCompress Processed]
   445                              <1> ;$translate{200}      = 17;    # DOUBLE_BOTTOM_LEFT_CORNER    [StringsCompress Processed]
   446                              <1> ;$translate{181}      = 18;    # DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL    [StringsCompress Processed]
   447                              <1> ;$translate{ord('0')} = 19;    [StringsCompress Processed]
   448                              <1> ;
   449                              <1> ; Formats begin immediately after the last Translated character (they are in the same table)
   450                              <1> ;
   451                              <1> ;$format_begin = 20;    [StringsCompress Processed]
   452                              <1> ;
   453                              <1> ;$format{"2-I"} = 20;        # must be even    [StringsCompress Processed]
   454                              <1> ;$format{"u"}   = 21;        # must be odd    [StringsCompress Processed]
   455                              <1> ;$format{"5-u"} = 22;        # must be even    [StringsCompress Processed]
   456                              <1> ;$format{"x"}   = 23;        # must be odd    [StringsCompress Processed]
   457                              <1> ;$format{"5-x"} = 24;        # must be even    [StringsCompress Processed]
   458                              <1> ;$format{"nl"}  = 25;        # n/a    [StringsCompress Processed]
   459                              <1> ;$format{"2-u"} = 26;        # must be even    [StringsCompress Processed]
   460                              <1> ;$format{"A"}   = 27;        # n/a    [StringsCompress Processed]
   461                              <1> ;$format{"c"}   = 28;        # n/a    [StringsCompress Processed]
   462                              <1> ;$format{"s"}   = 29;        # n/a, normal string from DS    [StringsCompress Processed]
   463                              <1> ;$format{"z"}   = 30;        # n/a, boot string from BDA    [StringsCompress Processed]
   464                              <1> ;
   465                              <1> ; NOTE: The last $format cannot exceed 31 (stored in a 5-bit quantity).
   466                              <1> ;
   467                              <1> ; Starting point for the "normal" range, typically around 0x40 to cover upper and lower case
   468                              <1> ; letters.  If lower case 'z' is not used, 0x3a can be a good choice as it adds ':' to the
   469                              <1> ; front end.
   470                              <1> ;
   471                              <1> ;$normal_base = 0x3a;    [StringsCompress Processed]
   472                              <1> ;
   473                              <1> ; End of StringsCompress.pl information
   474                              <1> ;
   475                              <1> ;;; end of input stream
   476                              <1> 
   477                              <1> %endif ; STRINGSCOMPRESSED_STRINGS
   478                              <1> 
   479                              <1> %ifdef STRINGSCOMPRESSED_TABLES
   480                              <1> 
   481                              <1> StringsCompressed_NormalBase     equ   58
   482                              <1> 
   483                              <1> StringsCompressed_FormatsBegin   equ   20
   484                              <1> 
   485                              <1> StringsCompressed_TranslatesAndFormats:
   486 00000A79 20                  <1>         db     32  ; 0
   487 00000A7A AC                  <1>         db     172  ; 1
   488 00000A7B AB                  <1>         db     171  ; 2
   489 00000A7C B3                  <1>         db     179  ; 3
   490 00000A7D AF                  <1>         db     175  ; 4
   491 00000A7E 21                  <1>         db     33  ; 5
   492 00000A7F 22                  <1>         db     34  ; 6
   493 00000A80 2C                  <1>         db     44  ; 7
   494 00000A81 2D                  <1>         db     45  ; 8
   495 00000A82 2E                  <1>         db     46  ; 9
   496 00000A83 2F                  <1>         db     47  ; 10
   497 00000A84 31                  <1>         db     49  ; 11
   498 00000A85 32                  <1>         db     50  ; 12
   499 00000A86 33                  <1>         db     51  ; 13
   500 00000A87 35                  <1>         db     53  ; 14
   501 00000A88 36                  <1>         db     54  ; 15
   502 00000A89 38                  <1>         db     56  ; 16
   503 00000A8A C8                  <1>         db     200  ; 17
   504 00000A8B B5                  <1>         db     181  ; 18
   505 00000A8C 30                  <1>         db     48  ; 19
   506 00000A8D 31                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I)    ; 20
   507 00000A8E 28                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u)    ; 21
   508 00000A8F 28                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u)    ; 22
   509 00000A90 39                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x)    ; 23
   510 00000A91 39                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x)    ; 24
   511 00000A92 6C                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl)    ; 25
   512 00000A93 2A                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u)    ; 26
   513 00000A94 42                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A)    ; 27
   514 00000A95 63                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c)    ; 28
   515 00000A96 00                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s)    ; 29
   516 00000A97 3E                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z)    ; 30
   517                              <1> 
   518                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   519                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_I || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I > 255
   520                              <1> %error "DisplayFormatCompressed_Format_2_I is out of range of DisplayFormatCompressed_BaseFormatOffset"
   521                              <1> %endif
   522                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u > 255
   523                              <1> %error "DisplayFormatCompressed_Format_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
   524                              <1> %endif
   525                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u > 255
   526                              <1> %error "DisplayFormatCompressed_Format_5_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
   527                              <1> %endif
   528                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x > 255
   529                              <1> %error "DisplayFormatCompressed_Format_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
   530                              <1> %endif
   531                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x > 255
   532                              <1> %error "DisplayFormatCompressed_Format_5_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
   533                              <1> %endif
   534                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_nl || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl > 255
   535                              <1> %error "DisplayFormatCompressed_Format_nl is out of range of DisplayFormatCompressed_BaseFormatOffset"
   536                              <1> %endif
   537                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u > 255
   538                              <1> %error "DisplayFormatCompressed_Format_2_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
   539                              <1> %endif
   540                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_A || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A > 255
   541                              <1> %error "DisplayFormatCompressed_Format_A is out of range of DisplayFormatCompressed_BaseFormatOffset"
   542                              <1> %endif
   543                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_c || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c > 255
   544                              <1> %error "DisplayFormatCompressed_Format_c is out of range of DisplayFormatCompressed_BaseFormatOffset"
   545                              <1> %endif
   546                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_s || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s > 255
   547                              <1> %error "DisplayFormatCompressed_Format_s is out of range of DisplayFormatCompressed_BaseFormatOffset"
   548                              <1> %endif
   549                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_z || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z > 255
   550                              <1> %error "DisplayFormatCompressed_Format_z is out of range of DisplayFormatCompressed_BaseFormatOffset"
   551                              <1> %endif
   552                              <1> %endif
   553                              <1> 
   554                              <1> ;; translated usage stats
   555                              <1> ;; 33:1
   556                              <1> ;; 32:34
   557                              <1> ;; 181:1
   558                              <1> ;; 53:2
   559                              <1> ;; 48:2
   560                              <1> ;; 200:1
   561                              <1> ;; 46:3
   562                              <1> ;; 179:8
   563                              <1> ;; 44:1
   564                              <1> ;; 50:2
   565                              <1> ;; 51:3
   566                              <1> ;; 47:2
   567                              <1> ;; 172:2
   568                              <1> ;; 34:3
   569                              <1> ;; 49:1
   570                              <1> ;; 56:7
   571                              <1> ;; 45:2
   572                              <1> ;; 175:1
   573                              <1> ;; 171:2
   574                              <1> ;; 54:1
   575                              <1> ;; total translated: 20
   576                              <1> 
   577                              <1> ;; format usage stats
   578                              <1> ;; A:4
   579                              <1> ;; 2-u:1
   580                              <1> ;; 5-u:2
   581                              <1> ;; x:5
   582                              <1> ;; s:14
   583                              <1> ;; 5-x:1
   584                              <1> ;; nl:12
   585                              <1> ;; 2-I:1
   586                              <1> ;; u:6
   587                              <1> ;; c:13
   588                              <1> ;; z:2
   589                              <1> ;; total format: 11
   590                              <1> 
   591                              <1> ;; alphabet usage stats
   592                              <1> ;; 58,::2
   593                              <1> ;; 59,;:
   594                              <1> ;; 60,<:
   595                              <1> ;; 61,=:
   596                              <1> ;; 62,>:
   597                              <1> ;; 63,?:
   598                              <1> ;; 64,@:1
   599                              <1> ;; 65,A:5
   600                              <1> ;; 66,B:9
   601                              <1> ;; 67,C:3
   602                              <1> ;; 68,D:11
   603                              <1> ;; 69,E:3
   604                              <1> ;; 70,F:3
   605                              <1> ;; 71,G:3
   606                              <1> ;; 72,H:2
   607                              <1> ;; 73,I:1
   608                              <1> ;; 74,J:
   609                              <1> ;; 75,K:1
   610                              <1> ;; 76,L:4
   611                              <1> ;; 77,M:7
   612                              <1> ;; 78,N:2
   613                              <1> ;; 79,O:2
   614                              <1> ;; 80,P:1
   615                              <1> ;; 81,Q:1
   616                              <1> ;; 82,R:7
   617                              <1> ;; 83,S:3
   618                              <1> ;; 84,T:1
   619                              <1> ;; 85,U:2
   620                              <1> ;; 86,V:
   621                              <1> ;; 87,W:
   622                              <1> ;; 88,X:1
   623                              <1> ;; 89,Y:
   624                              <1> ;; 90,Z:
   625                              <1> ;; 91,[:2
   626                              <1> ;; 92,\:
   627                              <1> ;; 93,]:2
   628                              <1> ;; 94,^:
   629                              <1> ;; 95,_:
   630                              <1> ;; 96,`:
   631                              <1> ;; 97,a:7
   632                              <1> ;; 98,b:
   633                              <1> ;; 99,c:6
   634                              <1> ;; 100,d:6
   635                              <1> ;; 101,e:15
   636                              <1> ;; 102,f:1
   637                              <1> ;; 103,g:2
   638                              <1> ;; 104,h:
   639                              <1> ;; 105,i:9
   640                              <1> ;; 106,j:
   641                              <1> ;; 107,k:4
   642                              <1> ;; 108,l:5
   643                              <1> ;; 109,m:2
   644                              <1> ;; 110,n:11
   645                              <1> ;; 111,o:20
   646                              <1> ;; 112,p:3
   647                              <1> ;; 113,q:
   648                              <1> ;; 114,r:11
   649                              <1> ;; 115,s:7
   650                              <1> ;; 116,t:15
   651                              <1> ;; 117,u:4
   652                              <1> ;; 118,v:3
   653                              <1> ;; 119,w:1
   654                              <1> ;; 120,x:
   655                              <1> ;; 121,y:2
   656                              <1> ;; alphabet used count: 45
   657                              <1> %endif ; STRINGSCOMPRESSED_TABLES
   658                              <1> 
   189                                  %endif
   190                                  
   191                                  	%include "Initialize.asm"		; For BIOS initialization
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for initializing the BIOS.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Initializes the BIOS.
    25                              <1> ; This function is called from main BIOS ROM search routine.
    26                              <1> ;
    27                              <1> ; Initialize_FromMainBiosRomSearch
    28                              <1> ;	Parameters:
    29                              <1> ;		Nothing
    30                              <1> ;	Returns:
    31                              <1> ;		Nothing
    32                              <1> ;	Corrupts registers:
    33                              <1> ;		Nothing
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> Initialize_FromMainBiosRomSearch:		; unused entrypoint ok
    36 00000A98 9C                  <1> 	pushf								; To store IF
    37 00000A99 1E                  <1> 	push	ds
    38                              <1> 
    39                              <1> %ifndef USE_186
    40 00000A9A 50                  <1> 	push	ax
    41                              <1> 	LOAD_BDA_SEGMENT_TO	ds, ax
    41                              <2> %ifndef USE_186
    41 00000A9B 31C0                <2>  xor %2, %2
    41 00000A9D 8ED8                <2>  mov %1, %2
    41                              <2> %elifidn %3, !
    41                              <2>  xor %2, %2
    41                              <2>  mov %1, %2
    41                              <2> %else
    41                              <2>  push BYTE 0
    41                              <2>  pop %1
    41                              <2> %endif
    42                              <1> %else
    43                              <1> 	push	BYTE 0
    44                              <1> 	pop		ds
    45                              <1> %endif
    46                              <1> 
    47 00000A9F FB                  <1> 	sti									; Enable interrupts for keystrokes
    48 00000AA0 F606170404          <1> 	test	BYTE [BDA.bKBFlgs1], (1<<2)	; Clears ZF if CTRL is held down
    49 00000AA5 750A                <1> 	jnz		SHORT .SkipRomInitialization
    50                              <1> 
    51                              <1> 	; Install INT 19h handler (boot loader) where drives are detected
    52 00000AA7 C7066400[2E12]      <1> 	mov		WORD [BIOS_BOOT_LOADER_INTERRUPT_19h*4], Int19h_BootLoaderHandler
    53 00000AAD 8C0E6600            <1> 	mov		[BIOS_BOOT_LOADER_INTERRUPT_19h*4+2], cs
    54                              <1> 
    55                              <1> .SkipRomInitialization:
    56                              <1> %ifndef USE_186
    57 00000AB1 58                  <1> 	pop		ax
    58                              <1> %endif
    59 00000AB2 1F                  <1> 	pop		ds
    60 00000AB3 9D                  <1> 	popf
    61 00000AB4 CB                  <1> 	retf
    62                              <1> 
    63                              <1> 
    64                              <1> ;--------------------------------------------------------------------
    65                              <1> ; Initializes the BIOS variables and detects IDE drives.
    66                              <1> ;
    67                              <1> ; Initialize_AndDetectDrives
    68                              <1> ;	Parameters:
    69                              <1> ;		ES:		BDA Segment
    70                              <1> ;	Returns:
    71                              <1> ;		DS:		RAMVARS segment
    72                              <1> ;	Corrupts registers:
    73                              <1> ;		All, except ES
    74                              <1> ;--------------------------------------------------------------------
    75                              <1> Initialize_AndDetectDrives:
    76 00000AB5 E8E403              <1> 	call	DetectPrint_InitializeDisplayContext
    77 00000AB8 E80E04              <1> 	call	DetectPrint_RomFoundAtSegment
    78 00000ABB E84A00              <1> 	call	RamVars_Initialize
    79 00000ABE E8D100              <1> 	call	BootVars_Initialize
    80 00000AC1 E83C03              <1> 	call	DetectDrives_FromAllIDEControllers
    81 00000AC4 E80A00              <1> 	call	Interrupts_InitializeInterruptVectors
    82                              <1> 	; Fall to .ResetDetectedDrives
    83                              <1> 
    84                              <1> ;--------------------------------------------------------------------
    85                              <1> ; .ResetDetectedDrives
    86                              <1> ;	Parameters:
    87                              <1> ;		DS:		RAMVARS segment
    88                              <1> ;		ES:		BDA and interrupt vector segment (zero)
    89                              <1> ;	Returns:
    90                              <1> ;		Nothing
    91                              <1> ;	Corrupts registers:
    92                              <1> ;		All, except DS and ES
    93                              <1> ;--------------------------------------------------------------------
    94                              <1> .ResetDetectedDrives:
    95 00000AC7 E85308              <1> 	call	Idepack_FakeToSSBP
    96 00000ACA E8900F              <1> 	call	AH0h_ResetAllOurHardDisksAtTheEndOfDriveInitialization
    97 00000ACD 83C409              <1> 	add		sp, BYTE SIZE_OF_IDEPACK_WITHOUT_INTPACK
    98 00000AD0 C3                  <1> 	ret
   192                                  	%include "Interrupts.asm"		; For Interrupt initialization
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for initializing the BIOS.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Drives must be detected before this function is called!
    25                              <1> ;
    26                              <1> ; Interrupts_InitializeInterruptVectors
    27                              <1> ;	Parameters:
    28                              <1> ;		DS:		RAMVARS segment
    29                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
    30                              <1> ;	Returns:
    31                              <1> ;		Nothing
    32                              <1> ;	Corrupts registers:
    33                              <1> ;		All except segments
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> Interrupts_InitializeInterruptVectors:
    36                              <1> 	; Install INT 19h handler to properly reset the system
    37 00000AD1 B019                <1> 	mov		al, BIOS_BOOT_LOADER_INTERRUPT_19h	; INT 19h interrupt vector offset
    38 00000AD3 BE[1713]            <1> 	mov		si, Int19hReset_Handler				; INT 19h handler to reboot the system
    39 00000AD6 E82200              <1> 	call	Interrupts_InstallHandlerToVectorInALFromCSSI
    40                              <1> 
    41                              <1> 	; If no drives detected, leave system INT 13h and 40h handlers
    42                              <1> 	; in place. We need our INT 13h handler to swap drive letters.
    43                              <1> %ifndef MODULE_DRIVEXLATE
    44                              <1> 	cmp		BYTE [RAMVARS.bDrvCnt], 0
    45                              <1> 	je		SHORT Interrupts_InstallHandlerToVectorInALFromCSSI.Interrupts_Return
    46                              <1> %endif
    47                              <1> 	; Fall to .InitializeInt13hAnd40h
    48                              <1> 
    49                              <1> ;--------------------------------------------------------------------
    50                              <1> ; .InitializeInt13hAnd40h
    51                              <1> ;	Parameters:
    52                              <1> ;		DS:		RAMVARS segment
    53                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
    54                              <1> ;	Returns:
    55                              <1> ;		Nothing
    56                              <1> ;	Corrupts registers:
    57                              <1> ;		AX, BX, CX, DX, SI, DI
    58                              <1> ;--------------------------------------------------------------------
    59                              <1> .InitializeInt13hAnd40h:
    60 00000AD9 26A14E00            <1> 	mov		ax, [es:BIOS_DISK_INTERRUPT_13h*4+2]; Load old INT 13h segment
    61 00000ADD A30200              <1> 	mov		[RAMVARS.fpOldI13h+2], ax			; Store old INT 13h segment
    62 00000AE0 92                  <1> 	xchg	dx, ax
    63 00000AE1 26A14C00            <1> 	mov		ax, [es:BIOS_DISK_INTERRUPT_13h*4]	; Load old INT 13h offset
    64 00000AE5 A30000              <1> 	mov		[RAMVARS.fpOldI13h], ax				; Store old INT 13h offset
    65                              <1> 
    66                              <1> %ifdef COPY_13H_HANDLER_TO_40H
    67                              <1> 	; Only store INT 13h handler to 40h if 40h is not already installed.
    68                              <1> 	; At least AMI BIOS for 286 stores 40h handler by itself and calls
    69                              <1> 	; 40h from 13h. That system locks to infinite loop if we copy 13h to 40h.
    70 00000AE8 E8CF00              <1> 	call	FloppyDrive_IsInt40hInstalled
    71 00000AEB 7209                <1> 	jc		SHORT .Int40hAlreadyInstalled
    72 00000AED 26A30001            <1> 	mov		[es:BIOS_DISKETTE_INTERRUPT_40h*4], ax		; Store old INT 13h offset
    73 00000AF1 2689160201          <1> 	mov		[es:BIOS_DISKETTE_INTERRUPT_40h*4+2], dx	; Store old INT 13h segment
    74                              <1> .Int40hAlreadyInstalled:
    75                              <1> %endif ; COPY_13H_HANDLER_TO_40H
    76                              <1> 
    77 00000AF6 B013                <1> 	mov		al, BIOS_DISK_INTERRUPT_13h			; INT 13h interrupt vector offset
    78                              <1> %ifdef RELOCATE_INT13H_STACK
    79                              <1> 	mov		si, Int13h_DiskFunctionsHandlerWithStackChange
    80                              <1> %else
    81 00000AF8 BE[0A19]            <1> 	mov		si, Int13h_DiskFunctionsHandler
    82                              <1> %endif
    83                              <1> 
    84                              <1> %ifndef MODULE_IRQ
    85                              <1> 	; Fall to Interrupts_InstallHandlerToVectorInALFromCSSI
    86                              <1> %else
    87                              <1> 	call	Interrupts_InstallHandlerToVectorInALFromCSSI
    88                              <1> 	; Fall to .InitializeHardwareIrqHandlers
    89                              <1> 
    90                              <1> ;--------------------------------------------------------------------
    91                              <1> ; .InitializeHardwareIrqHandlers
    92                              <1> ;	Parameters:
    93                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
    94                              <1> ;	Returns:
    95                              <1> ;		Nothing
    96                              <1> ;	Corrupts registers:
    97                              <1> ;		BX, CX, DX, SI, DI, AX
    98                              <1> ;--------------------------------------------------------------------
    99                              <1> .InitializeHardwareIrqHandlers:
   100                              <1> 	call	RamVars_GetIdeControllerCountToCX
   101                              <1> 	mov		di, ROMVARS.ideVars0+IDEVARS.bIRQ	; CS:SI points to first IDEVARS
   102                              <1> .IdeControllerLoop:
   103                              <1> 	mov		al, [cs:di]
   104                              <1> 	add		di, BYTE IDEVARS_size			; Increment to next controller
   105                              <1> 	call	.InstallLowOrHighIrqHandler
   106                              <1> 	loop	.IdeControllerLoop
   107                              <1> .Return:
   108                              <1> 	ret		; This ret is shared with .InstallLowOrHighIrqHandler
   109                              <1> 
   110                              <1> ;--------------------------------------------------------------------
   111                              <1> ; .InstallLowOrHighIrqHandler
   112                              <1> ;	Parameters:
   113                              <1> ;		AL:		IRQ number, 0 if IRQ disabled
   114                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
   115                              <1> ;	Returns:
   116                              <1> ;		Nothing
   117                              <1> ;	Corrupts registers:
   118                              <1> ;		BX, SI
   119                              <1> ;--------------------------------------------------------------------
   120                              <1> .InstallLowOrHighIrqHandler:
   121                              <1> 	test	al, al
   122                              <1> 	jz		SHORT .Return	; IRQ not used
   123                              <1> 	cmp		al, 8
   124                              <1> 	jb		SHORT .InstallLowIrqHandler
   125                              <1> 	; Fall to .InstallHighIrqHandler
   126                              <1> 
   127                              <1> ;--------------------------------------------------------------------
   128                              <1> ; .InstallHighIrqHandler
   129                              <1> ;	Parameters:
   130                              <1> ;		BX:		IRQ number (8...15)
   131                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
   132                              <1> ;	Returns:
   133                              <1> ;		Nothing
   134                              <1> ;	Corrupts registers:
   135                              <1> ;		AL, BX, SI
   136                              <1> ;--------------------------------------------------------------------
   137                              <1> .InstallHighIrqHandler:
   138                              <1> 	add		al, BYTE HARDWARE_IRQ_8_INTERRUPT_70h - 8	; Interrupt vector number
   139                              <1> 	mov		si, IdeIrq_InterruptServiceRoutineForIrqs8to15
   140                              <1> 	jmp		SHORT Interrupts_InstallHandlerToVectorInALFromCSSI
   141                              <1> 
   142                              <1> ;--------------------------------------------------------------------
   143                              <1> ; .InstallLowIrqHandler
   144                              <1> ;	Parameters:
   145                              <1> ;		AL:		IRQ number (0...7)
   146                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
   147                              <1> ;	Returns:
   148                              <1> ;		Nothing
   149                              <1> ;	Corrupts registers:
   150                              <1> ;		AL, BX, SI
   151                              <1> ;--------------------------------------------------------------------
   152                              <1> .InstallLowIrqHandler:
   153                              <1> 	add		al, BYTE HARDWARE_IRQ_0_INTERRUPT_08h		; Interrupt vector number
   154                              <1> 	mov		si, IdeIrq_InterruptServiceRoutineForIrqs2to7
   155                              <1> 	; Fall to Interrupts_InstallHandlerToVectorInALFromCSSI
   156                              <1> %endif ; MODULE_IRQ
   157                              <1> 
   158                              <1> 
   159                              <1> ;--------------------------------------------------------------------
   160                              <1> ; Interrupts_InstallHandlerToVectorInALFromCSSI
   161                              <1> ;	Parameters:
   162                              <1> ;		AL:		Interrupt vector number (for example 13h)
   163                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
   164                              <1> ;		CS:SI:	Ptr to interrupt handler
   165                              <1> ;	Returns:
   166                              <1> ;		Nothing
   167                              <1> ;	Corrupts registers:
   168                              <1> ;		AX, BX
   169                              <1> ;--------------------------------------------------------------------
   170                              <1> Interrupts_InstallHandlerToVectorInALFromCSSI:
   171 00000AFB B304                <1> 	mov		bl, 4					; Shift for DWORD offset, MUL smaller than other alternatives
   172 00000AFD F6E3                <1> 	mul		bl
   173 00000AFF 93                  <1> 	xchg	ax, bx
   174 00000B00 268937              <1> 	mov		[es:bx], si				; Store offset
   175 00000B03 268C4F02            <1> 	mov		[es:bx+2], cs			; Store segment
   176                              <1> .Interrupts_Return:
   177 00000B07 C3                  <1> 	ret
   178                              <1> 
   179                              <1> 
   180                              <1> %ifdef MODULE_IRQ
   181                              <1> ;--------------------------------------------------------------------
   182                              <1> ; Interrupts_UnmaskInterruptControllerForDriveInDSDI
   183                              <1> ;	Parameters:
   184                              <1> ;		DS:DI:	Ptr to DPT
   185                              <1> ;	Returns:
   186                              <1> ;		Nothing
   187                              <1> ;	Corrupts registers:
   188                              <1> ;		AX, BX, DX
   189                              <1> ;--------------------------------------------------------------------
   190                              <1> Interrupts_UnmaskInterruptControllerForDriveInDSDI:
   191                              <1> 	eMOVZX	bx, [di+DPT.bIdevarsOffset]
   192                              <1> 	mov		al, [cs:bx+IDEVARS.bIRQ]
   193                              <1> 	test	al, al
   194                              <1> 	jz		SHORT .Return	; Interrupts disabled
   195                              <1> 	cmp		al, 8
   196                              <1> 	jb		SHORT .UnmaskLowIrqController
   197                              <1> 	; Fall to .UnmaskHighIrqController
   198                              <1> 
   199                              <1> ;--------------------------------------------------------------------
   200                              <1> ; .UnmaskHighIrqController
   201                              <1> ;	Parameters:
   202                              <1> ;		AL:		IRQ number (8...15)
   203                              <1> ;	Returns:
   204                              <1> ;		Nothing
   205                              <1> ;	Corrupts registers:
   206                              <1> ;		AX, DX
   207                              <1> ;--------------------------------------------------------------------
   208                              <1> .UnmaskHighIrqController:
   209                              <1> 	sub		al, 8				; Slave interrupt number
   210                              <1> 	mov		dx, SLAVE_8259_IMR
   211                              <1> 	call	.ClearBitFrom8259MaskRegister
   212                              <1> 	mov		al, 2				; Master IRQ 2 to allow slave IRQs
   213                              <1> 	; Fall to .UnmaskLowIrqController
   214                              <1> 
   215                              <1> ;--------------------------------------------------------------------
   216                              <1> ; .UnmaskLowIrqController
   217                              <1> ;	Parameters:
   218                              <1> ;		AL:		IRQ number (0...7)
   219                              <1> ;	Returns:
   220                              <1> ;		Nothing
   221                              <1> ;	Corrupts registers:
   222                              <1> ;		AX, DX
   223                              <1> ;--------------------------------------------------------------------
   224                              <1> .UnmaskLowIrqController:
   225                              <1> 	mov		dx, MASTER_8259_IMR
   226                              <1> 	; Fall to .ClearBitFrom8259MaskRegister
   227                              <1> 
   228                              <1> ;--------------------------------------------------------------------
   229                              <1> ; .ClearBitFrom8259MaskRegister
   230                              <1> ;	Parameters:
   231                              <1> ;		AL:		8259 interrupt index (0...7)
   232                              <1> ;		DX:		Port address to Interrupt Mask Register
   233                              <1> ;	Returns:
   234                              <1> ;		Nothing
   235                              <1> ;	Corrupts registers:
   236                              <1> ;		AX
   237                              <1> ;--------------------------------------------------------------------
   238                              <1> .ClearBitFrom8259MaskRegister:
   239                              <1> 	push	cx
   240                              <1> 	xchg	ax, cx				; IRQ index to CL
   241                              <1> 	mov		ch, 1				; Load 1 to be shifted
   242                              <1> 	shl		ch, cl				; Shift bit to correct position
   243                              <1> 	not		ch					; Invert to create bit mask for clearing
   244                              <1> 	in		al, dx				; Read Interrupt Mask Register
   245                              <1> 	and		al, ch				; Clear wanted bit
   246                              <1> 	out		dx, al				; Write modified Interrupt Mask Register
   247                              <1> 	pop		cx
   248                              <1> .Return:
   249                              <1> 	ret
   250                              <1> 
   251                              <1> %endif ; MODULE_IRQ
   193                                  	%include "RamVars.asm"			; For RAMVARS initialization and access
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for accessings RAMVARS.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Initializes RAMVARS.
    25                              <1> ; Drive detection can be started after this function returns.
    26                              <1> ;
    27                              <1> ; RamVars_Initialize
    28                              <1> ;	Parameters:
    29                              <1> ;		Nothing
    30                              <1> ;	Returns:
    31                              <1> ;		DS:		RAMVARS segment
    32                              <1> ;	Corrupts registers:
    33                              <1> ;		AX, CX, DI
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> RamVars_Initialize:
    36 00000B08 06                  <1> 	push	es
    37                              <1> 	; Fall to .StealMemoryForRAMVARS
    38                              <1> 
    39                              <1> ;--------------------------------------------------------------------
    40                              <1> ; .StealMemoryForRAMVARS
    41                              <1> ;	Parameters:
    42                              <1> ;		Nothing
    43                              <1> ;	Returns:
    44                              <1> ;		DS:		RAMVARS segment
    45                              <1> ;	Corrupts registers:
    46                              <1> ;		AX
    47                              <1> ;--------------------------------------------------------------------
    48                              <1> .StealMemoryForRAMVARS:
    49                              <1> %ifndef USE_AT
    50 00000B09 B83000              <1> 	mov		ax, LITE_MODE_RAMVARS_SEGMENT
    51 00000B0C 2EF606460001        <1> 	test	BYTE [cs:ROMVARS.wFlags], FLG_ROMVARS_FULLMODE
    52 00000B12 7415                <1> 	jz		SHORT .InitializeRamvars	; No need to steal RAM
    53                              <1> %endif
    54                              <1> 
    55                              <1> 	LOAD_BDA_SEGMENT_TO	ds, ax, !		; Zero AX
    55                              <2> %ifndef USE_186
    55 00000B14 31C0                <2>  xor %2, %2
    55 00000B16 8ED8                <2>  mov %1, %2
    55                              <2> %elifidn %3, !
    55                              <2>  xor %2, %2
    55                              <2>  mov %1, %2
    55                              <2> %else
    55                              <2>  push BYTE 0
    55                              <2>  pop %1
    55                              <2> %endif
    56 00000B18 2EA04F00            <1> 	mov		al, [cs:ROMVARS.bStealSize]
    57 00000B1C 29061304            <1> 	sub		[BDA.wBaseMem], ax
    58 00000B20 A11304              <1> 	mov		ax, [BDA.wBaseMem]
    59                              <1> 	eSHL_IM	ax, 6						; Segment to first stolen kB (*=40h)
    59                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    59                              <2> %ifdef USE_386
    59                              <2>  %if %2 = 1
    59                              <2>  add %1, %1
    59                              <2>  %else
    59                              <2>  eSHIFT_IM %1, %2, shl
    59                              <2>  %endif
    59                              <2> %else
    59                              <2>  eSHIFT_IM %1, %2, shl
    59                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    59                              <3> %ifndef USE_186
    59                              <3>  %ifidni %1, cl
    59                              <3>  times %2 %3 %1, 1
    59                              <3>  %elifidni %1, ch
    59                              <3>  times %2 %3 %1, 1
    59                              <3>  %elifidni %1, cx
    59                              <3>  times %2 %3 %1, 1
    59                              <3>  %else
    59                              <3>  %if %2 > 3
    59 00000B23 51                  <3>  push cx
    59 00000B24 B106                <3>  mov cl, %2
    59 00000B26 D3E0                <3>  %3 %1, cl
    59 00000B28 59                  <3>  pop cx
    59                              <3>  %else
    59                              <3>  times %2 %3 %1, 1
    59                              <3>  %endif
    59                              <3>  %endif
    59                              <3> 
    59                              <3> %else
    59                              <3>  %3 %1, %2
    59                              <3> %endif
    59                              <3> %endif
    59                              <2> %endif
    59                              <2> %endif
    60                              <1> 	; Fall to .InitializeRamvars
    61                              <1> 
    62                              <1> ;--------------------------------------------------------------------
    63                              <1> ; .InitializeRamvars
    64                              <1> ;	Parameters:
    65                              <1> ;		AX:		RAMVARS segment
    66                              <1> ;	Returns:
    67                              <1> ;		DS:		RAMVARS segment
    68                              <1> ;	Corrupts registers:
    69                              <1> ;		AX, CX, DI, ES
    70                              <1> ;--------------------------------------------------------------------
    71                              <1> .InitializeRamvars:
    72 00000B29 8ED8                <1> 	mov		ds, ax
    73 00000B2B 8EC0                <1> 	mov		es, ax
    74 00000B2D B90E00              <1> 	mov		cx, RAMVARS_size
    75 00000B30 31FF                <1> 	xor		di, di
    76 00000B32 E8DBFE              <1> 	call	Memory_ZeroESDIwithSizeInCX
    77 00000B35 C70600005A5A        <1> 	mov		WORD [RAMVARS.wDrvDetectSignature], RAMVARS_DRV_DETECT_SIGNATURE
    78 00000B3B C70604005875        <1> 	mov		WORD [RAMVARS.wSignature], RAMVARS_RAM_SIGNATURE
    79                              <1> ;; There used to be a DriveXlate_Reset call here.  It isn't necessary, as we reset
    80                              <1> ;; when entering the boot menu and also before transferring control at boot time and
    81                              <1> ;; for ROM boots (in int19h.asm).
    82                              <1> 
    83 00000B41 07                  <1> 	pop		es
    84 00000B42 C3                  <1> 	ret
    85                              <1> 
    86                              <1> ;--------------------------------------------------------------------
    87                              <1> ; Returns segment to RAMVARS.
    88                              <1> ; RAMVARS might be located at the top of interrupt vectors (0030:0000h)
    89                              <1> ; or at the top of system base RAM.
    90                              <1> ;
    91                              <1> ; RamVars_GetSegmentToDS
    92                              <1> ;	Parameters:
    93                              <1> ;		Nothing
    94                              <1> ;	Returns:
    95                              <1> ;		DS:		RAMVARS segment
    96                              <1> ;	Corrupts registers:
    97                              <1> ;		DI
    98                              <1> ;--------------------------------------------------------------------
    99                              <1> ALIGN JUMP_ALIGN
   100                              <1> RamVars_GetSegmentToDS:
   101                              <1> 
   102                              <1> %ifndef USE_AT	; Always in Full Mode for AT builds
   103 00000B43 2EF606460001        <1> 	test	BYTE [cs:ROMVARS.wFlags], FLG_ROMVARS_FULLMODE
   104 00000B49 7506                <1> 	jnz		SHORT .GetStolenSegmentToDS
   105                              <1> 	%ifndef USE_186
   106 00000B4B BF3000              <1> 		mov		di, LITE_MODE_RAMVARS_SEGMENT
   107 00000B4E 8EDF                <1> 		mov		ds, di
   108                              <1> 	%else
   109                              <1> 		push	LITE_MODE_RAMVARS_SEGMENT
   110                              <1> 		pop		ds
   111                              <1> 	%endif
   112 00000B50 C3                  <1> 	ret
   113                              <1> %endif
   114                              <1> 
   115                              <1> ALIGN JUMP_ALIGN
   116                              <1> .GetStolenSegmentToDS:
   117                              <1> 	LOAD_BDA_SEGMENT_TO	ds, di
   117                              <2> %ifndef USE_186
   117 00000B51 31FF                <2>  xor %2, %2
   117 00000B53 8EDF                <2>  mov %1, %2
   117                              <2> %elifidn %3, !
   117                              <2>  xor %2, %2
   117                              <2>  mov %1, %2
   117                              <2> %else
   117                              <2>  push BYTE 0
   117                              <2>  pop %1
   117                              <2> %endif
   118 00000B55 8B3E1304            <1> 	mov		di, [BDA.wBaseMem]		; Load available base memory size in kB
   119                              <1> 	eSHL_IM	di, 6					; Segment to first stolen kB (*=40h)
   119                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   119                              <2> %ifdef USE_386
   119                              <2>  %if %2 = 1
   119                              <2>  add %1, %1
   119                              <2>  %else
   119                              <2>  eSHIFT_IM %1, %2, shl
   119                              <2>  %endif
   119                              <2> %else
   119                              <2>  eSHIFT_IM %1, %2, shl
   119                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   119                              <3> %ifndef USE_186
   119                              <3>  %ifidni %1, cl
   119                              <3>  times %2 %3 %1, 1
   119                              <3>  %elifidni %1, ch
   119                              <3>  times %2 %3 %1, 1
   119                              <3>  %elifidni %1, cx
   119                              <3>  times %2 %3 %1, 1
   119                              <3>  %else
   119                              <3>  %if %2 > 3
   119 00000B59 51                  <3>  push cx
   119 00000B5A B106                <3>  mov cl, %2
   119 00000B5C D3E7                <3>  %3 %1, cl
   119 00000B5E 59                  <3>  pop cx
   119                              <3>  %else
   119                              <3>  times %2 %3 %1, 1
   119                              <3>  %endif
   119                              <3>  %endif
   119                              <3> 
   119                              <3> %else
   119                              <3>  %3 %1, %2
   119                              <3> %endif
   119                              <3> %endif
   119                              <2> %endif
   119                              <2> %endif
   120                              <1> ALIGN JUMP_ALIGN
   121                              <1> .LoopStolenKBs:
   122 00000B5F 8EDF                <1> 	mov		ds, di					; EBDA segment to DS
   123 00000B61 83C740              <1> 	add		di, BYTE 64				; DI to next stolen kB
   124 00000B64 813E04005875        <1> 	cmp		WORD [RAMVARS.wSignature], RAMVARS_RAM_SIGNATURE
   125 00000B6A 75F3                <1> 	jne		SHORT .LoopStolenKBs	; Loop until sign found (always found eventually)
   126 00000B6C C3                  <1> 	ret
   127                              <1> 
   128                              <1> 
   129                              <1> ;--------------------------------------------------------------------
   130                              <1> ; RamVars_GetHardDiskCountFromBDAtoAX
   131                              <1> ;	Parameters:
   132                              <1> ;		DS:		RAMVARS segment
   133                              <1> ;	Returns:
   134                              <1> ;		AX:		Total hard disk count
   135                              <1> ;	Corrupts registers:
   136                              <1> ;		BX
   137                              <1> ;--------------------------------------------------------------------
   138                              <1> %ifdef MODULE_BOOT_MENU
   139                              <1> RamVars_GetHardDiskCountFromBDAtoAX:
   140 00000B6D E81100              <1> 	call	RamVars_GetCountOfKnownDrivesToAX
   141 00000B70 1E                  <1> 	push	ds
   142                              <1> 	LOAD_BDA_SEGMENT_TO	ds, bx
   142                              <2> %ifndef USE_186
   142 00000B71 31DB                <2>  xor %2, %2
   142 00000B73 8EDB                <2>  mov %1, %2
   142                              <2> %elifidn %3, !
   142                              <2>  xor %2, %2
   142                              <2>  mov %1, %2
   142                              <2> %else
   142                              <2>  push BYTE 0
   142                              <2>  pop %1
   142                              <2> %endif
   143 00000B75 8A1E7504            <1> 	mov		bl, [BDA.bHDCount]
   144                              <1> 	MAX_U	al, bl
   144 00000B79 38D8                <2>  cmp %1, %2
   144 00000B7B 7702                <2>  ja %%Return
   144 00000B7D 88D8                <2>  mov %1, %2
   144                              <2> ALIGN JUMP_ALIGN
   144                              <2> %%Return:
   145 00000B7F 1F                  <1> 	pop		ds
   146 00000B80 C3                  <1> 	ret
   147                              <1> %endif
   148                              <1> 
   149                              <1> 
   150                              <1> ;--------------------------------------------------------------------
   151                              <1> ; RamVars_GetCountOfKnownDrivesToAX
   152                              <1> ;	Parameters:
   153                              <1> ;		DS:		RAMVARS segment
   154                              <1> ;	Returns:
   155                              <1> ;		AX:		Total hard disk count
   156                              <1> ;	Corrupts registers:
   157                              <1> ;		None
   158                              <1> ;--------------------------------------------------------------------
   159                              <1> ALIGN JUMP_ALIGN
   160                              <1> RamVars_GetCountOfKnownDrivesToAX:
   161 00000B81 A10800              <1> 	mov		ax, [RAMVARS.wFirstDrvAndCount]
   162 00000B84 00E0                <1> 	add		al, ah
   163 00000B86 83E07F              <1> 	and		ax, BYTE 7fh
   164 00000B89 C3                  <1> 	ret
   165                              <1> 
   166                              <1> ;--------------------------------------------------------------------
   167                              <1> ; RamVars_GetIdeControllerCountToCX
   168                              <1> ;	Parameters:
   169                              <1> ;		Nothing
   170                              <1> ;	Returns:
   171                              <1> ;		CX:		Number of IDE controllers to handle
   172                              <1> ;	Corrupts registers:
   173                              <1> ;		Nothing
   174                              <1> ;--------------------------------------------------------------------
   175                              <1> ALIGN JUMP_ALIGN
   176                              <1> RamVars_GetIdeControllerCountToCX:
   177                              <1> 	eMOVZX	cx, [cs:ROMVARS.bIdeCnt]
   177                              <2> %ifndef USE_386
   177                              <2>  %ifidni %1, ax
   177                              <2>  mov al, %2
   177                              <2>  xor ah, ah
   177                              <2>  %elifidni %1, bx
   177                              <2>  mov bl, %2
   177                              <2>  xor bh, bh
   177                              <2>  %elifidni %1, cx
   177 00000B8A 2E8A0E4C00          <2>  mov cl, %2
   177 00000B8F 30ED                <2>  xor ch, ch
   177                              <2>  %elifidni %1, dx
   177                              <2>  mov dl, %2
   177                              <2>  xor dh, dh
   177                              <2>  %else
   177                              <2>  push ax
   177                              <2>  mov al, %2
   177                              <2>  xor ah, ah
   177                              <2>  xchg ax, %1
   177                              <2>  pop ax
   177                              <2>  %endif
   177                              <2> 
   177                              <2> %else
   177                              <2>  movzx %1, %2
   177                              <2> %endif
   178 00000B91 C3                  <1> 	ret
   179                              <1> 
   180                              <1> 
   181                              <1> %ifdef MODULE_SERIAL_FLOPPY
   182                              <1> ;--------------------------------------------------------------------
   183                              <1> ; RamVars_UnpackFlopCntAndFirstToAL
   184                              <1> ;	Parameters:
   185                              <1> ;		DS:		RAMVARS segment
   186                              <1> ;	Returns:
   187                              <1> ;		AL:		First floppy drive number supported
   188                              <1> ;       CF:		Number of floppy drives supported (clear = 1, set = 2)
   189                              <1> ;		SF:		Emulating drives (clear = yes, set = no)
   190                              <1> ;	Corrupts registers:
   191                              <1> ;		Nothing
   192                              <1> ;--------------------------------------------------------------------
   193                              <1> ALIGN JUMP_ALIGN
   194                              <1> RamVars_UnpackFlopCntAndFirstToAL:
   195                              <1> 	mov		al, [RAMVARS.xlateVars+XLATEVARS.bFlopCntAndFirst]
   196                              <1> 	sar		al, 1
   197                              <1> 	ret
   198                              <1> %endif
   199                              <1> 
   200                              <1> 
   201                              <1> %if 0							; unused...
   202                              <1> ;--------------------------------------------------------------------
   203                              <1> ; RamVars_IsDriveDetectionInProgress
   204                              <1> ;	Parameters:
   205                              <1> ;		DS:		RAMVARS segment
   206                              <1> ;	Returns:
   207                              <1> ;		ZF:		Set if drive detection is in progress (ROM initialization)
   208                              <1> ;	Corrupts registers:
   209                              <1> ;		None
   210                              <1> ;--------------------------------------------------------------------
   211                              <1> RamVars_IsDriveDetectionInProgress:
   212                              <1> 	cmp		WORD [RAMVARS.wSignature], RAMVARS_DRV_DETECT_SIGNATURE
   213                              <1> 	ret
   214                              <1> %endif
   194                                  	%include "BootVars.asm"			; For initializing variables used during init and boot
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for accessings BOOTVARS.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; BootVars_Initialize
    25                              <1> ;	Parameters:
    26                              <1> ;		DS:		RAMVARS Segment
    27                              <1> ;		ES:		BDA Segment
    28                              <1> ;	Returns:
    29                              <1> ;		Nothing
    30                              <1> ;	Corrupts registers:
    31                              <1> ;		AX, CX, DX, DI
    32                              <1> ;--------------------------------------------------------------------
    33                              <1> BootVars_Initialize:
    34                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
    35 00000B92 26C706047F4001      <1> 	mov		WORD [es:BOOTVARS.wNextXTCFportToScan], XTCF_BASE_PORT_DETECTION_SEED
    36                              <1> %endif
    37                              <1> 
    38                              <1> 	; Clear all DRVDETECTINFO structs to zero
    39 00000B99 B02A                <1> 	mov		al, DRVDETECTINFO_size
    40 00000B9B 2EF6264C00          <1> 	mul		BYTE [cs:ROMVARS.bIdeCnt]
    41 00000BA0 BF0C7F              <1> 	mov		di, BOOTVARS.rgDrvDetectInfo	; We must not initialize anything before this!
    42 00000BA3 91                  <1> 	xchg	cx, ax
    43                              <1> %ifndef MODULE_HOTKEYS
    44                              <1> 	jmp		Memory_ZeroESDIwithSizeInCX
    45                              <1> 
    46                              <1> %else ; if MODULE_HOTKEYS
    47 00000BA4 E869FE              <1> 	call	Memory_ZeroESDIwithSizeInCX
    48                              <1> 
    49                              <1> 	; Initialize HOTKEYVARS by storing default drives to boot from
    50 00000BA7 E80800              <1> 	call	BootVars_StoreDefaultDriveLettersToHotkeyVars
    51 00000BAA 2E8A164D00          <1> 	mov		dl, [cs:ROMVARS.bBootDrv]
    52 00000BAF E9F503              <1> 	jmp		HotkeyBar_StoreHotkeyToBootvarsForDriveNumberInDL
    53                              <1> 
    54                              <1> 
    55                              <1> ;--------------------------------------------------------------------
    56                              <1> ; BootVars_StoreDefaultDriveLettersToHotkeyVars
    57                              <1> ;	Parameters:
    58                              <1> ;		ES:		BDA Segment
    59                              <1> ;	Returns:
    60                              <1> ;		Nothing
    61                              <1> ;	Corrupts registers:
    62                              <1> ;		Nothing
    63                              <1> ;--------------------------------------------------------------------
    64                              <1> BootVars_StoreDefaultDriveLettersToHotkeyVars:
    65 00000BB2 26C706087F4143      <1> 	mov		WORD [es:BOOTVARS.hotkeyVars+HOTKEYVARS.wFddAndHddLetters], DEFAULT_FLOPPY_DRIVE_LETTER | (DEFAULT_HARD_DRIVE_LETTER<<8)
    66 00000BB9 C3                  <1> 	ret
    67                              <1> 
    68                              <1> %endif ; MODULE_HOTKEYS
   195                                  	%include "FloppyDrive.asm"		; Floppy Drive related functions
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Various floppy drive related functions that
     3                              <1> ;					Boot Menu uses.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ;
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> ; Section containing code
    22                              <1> SECTION .text
    23                              <1> 
    24                              <1> %ifdef COPY_13H_HANDLER_TO_40H
    25                              <1> ;--------------------------------------------------------------------
    26                              <1> ; Checks is floppy drive handler installed to interrupt vector 40h.
    27                              <1> ;
    28                              <1> ; FloppyDrive_IsInt40hInstalled
    29                              <1> ;	Parameters:
    30                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
    31                              <1> ;	Returns:
    32                              <1> ;		CF:		Set if INT 40h is installed
    33                              <1> ;				Cleared if INT 40h is not installed
    34                              <1> ;	Corrupts registers:
    35                              <1> ;		BX, CX, DI
    36                              <1> ;--------------------------------------------------------------------
    37                              <1> FloppyDrive_IsInt40hInstalled:
    38 00000BBA 26813E020100C0      <1> 	cmp		WORD [es:BIOS_DISKETTE_INTERRUPT_40h*4+2], 0C000h	; Any ROM segment?
    39                              <1> %ifdef USE_AT	; No need to verify on XT systems.
    40                              <1> 	jb		SHORT .Int40hHandlerIsNotInstalled
    41                              <1> 	call	.VerifyInt40hHandlerSinceSomeBiosesSimplyReturnFromInt40h
    42                              <1> .Int40hHandlerIsNotInstalled:
    43                              <1> %endif
    44 00000BC1 F5                  <1> 	cmc
    45 00000BC2 C3                  <1> 	ret
    46                              <1> 
    47                              <1> ;--------------------------------------------------------------------
    48                              <1> ; .VerifyInt40hHandlerSinceSomeBiosesSimplyReturnFromInt40h
    49                              <1> ;	Parameters:
    50                              <1> ;		Nothing
    51                              <1> ;	Returns:
    52                              <1> ;		CF:		Cleared if INT 40h is installed
    53                              <1> ;				Set if INT 40h is not installed
    54                              <1> ;	Corrupts registers:
    55                              <1> ;		BX, CX, DI
    56                              <1> ;--------------------------------------------------------------------
    57                              <1> %ifdef USE_AT
    58                              <1> .VerifyInt40hHandlerSinceSomeBiosesSimplyReturnFromInt40h:
    59                              <1> 	push	es
    60                              <1> 	push	dx
    61                              <1> 	push	ax
    62                              <1> 
    63                              <1> 	call	.LoadInt40hVerifyParameters
    64                              <1> 	int		BIOS_DISK_INTERRUPT_13h
    65                              <1> 	jc		SHORT .Int40hIsInstalled	; Maybe there are not any floppy drives at all
    66                              <1> 	push	es
    67                              <1> 	push	di
    68                              <1> 
    69                              <1> 	call	.LoadInt40hVerifyParameters
    70                              <1> 	int		BIOS_DISKETTE_INTERRUPT_40h
    71                              <1> 
    72                              <1> 	pop		dx
    73                              <1> 	pop		cx
    74                              <1> 	cmp		dx, di						; Difference in offsets?
    75                              <1> 	jne		SHORT .Int40hNotInstalled
    76                              <1> 	mov		dx, es
    77                              <1> 	cmp		cx, dx						; Difference in segments?
    78                              <1> 	je		SHORT .Int40hIsInstalled
    79                              <1> .Int40hNotInstalled:
    80                              <1> 	stc
    81                              <1> .Int40hIsInstalled:
    82                              <1> 	pop		ax
    83                              <1> 	pop		dx
    84                              <1> 	pop		es
    85                              <1> 	ret
    86                              <1> 
    87                              <1> ;--------------------------------------------------------------------
    88                              <1> ; .LoadInt40hVerifyParameters
    89                              <1> ;	Parameters:
    90                              <1> ;		Nothing
    91                              <1> ;	Returns:
    92                              <1> ;		AH:		08h (Get Drive Parameters)
    93                              <1> ;		DL:		00h (floppy drive)
    94                              <1> ;		ES:DI:	0:0h (to guard against BIOS bugs)
    95                              <1> ;	Corrupts registers:
    96                              <1> ;		DH
    97                              <1> ;--------------------------------------------------------------------
    98                              <1> .LoadInt40hVerifyParameters:
    99                              <1> 	mov		ah, 08h				; Get Drive Parameters
   100                              <1> 	cwd							; Floppy drive 0
   101                              <1> 	mov		di, dx
   102                              <1> 	mov		es, dx				; ES:DI = 0000:0000h to guard against BIOS bugs
   103                              <1> 	ret
   104                              <1> %endif
   105                              <1> 
   106                              <1> %endif ; COPY_13H_HANDLER_TO_40H
   107                              <1> 
   108                              <1> 
   109                              <1> ;--------------------------------------------------------------------
   110                              <1> ; Returns floppy drive type.
   111                              <1> ; PC/XT system do not support AH=08h but FLOPPY_TYPE_525_OR_35_DD
   112                              <1> ; is still returned for them.
   113                              <1> ;
   114                              <1> ; FloppyDrive_GetType
   115                              <1> ;	Parameters:
   116                              <1> ;		DL:		Floppy Drive number
   117                              <1> ;	Returns:
   118                              <1> ;		BX:		Floppy Drive Type:
   119                              <1> ;					FLOPPY_TYPE_525_OR_35_DD
   120                              <1> ;					FLOPPY_TYPE_525_DD
   121                              <1> ;					FLOPPY_TYPE_525_HD
   122                              <1> ;					FLOPPY_TYPE_35_DD
   123                              <1> ;					FLOPPY_TYPE_35_HD
   124                              <1> ;					FLOPPY_TYPE_35_ED
   125                              <1> ;		CF:		Set if AH=08h not supported (XT systems) or error
   126                              <1> ;				Cleared if type read correctly (AT systems)
   127                              <1> ;	Corrupts registers:
   128                              <1> ;		AX, CX, DX, DI, ES
   129                              <1> ;--------------------------------------------------------------------
   130                              <1> %ifdef MODULE_BOOT_MENU
   131                              <1> FloppyDrive_GetType:
   132 00000BC3 B408                <1> 	mov		ah, 08h			; Get Drive Parameters
   133 00000BC5 31DB                <1> 	xor		bx, bx			; FLOPPY_TYPE_525_OR_35_DD when function not supported
   134 00000BC7 CD40                <1> 	int		BIOS_DISKETTE_INTERRUPT_40h
   135 00000BC9 C3                  <1> 	ret
   136                              <1> %endif
   137                              <1> 
   138                              <1> 
   139                              <1> ;--------------------------------------------------------------------
   140                              <1> ; Returns number of Floppy Drives in system.
   141                              <1> ;
   142                              <1> ; FloppyDrive_GetCountToAX
   143                              <1> ;	Parameters:
   144                              <1> ;		DS:		RAMVARS Segment
   145                              <1> ;	Returns:
   146                              <1> ;		AX:		Number of Floppy Drives
   147                              <1> ;--------------------------------------------------------------------
   148                              <1> FloppyDrive_GetCountToAX:
   149                              <1> %ifdef MODULE_SERIAL_FLOPPY
   150                              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
   151                              <1> 	js		.UseBIOSorBDA				; We didn't add in any drives, counts here are not valid
   152                              <1> 
   153                              <1> 	adc		al,1						; adds in the drive count bit, and adds 1 for count vs. 0-index,
   154                              <1> 	jmp		.FinishCalc					; need to clear AH on the way out, and add in minimum drive numbers
   155                              <1> 
   156                              <1> .UseBIOSorBDA:
   157                              <1> %endif
   158 00000BCA E80D00              <1> 	call	FloppyDrive_GetCountFromBIOS_or_BDA
   159                              <1> 
   160                              <1> .FinishCalc:
   161 00000BCD 2E8A264E00          <1> 	mov		ah, [cs:ROMVARS.bMinFddCnt]
   162                              <1> 	MAX_U	al, ah
   162 00000BD2 38E0                <2>  cmp %1, %2
   162 00000BD4 7702                <2>  ja %%Return
   162 00000BD6 88E0                <2>  mov %1, %2
   162                              <2> ALIGN JUMP_ALIGN
   162                              <2> %%Return:
   163 00000BD8 98                  <1> 	cbw
   164                              <1> 
   165 00000BD9 C3                  <1> 	ret
   166                              <1> 
   167                              <1> FloppyDrive_GetCountFromBIOS_or_BDA:
   168 00000BDA 06                  <1> 	push	es
   169                              <1> 
   170                              <1> ;--------------------------------------------------------------------
   171                              <1> ; Reads Floppy Drive Count from BIOS.
   172                              <1> ; Does not work on most XT systems. Call .GetCountFromBDA
   173                              <1> ; if this function fails.
   174                              <1> ;
   175                              <1> ; .GetCountFromBIOS
   176                              <1> ;	Parameters:
   177                              <1> ;		Nothing
   178                              <1> ;	Returns:
   179                              <1> ;		AL:		Number of Floppy Drives
   180                              <1> ;		CF:		Cleared if successful
   181                              <1> ;				Set if BIOS function not supported
   182                              <1> ;	Corrupts registers:
   183                              <1> ;		ES
   184                              <1> ;--------------------------------------------------------------------
   185                              <1> %ifdef USE_AT
   186                              <1> .GetCountFromBIOS:
   187                              <1> 	push	di
   188                              <1> 	push	bx
   189                              <1> 	push	cx
   190                              <1> 	push	dx
   191                              <1> 
   192                              <1> 	mov		ah, 08h					; Get Drive Parameters
   193                              <1> 	cwd								; Floppy Drive 00h
   194                              <1> 	int		BIOS_DISKETTE_INTERRUPT_40h
   195                              <1> 	mov		al, dl					; Number of Floppy Drives to AL
   196                              <1> 
   197                              <1> 	pop		dx
   198                              <1> 	pop		cx
   199                              <1> 	pop		bx
   200                              <1> 	pop		di
   201                              <1> %endif
   202                              <1> 
   203                              <1> ;--------------------------------------------------------------------
   204                              <1> ; Reads Floppy Drive Count (0...4) from BIOS Data Area.
   205                              <1> ; This function should be used only if .GetCountFromBIOS fails.
   206                              <1> ;
   207                              <1> ; .GetCountFromBDA
   208                              <1> ;	Parameters:
   209                              <1> ;		Nothing
   210                              <1> ;	Returns:
   211                              <1> ;		AL:		Number of Floppy Drives
   212                              <1> ;	Corrupts registers:
   213                              <1> ;		AH, ES
   214                              <1> ;--------------------------------------------------------------------
   215                              <1> %ifndef USE_AT
   216                              <1> .GetCountFromBDA:
   217                              <1> 	LOAD_BDA_SEGMENT_TO	es, ax
   217                              <2> %ifndef USE_186
   217 00000BDB 31C0                <2>  xor %2, %2
   217 00000BDD 8EC0                <2>  mov %1, %2
   217                              <2> %elifidn %3, !
   217                              <2>  xor %2, %2
   217                              <2>  mov %1, %2
   217                              <2> %else
   217                              <2>  push BYTE 0
   217                              <2>  pop %1
   217                              <2> %endif
   218 00000BDF 26A01004            <1> 	mov		al, [es:BDA.wEquipment]			; Load Equipment WORD low byte
   219 00000BE3 88C4                <1> 	mov		ah, al							; Copy it to AH
   220 00000BE5 2501C0              <1> 	and		ax, 0C001h						; Leave bits 15..14 and 0
   221                              <1> 	eROL_IM	ah, 2							; EW low byte bits 7..6 to 1..0
   221                              <2>  eSHIFT_IM %1, %2, rol
   221                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   221                              <3> %ifndef USE_186
   221                              <3>  %ifidni %1, cl
   221                              <3>  times %2 %3 %1, 1
   221                              <3>  %elifidni %1, ch
   221                              <3>  times %2 %3 %1, 1
   221                              <3>  %elifidni %1, cx
   221                              <3>  times %2 %3 %1, 1
   221                              <3>  %else
   221                              <3>  %if %2 > 3
   221                              <3>  push cx
   221                              <3>  mov cl, %2
   221                              <3>  %3 %1, cl
   221                              <3>  pop cx
   221                              <3>  %else
   221 00000BE8 D0C4<rept>          <3>  times %2 %3 %1, 1
   221                              <3>  %endif
   221                              <3>  %endif
   221                              <3> 
   221                              <3> %else
   221                              <3>  %3 %1, %2
   221                              <3> %endif
   221                              <3> %endif
   222 00000BEC 00E0                <1> 	add		al, ah							; AL = Floppy Drive count
   223                              <1> %endif
   224                              <1> 
   225 00000BEE 07                  <1> 	pop		es
   226 00000BEF C3                  <1> 	ret
   196                                  	%include "CreateDPT.asm"		; For creating DPTs
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for creating Disk Parameter Table.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Creates new Disk Parameter Table for detected hard disk.
    25                              <1> ; Drive is then fully accessible using any BIOS function.
    26                              <1> ;
    27                              <1> ; CreateDPT_FromAtaInformation
    28                              <1> ;	Parameters:
    29                              <1> ;		BH:		Drive Select byte for Drive and Head Register
    30                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
    31                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    32                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
    33                              <1> ;		DS:		RAMVARS segment
    34                              <1> ;		ES:		BDA Segment
    35                              <1> ;	Returns:
    36                              <1> ;		DS:DI:	Ptr to Disk Parameter Table (if successful)
    37                              <1> ;		CF:		Cleared if DPT created successfully
    38                              <1> ;				Set if any error
    39                              <1> ;	Corrupts registers:
    40                              <1> ;		AX, BX, CX, DH
    41                              <1> ;--------------------------------------------------------------------
    42                              <1> CreateDPT_FromAtaInformation:
    43 00000BF0 E8B000              <1> 	call	FindDPT_ForNewDriveToDSDI
    44                              <1> 	; Fall to .InitializeDPT
    45                              <1> 
    46                              <1> ;--------------------------------------------------------------------
    47                              <1> ; .InitializeDPT
    48                              <1> ;	Parameters:
    49                              <1> ;		BH:		Drive Select byte for Drive and Head Register
    50                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
    51                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    52                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
    53                              <1> ;	Returns:
    54                              <1> ;		Nothing
    55                              <1> ;	Corrupts registers:
    56                              <1> ;		AX
    57                              <1> ;--------------------------------------------------------------------
    58                              <1> .InitializeDPT:
    59 00000BF3 E84100              <1> 	call	CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI
    60                              <1> 	; Fall to .StoreDriveSelectAndDriveControlByte
    61                              <1> 
    62                              <1> ;--------------------------------------------------------------------
    63                              <1> ; .StoreDriveSelectAndDriveControlByte
    64                              <1> ;	Parameters:
    65                              <1> ;		BH:		Drive Select byte for Drive and Head Register
    66                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    67                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    68                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
    69                              <1> ;	Returns:
    70                              <1> ;		Nothing
    71                              <1> ;	Corrupts registers:
    72                              <1> ;		AX
    73                              <1> ;--------------------------------------------------------------------
    74                              <1> .StoreDriveSelectAndDriveControlByte:
    75 00000BF6 88F8                <1> 	mov		al, bh
    76 00000BF8 83E010              <1> 	and		ax, BYTE FLG_DRVNHEAD_DRV		; AL now has Master/Slave bit
    77                              <1> %ifdef MODULE_IRQ
    78                              <1> 	cmp		[cs:bp+IDEVARS.bIRQ], ah		; Interrupts enabled?
    79                              <1> 	jz		SHORT .StoreFlags				;  If not, do not set interrupt flag
    80                              <1> 	or		al, FLGL_DPT_ENABLE_IRQ
    81                              <1> .StoreFlags:
    82                              <1> %endif
    83 00000BFB 8905                <1> 	mov		[di+DPT.wFlags], ax
    84                              <1> 	; Fall to .StoreCHSparametersAndAddressingMode
    85                              <1> 
    86                              <1> ;--------------------------------------------------------------------
    87                              <1> ; .StoreCHSparametersAndAddressingMode
    88                              <1> ;	Parameters:
    89                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    90                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    91                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
    92                              <1> ;	Returns:
    93                              <1> ;		Nothing
    94                              <1> ;	Corrupts registers:
    95                              <1> ;		AX, BX, CX, DX
    96                              <1> ;--------------------------------------------------------------------
    97                              <1> .StoreCHSparametersAndAddressingMode:
    98                              <1> 	; Check if CHS defined in ROMVARS
    99 00000BFD E84B00              <1> 	call	GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS
   100 00000C00 F6C120              <1> 	test	cl, FLG_DRVPARAMS_USERCHS
   101 00000C03 7405                <1> 	jz		SHORT .AutodetectPCHSvalues
   102                              <1> 
   103                              <1> 	; Translate P-CHS to L-CHS
   104 00000C05 E80701              <1> 	call	AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX
   105 00000C08 EB03                <1> 	jmp		SHORT .StoreLCHStoDPT
   106                              <1> .AutodetectPCHSvalues:
   107 00000C0A E8FF00              <1> 	call	AtaGeometry_GetLCHStoAXBLBHfromAtaInfoInESSIandTranslateModeInDX
   108                              <1> 
   109                              <1> .StoreLCHStoDPT:
   110                              <1> 	eSHL_IM	dl, TRANSLATEMODE_FIELD_POSITION
   110                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   110                              <2> %ifdef USE_386
   110                              <2>  %if %2 = 1
   110                              <2>  add %1, %1
   110                              <2>  %else
   110                              <2>  eSHIFT_IM %1, %2, shl
   110                              <2>  %endif
   110                              <2> %else
   110                              <2>  eSHIFT_IM %1, %2, shl
   110                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   110                              <3> %ifndef USE_186
   110                              <3>  %ifidni %1, cl
   110                              <3>  times %2 %3 %1, 1
   110                              <3>  %elifidni %1, ch
   110                              <3>  times %2 %3 %1, 1
   110                              <3>  %elifidni %1, cx
   110                              <3>  times %2 %3 %1, 1
   110                              <3>  %else
   110                              <3>  %if %2 > 3
   110                              <3>  push cx
   110                              <3>  mov cl, %2
   110                              <3>  %3 %1, cl
   110                              <3>  pop cx
   110                              <3>  %else
   110 00000C0D D0E2<rept>          <3>  times %2 %3 %1, 1
   110                              <3>  %endif
   110                              <3>  %endif
   110                              <3> 
   110                              <3> %else
   110                              <3>  %3 %1, %2
   110                              <3> %endif
   110                              <3> %endif
   110                              <2> %endif
   110                              <2> %endif
   111 00000C11 08D1                <1> 	or		cl, dl
   112 00000C13 080D                <1> 	or		[di+DPT.bFlagsLow], cl		; Shift count and addressing mode
   113 00000C15 894506              <1> 	mov		[di+DPT.wLchsCylinders], ax
   114 00000C18 895D08              <1> 	mov		[di+DPT.wLchsHeadsAndSectors], bx
   115                              <1> 
   116                              <1> 	; Store P-CHS to DPT
   117 00000C1B E81901              <1> 	call	AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI
   118 00000C1E 885D0A              <1> 	mov		[di+DPT.bPchsHeads], bl
   119                              <1> %ifdef MODULE_EBIOS
   120                              <1> 	mov		[di+DPT.wPchsCylinders], ax
   121                              <1> 	mov		[di+DPT.bPchsSectorsPerTrack], bh
   122                              <1> 	; Fall to .StoreNumberOfLbaSectors
   123                              <1> 
   124                              <1> ;--------------------------------------------------------------------
   125                              <1> ; .StoreNumberOfLbaSectors
   126                              <1> ;	Parameters:
   127                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   128                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
   129                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
   130                              <1> ;	Returns:
   131                              <1> ;		Nothing
   132                              <1> ;	Corrupts registers:
   133                              <1> ;		AX, BX, CX, DX
   134                              <1> ;--------------------------------------------------------------------
   135                              <1> 	; Check if LBA supported
   136                              <1> 	test	BYTE [es:si+ATA1.wCaps+1], A1_wCaps_LBA>>8
   137                              <1> 	jz		SHORT .NoLbaSupportedSoNoEBIOS
   138                              <1> 
   139                              <1> 	; Store LBA 28/48 total sector count
   140                              <1> 	call	AtaGeometry_GetLbaSectorCountToBXDXAXfromAtaInfoInESSI
   141                              <1> 	call	StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX
   142                              <1> 
   143                              <1> 	; Load user defined LBA
   144                              <1> 	call	GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS
   145                              <1> 	test	cl, FLG_DRVPARAMS_USERLBA
   146                              <1> 	jz		SHORT .KeepTotalSectorsFromAtaID
   147                              <1> 
   148                              <1> 	; Compare user defined and ATA-ID sector count and select smaller
   149                              <1> 	mov		dx, bx
   150                              <1> 	xor		bx, bx		; User defined LBA now in BX:DX:AX
   151                              <1> 	cmp		bx, [di+DPT.twLbaSectors+4]
   152                              <1> 	jb		SHORT .StoreUserDefinedSectorCountToDPT
   153                              <1> 	cmp		dx, [di+DPT.twLbaSectors+2]
   154                              <1> 	jb		SHORT .StoreUserDefinedSectorCountToDPT
   155                              <1> 	ja		SHORT .KeepTotalSectorsFromAtaID
   156                              <1> 	cmp		ax, [di+DPT.twLbaSectors]
   157                              <1> 	jae		SHORT .KeepTotalSectorsFromAtaID
   158                              <1> .StoreUserDefinedSectorCountToDPT:
   159                              <1> 	; CL bit FLGL_DPT_LBA48 is clear at this point
   160                              <1> 	call	StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX
   161                              <1> 
   162                              <1> .KeepTotalSectorsFromAtaID:
   163                              <1> .NoLbaSupportedSoNoEBIOS:
   164                              <1> %endif ; MODULE_EBIOS
   165                              <1> 	; Fall to .StoreBlockMode
   166                              <1> 
   167                              <1> ;--------------------------------------------------------------------
   168                              <1> ; .StoreBlockMode
   169                              <1> ;	Parameters:
   170                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   171                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
   172                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
   173                              <1> ;	Returns:
   174                              <1> ;		Nothing
   175                              <1> ;	Corrupts registers:
   176                              <1> ;		Nothing
   177                              <1> ;--------------------------------------------------------------------
   178                              <1> .StoreBlockMode:
   179 00000C21 26807C5E01          <1> 	cmp		BYTE [es:si+ATA1.bBlckSize], 1	; Max block size in sectors
   180 00000C26 7604                <1> 	jbe		SHORT .BlockModeTransfersNotSupported
   181 00000C28 804D0102            <1> 	or		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_BLOCK_MODE_SUPPORTED
   182                              <1> .BlockModeTransfersNotSupported:
   183                              <1> 	; Fall to .StoreDeviceSpecificParameters
   184                              <1> 
   185                              <1> ;--------------------------------------------------------------------
   186                              <1> ; .StoreDeviceSpecificParameters
   187                              <1> ;	Parameters:
   188                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   189                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
   190                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
   191                              <1> ;	Returns:
   192                              <1> ;		Nothing
   193                              <1> ;	Corrupts registers:
   194                              <1> ;		AX, BX, CX, DX
   195                              <1> ;--------------------------------------------------------------------
   196                              <1> .StoreDeviceSpecificParameters:
   197 00000C2C E83C0C              <1> 	call	Device_FinalizeDPT
   198                              <1> 
   199                              <1> ;----------------------------------------------------------------------
   200                              <1> ; Update drive counts (hard and floppy)
   201                              <1> ;----------------------------------------------------------------------
   202                              <1> 
   203                              <1> %ifdef MODULE_SERIAL_FLOPPY
   204                              <1> ;
   205                              <1> ; These two instructions serve two purposes:
   206                              <1> ; 1. If the drive is a floppy drive (CF set), then we effectively increment the counter.
   207                              <1> ; 2. If this is a hard disk, and there have been any floppy drives previously added, then the hard disk is
   208                              <1> ;    effectively discarded.  This is more of a safety check then code that should ever normally be hit (see below).
   209                              <1> ;    Since the floppy DPT's come after the hard disk DPT's, without expensive (code size) code to relocate a DPT,
   210                              <1> ;    this was necessary.  Now, this situation shouldn't happen in normal operation, for a couple of reasons:
   211                              <1> ; 		A. xtidecfg always puts configured serial ports at the end of the IDEVARS list
   212                              <1> ;       B. the auto serial code is always executed last
   213                              <1> ;       C. the serial server always returns floppy drives last
   214                              <1> ;
   215                              <1> 	adc		byte [RAMVARS.xlateVars+XLATEVARS.bFlopCreateCnt], 0
   216                              <1> 	jnz		.AllDone
   217                              <1> %else
   218                              <1> ;
   219                              <1> ; Even without floppy support enabled, we shouldn't try to mount a floppy image as a hard disk, which
   220                              <1> ; could lead to unpredictable results since no MBR will be present, etc.  The server doesn't know that
   221                              <1> ; floppies are supported, so it is important to still fail here if a floppy is seen during the drive scan.
   222                              <1> ;
   223 00000C2F 7204                <1> 	jc		.AllDone
   224                              <1> %endif
   225                              <1> 
   226 00000C31 FE060900            <1> 	inc		BYTE [RAMVARS.bDrvCnt]		; Increment drive count to RAMVARS
   227                              <1> 
   228                              <1> .AllDone:
   229 00000C35 F8                  <1> 	clc
   230 00000C36 C3                  <1> 	ret
   231                              <1> 
   232                              <1> 
   233                              <1> ;--------------------------------------------------------------------
   234                              <1> ; CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI
   235                              <1> ;	Parameters:
   236                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
   237                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   238                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
   239                              <1> ;	Returns:
   240                              <1> ;		Nothing
   241                              <1> ;	Corrupts registers:
   242                              <1> ;		AX
   243                              <1> ;--------------------------------------------------------------------
   244                              <1> CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI:
   245 00000C37 896D02              <1> 	mov		[di+DPT.bIdevarsOffset], bp		; IDEVARS must start in first 256 bytes of ROM
   246                              <1> 
   247                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   248 00000C3A E85002              <1> 	call	DetectDrives_DoesIdevarsInCSBPbelongToXTCF
   249 00000C3D 7504                <1> 	jne		SHORT .DeviceUsesPortSpecifiedInIDEVARS
   250 00000C3F 895504              <1> 	mov		[di+DPT.wBasePort], dx
   251 00000C42 C3                  <1> 	ret
   252                              <1> .DeviceUsesPortSpecifiedInIDEVARS:
   253                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
   254                              <1> 
   255 00000C43 2E8B4600            <1> 	mov		ax, [cs:bp+IDEVARS.wBasePort]
   256 00000C47 894504              <1> 	mov		[di+DPT.wBasePort], ax
   257 00000C4A C3                  <1> 	ret
   258                              <1> 
   259                              <1> 
   260                              <1> ;--------------------------------------------------------------------
   261                              <1> ; GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS
   262                              <1> ;	Parameters:
   263                              <1> ;		DS:DI:		Ptr to Disk Parameter Table
   264                              <1> ;	Returns:
   265                              <1> ;		AX:			User defined P-CHS Cylinders or LBA low word
   266                              <1> ;		BX:			User defined P-CHS Heads and Sectors or LBA high word
   267                              <1> ;		DX:			Translate mode or TRANSLATEMODE_AUTO
   268                              <1> ;		CX:			FLG_DRVPARAMS_USERCHS if user defined CHS in BX:AX
   269                              <1> ;					FLG_DRVPARAMS_USERLBA if user defined LBA in BX:AX
   270                              <1> ;					Zero if user has not defined capacity
   271                              <1> ;	Corrupts registers:
   272                              <1> ;		Nothing
   273                              <1> ;--------------------------------------------------------------------
   274                              <1> GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS:
   275 00000C4B E8A900              <1> 	call	AccessDPT_GetPointerToDRVPARAMStoCSBX
   276                              <1> 
   277                              <1> 	; Get settings
   278 00000C4E 2E8B0F              <1> 	mov		cx, [cs:bx+DRVPARAMS.wFlags]
   279 00000C51 89CA                <1> 	mov		dx, cx
   280 00000C53 83E160              <1> 	and		cx, BYTE FLG_DRVPARAMS_USERCHS | FLG_DRVPARAMS_USERLBA
   281 00000C56 83E20C              <1> 	and		dx, BYTE MASK_DRVPARAMS_TRANSLATEMODE
   282                              <1> 	eSHR_IM	dx, TRANSLATEMODE_FIELD_POSITION
   282                              <2>  eSHIFT_IM %1, %2, shr
   282                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   282                              <3> %ifndef USE_186
   282                              <3>  %ifidni %1, cl
   282                              <3>  times %2 %3 %1, 1
   282                              <3>  %elifidni %1, ch
   282                              <3>  times %2 %3 %1, 1
   282                              <3>  %elifidni %1, cx
   282                              <3>  times %2 %3 %1, 1
   282                              <3>  %else
   282                              <3>  %if %2 > 3
   282                              <3>  push cx
   282                              <3>  mov cl, %2
   282                              <3>  %3 %1, cl
   282                              <3>  pop cx
   282                              <3>  %else
   282 00000C59 D1EA<rept>          <3>  times %2 %3 %1, 1
   282                              <3>  %endif
   282                              <3>  %endif
   282                              <3> 
   282                              <3> %else
   282                              <3>  %3 %1, %2
   282                              <3> %endif
   282                              <3> %endif
   283                              <1> 
   284                              <1> 	; Get capacity
   285 00000C5D 2E8B4702            <1> 	mov		ax, [cs:bx+DRVPARAMS.wCylinders]		; Or .dwMaximumLBA
   286 00000C61 2E8B5F04            <1> 	mov		bx, [cs:bx+DRVPARAMS.wHeadsAndSectors]	; Or .dwMaximumLBA+2
   287 00000C65 C3                  <1> 	ret
   288                              <1> 
   289                              <1> 
   290                              <1> %ifdef MODULE_EBIOS
   291                              <1> ;--------------------------------------------------------------------
   292                              <1> ; StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX
   293                              <1> ;	Parameters:
   294                              <1> ;		BX:DX:AX:	Total Sector Count
   295                              <1> ;		CL:			FLGL_DPT_LBA48 if LBA48 supported
   296                              <1> ;		DS:DI:		Ptr to Disk Parameter Table
   297                              <1> ;	Returns:
   298                              <1> ;		Nothing
   299                              <1> ;	Corrupts registers:
   300                              <1> ;		CL
   301                              <1> ;--------------------------------------------------------------------
   302                              <1> StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX:
   303                              <1> 	or		cl, FLGL_DPT_LBA_AND_EBIOS_SUPPORTED
   304                              <1> 	and		BYTE [di+DPT.bFlagsLow], ~FLGL_DPT_LBA48
   305                              <1> 	or		[di+DPT.bFlagsLow], cl
   306                              <1> 	mov		[di+DPT.twLbaSectors], ax
   307                              <1> 	mov		[di+DPT.twLbaSectors+2], dx
   308                              <1> 	mov		[di+DPT.twLbaSectors+4], bx
   309                              <1> 	ret
   310                              <1> %endif ; MODULE_EBIOS
   197                                  	%include "FindDPT.asm"			; For finding DPTs
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for finding Disk Parameter Table.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Checks if drive is handled by this BIOS, and return DPT pointer.
    25                              <1> ;
    26                              <1> ; FindDPT_ForDriveNumberInDL
    27                              <1> ;	Parameters:
    28                              <1> ;		DL:		Drive number
    29                              <1> ;		DS:		RAMVARS segment
    30                              <1> ;	Returns:
    31                              <1> ;		CF:		Cleared if drive is handled by this BIOS
    32                              <1> ;				Set if drive belongs to some other BIOS
    33                              <1> ;		DI:		DPT Pointer if drive is handled by this BIOS
    34                              <1> ;				Zero if drive belongs to some other BIOS
    35                              <1> ;	Corrupts registers:
    36                              <1> ;		Nothing
    37                              <1> ;--------------------------------------------------------------------
    38                              <1> ALIGN JUMP_ALIGN
    39                              <1> FindDPT_ForDriveNumberInDL:
    40 00000C66 97                  <1> 	xchg	di, ax								; Save the contents of AX in DI
    41                              <1> 
    42                              <1> ;
    43                              <1> ; Check Our Hard Disks
    44                              <1> ;
    45 00000C67 A10800              <1> 	mov		ax, [RAMVARS.wFirstDrvAndCount]		; Drive count to AH, First number to AL
    46 00000C6A 00C4                <1> 	add		ah, al								; One past last drive to AH
    47                              <1> 
    48                              <1> %ifdef MODULE_SERIAL_FLOPPY
    49                              <1> 	cmp		dl, ah								; Above last supported?
    50                              <1> 	jae		SHORT .HardDiskNotHandledByThisBIOS
    51                              <1> 
    52                              <1> 	cmp		dl, al								; Below first supported?
    53                              <1> 	jae		SHORT .CalcDPTForDriveNumber
    54                              <1> 
    55                              <1> ALIGN JUMP_ALIGN
    56                              <1> .HardDiskNotHandledByThisBIOS:
    57                              <1> ;
    58                              <1> ; Check Our Floppy Disks
    59                              <1> ;
    60                              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
    61                              <1> 	js		SHORT .DiskIsNotHandledByThisBIOS
    62                              <1> 
    63                              <1> 	cbw											; Always 0h (no floppy drive covered above)
    64                              <1> 	adc		ah, al								; Add in first drive number and number of drives
    65                              <1> 
    66                              <1> 	cmp		ah, dl								; Check second drive if two, first drive if only one
    67                              <1> 	jz		SHORT .CalcDPTForDriveNumber
    68                              <1> 	cmp		al, dl								; Check first drive in all cases, redundant but OK to repeat
    69                              <1> 	jnz		SHORT .DiskIsNotHandledByThisBIOS
    70                              <1> %else
    71 00000C6C 38E2                <1> 	cmp		dl, ah								; Above last supported?
    72 00000C6E 7313                <1> 	jae		SHORT .DiskIsNotHandledByThisBIOS
    73                              <1> 
    74 00000C70 38C2                <1> 	cmp		dl, al								; Below first supported?
    75 00000C72 720F                <1> 	jb		SHORT .DiskIsNotHandledByThisBIOS
    76                              <1> %endif
    77                              <1> 	; fall-through to CalcDPTForDriveNumber
    78                              <1> 
    79                              <1> ;--------------------------------------------------------------------
    80                              <1> ; Finds Disk Parameter Table for drive number.
    81                              <1> ; Not intended to be called except by FindDPT_ForDriveNumberInDL
    82                              <1> ;
    83                              <1> ; CalcDPTForDriveNumber
    84                              <1> ;	Parameters:
    85                              <1> ;		DL:		Drive number
    86                              <1> ;		DS:		RAMVARS segment
    87                              <1> ;       DI:     Saved copy of AX from entry at FindDPT_ForDriveNumberInDL
    88                              <1> ;	Returns:
    89                              <1> ;		DS:DI:	Ptr to DPT
    90                              <1> ;       CF:     Clear
    91                              <1> ;	Corrupts registers:
    92                              <1> ;		Nothing
    93                              <1> ;--------------------------------------------------------------------
    94                              <1> ALIGN JUMP_ALIGN
    95                              <1> .CalcDPTForDriveNumber:
    96 00000C74 52                  <1> 	push	dx
    97                              <1> 
    98                              <1> %ifdef MODULE_SERIAL_FLOPPY
    99                              <1> 	mov		ax, [RAMVARS.wFirstDrvAndCount]
   100                              <1> 
   101                              <1> 	test	dl, dl
   102                              <1> 	js		.harddisk
   103                              <1> 
   104                              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
   105                              <1> 	add		dl, ah						; add in end of hard disk DPT list, floppies start immediately after
   106                              <1> 
   107                              <1> ALIGN JUMP_ALIGN
   108                              <1> .harddisk:
   109                              <1> 	sub		dl, al						; subtract off beginning of either hard disk or floppy list (as appropriate)
   110                              <1> %else
   111 00000C75 2A160800            <1> 	sub		dl, [RAMVARS.bFirstDrv]		; subtract off beginning of hard disk list
   112                              <1> %endif
   113                              <1> 
   114                              <1> .CalcDPTForNewDrive:
   115 00000C79 B00E                <1> 	mov		al, LARGEST_DPT_SIZE
   116                              <1> 
   117 00000C7B F6E2                <1> 	mul		dl
   118 00000C7D 83C00E              <1> 	add		ax, RAMVARS_size			; Clears CF (will not overflow)
   119                              <1> 
   120 00000C80 5A                  <1> 	pop		dx
   121                              <1> 
   122 00000C81 97                  <1> 	xchg	di, ax						; Restore AX from entry at FindDPT_ForDriveNumber, put DPT pointer in DI
   123 00000C82 C3                  <1> 	ret
   124                              <1> 
   125                              <1> ALIGN JUMP_ALIGN
   126                              <1> .DiskIsNotHandledByThisBIOS:
   127                              <1> ;
   128                              <1> ; Drive not found...
   129                              <1> ;
   130 00000C83 31C0                <1> 	xor		ax, ax								; Clear DPT pointer
   131 00000C85 F9                  <1> 	stc											; Is not supported by our BIOS
   132                              <1> 
   133 00000C86 97                  <1> 	xchg	di, ax								; Restore AX from save at top
   134 00000C87 C3                  <1> 	ret
   135                              <1> 
   136                              <1> 
   137                              <1> ;--------------------------------------------------------------------
   138                              <1> ; FindDPT_MasterOrSingleForIdevarsOffsetInDL
   139                              <1> ;	Parameters:
   140                              <1> ;		DL:		Offset to IDEVARS to search for
   141                              <1> ;		DS:		RAMVARS segment
   142                              <1> ;	Returns:
   143                              <1> ;		DS:DI:		Ptr to first DPT with same IDEVARS as in DL
   144                              <1> ;		CF:			Clear if wanted DPT found
   145                              <1> ;					Set if DPT not found, or no DPTs present
   146                              <1> ;	Corrupts registers:
   147                              <1> ;		SI
   148                              <1> ;--------------------------------------------------------------------
   149                              <1> FindDPT_MasterOrSingleForIdevarsOffsetInDL:
   150 00000C88 BE[9C0C]            <1> 	mov		si, IterateFindFirstDPTforIdevars			; iteration routine (see below)
   151 00000C8B EB27                <1> 	jmp		SHORT FindDPT_IterateAllDPTs				; look for the first drive on this controller, if any
   152                              <1> 
   153                              <1> ;--------------------------------------------------------------------
   154                              <1> ; FindDPT_SlaveForIdevarsOffsetInDL
   155                              <1> ;	Parameters:
   156                              <1> ;		DL:		Offset to IDEVARS to search for
   157                              <1> ;		DS:		RAMVARS segment
   158                              <1> ;	Returns:
   159                              <1> ;		DS:DI:		Ptr to second DPT with same IDEVARS as in DL
   160                              <1> ;		CF:			Clear if wanted DPT found
   161                              <1> ;					Set if DPT not found, or no DPTs present
   162                              <1> ;	Corrupts registers:
   163                              <1> ;		SI
   164                              <1> ;--------------------------------------------------------------------
   165                              <1> FindDPT_SlaveForIdevarsOffsetInDL:
   166 00000C8D BE[920C]            <1> 	mov		si, IterateFindSecondDPTforIdevars			; iteration routine (see below)
   167 00000C90 EB22                <1> 	jmp		SHORT FindDPT_IterateAllDPTs				; look for the second drive on this controller, if any
   168                              <1> 
   169                              <1> ;--------------------------------------------------------------------
   170                              <1> ; Iteration routines for FindDPT_MasterOrSingleForIdevarsOffsetInDL and
   171                              <1> ; FindDPT_SlaveForIdevarsOffsetInDL, for use with IterateAllDPTs
   172                              <1> ;
   173                              <1> ; Returns when DPT is found on the controller with Idevars offset in DL
   174                              <1> ;
   175                              <1> ; IterateFindSecondDPTforIdevars
   176                              <1> ; IterateFindFirstDPTforIdevars
   177                              <1> ;       DL:		Offset to IDEVARS to search from DPTs
   178                              <1> ;		SI:		Offset to this callback function
   179                              <1> ;		DS:DI:	Ptr to DPT to examine
   180                              <1> ;	Returns:
   181                              <1> ;		CF:		Clear if wanted DPT found
   182                              <1> ;				Set if wrong DPT
   183                              <1> ;--------------------------------------------------------------------
   184                              <1> IterateFindSecondDPTforIdevars:
   185 00000C92 E80700              <1> 	call	IterateFindFirstDPTforIdevars
   186 00000C95 7203                <1> 	jc		SHORT .WrongController
   187 00000C97 BE[9C0C]            <1> 	mov		si, IterateFindFirstDPTforIdevars
   188                              <1> .WrongController:
   189 00000C9A F9                  <1> 	stc
   190 00000C9B C3                  <1> 	ret
   191                              <1> 
   192                              <1> IterateFindFirstDPTforIdevars:
   193 00000C9C 3A5502              <1> 	cmp		dl, [di+DPT.bIdevarsOffset]			; Clears CF if matched
   194 00000C9F 7401                <1> 	je		.done
   195 00000CA1 F9                  <1> 	stc											; Set CF for not found
   196                              <1> .done:
   197 00000CA2 C3                  <1> 	ret
   198                              <1> 
   199                              <1> 
   200                              <1> ;--------------------------------------------------------------------
   201                              <1> ; Finds pointer to first unused Disk Parameter Table.
   202                              <1> ; Should only be used before DetectDrives is complete (not valid after this time).
   203                              <1> ;
   204                              <1> ; FindDPT_ForNewDriveToDSDI
   205                              <1> ;	Parameters:
   206                              <1> ;		DS:		RAMVARS segment
   207                              <1> ;	Returns:
   208                              <1> ;		DS:DI:	Ptr to first unused DPT
   209                              <1> ;	Corrupts registers:
   210                              <1> ;		AX
   211                              <1> ;--------------------------------------------------------------------
   212                              <1> ALIGN JUMP_ALIGN
   213                              <1> FindDPT_ForNewDriveToDSDI:
   214 00000CA3 52                  <1> 	push	dx
   215                              <1> 
   216                              <1> %ifdef MODULE_SERIAL_FLOPPY
   217                              <1> 	mov		dx, [RAMVARS.wDrvCntAndFlopCnt]
   218                              <1> 	add		dl, dh
   219                              <1> %else
   220 00000CA4 8A160900            <1> 	mov		dl, [RAMVARS.bDrvCnt]
   221                              <1> %endif
   222                              <1> 
   223 00000CA8 EBCF                <1> 	jmp		short FindDPT_ForDriveNumberInDL.CalcDPTForNewDrive
   224                              <1> 
   225                              <1> ;--------------------------------------------------------------------
   226                              <1> ; IterateToDptWithFlagsHighInBL
   227                              <1> ;	Parameters:
   228                              <1> ;		DS:DI:	Ptr to DPT to examine
   229                              <1> ;       BL:		Bit(s) to test in DPT.bFlagsHigh
   230                              <1> ;	Returns:
   231                              <1> ;		CF:		Clear if wanted DPT found
   232                              <1> ;				Set if wrong DPT
   233                              <1> ;	Corrupts registers:
   234                              <1> ;		Nothing
   235                              <1> ;--------------------------------------------------------------------
   236                              <1> ALIGN JUMP_ALIGN
   237                              <1> IterateToDptWithFlagsHighInBL:
   238 00000CAA 845D01              <1> 	test	[di+DPT.bFlagsHigh], bl				; Clears CF
   239 00000CAD 7501                <1> 	jnz		SHORT .ReturnRightDPT
   240 00000CAF F9                  <1> 	stc
   241                              <1> .ReturnRightDPT:
   242 00000CB0 C3                  <1> 	ret
   243                              <1> 
   244                              <1> ;--------------------------------------------------------------------
   245                              <1> ; FindDPT_ToDSDIforSerialDevice
   246                              <1> ;	Parameters:
   247                              <1> ;		DS:		RAMVARS segment
   248                              <1> ;	Returns:
   249                              <1> ;		DS:DI:	Ptr to DPT
   250                              <1> ;		CF:		Set if wanted DPT found
   251                              <1> ;				Cleared if DPT not found
   252                              <1> ;	Corrupts registers:
   253                              <1> ;		SI
   254                              <1> ;--------------------------------------------------------------------
   255                              <1> %ifdef MODULE_SERIAL
   256                              <1> ALIGN JUMP_ALIGN
   257                              <1> FindDPT_ToDSDIforSerialDevice:
   258                              <1> 	mov		bl, FLGH_DPT_SERIAL_DEVICE
   259                              <1> ; fall-through
   260                              <1> %endif
   261                              <1> 
   262                              <1> ;--------------------------------------------------------------------
   263                              <1> ; FindDPT_ToDSDIforFlagsHigh
   264                              <1> ;	Parameters:
   265                              <1> ;		DS:		RAMVARS segment
   266                              <1> ;       BL:		Bit(s) to test in DPT.bFlagsHigh
   267                              <1> ;	Returns:
   268                              <1> ;		DS:DI:	Ptr to DPT
   269                              <1> ;		CF:		Set if wanted DPT found
   270                              <1> ;				Cleared if DPT not found
   271                              <1> ;	Corrupts registers:
   272                              <1> ;		SI
   273                              <1> ;--------------------------------------------------------------------
   274                              <1> %ifdef MODULE_IRQ
   275                              <1> ALIGN JUMP_ALIGN
   276                              <1> FindDPT_ToDSDIforFlagsHighInBL:
   277                              <1> %endif
   278 00000CB1 BE[AA0C]            <1> 	mov		si, IterateToDptWithFlagsHighInBL
   279                              <1> 	; Fall to IterateAllDPTs
   280                              <1> 
   281                              <1> ;--------------------------------------------------------------------
   282                              <1> ; Iterates all Disk Parameter Tables.
   283                              <1> ;
   284                              <1> ; FindDPT_IterateAllDPTs
   285                              <1> ;	Parameters:
   286                              <1> ;		AX,BX,DX:	Parameters to callback function
   287                              <1> ;		CS:SI:		Ptr to callback function
   288                              <1> ;                   Callback routine should return CF=clear if found
   289                              <1> ;		DS:			RAMVARS segment
   290                              <1> ;	Returns:
   291                              <1> ;		DS:DI:		Ptr to wanted DPT (if found)
   292                              <1> ;					If not found, points to first empty DPT
   293                              <1> ;		CF:			Clear if wanted DPT found
   294                              <1> ;					Set if DPT not found, or no DPTs present
   295                              <1> ;	Corrupts registers:
   296                              <1> ;		Nothing unless corrupted by callback function
   297                              <1> ;--------------------------------------------------------------------
   298                              <1> ALIGN JUMP_ALIGN
   299                              <1> FindDPT_IterateAllDPTs:
   300 00000CB4 51                  <1> 	push	cx
   301                              <1> 
   302 00000CB5 BF0E00              <1> 	mov		di, RAMVARS_size			; Point DS:DI to first DPT
   303                              <1> 	eMOVZX	cx, [RAMVARS.bDrvCnt]
   303                              <2> %ifndef USE_386
   303                              <2>  %ifidni %1, ax
   303                              <2>  mov al, %2
   303                              <2>  xor ah, ah
   303                              <2>  %elifidni %1, bx
   303                              <2>  mov bl, %2
   303                              <2>  xor bh, bh
   303                              <2>  %elifidni %1, cx
   303 00000CB8 8A0E0900            <2>  mov cl, %2
   303 00000CBC 30ED                <2>  xor ch, ch
   303                              <2>  %elifidni %1, dx
   303                              <2>  mov dl, %2
   303                              <2>  xor dh, dh
   303                              <2>  %else
   303                              <2>  push ax
   303                              <2>  mov al, %2
   303                              <2>  xor ah, ah
   303                              <2>  xchg ax, %1
   303                              <2>  pop ax
   303                              <2>  %endif
   303                              <2> 
   303                              <2> %else
   303                              <2>  movzx %1, %2
   303                              <2> %endif
   304 00000CBE E309                <1> 	jcxz	.NotFound					; Return if no drives
   305                              <1> 
   306                              <1> ALIGN JUMP_ALIGN
   307                              <1> .LoopWhileDPTsLeft:
   308 00000CC0 FFD6                <1> 	call	si							; Is wanted DPT?
   309 00000CC2 7306                <1> 	jnc		SHORT .Found				;  If so, return
   310 00000CC4 83C70E              <1> 	add		di, BYTE LARGEST_DPT_SIZE	; Point to next DPT
   311 00000CC7 E2F7                <1> 	loop	.LoopWhileDPTsLeft
   312                              <1> 
   313                              <1> ALIGN JUMP_ALIGN
   314                              <1> .NotFound:
   315 00000CC9 F9                  <1> 	stc
   316                              <1> 
   317                              <1> ALIGN JUMP_ALIGN
   318                              <1> .Found:
   319 00000CCA 59                  <1> 	pop		cx
   320 00000CCB C3                  <1> 	ret
   198                                  	%include "AccessDPT.asm"		; For accessing DPTs
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for accessing DPT data.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    21                              <1> 
    22                              <1> ; Section containing code
    23                              <1> SECTION .text
    24                              <1> 
    25                              <1> ;--------------------------------------------------------------------
    26                              <1> ; AccessDPT_GetDriveSelectByteForOldInt13hToAL
    27                              <1> ; AccessDPT_GetDriveSelectByteForEbiosToAL
    28                              <1> ;	Parameters:
    29                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    30                              <1> ;	Returns:
    31                              <1> ;		AL:		Drive Select Byte
    32                              <1> ;	Corrupts registers:
    33                              <1> ;		Nothing
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> ALIGN JUMP_ALIGN
    36                              <1> AccessDPT_GetDriveSelectByteForOldInt13hToAL:
    37 00000CCC 8A05                <1> 	mov		al, [di+DPT.bFlagsLow]
    38 00000CCE A808                <1> 	test	al, FLGL_DPT_ASSISTED_LBA
    39 00000CD0 7505                <1> 	jnz		SHORT GetDriveSelectByteForAssistedLBAtoAL
    40                              <1> 
    41 00000CD2 2410                <1> 	and		al, FLG_DRVNHEAD_DRV	; Clear all but drive select bit
    42 00000CD4 0CA0                <1> 	or		al, MASK_DRVNHEAD_SET	; Bits set to 1 for old drives
    43 00000CD6 C3                  <1> 	ret
    44                              <1> 
    45                              <1> %ifdef MODULE_EBIOS
    46                              <1> ALIGN JUMP_ALIGN
    47                              <1> AccessDPT_GetDriveSelectByteForEbiosToAL:
    48                              <1> 	mov		al, [di+DPT.bFlagsLow]
    49                              <1> 	; Fall to GetDriveSelectByteForAssistedLBAtoAL
    50                              <1> %endif ; MODULE_EBIOS
    51                              <1> 
    52                              <1> ALIGN JUMP_ALIGN
    53                              <1> GetDriveSelectByteForAssistedLBAtoAL:
    54 00000CD7 2410                <1> 	and		al, FLG_DRVNHEAD_DRV	; Master / Slave select
    55 00000CD9 0CE0                <1> 	or		al, FLG_DRVNHEAD_LBA | MASK_DRVNHEAD_SET
    56 00000CDB C3                  <1> 	ret
    57                              <1> 
    58                              <1> 
    59                              <1> ;--------------------------------------------------------------------
    60                              <1> ; AccessDPT_GetDeviceControlByteToAL
    61                              <1> ;	Parameters:
    62                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    63                              <1> ;	Returns:
    64                              <1> ;		AL:		Device Control Byte
    65                              <1> ;	Corrupts registers:
    66                              <1> ;		Nothing
    67                              <1> ;--------------------------------------------------------------------
    68                              <1> ALIGN JUMP_ALIGN
    69                              <1> AccessDPT_GetDeviceControlByteToAL:
    70                              <1> %ifdef MODULE_IRQ
    71                              <1> 
    72                              <1> %ifndef USE_UNDOC_INTEL
    73                              <1> 	xor		al, al
    74                              <1> %endif
    75                              <1> 
    76                              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_ENABLE_IRQ	; Clears CF
    77                              <1> 
    78                              <1> %ifdef USE_UNDOC_INTEL
    79                              <1> 	eSALC	; Clears AL using CF while preserving flags
    80                              <1> %endif
    81                              <1> 
    82                              <1> 	jnz		SHORT .EnableDeviceIrq
    83                              <1> 	or		al, FLG_DEVCONTROL_nIEN	; Disable IRQ
    84                              <1> .EnableDeviceIrq:
    85                              <1> %else
    86 00000CDC B002                <1> 	mov		al, FLG_DEVCONTROL_nIEN	; Disable IRQ
    87                              <1> %endif ; MODULE_IRQ
    88 00000CDE C3                  <1> 	ret
    89                              <1> 
    90                              <1> 
    91                              <1> ;--------------------------------------------------------------------
    92                              <1> ; AccessDPT_GetLCHStoAXBLBH
    93                              <1> ;	Parameters:
    94                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    95                              <1> ;	Returns:
    96                              <1> ;		AX:		Number of L-CHS cylinders
    97                              <1> ;		BL:		Number of L-CHS heads
    98                              <1> ;		BH:		Number of L-CHS sectors per track
    99                              <1> ;	Corrupts registers:
   100                              <1> ;		Nothing
   101                              <1> ;--------------------------------------------------------------------
   102                              <1> AccessDPT_GetLCHStoAXBLBH:
   103 00000CDF 8B4506              <1> 	mov		ax, [di+DPT.wLchsCylinders]
   104 00000CE2 8B5D08              <1> 	mov		bx, [di+DPT.wLchsHeadsAndSectors]
   105 00000CE5 C3                  <1> 	ret
   106                              <1> 
   107                              <1> 
   108                              <1> %ifdef MODULE_8BIT_IDE
   109                              <1> ;--------------------------------------------------------------------
   110                              <1> ; AccessDPT_IsThisDeviceXTCF
   111                              <1> ;	Parameters:
   112                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   113                              <1> ;	Returns:
   114                              <1> ;		AH:		Device Type
   115                              <1> ;		ZF:		Set if XTCF
   116                              <1> ;				Cleared if some other device
   117                              <1> ;	Corrupts registers:
   118                              <1> ;		Nothing
   119                              <1> ;--------------------------------------------------------------------
   120                              <1> AccessDPT_IsThisDeviceXTCF:
   121 00000CE6 8A650C              <1> 	mov		ah, [di+DPT_ATA.bDevice]
   122 00000CE9 80FC0A              <1> 	cmp		ah, DEVICE_8BIT_XTCF_PIO8
   123 00000CEC 7408                <1> 	je		SHORT .DeviceIsXTCF
   124 00000CEE 80FC0C              <1> 	cmp		ah, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
   125 00000CF1 7403                <1> 	je		SHORT .DeviceIsXTCF
   126 00000CF3 80FC0E              <1> 	cmp		ah, DEVICE_8BIT_XTCF_DMA
   127                              <1> .DeviceIsXTCF:
   128 00000CF6 C3                  <1> 	ret		; note also executed if device *not* XT-CF
   129                              <1> %endif ; MODULE_8BIT_IDE
   130                              <1> 
   131                              <1> 
   132                              <1> %ifdef MODULE_EBIOS
   133                              <1> ;--------------------------------------------------------------------
   134                              <1> ; AccessDPT_GetLbaSectorCountToBXDXAX
   135                              <1> ;	Parameters:
   136                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   137                              <1> ;	Returns:
   138                              <1> ;		BX:DX:AX:	48-bit sector count
   139                              <1> ;	Corrupts registers:
   140                              <1> ;		Nothing
   141                              <1> ;--------------------------------------------------------------------
   142                              <1> AccessDPT_GetLbaSectorCountToBXDXAX:
   143                              <1> 	mov		ax, [di+DPT.twLbaSectors]
   144                              <1> 	mov		dx, [di+DPT.twLbaSectors+2]
   145                              <1> 	mov		bx, [di+DPT.twLbaSectors+4]
   146                              <1> 	ret
   147                              <1> %endif ; MODULE_EBIOS
   148                              <1> 
   149                              <1> 
   150                              <1> ;--------------------------------------------------------------------
   151                              <1> ; Returns pointer to DRVPARAMS for master or slave drive.
   152                              <1> ;
   153                              <1> ; AccessDPT_GetPointerToDRVPARAMStoCSBX
   154                              <1> ;	Parameters:
   155                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   156                              <1> ;	Returns:
   157                              <1> ;		CS:BX:	Ptr to DRVPARAMS
   158                              <1> ;	Corrupts registers:
   159                              <1> ;		Nothing
   160                              <1> ;--------------------------------------------------------------------
   161                              <1> AccessDPT_GetPointerToDRVPARAMStoCSBX:
   162 00000CF7 E80C00              <1> 	call	AccessDPT_GetIdevarsToCSBX
   163 00000CFA 83C306              <1> 	add		bx, BYTE IDEVARS.drvParamsMaster	; CS:BX points to Master Drive DRVPARAMS
   164 00000CFD F60510              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_SLAVE
   165 00000D00 7403                <1> 	jz		SHORT .ReturnPointerToDRVPARAMS
   166 00000D02 83C306              <1> 	add		bx, BYTE DRVPARAMS_size				; CS:BX points to Slave Drive DRVPARAMS
   167                              <1> .ReturnPointerToDRVPARAMS:
   168 00000D05 C3                  <1> 	ret
   169                              <1> 
   170                              <1> 
   171                              <1> ;--------------------------------------------------------------------
   172                              <1> ; Needed many times during initialization so it is better to
   173                              <1> ; make it as a function to save bytes.
   174                              <1> ;
   175                              <1> ; AccessDPT_GetIdevarsToCSBX
   176                              <1> ;	Parameters:
   177                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   178                              <1> ;	Returns:
   179                              <1> ;		CS:BX:	Ptr to IDEVARS for the drive
   180                              <1> ;	Corrupts registers:
   181                              <1> ;		Nothing
   182                              <1> ;--------------------------------------------------------------------
   183                              <1> AccessDPT_GetIdevarsToCSBX:
   184                              <1> 	eMOVZX	bx, BYTE [di+DPT.bIdevarsOffset]
   184                              <2> %ifndef USE_386
   184                              <2>  %ifidni %1, ax
   184                              <2>  mov al, %2
   184                              <2>  xor ah, ah
   184                              <2>  %elifidni %1, bx
   184 00000D06 8A5D02              <2>  mov bl, %2
   184 00000D09 30FF                <2>  xor bh, bh
   184                              <2>  %elifidni %1, cx
   184                              <2>  mov cl, %2
   184                              <2>  xor ch, ch
   184                              <2>  %elifidni %1, dx
   184                              <2>  mov dl, %2
   184                              <2>  xor dh, dh
   184                              <2>  %else
   184                              <2>  push ax
   184                              <2>  mov al, %2
   184                              <2>  xor ah, ah
   184                              <2>  xchg ax, %1
   184                              <2>  pop ax
   184                              <2>  %endif
   184                              <2> 
   184                              <2> %else
   184                              <2>  movzx %1, %2
   184                              <2> %endif
   185 00000D0B C3                  <1> 	ret
   186                              <1> 
   187                              <1> 
   188                              <1> ;--------------------------------------------------------------------
   189                              <1> ; ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF
   190                              <1> ;	Parameters:
   191                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   192                              <1> ;	Returns:
   193                              <1> ;		AX:		Translate Mode (TRANSLATEMODE_NORMAL, TRANSLATEMODE_LARGE or TRANSLATEMODE_ASSISTED_LBA)
   194                              <1> ;               unshifted (still shifted where it is in bFlagsLow)
   195                              <1> ;       ZF:     Set based on value in AL
   196                              <1> ;	Corrupts registers:
   197                              <1> ;		Nothing
   198                              <1> ;--------------------------------------------------------------------
   199                              <1> ;
   200                              <1> ; Converted to a macro since only called in two places, and the call/ret overhead
   201                              <1> ; is not worth it for these two instructions (4 bytes total)
   202                              <1> ;
   203                              <1> %macro ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF 0
   204                              <1> 	mov		al, [di+DPT.bFlagsLow]
   205                              <1> 	and		ax, BYTE MASKL_DPT_TRANSLATEMODE
   206                              <1> %endmacro
   199                                  	%include "AtaGeometry.asm"		; For generating L-CHS parameters
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for generating L-CHS parameters for
     3                              <1> ;					drives with more than 1024 cylinders.
     4                              <1> ;
     5                              <1> ; 					These algorithms are taken from: http://www.mossywell.com/boot-sequence
     6                              <1> ; 					Take a look at it for more detailed information.
     7                              <1> ;
     8                              <1> ;					This file is shared with BIOS Drive Information Tool.
     9                              <1> 
    10                              <1> ;
    11                              <1> ; XTIDE Universal BIOS and Associated Tools
    12                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
    13                              <1> ;
    14                              <1> ; This program is free software; you can redistribute it and/or modify
    15                              <1> ; it under the terms of the GNU General Public License as published by
    16                              <1> ; the Free Software Foundation; either version 2 of the License, or
    17                              <1> ; (at your option) any later version.
    18                              <1> ;
    19                              <1> ; This program is distributed in the hope that it will be useful,
    20                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    21                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    22                              <1> ; GNU General Public License for more details.
    23                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    24                              <1> ;
    25                              <1> 
    26                              <1> ; Section containing code
    27                              <1> SECTION .text
    28                              <1> 
    29                              <1> %ifdef MODULE_EBIOS
    30                              <1> ;--------------------------------------------------------------------
    31                              <1> ; AtaGeometry_GetLbaSectorCountToBXDXAXfromAtaInfoInESSI
    32                              <1> ;	Parameters:
    33                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    34                              <1> ;	Returns:
    35                              <1> ;		BX:DX:AX:	48-bit sector count
    36                              <1> ;		CL:			FLGL_DPT_LBA48 if LBA48 supported
    37                              <1> ;					Zero if only LBA28 is supported
    38                              <1> ;	Corrupts registers:
    39                              <1> ;		Nothing
    40                              <1> ;--------------------------------------------------------------------
    41                              <1> AtaGeometry_GetLbaSectorCountToBXDXAXfromAtaInfoInESSI:
    42                              <1> 	mov		bx, Registers_ExchangeDSSIwithESDI
    43                              <1> 	call	bx	; ATA info now in DS:DI
    44                              <1> 	push	bx	; We will return via Registers_ExchangeDSSIwithESDI
    45                              <1> 
    46                              <1> 	; Check if LBA48 supported
    47                              <1> 	test	BYTE [di+ATA6.wSetSup83+1], A6_wSetSup83_LBA48>>8
    48                              <1> 	jz		SHORT .GetLba28SectorCount
    49                              <1> 
    50                              <1> 	; Get LBA48 sector count
    51                              <1> 	mov		cl, FLGL_DPT_LBA48
    52                              <1> 	mov		ax, [di+ATA6.qwLBACnt]
    53                              <1> 	mov		dx, [di+ATA6.qwLBACnt+2]
    54                              <1> 	mov		bx, [di+ATA6.qwLBACnt+4]
    55                              <1> 	ret
    56                              <1> 
    57                              <1> .GetLba28SectorCount:
    58                              <1> 	xor		cl, cl
    59                              <1> 	xor		bx, bx
    60                              <1> 	mov		ax, [di+ATA1.dwLBACnt]
    61                              <1> 	mov		dx, [di+ATA1.dwLBACnt+2]
    62                              <1> 	ret
    63                              <1> %endif	; MODULE_EBIOS
    64                              <1> 
    65                              <1> 
    66                              <1> ;--------------------------------------------------------------------
    67                              <1> ; AtaGeometry_GetLCHStoAXBLBHfromAtaInfoInESSIandTranslateModeInDX
    68                              <1> ; AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX
    69                              <1> ;	Parameters:
    70                              <1> ;		DX:		Wanted translate mode or TRANSLATEMODE_AUTO to autodetect
    71                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    72                              <1> ;	Returns:
    73                              <1> ;		AX:		Number of L-CHS cylinders (1...1027, yes 1027)
    74                              <1> ;		BL:		Number of L-CHS heads (1...255)
    75                              <1> ;		BH:		Number of L-CHS sectors per track (1...63)
    76                              <1> ;		CX:		Number of bits shifted (0...3)
    77                              <1> ;		DL:		CHS Translate Mode
    78                              <1> ;	Corrupts registers:
    79                              <1> ;		DH
    80                              <1> ;--------------------------------------------------------------------
    81                              <1> AtaGeometry_GetLCHStoAXBLBHfromAtaInfoInESSIandTranslateModeInDX:
    82 00000D0C E82800              <1> 	call	AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI
    83                              <1> 	; Fall to AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX
    84                              <1> 
    85                              <1> AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX:
    86                              <1> 	; Check if user defined translate mode
    87 00000D0F 4A                  <1> 	dec		dx						; Set ZF if TRANSLATEMODE_LARGE, SF if TRANSLATEMODE_NORMAL
    88 00000D10 7909                <1> 	jns		SHORT .CheckIfLargeTranslationWanted
    89                              <1> 	MIN_U	ax, MAX_LCHS_CYLINDERS	; TRANSLATEMODE_NORMAL maximum cylinders
    89 00000D12 3D0004              <2>  cmp %1, %2
    89 00000D15 7203                <2>  jb %%Return
    89 00000D17 B80004              <2>  mov %1, %2
    89                              <2> ALIGN JUMP_ALIGN
    89                              <2> %%Return:
    90 00000D1A 42                  <1> 	inc		dx
    91                              <1> .CheckIfLargeTranslationWanted:
    92 00000D1B 742D                <1> 	jz		SHORT ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL
    93 00000D1D 4A                  <1> 	dec		dx						; Set ZF if TRANSLATEMODE_ASSISTED_LBA
    94 00000D1E 7405                <1> 	jz		SHORT .UseAssistedLBA
    95                              <1> 	; TRANSLATEMODE_AUTO set
    96                              <1> 
    97                              <1> 	; Generate L-CHS using simple bit shift algorithm (ECHS) if
    98                              <1> 	; 8192 or less cylinders.
    99 00000D20 3D0020              <1> 	cmp		ax, 8192
   100 00000D23 7639                <1> 	jbe		SHORT ConvertPCHfromAXBLtoEnhancedCHinAXBL
   101                              <1> 
   102                              <1> 	; We have 8193 or more cylinders so two algorithms are available:
   103                              <1> 	; Revised ECHS or Assisted LBA. The Assisted LBA provides larger
   104                              <1> 	; capacity but requires LBA support from drive (drives this large
   105                              <1> 	; always support LBA but user might have unintentionally set LBA).
   106                              <1> .UseAssistedLBA:
   107 00000D25 26F6446302          <1> 	test	BYTE [es:si+ATA1.wCaps+1], A1_wCaps_LBA>>8
   108 00000D2A 741E                <1> 	jz		SHORT ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL
   109                              <1> 
   110                              <1> 	; Drive supports LBA
   111 00000D2C E81500              <1> 	call	GetSectorCountToDXAXfromCHSinAXBLBH
   112 00000D2F E83E00              <1> 	call	ConvertChsSectorCountFromDXAXtoLbaAssistedLCHSinAXBLBH
   113 00000D32 31C9                <1> 	xor		cx, cx		; No bits to shift
   114 00000D34 B202                <1> 	mov		dl, TRANSLATEMODE_ASSISTED_LBA
   115 00000D36 C3                  <1> 	ret
   116                              <1> 
   117                              <1> 
   118                              <1> ;--------------------------------------------------------------------
   119                              <1> ; AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI
   120                              <1> ;	Parameters:
   121                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
   122                              <1> ;	Returns:
   123                              <1> ;		AX:		Number of P-CHS cylinders (1...16383)
   124                              <1> ;		BL:		Number of P-CHS heads (1...16)
   125                              <1> ;		BH:		Number of P-CHS sectors per track (1...63)
   126                              <1> ;	Corrupts registers:
   127                              <1> ;		Nothing
   128                              <1> ;--------------------------------------------------------------------
   129                              <1> AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI:
   130 00000D37 268B4402            <1> 	mov		ax, [es:si+ATA1.wCylCnt]	; Cylinders (1...16383)
   131 00000D3B 268A5C06            <1> 	mov		bl, [es:si+ATA1.wHeadCnt]	; Heads (1...16)
   132 00000D3F 268A7C0C            <1> 	mov		bh, [es:si+ATA1.wSPT]		; Sectors per Track (1...63)
   133 00000D43 C3                  <1> 	ret
   134                              <1> 
   135                              <1> 
   136                              <1> ;--------------------------------------------------------------------
   137                              <1> ; GetSectorCountToDXAXfromCHSinAXBLBH
   138                              <1> ;	Parameters:
   139                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
   140                              <1> ;		AX:		Number of cylinders (1...16383)
   141                              <1> ;		BL:		Number of heads (1...255)
   142                              <1> ;		BH:		Number of sectors per track (1...63)
   143                              <1> ;	Returns:
   144                              <1> ;		DX:AX:	Total number of CHS addressable sectors
   145                              <1> ;	Corrupts registers:
   146                              <1> ;		BX
   147                              <1> ;--------------------------------------------------------------------
   148                              <1> GetSectorCountToDXAXfromCHSinAXBLBH:
   149 00000D44 93                  <1> 	xchg	ax, bx
   150 00000D45 F6E4                <1> 	mul		ah			; AX = Heads * Sectors per track
   151 00000D47 F7E3                <1> 	mul		bx
   152 00000D49 C3                  <1> 	ret
   153                              <1> 
   154                              <1> 
   155                              <1> ;--------------------------------------------------------------------
   156                              <1> ; Revised Enhanced CHS calculation (Revised ECHS)
   157                              <1> ;
   158                              <1> ; This algorithm translates P-CHS sector count to L-CHS sector count
   159                              <1> ; with bit shift algorithm. Since 256 heads are not allowed
   160                              <1> ; (DOS limit), this algorithm makes translations so that maximum of
   161                              <1> ; 240 L-CHS heads can be used. This makes the maximum addressable capacity
   162                              <1> ; to 7,927,234,560 bytes ~ 7.38 GiB. LBA addressing needs to be used to
   163                              <1> ; get more capacity.
   164                              <1> ;
   165                              <1> ; L-CHS parameters generated here require the drive to use CHS addressing.
   166                              <1> ;
   167                              <1> ; Here is the algorithm:
   168                              <1> ; If cylinders > 8192 and heads = 16
   169                              <1> ;  Heads = 15
   170                              <1> ;  Cylinders = cylinders * 16 / 15 (losing the fraction component)
   171                              <1> ;  Do a standard ECHS translation
   172                              <1> ;
   173                              <1> ; ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL:
   174                              <1> ;	Parameters:
   175                              <1> ;		AX:		Number of P-CHS cylinders (8193...16383)
   176                              <1> ;		BL:		Number of P-CHS heads (1...16)
   177                              <1> ;	Returns:
   178                              <1> ;		AX:		Number of L-CHS cylinders (?...1024)
   179                              <1> ;		BL:		Number of L-CHS heads (?...240)
   180                              <1> ;		CX:		Number of bits shifted (0...3)
   181                              <1> ;		DL:		ADDRESSING_MODE_NORMAL or ADDRESSING_MODE_LARGE
   182                              <1> ;	Corrupts registers:
   183                              <1> ;		Nothing
   184                              <1> ;--------------------------------------------------------------------
   185                              <1> ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL:
   186                              <1> 	; Generate L-CHS using simple bit shift algorithm (ECHS) if
   187                              <1> 	; 8192 or less cylinders
   188 00000D4A 3D0020              <1> 	cmp		ax, 8192
   189 00000D4D 760F                <1> 	jbe		SHORT ConvertPCHfromAXBLtoEnhancedCHinAXBL
   190 00000D4F 80FB10              <1> 	cmp		bl, 16	; Drives with 8193 or more cylinders can report 15 heads
   191 00000D52 720A                <1> 	jb		SHORT ConvertPCHfromAXBLtoEnhancedCHinAXBL
   192                              <1> 
   193                              <1> 	eMOVZX	cx, bl	; CX = 16
   193                              <2> %ifndef USE_386
   193                              <2>  %ifidni %1, ax
   193                              <2>  mov al, %2
   193                              <2>  xor ah, ah
   193                              <2>  %elifidni %1, bx
   193                              <2>  mov bl, %2
   193                              <2>  xor bh, bh
   193                              <2>  %elifidni %1, cx
   193 00000D54 88D9                <2>  mov cl, %2
   193 00000D56 30ED                <2>  xor ch, ch
   193                              <2>  %elifidni %1, dx
   193                              <2>  mov dl, %2
   193                              <2>  xor dh, dh
   193                              <2>  %else
   193                              <2>  push ax
   193                              <2>  mov al, %2
   193                              <2>  xor ah, ah
   193                              <2>  xchg ax, %1
   193                              <2>  pop ax
   193                              <2>  %endif
   193                              <2> 
   193                              <2> %else
   193                              <2>  movzx %1, %2
   193                              <2> %endif
   194 00000D58 4B                  <1> 	dec		bx		; Heads = 15
   195 00000D59 F7E1                <1> 	mul		cx		; DX:AX = Cylinders * 16
   196 00000D5B 49                  <1> 	dec		cx		; CX = 15
   197 00000D5C F7F1                <1> 	div		cx		; AX = (Cylinders * 16) / 15
   198                              <1> 	; Fall to ConvertPCHfromAXBXtoEnhancedCHinAXBX
   199                              <1> 
   200                              <1> 
   201                              <1> ;--------------------------------------------------------------------
   202                              <1> ; Enhanced CHS calculation (ECHS)
   203                              <1> ;
   204                              <1> ; This algorithm translates P-CHS sector count to L-CHS sector count
   205                              <1> ; with simple bit shift algorithm. Since 256 heads are not allowed
   206                              <1> ; (DOS limit), this algorithm require that there are at most 8192
   207                              <1> ; P-CHS cylinders. This makes the maximum addressable capacity
   208                              <1> ; to 4,227,858,432 bytes ~ 3.94 GiB. Use Revised ECHS or Assisted LBA
   209                              <1> ; algorithms if there are more than 8192 P-CHS cylinders.
   210                              <1> ;
   211                              <1> ; L-CHS parameters generated here require the drive to use CHS addressing.
   212                              <1> ;
   213                              <1> ; Here is the algorithm:
   214                              <1> ;  Multiplier = 1
   215                              <1> ;  Cylinder = Cylinder - 1
   216                              <1> ;  Is Cylinder < 1024? If not:
   217                              <1> ;  Do a right bitwise rotation on the cylinder (i.e., divide by 2)
   218                              <1> ;  Do a left bitwise rotation on the multiplier (i.e., multiply by 2)
   219                              <1> ;  Use the multiplier on the Cylinder and Head values to obtain the translated values.
   220                              <1> ;
   221                              <1> ; ConvertPCHfromAXBLtoEnhancedCHinAXBL:
   222                              <1> ;	Parameters:
   223                              <1> ;		AX:		Number of P-CHS cylinders (1...8192)
   224                              <1> ;		BL:		Number of P-CHS heads (1...16)
   225                              <1> ;	Returns:
   226                              <1> ;		AX:		Number of L-CHS cylinders (?...1024)
   227                              <1> ;		BL:		Number of L-CHS heads (?...128)
   228                              <1> ;		CX:		Number of bits shifted (0...3)
   229                              <1> ;		DL:		TRANSLATEMODE_NORMAL or TRANSLATEMODE_LARGE
   230                              <1> ;	Corrupts registers:
   231                              <1> ;		Nothing
   232                              <1> ;--------------------------------------------------------------------
   233                              <1> ConvertPCHfromAXBLtoEnhancedCHinAXBL:
   234 00000D5E 31C9                <1> 	xor		cx, cx		; No bits to shift initially
   235 00000D60 30D2                <1> 	xor		dl, dl		; Assume TRANSLATEMODE_NORMAL
   236                              <1> .ShiftIfMoreThan1024Cylinder:
   237 00000D62 3D0004              <1> 	cmp		ax, MAX_LCHS_CYLINDERS
   238 00000D65 7633                <1> 	jbe		SHORT ReturnLCHSinAXBLBH
   239 00000D67 D1E8                <1> 	shr		ax, 1		; Halve cylinders
   240                              <1> 	eSHL_IM	bl, 1		; Double heads
   240                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   240                              <2> %ifdef USE_386
   240                              <2>  %if %2 = 1
   240                              <2>  add %1, %1
   240                              <2>  %else
   240                              <2>  eSHIFT_IM %1, %2, shl
   240                              <2>  %endif
   240                              <2> %else
   240                              <2>  eSHIFT_IM %1, %2, shl
   240                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   240                              <3> %ifndef USE_186
   240                              <3>  %ifidni %1, cl
   240                              <3>  times %2 %3 %1, 1
   240                              <3>  %elifidni %1, ch
   240                              <3>  times %2 %3 %1, 1
   240                              <3>  %elifidni %1, cx
   240                              <3>  times %2 %3 %1, 1
   240                              <3>  %else
   240                              <3>  %if %2 > 3
   240                              <3>  push cx
   240                              <3>  mov cl, %2
   240                              <3>  %3 %1, cl
   240                              <3>  pop cx
   240                              <3>  %else
   240 00000D69 D0E3                <3>  times %2 %3 %1, 1
   240                              <3>  %endif
   240                              <3>  %endif
   240                              <3> 
   240                              <3> %else
   240                              <3>  %3 %1, %2
   240                              <3> %endif
   240                              <3> %endif
   240                              <2> %endif
   240                              <2> %endif
   241 00000D6B 41                  <1> 	inc		cx			; Increment bit shift count
   242 00000D6C B201                <1> 	mov		dl, TRANSLATEMODE_LARGE
   243 00000D6E EBF2                <1> 	jmp		SHORT .ShiftIfMoreThan1024Cylinder
   244                              <1> 
   245                              <1> 
   246                              <1> ;--------------------------------------------------------------------
   247                              <1> ; LBA assist calculation (or Assisted LBA)
   248                              <1> ;
   249                              <1> ; This algorithm translates P-CHS sector count up to largest possible
   250                              <1> ; L-CHS sector count (1024, 255, 63). Note that INT 13h interface allows
   251                              <1> ; 256 heads but DOS supports up to 255 head. That is why BIOSes never
   252                              <1> ; use 256 heads.
   253                              <1> ;
   254                              <1> ; L-CHS parameters generated here require the drive to use LBA addressing.
   255                              <1> ;
   256                              <1> ; Here is the algorithm:
   257                              <1> ; If cylinders > 8192
   258                              <1> ;  Variable CH = Total CHS Sectors / 63
   259                              <1> ;  Divide (CH  1) by 1024 and add 1
   260                              <1> ;  Round the result up to the nearest of 16, 32, 64, 128 and 255. This is the value to be used for the number of heads.
   261                              <1> ;  Divide CH by the number of heads. This is the value to be used for the number of cylinders.
   262                              <1> ;
   263                              <1> ; ConvertChsSectorCountFromDXAXtoLbaAssistedLCHSinAXBLBH:
   264                              <1> ;	Parameters:
   265                              <1> ;		DX:AX:	Total number of P-CHS sectors for CHS addressing
   266                              <1> ;				(max = 16383 * 16 * 63 = 16,514,064)
   267                              <1> ;	Returns:
   268                              <1> ;		AX:		Number of cylinders (?...1027)
   269                              <1> ;		BL:		Number of heads (16, 32, 64, 128 or 255)
   270                              <1> ;		BH:		Number of sectors per track (always 63)
   271                              <1> ;	Corrupts registers:
   272                              <1> ;		CX, DX
   273                              <1> ;--------------------------------------------------------------------
   274                              <1> ConvertChsSectorCountFromDXAXtoLbaAssistedLCHSinAXBLBH:
   275                              <1> 	; Value CH = Total sector count / 63
   276                              <1> 	; Max = 16,514,064 / 63 = 262128
   277 00000D70 B93F00              <1> 	mov		cx, LBA_ASSIST_SPT			; CX = 63
   278 00000D73 E859FC              <1> 	call	Math_DivDXAXbyCX
   279 00000D76 52                  <1> 	push	dx
   280 00000D77 50                  <1> 	push	ax							; Value CH stored for later use
   281                              <1> 
   282                              <1> 	; BX:DX:AX = Value CH - 1
   283                              <1> 	; Max = 262128 - 1 = 262127
   284 00000D78 31DB                <1> 	xor		bx, bx
   285 00000D7A 83E801              <1> 	sub		ax, BYTE 1
   286 00000D7D 19DA                <1> 	sbb		dx, bx
   287                              <1> 
   288                              <1> 	; AX = Number of heads = ((Value CH - 1) / 1024) + 1
   289                              <1> 	; Max = (262127 / 1024) + 1 = 256
   290 00000D7F 56                  <1> 	push	si
   291 00000D80 E8DAFC              <1> 	call	Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
   292 00000D83 5E                  <1> 	pop		si
   293 00000D84 40                  <1> 	inc		ax							; + 1
   294                              <1> 
   295                              <1> 	; Heads must be 16, 32, 64, 128 or 255 (round up to the nearest)
   296                              <1> 	; Max = 255
   297 00000D85 B91000              <1> 	mov		cx, 16						; Min number of heads
   298                              <1> .CompareNextValidNumberOfHeads:
   299 00000D88 39C8                <1> 	cmp		ax, cx
   300 00000D8A 7606                <1> 	jbe		SHORT .NumberOfHeadsNowInCX
   301                              <1> 	eSHL_IM	cl, 1						; Double number of heads
   301                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   301                              <2> %ifdef USE_386
   301                              <2>  %if %2 = 1
   301                              <2>  add %1, %1
   301                              <2>  %else
   301                              <2>  eSHIFT_IM %1, %2, shl
   301                              <2>  %endif
   301                              <2> %else
   301                              <2>  eSHIFT_IM %1, %2, shl
   301                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   301                              <3> %ifndef USE_186
   301                              <3>  %ifidni %1, cl
   301 00000D8C D0E1                <3>  times %2 %3 %1, 1
   301                              <3>  %elifidni %1, ch
   301                              <3>  times %2 %3 %1, 1
   301                              <3>  %elifidni %1, cx
   301                              <3>  times %2 %3 %1, 1
   301                              <3>  %else
   301                              <3>  %if %2 > 3
   301                              <3>  push cx
   301                              <3>  mov cl, %2
   301                              <3>  %3 %1, cl
   301                              <3>  pop cx
   301                              <3>  %else
   301                              <3>  times %2 %3 %1, 1
   301                              <3>  %endif
   301                              <3>  %endif
   301                              <3> 
   301                              <3> %else
   301                              <3>  %3 %1, %2
   301                              <3> %endif
   301                              <3> %endif
   301                              <2> %endif
   301                              <2> %endif
   302 00000D8E 75F8                <1> 	jnz		SHORT .CompareNextValidNumberOfHeads	; Reached 256 heads?
   303 00000D90 FEC9                <1> 	dec		cl							;  If so, limit heads to 255
   304                              <1> .NumberOfHeadsNowInCX:
   305 00000D92 89CB                <1> 	mov		bx, cx						; Number of heads are returned in BL
   306 00000D94 B73F                <1> 	mov		bh, LBA_ASSIST_SPT			; Sectors per Track
   307                              <1> 
   308                              <1> 	; DX:AX = Number of cylinders = Value CH (without - 1) / number of heads
   309                              <1> 	; Max = 262128 / 255 = 1027
   310 00000D96 58                  <1> 	pop		ax
   311 00000D97 5A                  <1> 	pop		dx							; Value CH back to DX:AX
   312 00000D98 F7F1                <1> 	div		cx
   313                              <1> 
   314                              <1> 	; Return L-CHS
   315                              <1> ReturnLCHSinAXBLBH:
   316 00000D9A C3                  <1> 	ret
   200                                  	%include "DrvDetectInfo.asm"	; For creating DRVDETECTINFO structs
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for generating and accessing drive
     3                              <1> ;					information to be displayed on boot menu.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ;
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> ; Section containing code
    22                              <1> SECTION .text
    23                              <1> 
    24                              <1> ;--------------------------------------------------------------------
    25                              <1> ; Creates new DRVDETECTINFO struct for detected hard disk.
    26                              <1> ;
    27                              <1> ; DriveDetectInfo_CreateForHardDisk
    28                              <1> ;	Parameters:
    29                              <1> ;		DL:		Drive number
    30                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    31                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    32                              <1> ;	Returns:
    33                              <1> ;		ES:BX:	Ptr to DRVDETECTINFO (if successful)
    34                              <1> ;	Corrupts registers:
    35                              <1> ;		AX, BX, CX, DX, DI
    36                              <1> ;--------------------------------------------------------------------
    37                              <1> DriveDetectInfo_CreateForHardDisk:
    38 00000D9B E81700              <1> 	call	DriveDetectInfo_ConvertDPTtoBX		; ES:BX now points to new DRVDETECTINFO
    39                              <1> 
    40                              <1> 	; Store Drive Name
    41 00000D9E 1E                  <1> 	push	ds									; Preserve RAMVARS
    42 00000D9F 56                  <1> 	push	si
    43                              <1> 
    44 00000DA0 06                  <1> 	push	es									; ES copied to DS
    45 00000DA1 1F                  <1> 	pop		ds
    46                              <1> 
    47 00000DA2 83C636              <1> 	add		si, BYTE ATA1.strModel				; DS:SI now points drive name (Clears CF)
    48 00000DA5 8D3F                <1> 	lea		di, [bx+DRVDETECTINFO.szDrvName]	; ES:DI now points to name destination
    49 00000DA7 B90F00              <1> 	mov		cx, MAX_HARD_DISK_NAME_LENGTH / 2	; Max number of WORDs allowed
    50                              <1> .CopyNextWord:
    51 00000DAA AD                  <1> 	lodsw
    52 00000DAB 86C4                <1> 	xchg	al, ah								; Change endianness
    53 00000DAD AB                  <1> 	stosw
    54 00000DAE E2FA                <1> 	loop	.CopyNextWord
    55 00000DB0 91                  <1> 	xchg	cx, ax								; Zero AX (CF already cleared from the ADD above)
    56 00000DB1 AB                  <1> 	stosw										; Terminate with NULL
    57                              <1> 
    58 00000DB2 5E                  <1> 	pop		si
    59 00000DB3 1F                  <1> 	pop		ds
    60                              <1> 
    61 00000DB4 C3                  <1> 	ret
    62                              <1> 
    63                              <1> 
    64                              <1> ;--------------------------------------------------------------------
    65                              <1> ; Returns offset to DRVDETECTINFO based on DPT pointer.
    66                              <1> ;
    67                              <1> ; DriveDetectInfo_ConvertDPTtoBX
    68                              <1> ;	Parameters:
    69                              <1> ;		DS:DI:	DPT Pointer
    70                              <1> ;	Returns:
    71                              <1> ;		BX:		Offset to DRVDETECTINFO struct
    72                              <1> ;	Corrupts registers:
    73                              <1> ;		AX
    74                              <1> ;--------------------------------------------------------------------
    75                              <1> DriveDetectInfo_ConvertDPTtoBX:
    76 00000DB5 8D45F2              <1> 	lea		ax, [di-RAMVARS_size]					; subtract off base of DPTs
    77 00000DB8 B303                <1> 	mov		bl, DPT_DRVDETECTINFO_SIZE_MULTIPLIER	; DRVDETECTINFO are a whole number multiple of DPT size
    78 00000DBA F6E3                <1> 	mul		bl
    79 00000DBC 050C7F              <1> 	add		ax, BOOTVARS.rgDrvDetectInfo			; add base of DRVDETECTINFO
    80 00000DBF 93                  <1> 	xchg	bx, ax
    81 00000DC0 C3                  <1> 	ret
   201                                  	%include "AtaID.asm"			; For ATA Identify Device information
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for accessing ATA information read with
     3                              <1> ;					IDENTIFY DEVICE command.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ;
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> ; Section containing code
    22                              <1> SECTION .text
    23                              <1> 
    24                              <1> ;--------------------------------------------------------------------
    25                              <1> ; AtaID_VerifyFromESSI
    26                              <1> ;	Parameters:
    27                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    28                              <1> ;	Returns:
    29                              <1> ;		CF:		Set if failed to verify ATA-ID
    30                              <1> ;				Cleared if ATA-ID verified successfully
    31                              <1> ;	Corrupts registers:
    32                              <1> ;		AX, BX, CX
    33                              <1> ;--------------------------------------------------------------------
    34                              <1> AtaID_VerifyFromESSI:
    35                              <1> 	; We cannot start by reading ATA version since the ID might be
    36                              <1> 	; corrupted. We start by making sure P-CHS values are valid.
    37                              <1> 	; If they are, we assume the ATA ID to be valid. Fortunately we can do
    38                              <1> 	; further checking for ATA-5 and later since they contain signature and
    39                              <1> 	; checksum bytes. Those are not available for ATA-4 and older.
    40                              <1> 
    41                              <1> 	; Verify P-CHS cylinders
    42 00000DC1 BB0200              <1> 	mov		bx, ATA1.wCylCnt
    43 00000DC4 B9FF3F              <1> 	mov		cx, MAX_VALID_PCHS_CYLINDERS
    44 00000DC7 E82600              <1> 	call	.CompareCHorSfromOffsetBXtoMaxValueInCX
    45                              <1> 
    46 00000DCA B306                <1> 	mov		bl, ATA1.wHeadCnt & 0FFh
    47 00000DCC B91000              <1> 	mov		cx, MAX_VALID_PCHS_HEADS
    48 00000DCF E81E00              <1> 	call	.CompareCHorSfromOffsetBXtoMaxValueInCX
    49                              <1> 
    50 00000DD2 B30C                <1> 	mov		bl, ATA1.wSPT & 0FFh
    51 00000DD4 B13F                <1> 	mov		cl, MAX_VALID_PCHS_SECTORS_PER_TRACK
    52 00000DD6 E81700              <1> 	call	.CompareCHorSfromOffsetBXtoMaxValueInCX
    53                              <1> 
    54                              <1> 	; Check signature byte. It is only found on ATA-5 and later. It should be zero on
    55                              <1> 	; ATA-4 and older.
    56 00000DD9 268A84FE01          <1> 	mov		al, [es:si+ATA6.bSignature]
    57 00000DDE 84C0                <1> 	test	al, al
    58 00000DE0 740C                <1> 	jz		SHORT .AtaIDverifiedSuccessfully	; Old ATA so Signature and Checksum is not available
    59 00000DE2 3CA5                <1> 	cmp		al, A6_wIntegrity_SIGNATURE
    60 00000DE4 7518                <1> 	jne		SHORT .FailedToVerifyAtaID
    61                              <1> 
    62                              <1> 	; Check checksum byte since signature was present
    63 00000DE6 B90002              <1> 	mov		cx, ATA6_size
    64 00000DE9 E832FC              <1> 	call	Memory_SumCXbytesFromESSItoAL		; Returns with ZF set according to result
    65 00000DEC 7510                <1> 	jnz		SHORT .FailedToVerifyAtaID
    66                              <1> 
    67                              <1> 	; ATA-ID is now verified to be valid
    68                              <1> .AtaIDverifiedSuccessfully:
    69 00000DEE F8                  <1> 	clc
    70 00000DEF C3                  <1> 	ret
    71                              <1> 
    72                              <1> ;--------------------------------------------------------------------
    73                              <1> ; .CompareCHorSfromOffsetBXtoMaxValueInCX
    74                              <1> ;	Parameters:
    75                              <1> ;		BX:		C, H or S offset to ATA-ID
    76                              <1> ;		CX:		Maximum valid C, H or S value
    77                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    78                              <1> ;	Returns:
    79                              <1> ;		Exits from AtaID_VerifyFromESSI with CF set if invalid value
    80                              <1> ;	Corrupts registers:
    81                              <1> ;		AX
    82                              <1> ;--------------------------------------------------------------------
    83                              <1> .CompareCHorSfromOffsetBXtoMaxValueInCX:
    84 00000DF0 268B00              <1> 	mov		ax, [es:bx+si]
    85 00000DF3 85C0                <1> 	test	ax, ax
    86 00000DF5 7404                <1> 	jz		SHORT .InvalidPCHorSinOffsetBX
    87 00000DF7 39C8                <1> 	cmp		ax, cx			; Compare to max valid value
    88 00000DF9 7604                <1> 	jbe		SHORT .ValidPCHorSinOffsetBX
    89                              <1> .InvalidPCHorSinOffsetBX:
    90 00000DFB 83C402              <1> 	add		sp, BYTE 2		; Clear return address for this function
    91                              <1> .FailedToVerifyAtaID:
    92 00000DFE F9                  <1> 	stc						; Set carry to indicate invalid ATA-ID
    93                              <1> .ValidPCHorSinOffsetBX:
    94 00000DFF C3                  <1> 	ret
    95                              <1> 
    96                              <1> 
    97                              <1> %ifdef MODULE_ADVANCED_ATA
    98                              <1> ;--------------------------------------------------------------------
    99                              <1> ; AtaID_GetMaxPioModeToAXandMinCycleTimeToCX
   100                              <1> ;	Parameters:
   101                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
   102                              <1> ;	Returns:
   103                              <1> ;		AL:		Max supported PIO mode
   104                              <1> ;		AH:		FLGH_DPT_IORDY if IORDY supported, zero otherwise
   105                              <1> ;		CX:		Minimum Cycle Time in nanosecs
   106                              <1> ;	Corrupts registers:
   107                              <1> ;		BX
   108                              <1> ;--------------------------------------------------------------------
   109                              <1> AtaID_GetMaxPioModeToAXandMinCycleTimeToCX:
   110                              <1> 	; Get PIO mode and cycle time for PIO 0...2
   111                              <1> 	mov		bx, [es:si+ATA1.bPioMode]
   112                              <1> 	mov		ax, bx					; AH = 0, AL = PIO mode 0, 1 or 2
   113                              <1> 	eSHL_IM	bx, 1					; Shift for WORD lookup
   114                              <1> 	mov		cx, [cs:bx+.rgwPio0to2CycleTimeInNanosecs]
   115                              <1> 
   116                              <1> 	; Check if IORDY is supported
   117                              <1> 	test	BYTE [es:si+ATA2.wCaps+1], A2_wCaps_IORDY >> 8
   118                              <1> 	jz		SHORT .ReturnPioTimings	; No PIO 3 or higher if no IORDY
   119                              <1> 	mov		ah, FLGH_DPT_IORDY
   120                              <1> 
   121                              <1> 	; Check if Advanced PIO modes are supported (3 and above)
   122                              <1> 	test	BYTE [es:si+ATA2.wFields], A2_wFields_64to70
   123                              <1> 	jz		SHORT .ReturnPioTimings
   124                              <1> 
   125                              <1> 	; Get Advanced PIO mode
   126                              <1> 	; (Hard Disks supports up to 4 but CF cards can support 5 and 6)
   127                              <1> 	mov		bl, [es:si+ATA2.bPIOSupp]
   128                              <1> .CheckNextFlag:
   129                              <1> 	inc		ax
   130                              <1> 	shr		bl, 1
   131                              <1> 	jnz		SHORT .CheckNextFlag
   132                              <1> 	MIN_U	al, 6						; Make sure not above lookup tables
   133                              <1> 	mov		cx, [es:si+ATA2.wPIOMinCyF]	; Advanced modes use IORDY
   134                              <1> .ReturnPioTimings:
   135                              <1> 	ret
   136                              <1> 
   137                              <1> .rgwPio0to2CycleTimeInNanosecs:
   138                              <1> 	dw		PIO_0_MIN_CYCLE_TIME_NS
   139                              <1> 	dw		PIO_1_MIN_CYCLE_TIME_NS
   140                              <1> 	dw		PIO_2_MIN_CYCLE_TIME_NS
   141                              <1> 
   142                              <1> 
   143                              <1> ;--------------------------------------------------------------------
   144                              <1> ; AtaID_GetRecoveryTimeToAXfromPioModeInBXandCycleTimeInCX
   145                              <1> ;	Parameters:
   146                              <1> ;		BX:		PIO Mode
   147                              <1> ;		CX:		PIO Cycle Time in nanosecs
   148                              <1> ;	Returns:
   149                              <1> ;		AX:		Active Time in nanosecs
   150                              <1> ;	Corrupts registers:
   151                              <1> ;		BX, CX
   152                              <1> ;--------------------------------------------------------------------
   153                              <1> AtaID_GetRecoveryTimeToAXfromPioModeInBXandCycleTimeInCX:
   154                              <1> 	call	AtaID_GetActiveTimeToAXfromPioModeInBX
   155                              <1> 	mov		bl, [cs:bx+.rgbPioModeToAddressValidTimeNs]
   156                              <1> 	sub		cx, bx	; Cycle Time (t0) - Address Valid Time (t1)
   157                              <1> 	sub		cx, ax	; - Active Time (t2)
   158                              <1> 	xchg	ax, cx	; AX = Recovery Time (t2i)
   159                              <1> 	ret
   160                              <1> 
   161                              <1> .rgbPioModeToAddressValidTimeNs:
   162                              <1> 	db		PIO_0_MIN_ADDRESS_VALID_NS
   163                              <1> 	db		PIO_1_MIN_ADDRESS_VALID_NS
   164                              <1> 	db		PIO_2_MIN_ADDRESS_VALID_NS
   165                              <1> 	db		PIO_3_MIN_ADDRESS_VALID_NS
   166                              <1> 	db		PIO_4_MIN_ADDRESS_VALID_NS
   167                              <1> 	db		PIO_5_MIN_ADDRESS_VALID_NS
   168                              <1> 	db		PIO_6_MIN_ADDRESS_VALID_NS
   169                              <1> 
   170                              <1> 
   171                              <1> ;--------------------------------------------------------------------
   172                              <1> ; AtaID_GetActiveTimeToAXfromPioModeInBX
   173                              <1> ;	Parameters:
   174                              <1> ;		BX:		PIO Mode
   175                              <1> ;	Returns:
   176                              <1> ;		AX:		Active Time in nanosecs
   177                              <1> ;	Corrupts registers:
   178                              <1> ;		Nothing
   179                              <1> ;--------------------------------------------------------------------
   180                              <1> AtaID_GetActiveTimeToAXfromPioModeInBX:
   181                              <1> 	eMOVZX	ax, [cs:bx+.rgbPioModeToActiveTimeNs]
   182                              <1> 	ret
   183                              <1> 
   184                              <1> .rgbPioModeToActiveTimeNs:
   185                              <1> 	db		PIO_0_MIN_ACTIVE_TIME_NS
   186                              <1> 	db		PIO_1_MIN_ACTIVE_TIME_NS
   187                              <1> 	db		PIO_2_MIN_ACTIVE_TIME_NS
   188                              <1> 	db		PIO_3_MIN_ACTIVE_TIME_NS
   189                              <1> 	db		PIO_4_MIN_ACTIVE_TIME_NS
   190                              <1> 	db		PIO_5_MIN_ACTIVE_TIME_NS
   191                              <1> 	db		PIO_6_MIN_ACTIVE_TIME_NS
   192                              <1> 
   193                              <1> %endif ; MODULE_ADVANCED_ATA
   202                                  	%include "DetectDrives.asm"		; For detecting IDE drives
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for detecting drive for the BIOS.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    21                              <1> 
    22                              <1> ; Section containing code
    23                              <1> SECTION .text
    24                              <1> 
    25                              <1> ;--------------------------------------------------------------------
    26                              <1> ; Detects all IDE hard disks to be controlled by this BIOS.
    27                              <1> ;
    28                              <1> ; DetectDrives_FromAllIDEControllers
    29                              <1> ;	Parameters:
    30                              <1> ;		DS:		RAMVARS segment
    31                              <1> ;		ES:		BDA segment (zero)
    32                              <1> ;	Returns:
    33                              <1> ;		Nothing
    34                              <1> ;	Corrupts registers:
    35                              <1> ;		All (not segments)
    36                              <1> ;--------------------------------------------------------------------
    37                              <1> DetectDrives_FromAllIDEControllers:
    38 00000E00 E887FD              <1> 	call	RamVars_GetIdeControllerCountToCX
    39 00000E03 BD5100              <1> 	mov		bp, ROMVARS.ideVars0			; CS:BP now points to first IDEVARS
    40                              <1> 
    41                              <1> .DriveDetectLoop:							; Loop through IDEVARS
    42 00000E06 51                  <1> 	push	cx
    43                              <1> 
    44 00000E07 B9[9900]            <1> 	mov		cx, g_szDetectMaster
    45 00000E0A B7A0                <1> 	mov		bh, MASK_DRVNHEAD_SET								; Select Master drive
    46 00000E0C E82300              <1> 	call	StartDetectionWithDriveSelectByteInBHandStringInCX	; Detect and create DPT + BOOTNFO
    47                              <1> 
    48 00000E0F B9[9F00]            <1> 	mov		cx, g_szDetectSlave
    49 00000E12 B7B0                <1> 	mov		bh, MASK_DRVNHEAD_SET | FLG_DRVNHEAD_DRV
    50 00000E14 E81B00              <1> 	call	StartDetectionWithDriveSelectByteInBHandStringInCX
    51                              <1> 
    52 00000E17 59                  <1> 	pop		cx
    53                              <1> 
    54 00000E18 83C512              <1> 	add		bp, BYTE IDEVARS_size			; Point to next IDEVARS
    55                              <1> 
    56                              <1> %ifdef MODULE_SERIAL
    57                              <1> 	jcxz	.AddHardDisks					; Set to zero on .ideVarsSerialAuto iteration (if any)
    58                              <1> %endif
    59 00000E1B E2E9                <1> 	loop	.DriveDetectLoop
    60                              <1> 
    61                              <1> %ifdef MODULE_SERIAL
    62                              <1> ;----------------------------------------------------------------------
    63                              <1> ;
    64                              <1> ; if serial drive detected, do not scan (avoids duplicate drives and isn't needed - we already have a connection)
    65                              <1> ;
    66                              <1> 	call	FindDPT_ToDSDIforSerialDevice   ; does not modify AX
    67                              <1> 	jnc		.AddHardDisks
    68                              <1> 
    69                              <1> 	mov		bp, ROMVARS.ideVarsSerialAuto	; Point to our special IDEVARS structure, just for serial scans
    70                              <1> 
    71                              <1> %ifdef MODULE_HOTKEYS
    72                              <1> 	cmp		al, COM_DETECT_HOTKEY_SCANCODE  ; Set by last call to HotkeyBar_UpdateDuringDriveDetection above
    73                              <1> 	je		.DriveDetectLoop
    74                              <1> %endif
    75                              <1> 
    76                              <1> 	mov		al,[cs:ROMVARS.wFlags]			; Configurator set to always scan?
    77                              <1> 	or		al,[es:BDA.bKBFlgs1]			; Or, did the user hold down the ALT key?
    78                              <1> 	and		al,8							; 8 = alt key depressed, same as FLG_ROMVARS_SERIAL_ALWAYSDETECT
    79                              <1> 	jnz		.DriveDetectLoop
    80                              <1> %endif
    81                              <1> 
    82                              <1> .AddHardDisks:
    83                              <1> ;----------------------------------------------------------------------
    84                              <1> ;
    85                              <1> ; Add in hard disks to BDA, finalize our Count and First variables
    86                              <1> ;
    87                              <1> ; Note that we perform the add to bHDCount and store bFirstDrv even if the count is zero.
    88                              <1> ; This is done because we use the value of .bFirstDrv to know how many drives were in the system
    89                              <1> ; at the time of boot, and to return that number on int13h/8h calls.  Because the count is zero,
    90                              <1> ; FindDPT_ForDriveNumber will not find any drives that are ours.
    91                              <1> ;
    92 00000E1D 8B0E0900            <1> 	mov		cx, [RAMVARS.wDrvCntAndFlopCnt]		; Our count of hard disks
    93                              <1> 
    94 00000E21 26A07504            <1> 	mov		al, [es:BDA.bHDCount]
    95 00000E25 00C1                <1> 	add		cl, al						; Add our drives to the system count
    96 00000E27 26880E7504          <1> 	mov		[es:BDA.bHDCount], cl
    97 00000E2C 0C80                <1> 	or		al, 80h						; Or in hard disk flag
    98 00000E2E A20800              <1> 	mov		[RAMVARS.bFirstDrv], al		; Store first drive number
    99                              <1> 
   100                              <1> .AddFloppies:
   101                              <1> %ifdef MODULE_SERIAL_FLOPPY
   102                              <1> ;----------------------------------------------------------------------
   103                              <1> ;
   104                              <1> ; Add in any emulated serial floppy drives, finalize our packed Count and First variables
   105                              <1> ;
   106                              <1> 	dec		ch
   107                              <1> 	mov		al, ch
   108                              <1> 	js		.NoFloppies						; if no drives are present, we store 0ffh
   109                              <1> 
   110                              <1> 	call	FloppyDrive_GetCountFromBIOS_or_BDA
   111                              <1> 
   112                              <1> 	push	ax
   113                              <1> 
   114                              <1> 	add		al, ch							; Add our drives to existing drive count
   115                              <1> 	cmp		al, 3							; For BDA, max out at 4 drives (ours is zero based)
   116                              <1> 	jb		.MaxBDAFloppiesExceeded
   117                              <1> 	mov		al, 3
   118                              <1> .MaxBDAFloppiesExceeded:
   119                              <1> 	eROR_IM	al, 2							; move to bits 6-7
   120                              <1> 	inc		ax								; low order bit, indicating floppy drive exists
   121                              <1> 
   122                              <1> 	mov		ah, [es:BDA.wEquipment]			; Load Equipment WORD low byte
   123                              <1> 	and		ah, 03eh						; Mask off drive number and drives present bit
   124                              <1> 	or		al, ah							; Or in new values
   125                              <1> 	mov		[es:BDA.wEquipment], al			; and store
   126                              <1> 
   127                              <1> 	mov		al, 1eh							; BDA pointer to Floppy DPT
   128                              <1> 	mov		si, AH8h_FloppyDPT
   129                              <1> 	call	Interrupts_InstallHandlerToVectorInALFromCSSI
   130                              <1> 
   131                              <1> 	pop		ax
   132                              <1> 
   133                              <1> 	shr		ch, 1							; number of drives, 1 or 2 only, to CF flag (clear=1, set=2)
   134                              <1> 	rcl		al, 1							; starting drive number in upper 7 bits, number of drives in low bit
   135                              <1> .NoFloppies:
   136                              <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bFlopCntAndFirst], al
   137                              <1> %endif
   138                              <1> 
   139 00000E31 C3                  <1> 	ret
   140                              <1> 
   141                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   142                              <1> 	%if FLG_ROMVARS_SERIAL_SCANDETECT != 8
   143                              <1> 		%error "DetectDrives is currently coded to assume that FLG_ROMVARS_SERIAL_SCANDETECT is the same bit as the ALT key code in the BDA.  Changes in the code will be needed if these values are no longer the same."
   144                              <1> 	%endif
   145                              <1> %endif
   146                              <1> 
   147                              <1> 
   148                              <1> ;--------------------------------------------------------------------
   149                              <1> ; StartDetectionWithDriveSelectByteInBHandStringInCX
   150                              <1> ;	Parameters:
   151                              <1> ;		BH:		Drive Select byte for Drive and Head Register
   152                              <1> ;		CX:		Offset to "Master" or "Slave" string
   153                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
   154                              <1> ;		DS:		RAMVARS segment
   155                              <1> ;		ES:		Zero (BDA segment)
   156                              <1> ;	Returns:
   157                              <1> ;       None
   158                              <1> ;	Corrupts registers:
   159                              <1> ;		AX, BL, CX, DX, SI, DI
   160                              <1> ;--------------------------------------------------------------------
   161                              <1> StartDetectionWithDriveSelectByteInBHandStringInCX:
   162                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   163                              <1> 	; Autodetect port for XT-CF
   164 00000E32 E85800              <1> 	call	DetectDrives_DoesIdevarsInCSBPbelongToXTCF
   165 00000E35 7527                <1> 	jne		SHORT .SkipXTCFportDetection
   166                              <1> 
   167                              <1> 	; XT-CF do not support slave drives so skip detection
   168 00000E37 F6C710              <1> 	test	bh, FLG_DRVNHEAD_DRV
   169 00000E3A 755F                <1> 	jnz		SHORT NoSlaveDriveAvailable
   170                              <1> 
   171                              <1> 	; XT-CF do not support slave drives so we can safely update port
   172                              <1> 	; for next drive (another XT-CF card on same system)
   173                              <1> .DetectNextPort:
   174 00000E3C 268B16047F          <1> 	mov		dx, [es:BOOTVARS.wNextXTCFportToScan]
   175 00000E41 80F240              <1> 	xor		dl, 40h
   176 00000E44 7507                <1> 	jnz		SHORT .StoreNextXTCFportToScan
   177 00000E46 FEC6                <1> 	inc		dh
   178 00000E48 80FE03              <1> 	cmp		dh, XTCF_BASE_PORT_4 >> 8
   179 00000E4B 7711                <1> 	ja		SHORT .SkipXTCFportDetection		; XT-CF not found from any port
   180                              <1> .StoreNextXTCFportToScan:
   181 00000E4D 268916047F          <1> 	mov		[es:BOOTVARS.wNextXTCFportToScan], dx
   182                              <1> 
   183 00000E52 E80E0E              <1> 	call	AH1Eh_DetectXTCFwithBasePortInDX
   184 00000E55 72E5                <1> 	jc		SHORT .DetectNextPort				; XT-CF not found from this port
   185                              <1> 
   186                              <1> 	; We now have autodetected port in DX
   187 00000E57 52                  <1> 	push	dx
   188 00000E58 92                  <1> 	xchg	ax, dx								; Port to print in AX
   189 00000E59 E85000              <1> 	call	DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP
   190 00000E5C EB04                <1> 	jmp		SHORT .DriveDetectionStringPrintedOnScreen
   191                              <1> 
   192                              <1> 	; Print detect string for devices that do not support autodetection
   193                              <1> .SkipXTCFportDetection:
   194 00000E5E 52                  <1> 	push	dx
   195                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
   196                              <1> 
   197 00000E5F E84600              <1> 	call	DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
   198                              <1> .DriveDetectionStringPrintedOnScreen:
   199                              <1> %ifdef MODULE_HOTKEYS
   200 00000E62 E8AE00              <1> 	call	HotkeyBar_UpdateDuringDriveDetection
   201                              <1> %endif
   202                              <1> 
   203                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   204 00000E65 5A                  <1> 	pop		dx
   205                              <1> %endif
   206                              <1> 	; Fall to .ReadAtaInfoFromHardDisk
   207                              <1> 
   208                              <1> 
   209                              <1> ;--------------------------------------------------------------------
   210                              <1> ; .ReadAtaInfoFromHardDisk
   211                              <1> ;	Parameters:
   212                              <1> ;		BH:		Drive Select byte for Drive and Head Register
   213                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
   214                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
   215                              <1> ;		DS:		RAMVARS segment
   216                              <1> ;		ES:		Zero (BDA segment)
   217                              <1> ;	Returns:
   218                              <1> ;		CF:		Cleared if ATA-information read successfully
   219                              <1> ;				Set if any error
   220                              <1> ;	Corrupts registers:
   221                              <1> ;		AX, BL, CX, DX, SI, DI
   222                              <1> ;--------------------------------------------------------------------
   223                              <1> .ReadAtaInfoFromHardDisk:
   224 00000E66 BE007C              <1> 	mov		si, BOOTVARS.rgbAtaInfo		; ES:SI now points to ATA info location
   225 00000E69 06                  <1> 	push	es
   226 00000E6A 56                  <1> 	push	si
   227 00000E6B 52                  <1> 	push	dx
   228 00000E6C 53                  <1> 	push	bx
   229 00000E6D E85805              <1> 	call	Device_IdentifyToBufferInESSIwithDriveSelectByteInBH
   230 00000E70 5B                  <1> 	pop		bx
   231 00000E71 5A                  <1> 	pop		dx
   232 00000E72 5E                  <1> 	pop		si
   233 00000E73 07                  <1> 	pop		es
   234 00000E74 7306                <1> 	jnc		SHORT CreateBiosTablesForHardDisk
   235                              <1> 	; Fall to .ReadAtapiInfoFromDrive
   236                              <1> 
   237                              <1> .ReadAtapiInfoFromDrive:				; Not yet implemented
   238                              <1> 	;call	ReadAtapiInfoFromDrive		; Assume CD-ROM
   239                              <1> 	;jnc	SHORT _CreateBiosTablesForCDROM
   240                              <1> 
   241                              <1> 	;jmp	short DetectDrives_DriveNotFound
   242                              <1> ;;; fall-through instead of previous jmp instruction
   243                              <1> ;--------------------------------------------------------------------
   244                              <1> ; DetectDrives_DriveNotFound
   245                              <1> ;	Parameters:
   246                              <1> ;		Nothing
   247                              <1> ;	Returns:
   248                              <1> ;		CF:     Set (from DetectPrint_NullTerminatedStringFromCSSIandSetCF)
   249                              <1> ;	Corrupts registers:
   250                              <1> ;		AX, SI
   251                              <1> ;--------------------------------------------------------------------
   252                              <1> DetectDrives_DriveNotFound:
   253 00000E76 BE[E900]            <1> 	mov		si, g_szNotFound
   254 00000E79 E98B00              <1> 	jmp		DetectPrint_NullTerminatedStringFromCSSIandSetCF
   255                              <1> 
   256                              <1> 
   257                              <1> ;--------------------------------------------------------------------
   258                              <1> ; CreateBiosTablesForHardDisk
   259                              <1> ;	Parameters:
   260                              <1> ;		BH:		Drive Select byte for Drive and Head Register
   261                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
   262                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
   263                              <1> ;		ES:SI	Ptr to ATA information for the drive
   264                              <1> ;		DS:		RAMVARS segment
   265                              <1> ;		ES:		BDA segment
   266                              <1> ;	Returns:
   267                              <1> ;		Nothing
   268                              <1> ;	Corrupts registers:
   269                              <1> ;		AX, BX, CX, DX, SI, DI
   270                              <1> ;--------------------------------------------------------------------
   271                              <1> CreateBiosTablesForHardDisk:
   272 00000E7C 53                  <1> 	push	bx
   273 00000E7D E841FF              <1> 	call	AtaID_VerifyFromESSI
   274 00000E80 5B                  <1> 	pop		bx
   275 00000E81 72F3                <1> 	jc		SHORT DetectDrives_DriveNotFound
   276 00000E83 E86AFD              <1> 	call	CreateDPT_FromAtaInformation
   277 00000E86 72EE                <1> 	jc		SHORT DetectDrives_DriveNotFound
   278 00000E88 E810FF              <1> 	call	DriveDetectInfo_CreateForHardDisk
   279 00000E8B EB31                <1> 	jmp		SHORT DetectPrint_DriveNameFromDrvDetectInfoInESBX
   280                              <1> 
   281                              <1> 
   282                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   283                              <1> ;--------------------------------------------------------------------
   284                              <1> ; DetectDrives_DoesIdevarsInCSBPbelongToXTCF
   285                              <1> ;	Parameters:
   286                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
   287                              <1> ;	Returns:
   288                              <1> ;		ZF:		Set if IDEVARS belongs to XT-CF device
   289                              <1> ;				Cleared if some other device
   290                              <1> ;	Corrupts registers:
   291                              <1> ;		AL
   292                              <1> ;--------------------------------------------------------------------
   293                              <1> DetectDrives_DoesIdevarsInCSBPbelongToXTCF:
   294 00000E8D 2E8A4604            <1> 	mov		al, [cs:bp+IDEVARS.bDevice]
   295 00000E91 3C0A                <1> 	cmp		al, DEVICE_8BIT_XTCF_PIO8
   296 00000E93 7406                <1> 	je		SHORT .DeviceIsXTCF
   297 00000E95 3C0C                <1> 	cmp		al, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
   298 00000E97 7402                <1> 	je		SHORT .DeviceIsXTCF
   299 00000E99 3C0E                <1> 	cmp		al, DEVICE_8BIT_XTCF_DMA
   300                              <1> .DeviceIsXTCF:
   301                              <1> NoSlaveDriveAvailable:
   302 00000E9B C3                  <1> 	ret
   303                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
   304                              <1> 
   203                                  	%include "DetectPrint.asm"		; For printing drive detection strings
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for printing drive detection strings.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; DetectPrint_InitializeDisplayContext
    25                              <1> ;	Parameters:
    26                              <1> ;		Nothing
    27                              <1> ;	Returns:
    28                              <1> ;		Nothing
    29                              <1> ;	Corrupts registers:
    30                              <1> ;		AX, DI
    31                              <1> ;--------------------------------------------------------------------
    32                              <1> DetectPrint_InitializeDisplayContext:
    33                              <1> 	JMP_DISPLAY_LIBRARY InitializeDisplayContext
    33                              <2>  %ifidn %1, PushDisplayContext
    33                              <2>  jmp DisplayContext_Push
    33                              <2>  %elifidn %1, PopDisplayContext
    33                              <2>  call DisplayContext_Pop
    33                              <2>  ret
    33                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    33                              <2>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    33                              <2>  %elifidn %1, FormatNullTerminatedStringFromCSSI
    33                              <2>  mov di, %1
    33                              <2>  call Display_FunctionFromDI
    33                              <2>  ret
    33                              <2>  %else
    33 00000E9C BF[4D02]            <2>  mov di, %1
    33 00000E9F E94DF3              <2>  jmp Display_FunctionFromDI
    33                              <2>  %endif
    34                              <1> 
    35                              <1> 
    36                              <1> %ifdef MODULE_HOTKEYS
    37                              <1> ;--------------------------------------------------------------------
    38                              <1> ; DetectPrint_GetSoftwareCoordinatesToAX
    39                              <1> ;	Parameters:
    40                              <1> ;		Nothing
    41                              <1> ;	Returns:
    42                              <1> ;		Nothing
    43                              <1> ;	Corrupts registers:
    44                              <1> ;		AX, DI
    45                              <1> ;--------------------------------------------------------------------
    46                              <1> DetectPrint_GetSoftwareCoordinatesToAX:
    47                              <1> 	JMP_DISPLAY_LIBRARY GetSoftwareCoordinatesToAX
    47                              <2>  %ifidn %1, PushDisplayContext
    47                              <2>  jmp DisplayContext_Push
    47                              <2>  %elifidn %1, PopDisplayContext
    47                              <2>  call DisplayContext_Pop
    47                              <2>  ret
    47                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    47                              <2>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    47                              <2>  %elifidn %1, FormatNullTerminatedStringFromCSSI
    47                              <2>  mov di, %1
    47                              <2>  call Display_FunctionFromDI
    47                              <2>  ret
    47                              <2>  %else
    47 00000EA2 BF[1403]            <2>  mov di, %1
    47 00000EA5 E947F3              <2>  jmp Display_FunctionFromDI
    47                              <2>  %endif
    48                              <1> %endif
    49                              <1> 
    50                              <1> 
    51                              <1> ;--------------------------------------------------------------------
    52                              <1> ; DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
    53                              <1> ;	Parameters:
    54                              <1> ;		CS:CX:	Ptr to "Master" or "Slave" string
    55                              <1> ;		CS:BP:	Ptr to IDEVARS
    56                              <1> ;	Returns:
    57                              <1> ;		Nothing
    58                              <1> ;	Corrupts registers:
    59                              <1> ;		AX, CX, DX, SI, DI
    60                              <1> ;--------------------------------------------------------------------
    61                              <1> DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP:
    62 00000EA8 2E8B4600            <1> 	mov		ax, [cs:bp+IDEVARS.wBasePort]   ; for IDE: AX=port address, DH=.bDevice
    63                              <1> 	; fall through to DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP
    64                              <1> 
    65                              <1> ;--------------------------------------------------------------------
    66                              <1> ; DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP
    67                              <1> ;	Parameters:
    68                              <1> ;		AX:		Base Port Address
    69                              <1> ;		CS:CX:	Ptr to "Master" or "Slave" string
    70                              <1> ;		CS:BP:	Ptr to IDEVARS
    71                              <1> ;	Returns:
    72                              <1> ;		Nothing
    73                              <1> ;	Corrupts registers:
    74                              <1> ;		AX, CX, DX, SI, DI
    75                              <1> ;--------------------------------------------------------------------
    76                              <1> DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP:
    77 00000EAC 2E8B5603            <1> 	mov		dx, [cs:bp+IDEVARS.bDevice-1]   ; for Serial: AL=port address>>2, AH=baud rate
    78                              <1> 											;			  DL=COM number character, DH=.bDevice
    79 00000EB0 55                  <1> 	push	bp								; setup stack for call to
    80 00000EB1 89E5                <1> 	mov		bp, sp							; BootMenuPrint_FormatCSSIfromParamsInSSBP
    81                              <1> 
    82 00000EB3 51                  <1> 	push 	cx								; Push "Master" or "Slave"
    83                              <1> 
    84 00000EB4 B1AC                <1> 	mov		cl, (g_szDetectPort-$$) & 0xff	; Setup print string for standard IDE
    85                              <1> 											; Note that we modify only the low order bits of CX a lot here,
    86                              <1> 											; saving code space rather than reloading CX completely.
    87                              <1> 											; This optimization requires that all the g_szDetect* strings are
    88                              <1> 											; on the same 256 byte page, which is checked in strings.asm.
    89                              <1> 
    90                              <1> %ifdef MODULE_SERIAL
    91                              <1> 	cmp		dh, DEVICE_SERIAL_PORT		  	; Check if this is a serial device
    92                              <1> 
    93                              <1> 	jnz		.pushAndPrint					; CX = string to print, AX = port address, DX won't be used
    94                              <1> 
    95                              <1> 	mov		cl, (g_szDetectCOM-$$) & 0xff	; Setup print string for COM ports
    96                              <1> 	push	cx								; And push now.  We use the fact that format strings can contain
    97                              <1> 											; themselves format strings.
    98                              <1> 
    99                              <1> 	push	dx								; Push COM number character
   100                              <1> 											; If the string is going to be "Auto", we will push a NULL (zero)
   101                              <1> 											; here for the COM port number, which will be eaten by the
   102                              <1> 											; print routine (DisplayPrint_CharacterFromAL), resulting in
   103                              <1> 											; just "COM" being printed without a character after it.
   104                              <1> 
   105                              <1>  	mov		cl, (g_szDetectCOMAuto-$$) & 0xff	; Setup secondary print string for "Auto"
   106                              <1> 
   107                              <1> 	test	dl, dl							; Check if serial port "Auto"
   108                              <1> 	jz		.pushAndPrintSerial				; CX = string to print, AX and DX won't be used
   109                              <1> 
   110                              <1> 	mov		cl, (g_szDetectCOMLarge-$$) & 0xff	; Setup secondary print string for "COMn/xx.yK"
   111                              <1> 
   112                              <1> 	mov		al,ah							; baud rate divisor to AL
   113                              <1> 	cbw										; clear AH, AL will always be less than 128
   114                              <1> 	xchg	si,ax							; move AX to SI for divide
   115                              <1> 	mov		ax,1152							; baud rate to display is 115200/divisor, the "00" is handled
   116                              <1> 											; in the print strings
   117                              <1> 	cwd										; clear top 16-bits of dividend
   118                              <1> 	div		si								; and divide...  Now AX = baud rate/100, DX = 0 (always a clean divide)
   119                              <1> 
   120                              <1> 	mov		si,10							; Now separate the whole portion from the fractional for "K" display
   121                              <1> 	div		si								; and divide...  Now AX = baud rate/1000, DX = low order digit
   122                              <1> 
   123                              <1> 	cmp		ax,si							; < 10: "2400", "9600", etc.; >= 10: "19.2K", "38.4K", etc.
   124                              <1> 	jae		.pushAndPrintSerial
   125                              <1> 
   126                              <1> 	mov		cl, (g_szDetectCOMSmall-$$) & 0xff	; Setup secondary print string for "COMn/XXy00"
   127                              <1> 
   128                              <1> .pushAndPrintSerial:
   129                              <1> .pushAndPrint:
   130                              <1> %endif
   131                              <1> 
   132 00000EB6 51                  <1> 	push	cx								; Push print string
   133 00000EB7 50                  <1> 	push	ax								; Push high order digits, or port address, or N/A
   134 00000EB8 52                  <1> 	push	dx								; Push low order digit, or N/A
   135                              <1> 
   136 00000EB9 BE[A500]            <1> 	mov		si, g_szDetectOuter				; Load SI with default wrapper string "IDE %s at %s: "
   137                              <1> 
   138 00000EBC EB4C                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
   139                              <1> 
   140                              <1> 
   141                              <1> ;--------------------------------------------------------------------
   142                              <1> ; DetectPrint_DriveNameFromDrvDetectInfoInESBX
   143                              <1> ;	Parameters:
   144                              <1> ;		ES:BX:	Ptr to DRVDETECTINFO (if drive found)
   145                              <1> ;	Returns:
   146                              <1> ;		Nothing
   147                              <1> ;	Corrupts registers:
   148                              <1> ;		AX, SI, DI
   149                              <1> ;--------------------------------------------------------------------
   150                              <1> DetectPrint_DriveNameFromDrvDetectInfoInESBX:
   151 00000EBE 55                  <1> 	push	bp
   152 00000EBF 89E5                <1> 	mov		bp,sp
   153 00000EC1 8D37                <1> 	lea		si,[bx+DRVDETECTINFO.szDrvName]
   154 00000EC3 56                  <1> 	push	si
   155 00000EC4 BE[D200]            <1> 	mov		si,g_szDriveName
   156 00000EC7 EB41                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
   157                              <1> 
   158                              <1> 
   159                              <1> ;--------------------------------------------------------------------
   160                              <1> ; Prints BIOS name and segment address where it is found.
   161                              <1> ;
   162                              <1> ; DetectPrint_RomFoundAtSegment
   163                              <1> ;	Parameters:
   164                              <1> ;		Nothing
   165                              <1> ;	Returns:
   166                              <1> ;		Nothing
   167                              <1> ;	Corrupts registers:
   168                              <1> ;		AX, SI, DI
   169                              <1> ;--------------------------------------------------------------------
   170                              <1> DetectPrint_RomFoundAtSegment:
   171 00000EC9 BE[AF00]            <1> 	mov		si, g_szRomAt
   172 00000ECC 8CCF                <1> 	mov		di, cs						; BIOS segment address, for later inclusion in the output, parameterized
   173                              <1> 										; so that it can be a different value when using .BootMenuEntry
   174                              <1> 
   175                              <1> .BootMenuEntry:
   176 00000ECE 55                  <1> 	push	bp
   177 00000ECF 89E5                <1> 	mov		bp, sp
   178                              <1> 
   179                              <1> %ifndef USE_186
   180 00000ED1 B80E00              <1> 	mov		ax, ROMVARS.szTitle
   181 00000ED4 50                  <1> 	push	ax
   182 00000ED5 57                  <1> 	push	di							; BIOS segment
   183 00000ED6 041F                <1> 	add		al, ROMVARS.szVersion - ROMVARS.szTitle
   184 00000ED8 50                  <1> 	push	ax
   185                              <1> %else
   186                              <1> 	; szTitle and szVersion have the high order byte of their addresses zero,
   187                              <1> 	; so these push instructions are only 2 bytes
   188                              <1> 	;
   189                              <1> 	push	ROMVARS.szTitle
   190                              <1> 	push	di							; BIOS segment
   191                              <1> 	push	ROMVARS.szVersion
   192                              <1> %endif
   193                              <1> 
   194 00000ED9 EB2F                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
   195                              <1> 
   196                              <1> 
   197                              <1> ;--------------------------------------------------------------------
   198                              <1> ; DetectPrint_FailedToLoadFirstSector
   199                              <1> ;	Parameters:
   200                              <1> ;		AH:		INT 13h error code
   201                              <1> ;	Returns:
   202                              <1> ;		CF:		Set
   203                              <1> ;	Corrupts registers:
   204                              <1> ;		AX, CX, SI, DI
   205                              <1> ;--------------------------------------------------------------------
   206                              <1> DetectPrint_FailedToLoadFirstSector:
   207 00000EDB 55                  <1> 	push	bp
   208 00000EDC 89E5                <1> 	mov		bp, sp
   209                              <1> 	eMOVZX	cx, ah
   209                              <2> %ifndef USE_386
   209                              <2>  %ifidni %1, ax
   209                              <2>  mov al, %2
   209                              <2>  xor ah, ah
   209                              <2>  %elifidni %1, bx
   209                              <2>  mov bl, %2
   209                              <2>  xor bh, bh
   209                              <2>  %elifidni %1, cx
   209 00000EDE 88E1                <2>  mov cl, %2
   209 00000EE0 30ED                <2>  xor ch, ch
   209                              <2>  %elifidni %1, dx
   209                              <2>  mov dl, %2
   209                              <2>  xor dh, dh
   209                              <2>  %else
   209                              <2>  push ax
   209                              <2>  mov al, %2
   209                              <2>  xor ah, ah
   209                              <2>  xchg ax, %1
   209                              <2>  pop ax
   209                              <2>  %endif
   209                              <2> 
   209                              <2> %else
   209                              <2>  movzx %1, %2
   209                              <2> %endif
   210 00000EE2 51                  <1> 	push	cx					; Push INT 13h error code
   211 00000EE3 BE[F200]            <1> 	mov		si, g_szReadError
   212 00000EE6 EB22                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP	; Sets CF
   213                              <1> 
   214                              <1> 
   215                              <1> ;--------------------------------------------------------------------
   216                              <1> ; DetectPrint_TryToBootFromDL
   217                              <1> ;	Parameters:
   218                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
   219                              <1> ;		DS:		RAMVARS segment
   220                              <1> ;	Returns:
   221                              <1> ;		Nothing
   222                              <1> ;	Corrupts registers:
   223                              <1> ;		AX, DH, SI, DI
   224                              <1> ;--------------------------------------------------------------------
   225                              <1> DetectPrint_TryToBootFromDL:
   226 00000EE8 55                  <1> 	push	bp
   227 00000EE9 89E5                <1> 	mov		bp, sp
   228                              <1> 
   229                              <1> %ifdef MODULE_DRIVEXLATE
   230                              <1> 
   231 00000EEB E83901              <1> 	call	DriveXlate_ToOrBack	; DL = Untranslated Drive number
   232 00000EEE 88D6                <1> 	mov		dh, dl
   233 00000EF0 E83401              <1> 	call	DriveXlate_ToOrBack	; DL = Translated Drive number
   234                              <1> 
   235 00000EF3 E81501              <1> 	call	DriveXlate_ConvertDriveNumberFromDLtoDriveLetter	; DL = Translated letter
   236 00000EF6 86D6                <1> 	xchg	dl, dh
   237 00000EF8 E81001              <1> 	call	DriveXlate_ConvertDriveNumberFromDLtoDriveLetter	; DL = Untranslated letter
   238 00000EFB 52                  <1> 	push	dx
   239 00000EFC 86D6                <1> 	xchg	dl, dh
   240 00000EFE 52                  <1> 	push	dx
   241                              <1> 
   242 00000EFF E8F800              <1> 	call	DriveXlate_ConvertDriveLetterInDLtoDriveNumber	; Restore DL
   243                              <1> 
   244                              <1> %else
   245                              <1> 	ePUSH_T	ax, ' '			; No drive translation so print space
   246                              <1> 
   247                              <1> 	; Get boot drive letters
   248                              <1> 	call	FloppyDrive_GetCountToAX
   249                              <1> 	mov		ah, 'A'			; AH = First Floppy Drive letter (always 'A')
   250                              <1> 	add		al, ah
   251                              <1> 	MAX_U	al, 'C'			; AL = First Hard Drive letter ('C', 'D', or 'E')
   252                              <1> 	test	dl, dl
   253                              <1> 	eCMOVNS	al, ah
   254                              <1> 	push	ax
   255                              <1> 
   256                              <1> %endif ; MODULE_DRIVEXLATE
   257                              <1> 
   258 00000F02 BE[D400]            <1> 	mov		si, g_szTryToBoot
   259 00000F05 EB03                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
   260                              <1> 
   261                              <1> 
   262                              <1> ;--------------------------------------------------------------------
   263                              <1> ; DetectPrint_NullTerminatedStringFromCSSI
   264                              <1> ; DetectPrint_NullTerminatedStringFromCSSIandSetCF
   265                              <1> ;	Parameters:
   266                              <1> ;		CS:SI:	Ptr to NULL terminated string to print
   267                              <1> ;	Returns:
   268                              <1> ;		CF:		Set since menu event was handled successfully
   269                              <1> ;	Corrupts registers:
   270                              <1> ;		AX, DI
   271                              <1> ;--------------------------------------------------------------------
   272                              <1> DetectPrint_NullTerminatedStringFromCSSI:
   273                              <1> DetectPrint_NullTerminatedStringFromCSSIandSetCF:
   274                              <1> ;
   275                              <1> ; We send all CSSI strings through the Format routine for the case of
   276                              <1> ; compressed strings, but this doesn't hurt in the non-compressed case either
   277                              <1> ; (perhaps a little slower, but shouldn't be noticeable to the user)
   278                              <1> ; and results in smaller code size.
   279                              <1> ;
   280 00000F07 55                  <1> 	push	bp
   281 00000F08 89E5                <1> 	mov		bp,sp
   282                              <1> 	; Fall to DetectPrint_FormatCSSIfromParamsInSSBP
   283                              <1> 
   284                              <1> ;--------------------------------------------------------------------
   285                              <1> ; DetectPrint_FormatCSSIfromParamsInSSBP
   286                              <1> ;	Parameters:
   287                              <1> ;		CS:SI:	Ptr to string to format
   288                              <1> ;		BP:		SP before pushing parameters
   289                              <1> ;	Returns:
   290                              <1> ;		BP:		Popped from stack
   291                              <1> ;		CF:		Set since menu event was handled successfully
   292                              <1> ;	Corrupts registers:
   293                              <1> ;		AX, DI
   294                              <1> ;--------------------------------------------------------------------
   295                              <1> DetectPrint_FormatCSSIfromParamsInSSBP:
   296                              <1> 	CALL_DISPLAY_LIBRARY FormatNullTerminatedStringFromCSSI
   296                              <2>  %ifidn %1, PushDisplayContext
   296                              <2>  call DisplayContext_Push
   296                              <2>  %elifidn %1, PopDisplayContext
   296                              <2>  call DisplayContext_Pop
   296                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   296                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   296                              <2>  %else
   296 00000F0A BF[0702]            <2>  mov di, %1
   296 00000F0D E8DFF2              <2>  call Display_FunctionFromDI
   296                              <2>  %endif
   297 00000F10 F9                  <1> 	stc				; Successful return from menu event
   298 00000F11 5D                  <1> 	pop		bp
   299 00000F12 C3                  <1> 	ret
   204                                  
   205                                  	; Hotkey Bar
   206                                  %ifdef MODULE_HOTKEYS
   207                                  	%include "HotkeyBar.asm"		; For hotkeys during drive detection and boot menu
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Hotkey Bar related functions.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Scans key presses and draws any hotkey changes.
    25                              <1> ;
    26                              <1> ; HotkeyBar_UpdateDuringDriveDetection
    27                              <1> ;	Parameters:
    28                              <1> ;		DS:		RAMVARS segment
    29                              <1> ;		ES:		BDA segment (zero)
    30                              <1> ;	Returns:
    31                              <1> ;		Nothing
    32                              <1> ;	Corrupts registers:
    33                              <1> ;		AX, CX, DX, SI, DI
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> HotkeyBar_UpdateDuringDriveDetection:
    36 00000F13 E89C00              <1> 	call	ScanHotkeysFromKeyBufferAndStoreToBootvars
    37                              <1> 	; Fall to HotkeyBar_DrawToTopOfScreen
    38                              <1> 
    39                              <1> 
    40                              <1> ;--------------------------------------------------------------------
    41                              <1> ; HotkeyBar_DrawToTopOfScreen
    42                              <1> ;	Parameters:
    43                              <1> ;		DS:		RAMVARS segment
    44                              <1> ;		ES:		BDA segment (zero)
    45                              <1> ;	Returns:
    46                              <1> ;		Nothing
    47                              <1> ;	Corrupts registers:
    48                              <1> ;		AX, CX, DX, SI, DI
    49                              <1> ;--------------------------------------------------------------------
    50                              <1> HotkeyBar_DrawToTopOfScreen:
    51                              <1> 	; Store current screen coordinates to be restored
    52                              <1> 	; when Hotkey Bar is rendered
    53 00000F16 E889FF              <1> 	call	DetectPrint_GetSoftwareCoordinatesToAX
    54 00000F19 50                  <1> 	push	ax
    55                              <1> 
    56 00000F1A E88200              <1> 	call	MoveCursorToScreenTopLeftCorner
    57                              <1> 	; Fall to .PrintFloppyDriveHotkeys
    58                              <1> 
    59                              <1> ;--------------------------------------------------------------------
    60                              <1> ; .PrintFloppyDriveHotkeys
    61                              <1> ;	Parameters:
    62                              <1> ;		DS:		RAMVARS segment
    63                              <1> ;		ES:		BDA segment (zero)
    64                              <1> ;	Returns:
    65                              <1> ;		Nothing
    66                              <1> ;	Corrupts registers:
    67                              <1> ;		AX, CX, DX, SI, DI
    68                              <1> ;--------------------------------------------------------------------
    69                              <1> .PrintFloppyDriveHotkeys:
    70 00000F1D E8AAFC              <1> 	call	FloppyDrive_GetCountToAX
    71 00000F20 85C0                <1> 	test	ax, ax		; Any Floppy Drives?
    72 00000F22 740E                <1> 	jz		SHORT .SkipFloppyDriveHotkeys
    73                              <1> 
    74 00000F24 B841AF              <1> 	mov		ax, (ANGLE_QUOTE_RIGHT << 8) | DEFAULT_FLOPPY_DRIVE_LETTER
    75 00000F27 268A0E087F          <1> 	mov		cl, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bFddLetter]
    76 00000F2C BF[FA00]            <1> 	mov		di, g_szFDD
    77 00000F2F E85000              <1> 	call	FormatDriveHotkeyString
    78                              <1> 
    79                              <1> .SkipFloppyDriveHotkeys:
    80                              <1> 	; Fall to .PrintHardDriveHotkeys
    81                              <1> 
    82                              <1> ;--------------------------------------------------------------------
    83                              <1> ; .PrintHardDriveHotkeys
    84                              <1> ;	Parameters:
    85                              <1> ;		DS:		RAMVARS segment
    86                              <1> ;		ES:		BDA segment (zero)
    87                              <1> ;	Returns:
    88                              <1> ;		Nothing
    89                              <1> ;	Corrupts registers:
    90                              <1> ;		AX, CX, DX, SI, DI
    91                              <1> ;--------------------------------------------------------------------
    92 00000F32 E8E600              <1> 	call	DriveXlate_GetLetterForFirstHardDriveToAX
    93 00000F35 B4AF                <1> 	mov		ah, ANGLE_QUOTE_RIGHT
    94 00000F37 268A0E097F          <1> 	mov		cl, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bHddLetter]
    95 00000F3C BF[0001]            <1> 	mov		di, g_szHDD
    96 00000F3F E84000              <1> 	call	FormatDriveHotkeyString
    97                              <1> 	; Fall to .PrintBootMenuHotkey
    98                              <1> 
    99                              <1> ;--------------------------------------------------------------------
   100                              <1> ; .PrintBootMenuHotkey
   101                              <1> ;	Parameters:
   102                              <1> ;		ES:		BDA segment (zero)
   103                              <1> ;	Returns:
   104                              <1> ;		Nothing
   105                              <1> ;	Corrupts registers:
   106                              <1> ;		AX, CX, DX, SI, DI
   107                              <1> ;--------------------------------------------------------------------
   108                              <1> .PrintBootMenuHotkey:
   109                              <1> %ifdef MODULE_BOOT_MENU
   110 00000F42 B83C32              <1> 	mov		ax, BOOT_MENU_HOTKEY_SCANCODE | ('2' << 8)
   111 00000F45 BF[0601]            <1> 	mov		di, g_szBootMenu
   112 00000F48 E82900              <1> 	call	FormatFunctionHotkeyString
   113                              <1> %endif
   114                              <1> 	; Fall to .PrintComDetectHotkey
   115                              <1> 
   116                              <1> ;--------------------------------------------------------------------
   117                              <1> ; .PrintComDetectHotkey
   118                              <1> ;	Parameters:
   119                              <1> ;		ES:		BDA segment (zero)
   120                              <1> ;	Returns:
   121                              <1> ;		Nothing
   122                              <1> ;	Corrupts registers:
   123                              <1> ;		AX, CX, DX, SI, DI
   124                              <1> ;--------------------------------------------------------------------
   125                              <1> .PrintComDetectHotkey:
   126                              <1> %ifdef MODULE_SERIAL
   127                              <1> 	mov		ax, COM_DETECT_HOTKEY_SCANCODE | ('6' << 8)
   128                              <1> 	mov		di, g_szHotComDetect
   129                              <1> 	call	FormatFunctionHotkeyString
   130                              <1> %endif
   131                              <1> 	; Fall to .PrintRomBootHotkey
   132                              <1> 
   133                              <1> ;--------------------------------------------------------------------
   134                              <1> ; .PrintRomBootHotkey
   135                              <1> ;	Parameters:
   136                              <1> ;		ES:		BDA segment (zero)
   137                              <1> ;	Returns:
   138                              <1> ;		Nothing
   139                              <1> ;	Corrupts registers:
   140                              <1> ;		AX, CX, DX, SI, DI
   141                              <1> ;--------------------------------------------------------------------
   142                              <1> .PrintRomBootHotkey:
   143 00000F4B B84238              <1> 	mov		ax, ROM_BOOT_HOTKEY_SCANCODE | ('8' << 8)
   144 00000F4E BF[1901]            <1> 	mov		di, g_szRomBoot
   145 00000F51 E82000              <1> 	call	FormatFunctionHotkeyString
   146                              <1> 	; Fall to .EndHotkeyBarRendering
   147                              <1> 
   148                              <1> ;--------------------------------------------------------------------
   149                              <1> ; .EndHotkeyBarRendering
   150                              <1> ;	Parameters:
   151                              <1> ;		Stack:	Screen coordinates before drawing Hotkey Bar
   152                              <1> ;	Returns:
   153                              <1> ;		Nothing
   154                              <1> ;	Corrupts registers:
   155                              <1> ;		AX, CX, DI
   156                              <1> ;--------------------------------------------------------------------
   157                              <1> .EndHotkeyBarRendering:
   158 00000F54 E80300              <1> 	call	HotkeyBar_ClearRestOfTopRow
   159 00000F57 58                  <1> 	pop		ax
   160 00000F58 EB47                <1> 	jmp		SHORT HotkeyBar_RestoreCursorCoordinatesFromAX
   161                              <1> 
   162                              <1> 
   163                              <1> ;--------------------------------------------------------------------
   164                              <1> ; HotkeyBar_ClearRestOfTopRow
   165                              <1> ;	Parameters:
   166                              <1> ;		Nothing
   167                              <1> ;	Returns:
   168                              <1> ;		Nothing
   169                              <1> ;	Corrupts registers:
   170                              <1> ;		AX, CX, DI
   171                              <1> ;--------------------------------------------------------------------
   172                              <1> HotkeyBar_ClearRestOfTopRow:
   173                              <1> 	CALL_DISPLAY_LIBRARY GetColumnsToALandRowsToAH
   173                              <2>  %ifidn %1, PushDisplayContext
   173                              <2>  call DisplayContext_Push
   173                              <2>  %elifidn %1, PopDisplayContext
   173                              <2>  call DisplayContext_Pop
   173                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   173                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   173                              <2>  %else
   173 00000F5A BF[5703]            <2>  mov di, %1
   173 00000F5D E88FF2              <2>  call Display_FunctionFromDI
   173                              <2>  %endif
   174                              <1> 	eMOVZX	cx, al
   174                              <2> %ifndef USE_386
   174                              <2>  %ifidni %1, ax
   174                              <2>  mov al, %2
   174                              <2>  xor ah, ah
   174                              <2>  %elifidni %1, bx
   174                              <2>  mov bl, %2
   174                              <2>  xor bh, bh
   174                              <2>  %elifidni %1, cx
   174 00000F60 88C1                <2>  mov cl, %2
   174 00000F62 30ED                <2>  xor ch, ch
   174                              <2>  %elifidni %1, dx
   174                              <2>  mov dl, %2
   174                              <2>  xor dh, dh
   174                              <2>  %else
   174                              <2>  push ax
   174                              <2>  mov al, %2
   174                              <2>  xor ah, ah
   174                              <2>  xchg ax, %1
   174                              <2>  pop ax
   174                              <2>  %endif
   174                              <2> 
   174                              <2> %else
   174                              <2>  movzx %1, %2
   174                              <2> %endif
   175                              <1> 	CALL_DISPLAY_LIBRARY GetSoftwareCoordinatesToAX
   175                              <2>  %ifidn %1, PushDisplayContext
   175                              <2>  call DisplayContext_Push
   175                              <2>  %elifidn %1, PopDisplayContext
   175                              <2>  call DisplayContext_Pop
   175                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   175                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   175                              <2>  %else
   175 00000F64 BF[1403]            <2>  mov di, %1
   175 00000F67 E885F2              <2>  call Display_FunctionFromDI
   175                              <2>  %endif
   176 00000F6A 28C1                <1> 	sub		cl, al
   177 00000F6C B020                <1> 	mov		al, ' '
   178                              <1> 	JMP_DISPLAY_LIBRARY PrintRepeatedCharacterFromALwithCountInCX
   178                              <2>  %ifidn %1, PushDisplayContext
   178                              <2>  jmp DisplayContext_Push
   178                              <2>  %elifidn %1, PopDisplayContext
   178                              <2>  call DisplayContext_Pop
   178                              <2>  ret
   178                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   178                              <2>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   178                              <2>  %elifidn %1, FormatNullTerminatedStringFromCSSI
   178                              <2>  mov di, %1
   178                              <2>  call Display_FunctionFromDI
   178                              <2>  ret
   178                              <2>  %else
   178 00000F6E BF[9E03]            <2>  mov di, %1
   178 00000F71 E97BF2              <2>  jmp Display_FunctionFromDI
   178                              <2>  %endif
   179                              <1> 
   180                              <1> 
   181                              <1> ;--------------------------------------------------------------------
   182                              <1> ; FormatDriveHotkeyString
   183                              <1> ;	Parameters:
   184                              <1> ;		CL:			Drive letter hotkey from BOOTVARS
   185                              <1> ;		AL:			First character for drive key string
   186                              <1> ;		AH:			Second character for drive key string (ANGLE_QUOTE_RIGHT)
   187                              <1> ;		SI:			Offset to hotkey description string
   188                              <1> ;		ES:			BDA segment (zero)
   189                              <1> ;	Returns:
   190                              <1> ;		Nothing
   191                              <1> ;	Corrupts registers:
   192                              <1> ;		AX, CX, DX, SI, DI
   193                              <1> ;--------------------------------------------------------------------
   194                              <1> ;; No work to do before going into FormatFunctionHotkeyString
   195                              <1> FormatDriveHotkeyString  equ  GetNonSelectedHotkeyDescriptionAttributeToDX
   196                              <1> 
   197                              <1> ;--------------------------------------------------------------------
   198                              <1> ; FormatFunctionHotkeyString
   199                              <1> ;	Parameters:
   200                              <1> ;		AL:			Scancode of function key, to know which if any to show as selected
   201                              <1> ;					Later replaced with an 'F' for the call to the output routine
   202                              <1> ;		AH:			Second character for drive key string
   203                              <1> ;		SI:			Offset to hotkey description string
   204                              <1> ;		ES:			BDA segment (zero)
   205                              <1> ;	Returns:
   206                              <1> ;		Nothing
   207                              <1> ;	Corrupts registers:
   208                              <1> ;		AX, CX, DX, SI, DI
   209                              <1> ;--------------------------------------------------------------------
   210                              <1> FormatFunctionHotkeyString:
   211 00000F74 31C9                <1> 	xor		cx, cx		; Null character, eaten in output routines
   212                              <1> 
   213 00000F76 2638060B7F          <1> 	cmp		[es:BOOTVARS.hotkeyVars+HOTKEYVARS.bScancode], al
   214 00000F7B B046                <1> 	mov		al, 'F'		; Replace scancode with character for output
   215                              <1> 
   216                              <1> %ifdef MODULE_BOOT_MENU
   217                              <1> 
   218 00000F7D BE0500              <1> 	mov		si, ATTRIBUTE_CHARS.cHurryTimeout		; Selected hotkey
   219 00000F80 7403                <1> 	je		SHORT GetDescriptionAttributeToDX		; From compare with bScancode above
   220                              <1> 
   221                              <1> GetNonSelectedHotkeyDescriptionAttributeToDX:
   222 00000F82 BE0400              <1> 	mov		si, ATTRIBUTE_CHARS.cHighlightedItem	; Unselected hotkey
   223                              <1> 
   224                              <1> 	; Display Library should not be called like this
   225                              <1> GetDescriptionAttributeToDX:
   226 00000F85 92                  <1> 	xchg	dx, ax
   227 00000F86 E861F5              <1> 	call	MenuAttribute_GetToAXfromTypeInSI
   228 00000F89 92                  <1> 	xchg	dx, ax					; DX = Description attribute
   229                              <1> 	;;  fall through to PushHotkeyParamsAndFormat
   230                              <1> 
   231                              <1> 
   232                              <1> %else ; if no MODULE_BOOT_MENU - No boot menu so use simpler attributes
   233                              <1> 
   234                              <1> 	mov		dx, (COLOR_ATTRIBUTE(COLOR_YELLOW, COLOR_CYAN) << 8) | MONO_REVERSE_BLINK
   235                              <1> 	je		SHORT SelectAttributeFromDHorDLbasedOnVideoMode		; From compare with bScancode above
   236                              <1> 
   237                              <1> GetNonSelectedHotkeyDescriptionAttributeToDX:
   238                              <1> 	mov		dx, (COLOR_ATTRIBUTE(COLOR_BLACK, COLOR_CYAN) << 8) | MONO_REVERSE
   239                              <1> 
   240                              <1> SelectAttributeFromDHorDLbasedOnVideoMode:
   241                              <1> 	mov		ch, [es:BDA.bVidMode]		; We only need to preserve CL
   242                              <1> 	shr		ch, 1
   243                              <1> 	jnc		SHORT .AttributeLoadedToDL	; Black & White modes
   244                              <1> 	shr		ch, 1
   245                              <1> 	jnz		SHORT .AttributeLoadedToDL	; MDA
   246                              <1> 	mov		dl, dh
   247                              <1> .AttributeLoadedToDL:
   248                              <1> 	;;  fall through to PushHotkeyParamsAndFormat
   249                              <1> 
   250                              <1> %endif ; MODULE_BOOT_MENU
   251                              <1> 
   252                              <1> 
   253                              <1> ;--------------------------------------------------------------------
   254                              <1> ; PushHotkeyParamsAndFormat
   255                              <1> ;	Parameters:
   256                              <1> ;		AL:			First character
   257                              <1> ;		AH:			Second character
   258                              <1> ;		DX:			Description Attribute
   259                              <1> ;		CX:			Description string parameter
   260                              <1> ;		CS:DI:		Description string
   261                              <1> ;	Returns:
   262                              <1> ;		Nothing
   263                              <1> ;	Corrupts registers:
   264                              <1> ;		AX, SI, DI
   265                              <1> ;--------------------------------------------------------------------
   266                              <1> PushHotkeyParamsAndFormat:
   267 00000F8A 55                  <1> 	push	bp
   268 00000F8B 89E5                <1> 	mov		bp, sp
   269                              <1> 
   270 00000F8D BE0F00              <1> 	mov		si, MONO_BRIGHT
   271                              <1> 
   272 00000F90 56                  <1> 	push	si				; Key attribute
   273 00000F91 50                  <1> 	push	ax				; First Character
   274 00000F92 88E0                <1> 	mov		al, ah
   275 00000F94 50                  <1> 	push	ax				; Second Character
   276                              <1> 
   277 00000F95 52                  <1> 	push	dx				; Description attribute
   278 00000F96 57                  <1> 	push	di				; Description string
   279 00000F97 51                  <1> 	push	cx				; Description string parameter
   280                              <1> 
   281 00000F98 56                  <1> 	push	si				; Key attribute for last space
   282                              <1> 
   283 00000F99 BE[0E01]            <1> 	mov		si, g_szHotkey
   284 00000F9C E96BFF              <1> 	jmp		DetectPrint_FormatCSSIfromParamsInSSBP
   285                              <1> 
   286                              <1> 
   287                              <1> ;--------------------------------------------------------------------
   288                              <1> ; MoveCursorToScreenTopLeftCorner
   289                              <1> ;	Parameters:
   290                              <1> ;		Nothing
   291                              <1> ;	Returns:
   292                              <1> ;		Nothing
   293                              <1> ;	Corrupts registers:
   294                              <1> ;		AX, DI
   295                              <1> ;--------------------------------------------------------------------
   296                              <1> MoveCursorToScreenTopLeftCorner:
   297 00000F9F 31C0                <1> 	xor		ax, ax			; Top left corner (0, 0)
   298                              <1> 	; Fall to HotkeyBar_RestoreCursorCoordinatesFromAX
   299                              <1> 
   300                              <1> 
   301                              <1> ;--------------------------------------------------------------------
   302                              <1> ; HotkeyBar_RestoreCursorCoordinatesFromAX
   303                              <1> ;	Parameters:
   304                              <1> ;		Nothing
   305                              <1> ;	Returns:
   306                              <1> ;		Nothing
   307                              <1> ;	Corrupts registers:
   308                              <1> ;		AX, DI
   309                              <1> ;--------------------------------------------------------------------
   310                              <1> HotkeyBar_RestoreCursorCoordinatesFromAX:
   311                              <1> 	JMP_DISPLAY_LIBRARY SetCursorCoordinatesFromAX
   311                              <2>  %ifidn %1, PushDisplayContext
   311                              <2>  jmp DisplayContext_Push
   311                              <2>  %elifidn %1, PopDisplayContext
   311                              <2>  call DisplayContext_Pop
   311                              <2>  ret
   311                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   311                              <2>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   311                              <2>  %elifidn %1, FormatNullTerminatedStringFromCSSI
   311                              <2>  mov di, %1
   311                              <2>  call Display_FunctionFromDI
   311                              <2>  ret
   311                              <2>  %else
   311 00000FA1 BF[FF02]            <2>  mov di, %1
   311 00000FA4 E948F2              <2>  jmp Display_FunctionFromDI
   311                              <2>  %endif
   312                              <1> 
   313                              <1> 
   314                              <1> ;--------------------------------------------------------------------
   315                              <1> ; HotkeyBar_StoreHotkeyToBootvarsForDriveNumberInDL
   316                              <1> ;	Parameters:
   317                              <1> ;		DS:		RAMVARS segment
   318                              <1> ;		ES:		BDA segment (zero)
   319                              <1> ;		DL:		Drive Number
   320                              <1> ;	Returns:
   321                              <1> ;		Nothing
   322                              <1> ;	Corrupts registers:
   323                              <1> ;		AX, CX, DL, DI
   324                              <1> ;--------------------------------------------------------------------
   325                              <1> HotkeyBar_StoreHotkeyToBootvarsForDriveNumberInDL:
   326 00000FA7 E86100              <1> 	call	DriveXlate_ConvertDriveNumberFromDLtoDriveLetter
   327                              <1> 	; Fall to StoreHotkeyToBootvarsForDriveLetterInDL
   328                              <1> 
   329                              <1> 
   330                              <1> ;--------------------------------------------------------------------
   331                              <1> ; StoreHotkeyToBootvarsForDriveLetterInDL
   332                              <1> ;	Parameters:
   333                              <1> ;		DS:		RAMVARS segment
   334                              <1> ;		ES:		BDA segment (zero)
   335                              <1> ;		DL:		Drive Letter ('A'...)
   336                              <1> ;	Returns:
   337                              <1> ;		Nothing
   338                              <1> ;	Corrupts registers:
   339                              <1> ;		AX, CX, DI
   340                              <1> ;--------------------------------------------------------------------
   341                              <1> StoreHotkeyToBootvarsForDriveLetterInDL:
   342                              <1> 	eMOVZX	ax, dl
   342                              <2> %ifndef USE_386
   342                              <2>  %ifidni %1, ax
   342 00000FAA 88D0                <2>  mov al, %2
   342 00000FAC 30E4                <2>  xor ah, ah
   342                              <2>  %elifidni %1, bx
   342                              <2>  mov bl, %2
   342                              <2>  xor bh, bh
   342                              <2>  %elifidni %1, cx
   342                              <2>  mov cl, %2
   342                              <2>  xor ch, ch
   342                              <2>  %elifidni %1, dx
   342                              <2>  mov dl, %2
   342                              <2>  xor dh, dh
   342                              <2>  %else
   342                              <2>  push ax
   342                              <2>  mov al, %2
   342                              <2>  xor ah, ah
   342                              <2>  xchg ax, %1
   342                              <2>  pop ax
   342                              <2>  %endif
   342                              <2> 
   342                              <2> %else
   342                              <2>  movzx %1, %2
   342                              <2> %endif
   343 00000FAE 0C20                <1> 	or		al, 32	; Upper case drive letter to lower case keystroke
   344 00000FB0 EB09                <1> 	jmp		SHORT HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX
   345                              <1> 
   346                              <1> 
   347                              <1> ;--------------------------------------------------------------------
   348                              <1> ; ScanHotkeysFromKeyBufferAndStoreToBootvars
   349                              <1> ;	Parameters:
   350                              <1> ;		DS:		RAMVARS segment
   351                              <1> ;		ES:		BDA segment (zero)
   352                              <1> ;	Returns:
   353                              <1> ;		AL:		Last scancode value
   354                              <1> ;	Corrupts registers:
   355                              <1> ;		AH, CX
   356                              <1> ;--------------------------------------------------------------------
   357                              <1> ScanHotkeysFromKeyBufferAndStoreToBootvars:
   358 00000FB2 E8B4F4              <1> 	call	Keyboard_GetKeystrokeToAX
   359 00000FB5 742A                <1> 	jz		SHORT NoHotkeyToProcess
   360                              <1> 
   361                              <1> 	; Prepare to read another key from buffer
   362                              <1> 	ePUSH_T	cx, ScanHotkeysFromKeyBufferAndStoreToBootvars
   362                              <2> %ifndef USE_186
   362                              <2>  %ifidni %2, 0
   362                              <2>  xor %1, %1
   362                              <2>  %else
   362 00000FB7 B9[B20F]            <2>  mov %1, %2
   362                              <2>  %endif
   362 00000FBA 51                  <2>  push %1
   362                              <2> 
   362                              <2> %else
   362                              <2>  push %2
   362                              <2> %endif
   363                              <1> 	; Fall to HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX
   364                              <1> 
   365                              <1> 
   366                              <1> ;--------------------------------------------------------------------
   367                              <1> ; HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX
   368                              <1> ;	Parameters:
   369                              <1> ;		AL:		Hotkey ASCII code
   370                              <1> ;		AH:		Hotkey Scancode
   371                              <1> ;		DS:		RAMVARS segment
   372                              <1> ;		ES:		BDA segment (zero)
   373                              <1> ;	Returns:
   374                              <1> ;       AL:     Last scancode seen
   375                              <1> ;		CF:		Set if valid hotkey in AL
   376                              <1> ;				Clear if scancode in AL is not for any hotkey
   377                              <1> ;	Corrupts registers:
   378                              <1> ;		AH, CX, DI
   379                              <1> ;--------------------------------------------------------------------
   380                              <1> HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX:
   381 00000FBB BF0B7F              <1> 	mov		di, BOOTVARS.hotkeyVars+HOTKEYVARS.bScancode
   382                              <1> 
   383                              <1> 	; All scancodes are saved, even if it wasn't a drive letter,
   384                              <1> 	; which also covers our function key case.  Invalid function keys
   385                              <1> 	; will not do anything (won't be printed, won't be accepted as input)
   386 00000FBE 268825              <1> 	mov		[es:di], ah
   387                              <1> 
   388                              <1> 	; Drive letter hotkeys remaining, allow 'a' to 'z'
   389 00000FC1 E8DEF9              <1> 	call	Char_IsLowerCaseLetterInAL
   390 00000FC4 731B                <1> 	jnc		SHORT .KeystrokeIsNotValidDriveLetter
   391 00000FC6 24DF                <1> 	and		al, ~32					; We want to print upper case letters
   392                              <1> 
   393                              <1> 	; Clear HD First flag to assume Floppy Drive hotkey
   394 00000FC8 4F                  <1> 	dec		di
   395 00000FC9 268025FE            <1> 	and		BYTE [es:di], ~FLG_HOTKEY_HD_FIRST
   396                              <1> 
   397                              <1> 	; Determine if Floppy or Hard Drive hotkey
   398 00000FCD 91                  <1> 	xchg	cx, ax
   399 00000FCE E84A00              <1> 	call	DriveXlate_GetLetterForFirstHardDriveToAX
   400 00000FD1 38C1                <1> 	cmp		cl, al
   401 00000FD3 7204                <1> 	jb		SHORT .StoreDriveLetter	; Store Floppy Drive letter
   402                              <1> 
   403                              <1> 	; Store Hard Drive letter
   404 00000FD5 26800D01            <1> 	or		BYTE [es:di], FLG_HOTKEY_HD_FIRST
   405                              <1> 
   406                              <1> .StoreDriveLetter:
   407 00000FD9 83DF01              <1> 	sbb		di, BYTE 1				; Sub CF if Floppy Drive
   408 00000FDC 91                  <1> 	xchg	ax, cx
   409 00000FDD 268805              <1> 	mov		[es:di], al
   410 00000FE0 F9                  <1> 	stc								; Valid hotkey scancode returned in AL
   411                              <1> 
   412                              <1> .KeystrokeIsNotValidDriveLetter:
   413                              <1> NoHotkeyToProcess:
   414 00000FE1 26A00B7F            <1> 	mov		al, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bScancode]
   415 00000FE5 C3                  <1> 	ret
   416                              <1> 
   417                              <1> 
   418                              <1> ;--------------------------------------------------------------------
   419                              <1> ; HotkeyBar_GetBootDriveNumbersToDX
   420                              <1> ;	Parameters:
   421                              <1> ;		DS:		RAMVARS segment
   422                              <1> ;		ES:		BDA segment (zero)
   423                              <1> ;	Returns:
   424                              <1> ;		DX:		Drives selected as boot device, DL is primary
   425                              <1> ;	Corrupts registers:
   426                              <1> ;		AX
   427                              <1> ;--------------------------------------------------------------------
   428                              <1> HotkeyBar_GetBootDriveNumbersToDX:
   429 00000FE6 268B16087F          <1> 	mov		dx, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.wFddAndHddLetters]
   430 00000FEB 26F6060A7F01        <1> 	test	BYTE [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bFlags], FLG_HOTKEY_HD_FIRST
   431 00000FF1 7502                <1> 	jnz		.noflip
   432 00000FF3 86D6                <1> 	xchg	dl, dh
   433                              <1> .noflip:
   434 00000FF5 E80200              <1> 	call	DriveXlate_ConvertDriveLetterInDLtoDriveNumber
   435 00000FF8 86D6                <1> 	xchg	dl, dh
   436                              <1> 	; Fall to HotkeyBar_FallThroughTo_DriveXlate_ConvertDriveLetterInDLtoDriveNumber
   437                              <1> 
   438                              <1> HotkeyBar_FallThroughTo_DriveXlate_ConvertDriveLetterInDLtoDriveNumber:
   439                              <1> 
   208                                  %endif
   209                                  %ifdef MODULE_DRIVEXLATE
   210                                  	%include "DriveXlate.asm"		; For swapping drive numbers, must come immediately after HotkeyBar.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for swapping drive letters.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; DriveXlate_ConvertDriveLetterInDLtoDriveNumber
    25                              <1> ;	Parameters:
    26                              <1> ;		DS:		RAMVARS segment
    27                              <1> ;		DL:		Drive letter ('A'...)
    28                              <1> ;	Returns:
    29                              <1> ;		DL:		Drive number (0xh for Floppy Drives, 8xh for Hard Drives)
    30                              <1> ;	Corrupts registers:
    31                              <1> ;		AX
    32                              <1> ;--------------------------------------------------------------------
    33                              <1> DriveXlate_ConvertDriveLetterInDLtoDriveNumber:
    34 00000FFA E81E00              <1> 	call	DriveXlate_GetLetterForFirstHardDriveToAX
    35 00000FFD 38C2                <1> 	cmp		dl, al
    36 00000FFF 7206                <1> 	jb		SHORT .ConvertLetterInDLtoFloppyDriveNumber
    37                              <1> 
    38                              <1> 	; Convert letter in DL to Hard Drive number
    39 00001001 28C2                <1> 	sub		dl, al
    40 00001003 80CA80              <1> 	or		dl, 80h
    41 00001006 C3                  <1> 	ret
    42                              <1> 
    43                              <1> .ConvertLetterInDLtoFloppyDriveNumber:
    44 00001007 80EA41              <1> 	sub		dl, DEFAULT_FLOPPY_DRIVE_LETTER
    45 0000100A C3                  <1> 	ret
    46                              <1> 
    47                              <1> %ifdef MODULE_HOTKEY
    48                              <1> %if HotkeyBar_FallThroughTo_DriveXlate_ConvertDriveLetterInDLtoDriveNumber <> DriveXlate_ConvertDriveLetterInDLtoDriveNumber
    49                              <1> 	%error "DriveXlate_ConvertDriveLetterInDLtoDriveNumber must be at the top of DriveXlate.asm, and that file must immediately follow HotKeys.asm"
    50                              <1> %endif
    51                              <1> %endif
    52                              <1> 
    53                              <1> ;--------------------------------------------------------------------
    54                              <1> ; DriveXlate_ConvertDriveNumberFromDLtoDriveLetter
    55                              <1> ;	Parameters:
    56                              <1> ;		DL:		Drive number (0xh for Floppy Drives, 8xh for Hard Drives)
    57                              <1> ;		DS:		RAMVARS Segment
    58                              <1> ;	Returns:
    59                              <1> ;		DL:		Drive letter ('A'...)
    60                              <1> ;		CF:		Set if Hard Drive
    61                              <1> ;				Clear if Floppy Drive
    62                              <1> ;	Corrupts registers:
    63                              <1> ;		AX
    64                              <1> ;--------------------------------------------------------------------
    65                              <1> DriveXlate_ConvertDriveNumberFromDLtoDriveLetter:
    66 0000100B 80F280              <1> 	xor		dl, 80h
    67 0000100E 7807                <1> 	js		SHORT .GetDefaultFloppyDrive
    68                              <1> 
    69                              <1> 	; Store default hard drive to boot from
    70 00001010 E80800              <1> 	call	DriveXlate_GetLetterForFirstHardDriveToAX
    71 00001013 00C2                <1> 	add		dl, al
    72 00001015 F9                  <1> 	stc
    73 00001016 C3                  <1> 	ret
    74                              <1> 
    75                              <1> .GetDefaultFloppyDrive:
    76 00001017 80EA3F              <1> 	sub		dl, 80h - DEFAULT_FLOPPY_DRIVE_LETTER	; Clears CF
    77 0000101A C3                  <1> 	ret
    78                              <1> 
    79                              <1> 
    80                              <1> ;--------------------------------------------------------------------
    81                              <1> ; Returns letter for first hard disk. Usually it will be 'C' but it
    82                              <1> ; can be higher if more than two floppy drives are found.
    83                              <1> ;
    84                              <1> ; DriveXlate_GetLetterForFirstHardDriveToAX
    85                              <1> ;	Parameters:
    86                              <1> ;		DS:		RAMVARS segment
    87                              <1> ;	Returns:
    88                              <1> ;		AX:		Upper case letter for first hard disk
    89                              <1> ;	Corrupts registers:
    90                              <1> ;		Nothing
    91                              <1> ;--------------------------------------------------------------------
    92                              <1> DriveXlate_GetLetterForFirstHardDriveToAX:
    93 0000101B E8ACFB              <1> 	call	FloppyDrive_GetCountToAX
    94 0000101E 0441                <1> 	add		al, DEFAULT_FLOPPY_DRIVE_LETTER
    95                              <1> 	MAX_U	al, DEFAULT_HARD_DRIVE_LETTER
    95 00001020 3C43                <2>  cmp %1, %2
    95 00001022 7702                <2>  ja %%Return
    95 00001024 B043                <2>  mov %1, %2
    95                              <2> ALIGN JUMP_ALIGN
    95                              <2> %%Return:
    96 00001026 C3                  <1> 	ret
    97                              <1> 
    98                              <1> 
    99                              <1> ;--------------------------------------------------------------------
   100                              <1> ; DriveXlate_ToOrBack
   101                              <1> ;	Parameters:
   102                              <1> ;		DL:		Drive number to be possibly translated
   103                              <1> ;		DS:		RAMVARS segment
   104                              <1> ;	Returns:
   105                              <1> ;		DL:		Translated drive number
   106                              <1> ;	Corrupts registers:
   107                              <1> ;		DI
   108                              <1> ;--------------------------------------------------------------------
   109                              <1> ALIGN JUMP_ALIGN
   110                              <1> DriveXlate_ToOrBack:
   111 00001027 97                  <1> 	xchg	di, ax					; Backup AX
   112                              <1> 
   113 00001028 B480                <1> 	mov		ah, 80h					; Assume hard disk
   114 0000102A A00D00              <1> 	mov		al, [RAMVARS.xlateVars+XLATEVARS.bHDSwap]
   115 0000102D 84E2                <1> 	test	dl, ah					; Hard disk?
   116 0000102F 7504                <1> 	jnz		SHORT .SwapDrive		; If so, jump to swap
   117 00001031 A00C00              <1> 	mov		al, [RAMVARS.xlateVars+XLATEVARS.bFDSwap]
   118 00001034 98                  <1> 	cbw
   119                              <1> 
   120                              <1> ALIGN JUMP_ALIGN
   121                              <1> .SwapDrive:
   122 00001035 38D4                <1> 	cmp		ah, dl					; Swap DL from 00h/80h to xxh?
   123 00001037 7406                <1> 	je		SHORT .SwapToXXhInAL
   124 00001039 38D0                <1> 	cmp		al, dl					; Swap DL from xxh to 00h/80h?
   125 0000103B 7504                <1> 	jne		SHORT .RestoreAXandReturn
   126 0000103D 88E0                <1> 	mov		al, ah
   127                              <1> ALIGN JUMP_ALIGN
   128                              <1> .SwapToXXhInAL:
   129 0000103F 88C2                <1> 	mov		dl, al
   130                              <1> ALIGN JUMP_ALIGN
   131                              <1> .RestoreAXandReturn:
   132 00001041 97                  <1> 	xchg	ax, di					; Restore AX
   133 00001042 C3                  <1> 	ret
   134                              <1> 
   135                              <1> 
   136                              <1> ;--------------------------------------------------------------------
   137                              <1> ; Resets drive swapping variables to defaults (no swapping).
   138                              <1> ;
   139                              <1> ; DriveXlate_Reset
   140                              <1> ;	Parameters:
   141                              <1> ;		DS:		RAMVARS segment
   142                              <1> ;	Returns:
   143                              <1> ;		Nothing
   144                              <1> ;	Corrupts registers:
   145                              <1> ;		Nothing
   146                              <1> ;--------------------------------------------------------------------
   147                              <1> DriveXlate_Reset:
   148 00001043 C7060C000080        <1> 	mov		WORD [RAMVARS.xlateVars+XLATEVARS.wFDandHDswap], 8000h
   149 00001049 C3                  <1> 	ret
   150                              <1> 
   151                              <1> 
   152                              <1> ;--------------------------------------------------------------------
   153                              <1> ; Stores drive to be swapped.
   154                              <1> ;
   155                              <1> ; DriveXlate_SetDriveToSwap
   156                              <1> ;	Parameters:
   157                              <1> ;		DL:		Hard Drive to swap to first Hard Drive
   158                              <1> ;				Floppy Drive to swap to first Floppy Drive
   159                              <1> ;		DS:		RAMVARS segment
   160                              <1> ;	Returns:
   161                              <1> ;		Nothing
   162                              <1> ;	Corrupts registers:
   163                              <1> ;		Nothing
   164                              <1> ;--------------------------------------------------------------------
   165                              <1> DriveXlate_SetDriveToSwap:
   166 0000104A 84D2                <1> 	test	dl, dl				; Floppy drive?
   167 0000104C 7805                <1> 	js		SHORT .SetHardDriveToSwap
   168                              <1> 
   169                              <1> 	; Set Floppy Drive to swap
   170 0000104E 88160C00            <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bFDSwap], dl
   171 00001052 C3                  <1> 	ret
   172                              <1> 
   173                              <1> .SetHardDriveToSwap:
   174 00001053 88160D00            <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bHDSwap], dl
   175 00001057 C3                  <1> 	ret
   211                                  %endif
   212                                  
   213                                  	; Boot menu
   214                                  %ifdef MODULE_BOOT_MENU
   215                                  	%include "BootMenu.asm"			; For Boot Menu operations
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Displays Boot Menu.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Displays Boot Menu and returns Drive or Function number.
    25                              <1> ;
    26                              <1> ; BootMenu_DisplayAndReturnDriveInDLRomBootClearCF
    27                              <1> ;	Parameters:
    28                              <1> ;		DS:		RAMVARS segment
    29                              <1> ;	Returns:
    30                              <1> ;		DL:		Drive number selected
    31                              <1> ;		CF:		Set if selected item is an actual drive, DL is valid
    32                              <1> ;				Clear if selected item is Rom Boot, DL is invalid
    33                              <1> ;	Corrupts registers:
    34                              <1> ;		All General Purpose Registers
    35                              <1> ;--------------------------------------------------------------------
    36                              <1> BootMenu_DisplayAndReturnDriveInDLRomBootClearCF:
    37 00001058 E8E8FF              <1> 	call	DriveXlate_Reset
    38                              <1> 
    39 0000105B BB[9210]            <1> 	mov		bx, BootMenuEvent_Handler
    40                              <1> 	CALL_MENU_LIBRARY	DisplayWithHandlerInBXandUserDataInDXAX
    40                              <2>  %ifidn %1, CloseMenuIfExitEventAllows
    40                              <2>  call MenuInit_CloseMenuIfExitEventAllows
    40                              <2> 
    40                              <2>  %elifidn %1, Close
    40                              <2>  call MenuInit_CloseMenuWindow
    40                              <2> 
    40                              <2>  %elifidn %1, SetUserDataFromDSSI
    40                              <2>  call MenuInit_SetUserDataFromDSSI
    40                              <2> 
    40                              <2>  %elifidn %1, GetUserDataToDSSI
    40                              <2>  call MenuInit_GetUserDataToDSSI
    40                              <2> 
    40                              <2>  %elifidn %1, SetTitleHeightFromAL
    40                              <2>  call MenuInit_SetTitleHeightFromAL
    40                              <2> 
    40                              <2>  %elifidn %1, GetHighlightedItemToAX
    40                              <2>  call MenuInit_GetHighlightedItemToAX
    40                              <2> 
    40                              <2>  %elifidn %1, SetTotalItemsFromAX
    40                              <2>  call MenuInit_SetTotalItemsFromAX
    40                              <2> 
    40                              <2>  %elifidn %1, SetInformationHeightFromAL
    40                              <2>  call MenuInit_SetInformationHeightFromAL
    40                              <2> 
    40                              <2>  %elifidn %1, SetTimeoutValueFromAX
    40                              <2>  call MenuTime_SetSelectionTimeoutValueFromAX
    40                              <2> 
    40                              <2>  %else
    40 0000105E BF[B306]            <2>  mov di, %1
    40 00001061 E872F4              <2>  call Menu_FunctionFromDI
    40                              <2>  %endif
    41                              <1> 
    42 00001064 91                  <1> 	xchg	cx, ax
    43                              <1> 
    44                              <1> 	; Clear Boot Menu from screen
    45 00001065 B82007              <1> 	mov		ax, ' ' | (MONO_NORMAL<<8)
    46                              <1> 	CALL_DISPLAY_LIBRARY	ClearScreenWithCharInALandAttrInAH
    46                              <2>  %ifidn %1, PushDisplayContext
    46                              <2>  call DisplayContext_Push
    46                              <2>  %elifidn %1, PopDisplayContext
    46                              <2>  call DisplayContext_Pop
    46                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
    46                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
    46                              <2>  %else
    46 00001068 BF[8703]            <2>  mov di, %1
    46 0000106B E881F1              <2>  call Display_FunctionFromDI
    46                              <2>  %endif
    47                              <1> 	
    48                              <1> 	; fall through to BootMenu_GetDriveToDXforMenuitemInCX
    49                              <1> 
    50                              <1> ;--------------------------------------------------------------------
    51                              <1> ; BootMenu_GetDriveToDXforMenuitemInCX
    52                              <1> ;	Parameters:
    53                              <1> ;		CX:		Index of menuitem selected from Boot Menu
    54                              <1> ;		DS:		RAMVARS segment
    55                              <1> ;	Returns:
    56                              <1> ;		DX:		Drive number to be used for booting
    57                              <1> ;       CF:     Set: There is a selected menu item, DL is valid
    58                              <1> ;               Clear: The item selected is Rom Boot, DL is not valid
    59                              <1> ;	Corrupts registers:
    60                              <1> ;		AX, BX
    61                              <1> ;
    62                              <1> ; NOTE: We can't use the menu structure in here, as we are falling through
    63                              <1> ; from BootMenu_DisplayAndReturnDriveInDLRomBootClearCF when the
    64                              <1> ; menu structure has already been destroyed.
    65                              <1> ;--------------------------------------------------------------------
    66                              <1> BootMenu_GetDriveToDXforMenuitemInCX:
    67 0000106E 88CA                <1> 	mov		dl, cl							; Copy menuitem index to DX
    68 00001070 E857FB              <1> 	call	FloppyDrive_GetCountToAX
    69 00001073 38C2                <1> 	cmp		dl, al							; Floppy drive?
    70 00001075 720B                <1> 	jb		SHORT .ReturnFloppyDriveInDX	; Set CF if branch taken
    71 00001077 0C80                <1> 	or		al, 80h							; Or 80h into AL before the sub
    72                              <1> 											; shorter instruction than or'ing it in afterward
    73 00001079 28C2                <1> 	sub		dl, al							; Remove floppy drives from index
    74 0000107B E8EFFA              <1> 	call	RamVars_GetHardDiskCountFromBDAtoAX
    75 0000107E 0C80                <1> 	or		al, 80h							; Or 80h into AL before the sub
    76 00001080 38C2                <1> 	cmp		dl, al							; Set CF if hard disk
    77                              <1> 											; Clear CF if last item, beyond hard disk list, which indicates ROM boot
    78                              <1> .ReturnFloppyDriveInDX:
    79 00001082 C3                  <1> 	ret
   216                                  	%include "BootMenuEvent.asm"	; For menu library event handling
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Boot Menu event handler for menu library callbacks.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; GetMenuitemToDXforDriveInDL
    25                              <1> ;	Parameters:
    26                              <1> ;		DL:		Drive number
    27                              <1> ;	Returns:
    28                              <1> ;		DX:		Menuitem index (assuming drive is available)
    29                              <1> ;	Corrupts registers:
    30                              <1> ;		AX
    31                              <1> ;--------------------------------------------------------------------
    32                              <1> GetMenuitemToDXforDriveInDL:
    33 00001083 30F6                <1> 	xor		dh, dh						; Drive number now in DX
    34 00001085 84D2                <1> 	test	dl, dl
    35 00001087 7908                <1> 	jns		SHORT .ReturnItemIndexInDX	; Return if floppy drive (HD bit not set)
    36 00001089 E83EFB              <1> 	call	FloppyDrive_GetCountToAX
    37 0000108C 80E27F              <1> 	and		dl, ~80h					; Clear HD bit
    38 0000108F 01C2                <1> 	add		dx, ax
    39                              <1> .ReturnItemIndexInDX:
    40 00001091 C3                  <1> 	ret
    41                              <1> 
    42                              <1> 
    43                              <1> ;--------------------------------------------------------------------
    44                              <1> ; BootMenuEvent_Handler
    45                              <1> ;	Common parameters for all events:
    46                              <1> ;		BX:			Menu event (anything from MENUEVENT struct)
    47                              <1> ;		SS:BP:		Menu library handle
    48                              <1> ;	Common return values for all events:
    49                              <1> ;		CF:			Set if event processed
    50                              <1> ;					Cleared if event not processed
    51                              <1> ;	Corrupts registers:
    52                              <1> ;		All
    53                              <1> ;--------------------------------------------------------------------
    54                              <1> BootMenuEvent_Handler:
    55                              <1> 	LOAD_BDA_SEGMENT_TO	es, di
    55                              <2> %ifndef USE_186
    55 00001092 31FF                <2>  xor %2, %2
    55 00001094 8EC7                <2>  mov %1, %2
    55                              <2> %elifidn %3, !
    55                              <2>  xor %2, %2
    55                              <2>  mov %1, %2
    55                              <2> %else
    55                              <2>  push BYTE 0
    55                              <2>  pop %1
    55                              <2> %endif
    56 00001096 E8AAFA              <1> 	call	RamVars_GetSegmentToDS
    57                              <1> 
    58                              <1> %ifdef MENUEVENT_INLINE_OFFSETS
    59                              <1> 
    60 00001099 81C3[A210]          <1> 	add		bx, FirstEvent
    61 0000109D FFE3                <1> 	jmp		bx
    62                              <1> 
    63                              <1> .EventNotHandled:
    64                              <1> .DoNotSetDefaultMenuitem:
    65 0000109F 31D2                <1> 	xor		dx, dx		; Clear CF (and menuitem index for DoNotSetDefaultMenuitem)
    66 000010A1 C3                  <1> 	ret
    67                              <1> 
    68                              <1> MENUEVENT_InitializeMenuinitFromDSSI equ  (EventInitializeMenuinitFromSSBP - FirstEvent)
    69                              <1> MENUEVENT_ExitMenu equ  (BootMenuEvent_Completed - FirstEvent)
    70                              <1> MENUEVENT_ItemHighlightedFromCX equ (EventItemHighlightedFromCX - FirstEvent)
    71                              <1> MENUEVENT_KeyStrokeInAX equ	(EventKeyStrokeInAX - FirstEvent)
    72                              <1> MENUEVENT_ItemSelectedFromCX equ (EventItemSelectedFromCX - FirstEvent)
    73                              <1> MENUEVENT_RefreshTitle equ (BootMenuPrint_TitleStrings - FirstEvent)
    74                              <1> MENUEVENT_RefreshInformation equ (BootMenuPrint_RefreshInformation - FirstEvent)
    75                              <1> MENUEVENT_RefreshItemFromCX equ (BootMenuPrint_RefreshItem - FirstEvent)
    76                              <1> ;
    77                              <1> ; Note that there is no entry for MENUEVENT_IdleProcessing.  If MENUEVENT_IDLEPROCESSING_ENABLE is not %defined,
    78                              <1> ; then the entry point will not be called (saving memory on this end and at the CALL point).
    79                              <1> ;
    80                              <1> 
    81                              <1> %else
    82                              <1> 
    83                              <1> 	cmp		bx, BYTE MENUEVENT.RefreshItemFromCX	; Above last supported item?
    84                              <1> 	ja		SHORT .EventNotHandled
    85                              <1> 	jmp		[cs:bx+rgfnEventSpecificHandlers]
    86                              <1> 
    87                              <1> .EventNotHandled:
    88                              <1> .DoNotSetDefaultMenuitem:
    89                              <1> 	xor		dx, dx		; Clear CF (and menuitem index for DoNotSetDefaultMenuitem)
    90                              <1> 	ret
    91                              <1> 
    92                              <1> rgfnEventSpecificHandlers:
    93                              <1> 	dw		EventInitializeMenuinitFromSSBP		; MENUEVENT.InitializeMenuinitFromDSSI
    94                              <1> 	dw		EventCompleted						; MENUEVENT.ExitMenu
    95                              <1> 	dw		EventNotHandled						; MENUEVENT.IdleProcessing
    96                              <1> 	dw		EventItemHighlightedFromCX			; MENUEVENT.ItemHighlightedFromCX
    97                              <1> 	
    98                              <1> 	dw		EventItemSelectedFromCX				; MENUEVENT.ItemSelectedFromCX
    99                              <1> 	dw		EventKeyStrokeInAX					; MENUEVENT.KeyStrokeInAX
   100                              <1> 	dw		BootMenuPrint_TitleStrings			; MENUEVENT.RefreshTitle
   101                              <1> 	dw		BootMenuPrint_RefreshInformation	; MENUEVENT.RefreshInformation
   102                              <1> 	dw		BootMenuPrint_RefreshItem			; MENUEVENT.RefreshItemFromCX
   103                              <1> 
   104                              <1> %endif
   105                              <1> 
   106                              <1> 
   107                              <1> ;--------------------------------------------------------------------
   108                              <1> ; EventInitializeMenuinitFromSSBP
   109                              <1> ;	Parameters
   110                              <1> ;		DS:		Ptr to RAMVARS
   111                              <1> ;		ES:		Ptr to BDA (zero)
   112                              <1> ;		SS:BP:	Ptr to MENUINIT struct to initialize
   113                              <1> ;	Returns:
   114                              <1> ;		CF:		Set if event processed
   115                              <1> ;				Cleared if event not processed
   116                              <1> ;	Corrupts registers:
   117                              <1> ;		Does not matter
   118                              <1> ;--------------------------------------------------------------------
   119                              <1> FirstEvent:
   120                              <1> EventInitializeMenuinitFromSSBP:
   121                              <1> 	; Store default Menuitem (=default drive to boot from)
   122 000010A2 31D2                <1> 	xor		dx, dx
   123 000010A4 895602              <1> 	mov		[bp+MENUINIT.wHighlightedItem], dx
   124                              <1> 
   125                              <1> 	; Store number of Menuitems
   126 000010A7 E8C3FA              <1> 	call	RamVars_GetHardDiskCountFromBDAtoAX
   127 000010AA 91                  <1> 	xchg	ax, cx
   128 000010AB E81CFB              <1> 	call	FloppyDrive_GetCountToAX
   129 000010AE 01C8                <1> 	add		ax, cx
   130 000010B0 40                  <1> 	inc		ax								; extra entry for ROM Boot item
   131 000010B1 894600              <1> 	mov		[bp+MENUINIT.wItems], ax
   132                              <1> 
   133                              <1> 	; Store menu size
   134 000010B4 C746040203          <1> 	mov		WORD [bp+MENUINIT.wTitleAndInfoLines], BOOT_MENU_TITLE_AND_INFO_LINES
   135 000010B9 C6460628            <1> 	mov		BYTE [bp+MENUINIT.bWidth], BOOT_MENU_WIDTH
   136 000010BD 040A                <1> 	add		al, BOOT_MENU_HEIGHT_WITHOUT_ITEMS
   137 000010BF 91                  <1> 	xchg	cx, ax
   138                              <1> 	CALL_DISPLAY_LIBRARY	GetColumnsToALandRowsToAH
   138                              <2>  %ifidn %1, PushDisplayContext
   138                              <2>  call DisplayContext_Push
   138                              <2>  %elifidn %1, PopDisplayContext
   138                              <2>  call DisplayContext_Pop
   138                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   138                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   138                              <2>  %else
   138 000010C0 BF[5703]            <2>  mov di, %1
   138 000010C3 E829F1              <2>  call Display_FunctionFromDI
   138                              <2>  %endif
   139                              <1> 	MIN_U	ah, cl
   139 000010C6 38CC                <2>  cmp %1, %2
   139 000010C8 7202                <2>  jb %%Return
   139 000010CA 88CC                <2>  mov %1, %2
   139                              <2> ALIGN JUMP_ALIGN
   139                              <2> %%Return:
   140 000010CC 886607              <1> 	mov		[bp+MENUINIT.bHeight], ah
   141                              <1> 
   142                              <1> 	; Store selection timeout
   143 000010CF 2EA14A00            <1> 	mov		ax, [cs:ROMVARS.wBootTimeout]
   144                              <1> 	CALL_MENU_LIBRARY StartSelectionTimeoutWithTicksInAX
   144                              <2>  %ifidn %1, CloseMenuIfExitEventAllows
   144                              <2>  call MenuInit_CloseMenuIfExitEventAllows
   144                              <2> 
   144                              <2>  %elifidn %1, Close
   144                              <2>  call MenuInit_CloseMenuWindow
   144                              <2> 
   144                              <2>  %elifidn %1, SetUserDataFromDSSI
   144                              <2>  call MenuInit_SetUserDataFromDSSI
   144                              <2> 
   144                              <2>  %elifidn %1, GetUserDataToDSSI
   144                              <2>  call MenuInit_GetUserDataToDSSI
   144                              <2> 
   144                              <2>  %elifidn %1, SetTitleHeightFromAL
   144                              <2>  call MenuInit_SetTitleHeightFromAL
   144                              <2> 
   144                              <2>  %elifidn %1, GetHighlightedItemToAX
   144                              <2>  call MenuInit_GetHighlightedItemToAX
   144                              <2> 
   144                              <2>  %elifidn %1, SetTotalItemsFromAX
   144                              <2>  call MenuInit_SetTotalItemsFromAX
   144                              <2> 
   144                              <2>  %elifidn %1, SetInformationHeightFromAL
   144                              <2>  call MenuInit_SetInformationHeightFromAL
   144                              <2> 
   144                              <2>  %elifidn %1, SetTimeoutValueFromAX
   144                              <2>  call MenuTime_SetSelectionTimeoutValueFromAX
   144                              <2> 
   144                              <2>  %else
   144 000010D3 BF[4F09]            <2>  mov di, %1
   144 000010D6 E8FDF3              <2>  call Menu_FunctionFromDI
   144                              <2>  %endif
   145 000010D9 F9                  <1> 	stc
   146 000010DA C3                  <1> 	ret
   147                              <1> 
   148                              <1> 
   149                              <1> ;--------------------------------------------------------------------
   150                              <1> ; EventItemHighlightedFromCX
   151                              <1> ;	Parameters
   152                              <1> ;		CX:		Index of new highlighted item
   153                              <1> ;		DX:		Index of previously highlighted item or NO_ITEM_HIGHLIGHTED
   154                              <1> ;		DS:		Ptr to RAMVARS
   155                              <1> ;		ES:		Ptr to BDA (zero)
   156                              <1> ;		SS:BP:	Menu library handle
   157                              <1> ;	Returns:
   158                              <1> ;		CF:		Set if event processed
   159                              <1> ;				Cleared if event not processed
   160                              <1> ;	Corrupts registers:
   161                              <1> ;		Does not matter
   162                              <1> ;--------------------------------------------------------------------
   163                              <1> EventItemHighlightedFromCX:
   164 000010DB 51                  <1> 	push	cx
   165                              <1> 
   166                              <1> 	; Drive number translations and hotkeys must be reset to defaults so highlighted
   167                              <1> 	; selections are correctly displayed on Hotkey Bar and on Boot Menu
   168                              <1> %ifdef MODULE_HOTKEYS
   169 000010DC E8D3FA              <1> 	call	BootVars_StoreDefaultDriveLettersToHotkeyVars
   170                              <1> %endif
   171 000010DF E861FF              <1> 	call	DriveXlate_Reset
   172                              <1> 
   173                              <1> 	; Set highlighted item to be drive to boot from for visual purposes only
   174 000010E2 E889FF              <1> 	call	BootMenu_GetDriveToDXforMenuitemInCX
   175 000010E5 7308                <1> 	jnc		SHORT .noDriveSwapSinceRomBootSelected
   176 000010E7 E860FF              <1> 	call	DriveXlate_SetDriveToSwap
   177                              <1> 
   178                              <1> %ifdef MODULE_HOTKEYS
   179                              <1> 	; Store highlighted drive as hotkey
   180 000010EA E8BAFE              <1> 	call	HotkeyBar_StoreHotkeyToBootvarsForDriveNumberInDL
   181 000010ED EB05                <1> 	jmp		SHORT .UpdateHotkeyBar
   182                              <1> .noDriveSwapSinceRomBootSelected:
   183 000010EF B442                <1> 	mov		ah, ROM_BOOT_HOTKEY_SCANCODE
   184 000010F1 E8C7FE              <1> 	call	HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX
   185                              <1> 
   186                              <1> .UpdateHotkeyBar:
   187                              <1> 	; Redraw Hotkey Bar for updated boot drive letters
   188 000010F4 B007                <1> 	mov		al, MONO_NORMAL
   189                              <1> 	CALL_DISPLAY_LIBRARY	SetCharacterAttributeFromAL
   189                              <2>  %ifidn %1, PushDisplayContext
   189                              <2>  call DisplayContext_Push
   189                              <2>  %elifidn %1, PopDisplayContext
   189                              <2>  call DisplayContext_Pop
   189                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   189                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   189                              <2>  %else
   189 000010F6 BF[E502]            <2>  mov di, %1
   189 000010F9 E8F3F0              <2>  call Display_FunctionFromDI
   189                              <2>  %endif
   190                              <1> 
   191 000010FC B301                <1> 	mov		bl, ATTRIBUTES_ARE_USED
   192 000010FE B8[1702]            <1> 	mov		ax, TELETYPE_OUTPUT_WITH_ATTRIBUTE
   193                              <1> 	CALL_DISPLAY_LIBRARY	SetCharOutputFunctionFromAXwithAttribFlagInBL
   193                              <2>  %ifidn %1, PushDisplayContext
   193                              <2>  call DisplayContext_Push
   193                              <2>  %elifidn %1, PopDisplayContext
   193                              <2>  call DisplayContext_Pop
   193                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
   193                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
   193                              <2>  %else
   193 00001101 BF[D502]            <2>  mov di, %1
   193 00001104 E8E8F0              <2>  call Display_FunctionFromDI
   193                              <2>  %endif
   194 00001107 E80CFE              <1> 	call	HotkeyBar_DrawToTopOfScreen
   195                              <1> %else
   196                              <1> .noDriveSwapSinceRomBootSelected:
   197                              <1> %endif ; MODULE_HOTKEYS
   198                              <1> 
   199                              <1> 	; Redraw changes in drive numbers
   200 0000110A 31C0                <1> 	xor		ax, ax	; Update first floppy drive (for translated drive number)
   201                              <1> 	CALL_MENU_LIBRARY	RefreshItemFromAX
   201                              <2>  %ifidn %1, CloseMenuIfExitEventAllows
   201                              <2>  call MenuInit_CloseMenuIfExitEventAllows
   201                              <2> 
   201                              <2>  %elifidn %1, Close
   201                              <2>  call MenuInit_CloseMenuWindow
   201                              <2> 
   201                              <2>  %elifidn %1, SetUserDataFromDSSI
   201                              <2>  call MenuInit_SetUserDataFromDSSI
   201                              <2> 
   201                              <2>  %elifidn %1, GetUserDataToDSSI
   201                              <2>  call MenuInit_GetUserDataToDSSI
   201                              <2> 
   201                              <2>  %elifidn %1, SetTitleHeightFromAL
   201                              <2>  call MenuInit_SetTitleHeightFromAL
   201                              <2> 
   201                              <2>  %elifidn %1, GetHighlightedItemToAX
   201                              <2>  call MenuInit_GetHighlightedItemToAX
   201                              <2> 
   201                              <2>  %elifidn %1, SetTotalItemsFromAX
   201                              <2>  call MenuInit_SetTotalItemsFromAX
   201                              <2> 
   201                              <2>  %elifidn %1, SetInformationHeightFromAL
   201                              <2>  call MenuInit_SetInformationHeightFromAL
   201                              <2> 
   201                              <2>  %elifidn %1, SetTimeoutValueFromAX
   201                              <2>  call MenuTime_SetSelectionTimeoutValueFromAX
   201                              <2> 
   201                              <2>  %else
   201 0000110C BF[C708]            <2>  mov di, %1
   201 0000110F E8C4F3              <2>  call Menu_FunctionFromDI
   201                              <2>  %endif
   202 00001112 B280                <1> 	mov		dl, 80h
   203 00001114 E86CFF              <1> 	call	GetMenuitemToDXforDriveInDL
   204 00001117 92                  <1> 	xchg	ax, dx	; Update first hard disk (for translated drive number)
   205                              <1> 	CALL_MENU_LIBRARY	RefreshItemFromAX
   205                              <2>  %ifidn %1, CloseMenuIfExitEventAllows
   205                              <2>  call MenuInit_CloseMenuIfExitEventAllows
   205                              <2> 
   205                              <2>  %elifidn %1, Close
   205                              <2>  call MenuInit_CloseMenuWindow
   205                              <2> 
   205                              <2>  %elifidn %1, SetUserDataFromDSSI
   205                              <2>  call MenuInit_SetUserDataFromDSSI
   205                              <2> 
   205                              <2>  %elifidn %1, GetUserDataToDSSI
   205                              <2>  call MenuInit_GetUserDataToDSSI
   205                              <2> 
   205                              <2>  %elifidn %1, SetTitleHeightFromAL
   205                              <2>  call MenuInit_SetTitleHeightFromAL
   205                              <2> 
   205                              <2>  %elifidn %1, GetHighlightedItemToAX
   205                              <2>  call MenuInit_GetHighlightedItemToAX
   205                              <2> 
   205                              <2>  %elifidn %1, SetTotalItemsFromAX
   205                              <2>  call MenuInit_SetTotalItemsFromAX
   205                              <2> 
   205                              <2>  %elifidn %1, SetInformationHeightFromAL
   205                              <2>  call MenuInit_SetInformationHeightFromAL
   205                              <2> 
   205                              <2>  %elifidn %1, SetTimeoutValueFromAX
   205                              <2>  call MenuTime_SetSelectionTimeoutValueFromAX
   205                              <2> 
   205                              <2>  %else
   205 00001118 BF[C708]            <2>  mov di, %1
   205 0000111B E8B8F3              <2>  call Menu_FunctionFromDI
   205                              <2>  %endif
   206 0000111E 58                  <1> 	pop		ax		; Update new item (for translated drive number)
   207                              <1> 	CALL_MENU_LIBRARY	RefreshItemFromAX
   207                              <2>  %ifidn %1, CloseMenuIfExitEventAllows
   207                              <2>  call MenuInit_CloseMenuIfExitEventAllows
   207                              <2> 
   207                              <2>  %elifidn %1, Close
   207                              <2>  call MenuInit_CloseMenuWindow
   207                              <2> 
   207                              <2>  %elifidn %1, SetUserDataFromDSSI
   207                              <2>  call MenuInit_SetUserDataFromDSSI
   207                              <2> 
   207                              <2>  %elifidn %1, GetUserDataToDSSI
   207                              <2>  call MenuInit_GetUserDataToDSSI
   207                              <2> 
   207                              <2>  %elifidn %1, SetTitleHeightFromAL
   207                              <2>  call MenuInit_SetTitleHeightFromAL
   207                              <2> 
   207                              <2>  %elifidn %1, GetHighlightedItemToAX
   207                              <2>  call MenuInit_GetHighlightedItemToAX
   207                              <2> 
   207                              <2>  %elifidn %1, SetTotalItemsFromAX
   207                              <2>  call MenuInit_SetTotalItemsFromAX
   207                              <2> 
   207                              <2>  %elifidn %1, SetInformationHeightFromAL
   207                              <2>  call MenuInit_SetInformationHeightFromAL
   207                              <2> 
   207                              <2>  %elifidn %1, SetTimeoutValueFromAX
   207                              <2>  call MenuTime_SetSelectionTimeoutValueFromAX
   207                              <2> 
   207                              <2>  %else
   207 0000111F BF[C708]            <2>  mov di, %1
   207 00001122 E8B1F3              <2>  call Menu_FunctionFromDI
   207                              <2>  %endif
   208                              <1> 	CALL_MENU_LIBRARY	RefreshInformation
   208                              <2>  %ifidn %1, CloseMenuIfExitEventAllows
   208                              <2>  call MenuInit_CloseMenuIfExitEventAllows
   208                              <2> 
   208                              <2>  %elifidn %1, Close
   208                              <2>  call MenuInit_CloseMenuWindow
   208                              <2> 
   208                              <2>  %elifidn %1, SetUserDataFromDSSI
   208                              <2>  call MenuInit_SetUserDataFromDSSI
   208                              <2> 
   208                              <2>  %elifidn %1, GetUserDataToDSSI
   208                              <2>  call MenuInit_GetUserDataToDSSI
   208                              <2> 
   208                              <2>  %elifidn %1, SetTitleHeightFromAL
   208                              <2>  call MenuInit_SetTitleHeightFromAL
   208                              <2> 
   208                              <2>  %elifidn %1, GetHighlightedItemToAX
   208                              <2>  call MenuInit_GetHighlightedItemToAX
   208                              <2> 
   208                              <2>  %elifidn %1, SetTotalItemsFromAX
   208                              <2>  call MenuInit_SetTotalItemsFromAX
   208                              <2> 
   208                              <2>  %elifidn %1, SetInformationHeightFromAL
   208                              <2>  call MenuInit_SetInformationHeightFromAL
   208                              <2> 
   208                              <2>  %elifidn %1, SetTimeoutValueFromAX
   208                              <2>  call MenuTime_SetSelectionTimeoutValueFromAX
   208                              <2> 
   208                              <2>  %else
   208 00001125 BF[9908]            <2>  mov di, %1
   208 00001128 E8ABF3              <2>  call Menu_FunctionFromDI
   208                              <2>  %endif
   209 0000112B F9                  <1> 	stc
   210 0000112C C3                  <1> 	ret
   211                              <1> 
   212                              <1> 
   213                              <1> ;--------------------------------------------------------------------
   214                              <1> ; EventKeyStrokeInAX
   215                              <1> ;	Parameters
   216                              <1> ;		AL:		ASCII character for the key
   217                              <1> ;		AH:		Keyboard library scan code for the key
   218                              <1> ;		DS:		Ptr to RAMVARS
   219                              <1> ;		ES:		Ptr to BDA (zero)
   220                              <1> ;		SS:BP:	Menu library handle
   221                              <1> ;	Returns:
   222                              <1> ;		CF:		Set if event processed
   223                              <1> ;				Cleared if event not processed
   224                              <1> ;	Corrupts registers:
   225                              <1> ;		Does not matter
   226                              <1> ;--------------------------------------------------------------------
   227                              <1> %ifdef MODULE_HOTKEYS
   228                              <1> EventKeyStrokeInAX:
   229                              <1> 	; Keypress will be the primary boot drive
   230 0000112D 80FC3C              <1> 	cmp		ah, BOOT_MENU_HOTKEY_SCANCODE
   231 00001130 7408                <1> 	je		SHORT BootMenuEvent_Completed	; Ignore Boot Menu hotkey
   232 00001132 E886FE              <1> 	call	HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX
   233 00001135 7303                <1> 	jnc		SHORT BootMenuEvent_Completed
   234                              <1> 	; Fall to CloseBootMenu through EventItemSelectedFromCX
   235                              <1> %endif
   236                              <1> 
   237                              <1> 
   238                              <1> ;--------------------------------------------------------------------
   239                              <1> ; EventItemSelectedFromCX
   240                              <1> ;	Parameters
   241                              <1> ;		CX:		Index of selected item
   242                              <1> ;		DS:		Ptr to RAMVARS
   243                              <1> ;		ES:		Ptr to BDA (zero)
   244                              <1> ;		SS:BP:	Menu library handle
   245                              <1> ;	Returns:
   246                              <1> ;		CF:		Set if event processed
   247                              <1> ;				Cleared if event not processed
   248                              <1> ;	Corrupts registers:
   249                              <1> ;		Does not matter
   250                              <1> ;--------------------------------------------------------------------
   251                              <1> EventItemSelectedFromCX:
   252                              <1> 	; Fall to CloseBootMenu
   253                              <1> 
   254                              <1> 
   255                              <1> ;--------------------------------------------------------------------
   256                              <1> ; CloseBootMenu
   257                              <1> ;	Parameters
   258                              <1> ;		DS:		RAMVARS segment
   259                              <1> ;		ES:		BDA segment (zero)
   260                              <1> ;	Returns:
   261                              <1> ;		Nothing
   262                              <1> ;	Corrupts registers:
   263                              <1> ;		Does not matter
   264                              <1> ;--------------------------------------------------------------------
   265                              <1> CloseBootMenu:
   266                              <1> 	CALL_MENU_LIBRARY	Close
   266                              <2>  %ifidn %1, CloseMenuIfExitEventAllows
   266                              <2>  call MenuInit_CloseMenuIfExitEventAllows
   266                              <2> 
   266                              <2>  %elifidn %1, Close
   266 00001137 E8C2F5              <2>  call MenuInit_CloseMenuWindow
   266                              <2> 
   266                              <2>  %elifidn %1, SetUserDataFromDSSI
   266                              <2>  call MenuInit_SetUserDataFromDSSI
   266                              <2> 
   266                              <2>  %elifidn %1, GetUserDataToDSSI
   266                              <2>  call MenuInit_GetUserDataToDSSI
   266                              <2> 
   266                              <2>  %elifidn %1, SetTitleHeightFromAL
   266                              <2>  call MenuInit_SetTitleHeightFromAL
   266                              <2> 
   266                              <2>  %elifidn %1, GetHighlightedItemToAX
   266                              <2>  call MenuInit_GetHighlightedItemToAX
   266                              <2> 
   266                              <2>  %elifidn %1, SetTotalItemsFromAX
   266                              <2>  call MenuInit_SetTotalItemsFromAX
   266                              <2> 
   266                              <2>  %elifidn %1, SetInformationHeightFromAL
   266                              <2>  call MenuInit_SetInformationHeightFromAL
   266                              <2> 
   266                              <2>  %elifidn %1, SetTimeoutValueFromAX
   266                              <2>  call MenuTime_SetSelectionTimeoutValueFromAX
   266                              <2> 
   266                              <2>  %else
   266                              <2>  mov di, %1
   266                              <2>  call Menu_FunctionFromDI
   266                              <2>  %endif
   267                              <1> 	; Fall to BootMenuEvent_Completed
   268                              <1> 
   269                              <1> 
   270                              <1> ;--------------------------------------------------------------------
   271                              <1> ; BootMenuEvent_Completed
   272                              <1> ;	Parameters
   273                              <1> ;		Nothing
   274                              <1> ;	Returns:
   275                              <1> ;		CF:		Set to exit from menu
   276                              <1> ;	Corrupts registers:
   277                              <1> ;		Nothing
   278                              <1> ;--------------------------------------------------------------------
   279                              <1> BootMenuEvent_Completed:
   280 0000113A F9                  <1> 	stc
   281                              <1> %ifndef MODULE_HOTKEYS
   282                              <1> EventKeyStrokeInAX:
   283                              <1> %endif
   284 0000113B C3                  <1> 	ret
   217                                  									; NOTE: BootMenuPrint needs to come immediately after BootMenuEvent
   218                                  									;       so that jump table entries in BootMenuEvent stay within 8-bits
   219                                  	%include "BootMenuPrint.asm"	; For printing Boot Menu strings, also includes "BootMenuPrintCfg.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for printing boot menu strings.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; BootMenuPrint_RefreshItem
    25                              <1> ;
    26                              <1> ;	Parameters:
    27                              <1> ;		CX:		Index of highlighted item
    28                              <1> ;		DS:		RAMVARS segment
    29                              <1> ;	Returns:
    30                              <1> ;		Nothing
    31                              <1> ;	Corrupts registers:
    32                              <1> ;		Does not matter
    33                              <1> ;--------------------------------------------------------------------
    34                              <1> BootMenuPrint_RefreshItem:
    35 0000113C 55                  <1> 	push	bp
    36 0000113D 89E5                <1> 	mov		bp, sp
    37                              <1> 
    38 0000113F E82CFF              <1> 	call	BootMenu_GetDriveToDXforMenuitemInCX
    39 00001142 BE[1501]            <1> 	mov		si, g_szRomBootDash						; Standard "Rom Boot" but with a "-" at the front
    40 00001145 B020                <1> 	mov		al, 20h									; The space between "Rom" and "Boot"
    41 00001147 7328                <1> 	jnc		.ROMBoot								; display "Rom Boot" option for last entry
    42                              <1> 
    43 00001149 E81AFB              <1> 	call	FindDPT_ForDriveNumberInDL
    44 0000114C 7208                <1> 	jc		.notOurs
    45                              <1> 
    46 0000114E E864FC              <1> 	call	DriveDetectInfo_ConvertDPTtoBX
    47 00001151 BE[BE01]            <1> 	mov		si, g_szDriveNumBOOTNFO					; special g_szDriveNum that prints from BDA
    48 00001154 EB0C                <1> 	jmp		.go
    49                              <1> 
    50                              <1> .notOurs:
    51 00001156 BE[BA01]            <1> 	mov		si,g_szDriveNum
    52 00001159 BB[CD01]            <1> 	mov		bx,g_szForeignHD						; assume a hard disk for the moment
    53                              <1> 
    54 0000115C 84D2                <1> 	test	dl, dl
    55 0000115E 7802                <1> 	js		.go
    56 00001160 B3C1                <1> 	mov		bl,((g_szFloppyDrv)-$$ & 0xff)			; and revisit the earlier assumption...
    57                              <1> 
    58                              <1> .go:
    59 00001162 89D0                <1> 	mov		ax, dx									; preserve DL for the floppy drive letter addition
    60 00001164 E8C0FE              <1> 	call	DriveXlate_ToOrBack
    61                              <1> 
    62 00001167 F6C2F0              <1> 	test	dl, 0f0h								; if there is a character in the upper nibble
    63 0000116A 7501                <1> 	jnz		.noSpace
    64 0000116C 4E                  <1> 	dec		si										; backup a character to a leading space
    65                              <1> .noSpace:
    66                              <1> 
    67 0000116D 52                  <1> 	push	dx										; translated drive number
    68 0000116E 53                  <1> 	push	bx										; sub string
    69 0000116F 0441                <1> 	add		al, 'A'									; floppy drive letter (we always push this although
    70                              <1> 													; the hard disks don't ever use it, but it does no harm)
    71                              <1> .ROMBoot:
    72 00001171 50                  <1> 	push	ax
    73                              <1> 
    74 00001172 EB51                <1> 	jmp		SHORT BootMenuPrint_RefreshInformation.FormatRelay
    75                              <1> 
    76                              <1> ;--------------------------------------------------------------------
    77                              <1> ; Prints Boot Menu title strings.
    78                              <1> ;
    79                              <1> ; BootMenuPrint_TitleStrings
    80                              <1> ;	Parameters:
    81                              <1> ;		Nothing
    82                              <1> ;	Returns:
    83                              <1> ;		CF:		Set since menu event handled
    84                              <1> ;	Corrupts registers:
    85                              <1> ;		AX, SI, DI
    86                              <1> ;--------------------------------------------------------------------
    87                              <1> BootMenuPrint_TitleStrings:
    88 00001174 31FF                <1> 	xor		di,di						; Null character will be eaten
    89 00001176 BE[CE00]            <1> 	mov		si, g_szBootMenuTitle
    90 00001179 E952FD              <1> 	jmp		DetectPrint_RomFoundAtSegment.BootMenuEntry
    91                              <1> 
    92                              <1> 
    93                              <1> ;--------------------------------------------------------------------
    94                              <1> ; BootMenuPrint_RefreshInformation
    95                              <1> ;	Parameters:
    96                              <1> ;		CX:		Index of highlighted item
    97                              <1> ;		DS:		RAMVARS segment
    98                              <1> ;	Returns:
    99                              <1> ;		CF:		Set since menu event was handled successfully
   100                              <1> ;	Corrupts registers:
   101                              <1> ;		Does not matter
   102                              <1> ;--------------------------------------------------------------------
   103                              <1> BootMenuPrint_RefreshInformation:
   104                              <1> 	CALL_MENU_LIBRARY ClearInformationArea
   104                              <2>  %ifidn %1, CloseMenuIfExitEventAllows
   104                              <2>  call MenuInit_CloseMenuIfExitEventAllows
   104                              <2> 
   104                              <2>  %elifidn %1, Close
   104                              <2>  call MenuInit_CloseMenuWindow
   104                              <2> 
   104                              <2>  %elifidn %1, SetUserDataFromDSSI
   104                              <2>  call MenuInit_SetUserDataFromDSSI
   104                              <2> 
   104                              <2>  %elifidn %1, GetUserDataToDSSI
   104                              <2>  call MenuInit_GetUserDataToDSSI
   104                              <2> 
   104                              <2>  %elifidn %1, SetTitleHeightFromAL
   104                              <2>  call MenuInit_SetTitleHeightFromAL
   104                              <2> 
   104                              <2>  %elifidn %1, GetHighlightedItemToAX
   104                              <2>  call MenuInit_GetHighlightedItemToAX
   104                              <2> 
   104                              <2>  %elifidn %1, SetTotalItemsFromAX
   104                              <2>  call MenuInit_SetTotalItemsFromAX
   104                              <2> 
   104                              <2>  %elifidn %1, SetInformationHeightFromAL
   104                              <2>  call MenuInit_SetInformationHeightFromAL
   104                              <2> 
   104                              <2>  %elifidn %1, SetTimeoutValueFromAX
   104                              <2>  call MenuTime_SetSelectionTimeoutValueFromAX
   104                              <2> 
   104                              <2>  %else
   104 0000117C BF[7008]            <2>  mov di, %1
   104 0000117F E854F3              <2>  call Menu_FunctionFromDI
   104                              <2>  %endif
   105                              <1> 
   106 00001182 E8E9FE              <1> 	call	BootMenu_GetDriveToDXforMenuitemInCX
   107 00001185 73B3                <1> 	jnc		BootMenuEvent_Completed						; nothing to display if "Rom Boot" option
   108                              <1> 
   109 00001187 55                  <1> 	push	bp
   110 00001188 89E5                <1> 	mov		bp, sp
   111                              <1> 
   112 0000118A BE[8101]            <1> 	mov		si, g_szCapacity							; Setup print string now, carries through to print call
   113                              <1> 
   114 0000118D E8D6FA              <1> 	call	FindDPT_ForDriveNumberInDL
   115                              <1> 
   116 00001190 FEC2                <1> 	inc		dl											; are we a hard disk?
   117 00001192 FECA                <1> 	dec		dl											; inc/dec will set SF, without modifying CF or DL
   118 00001194 7832                <1> 	js		.HardDiskRefreshInformation
   119                              <1> 
   120 00001196 7305                <1> 	jnc		.ours										; Based on CF from FindDPT_ForDriveNumberInDL above
   121 00001198 E828FA              <1> 	call	FloppyDrive_GetType							; Get Floppy Drive type to BX
   122 0000119B EB03                <1> 	jmp		.around
   123                              <1> .ours:
   124 0000119D E85909              <1> 	call	AH8h_GetDriveParameters
   125                              <1> .around:
   126                              <1> 
   127 000011A0 B8[2801]            <1> 	mov		ax, g_szFddSizeOr	        				; .PrintXTFloppyType
   128 000011A3 84DB                <1> 	test	bl, bl										; Two possibilities? (FLOPPY_TYPE_525_OR_35_DD)
   129 000011A5 741D                <1> 	jz		SHORT .PushAXAndOutput
   130                              <1> 
   131 000011A7 B021                <1> 	mov		al, (g_szFddUnknown - $$) & 0xff	        ; .PrintUnknownFloppyType
   132 000011A9 80FB06              <1> 	cmp		bl, FLOPPY_TYPE_35_ED
   133 000011AC 7716                <1> 	ja		SHORT .PushAXAndOutput
   134                              <1> 
   135                              <1> 	; Fall to .PrintKnownFloppyType
   136                              <1> 
   137                              <1> ;--------------------------------------------------------------------
   138                              <1> ; .PrintKnownFloppyType
   139                              <1> ;	Parameters:
   140                              <1> ;		BX:		Floppy drive type
   141                              <1> ;	Returns:
   142                              <1> ;		CF:		Set since menu event was handled successfully
   143                              <1> ;	Corrupts registers:
   144                              <1> ;		AX, BX, SI, DI
   145                              <1> ;
   146                              <1> ; Floppy Drive Types:
   147                              <1> ;
   148                              <1> ;   0  Handled above
   149                              <1> ;   1  FLOPPY_TYPE_525_DD          5 1/4   360K
   150                              <1> ;   2  FLOPPY_TYPE_525_HD          5 1/4   1.2M
   151                              <1> ;   3  FLOPPY_TYPE_35_DD           3 1/2   720K
   152                              <1> ;   4  FLOPPY_TYPE_35_HD           3 1/2   1.44M
   153                              <1> ;   5  3.5" ED on some BIOSes      3 1/2   2.88M
   154                              <1> ;   6  FLOPPY_TYPE_35_ED		   3 1/2   2.88M
   155                              <1> ;   >6 Unknown, handled above
   156                              <1> ;
   157                              <1> ;--------------------------------------------------------------------
   158                              <1> .PrintKnownFloppyType:
   159 000011AE B034                <1> 	mov		al, (g_szFddSize - $$) & 0xff
   160 000011B0 50                  <1> 	push	ax
   161                              <1> 
   162 000011B1 B03D                <1> 	mov		al, (g_szFddThreeHalf - $$) & 0xff
   163 000011B3 80FB02              <1> 	cmp		bl, FLOPPY_TYPE_525_HD
   164 000011B6 7702                <1> 	ja		.ThreeHalf
   165 000011B8 B03F                <1> 	mov		al, (g_szFddFiveQuarter - $$) & 0xff
   166                              <1> .ThreeHalf:
   167 000011BA 50                  <1> 	push	ax											; "5 1/4" or "3 1/2"
   168                              <1> 
   169 000011BB 30FF                <1> 	xor		bh, bh
   170 000011BD B078                <1> 	mov		al,FloppyTypes.rgbCapacityMultiplier
   171 000011BF 2EF6A7[2712]        <1> 	mul		BYTE [cs:bx+FloppyTypes.rgbCapacity - 1]    ; -1 since 0 is handled above and not in the table
   172                              <1> 
   173                              <1> .PushAXAndOutput:
   174 000011C4 50                  <1> 	push	ax
   175                              <1> 
   176                              <1> .FormatRelay:
   177 000011C5 E942FD              <1> 	jmp		DetectPrint_FormatCSSIfromParamsInSSBP
   178                              <1> 
   179                              <1> 
   180                              <1> ;--------------------------------------------------------------------
   181                              <1> ; Prints Hard Disk Menuitem information strings.
   182                              <1> ;
   183                              <1> ; BootMenuPrint_HardDiskMenuitemInformation
   184                              <1> ;	Parameters:
   185                              <1> ;		DS:		RAMVARS segment
   186                              <1> ;	Returns:
   187                              <1> ;		CF:		Set since menu event was handled successfully
   188                              <1> ;	Corrupts registers:
   189                              <1> ;		BX, CX, DX, SI, DI, ES
   190                              <1> ;--------------------------------------------------------------------
   191                              <1> .HardDiskRefreshInformation:
   192 000011C8 7209                <1> 	jc		.HardDiskMenuitemInfoForForeignDrive		; Based on CF from FindDPT_ForDriveNumberInDL (way) above
   193                              <1> 
   194                              <1> .HardDiskMenuitemInfoForOurDrive:
   195                              <1> 	ePUSH_T ax, g_szInformation							; Add substring for our hard disk information
   195                              <2> %ifndef USE_186
   195                              <2>  %ifidni %2, 0
   195                              <2>  xor %1, %1
   195                              <2>  %else
   195 000011CA B8[9201]            <2>  mov %1, %2
   195                              <2>  %endif
   195 000011CD 50                  <2>  push %1
   195                              <2> 
   195                              <2> %else
   195                              <2>  push %2
   195                              <2> %endif
   196 000011CE E83B0A              <1> 	call	GetTotalSectorCount
   197 000011D1 EB06                <1> 	jmp		.ConvertSectorCountInBXDXAXtoSizeAndPushForFormat
   198                              <1> 
   199                              <1> .HardDiskMenuitemInfoForForeignDrive:
   200 000011D3 E851FE              <1> 	call	DriveXlate_ToOrBack
   201 000011D6 E82C0A              <1> 	call	AH15h_GetSectorCountFromForeignDriveToDXAX
   202                              <1> 
   203                              <1> .ConvertSectorCountInBXDXAXtoSizeAndPushForFormat:
   204                              <1> 	ePUSH_T	cx, g_szCapacityNum		; Push format substring
   204                              <2> %ifndef USE_186
   204                              <2>  %ifidni %2, 0
   204                              <2>  xor %1, %1
   204                              <2>  %else
   204 000011D9 B9[8B01]            <2>  mov %1, %2
   204                              <2>  %endif
   204 000011DC 51                  <2>  push %1
   204                              <2> 
   204                              <2> %else
   204                              <2>  push %2
   204                              <2> %endif
   205 000011DD E892F8              <1> 	call	Size_ConvertSectorCountInBXDXAXtoKiB
   206 000011E0 B90100              <1> 	mov		cx, BYTE_MULTIPLES.kiB
   207 000011E3 E844F8              <1> 	call	Size_GetSizeToAXAndCharToDLfromBXDXAXwithMagnitudeInCX
   208 000011E6 50                  <1> 	push	ax						; Size in magnitude
   209 000011E7 51                  <1> 	push	cx						; Tenths
   210 000011E8 52                  <1> 	push	dx						; Magnitude character
   211                              <1> 
   212 000011E9 85FF                <1> 	test	di, di					; Zero if foreign drive
   213 000011EB 74D8                <1> 	jz		SHORT BootMenuPrint_RefreshInformation.FormatRelay
   214                              <1> 
   215                              <1> %include "BootMenuPrintCfg.asm"		; Inline of code to fill out remainder of information string
     1                              <2> ; Project name	:	XTIDE Universal BIOS
     2                              <2> ; Description	:	Functions for printing drive configuration
     3                              <2> ;					information on Boot Menu.
     4                              <2> ;
     5                              <2> ; Included by BootMenuPrint.asm, this routine is to be inserted into
     6                              <2> ; BootMenuPrint_HardDiskRefreshInformation.
     7                              <2> ;
     8                              <2> 
     9                              <2> ;
    10                              <2> ; XTIDE Universal BIOS and Associated Tools
    11                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
    12                              <2> ;
    13                              <2> ; This program is free software; you can redistribute it and/or modify
    14                              <2> ; it under the terms of the GNU General Public License as published by
    15                              <2> ; the Free Software Foundation; either version 2 of the License, or
    16                              <2> ; (at your option) any later version.
    17                              <2> ;
    18                              <2> ; This program is distributed in the hope that it will be useful,
    19                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    20                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    21                              <2> ; GNU General Public License for more details.
    22                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    23                              <2> ;
    24                              <2> 
    25                              <2> ; Section containing code
    26                              <2> SECTION .text
    27                              <2> 
    28                              <2> ;;; fall-into from BootMenuPrint_HardDiskRefreshInformation.
    29                              <2> 
    30                              <2> ;--------------------------------------------------------------------
    31                              <2> ; Prints Hard Disk configuration for drive handled by our BIOS.
    32                              <2> ; Cursor is set to configuration header string position.
    33                              <2> ;
    34                              <2> ; BootMenuPrintCfg_ForOurDrive
    35                              <2> ;	Parameters:
    36                              <2> ;		DS:DI:		Pointer to DPT
    37                              <2> ;	Returns:
    38                              <2> ;		Nothing
    39                              <2> ;	Corrupts registers:
    40                              <2> ;		AX, BX, CX, DX
    41                              <2> ;--------------------------------------------------------------------
    42                              <2> .BootMenuPrintCfg_ForOurDrive:
    43                              <2> 	eMOVZX	ax, [di+DPT.bIdevarsOffset]
    43                              <3> %ifndef USE_386
    43                              <3>  %ifidni %1, ax
    43 000011ED 8A4502              <3>  mov al, %2
    43 000011F0 30E4                <3>  xor ah, ah
    43                              <3>  %elifidni %1, bx
    43                              <3>  mov bl, %2
    43                              <3>  xor bh, bh
    43                              <3>  %elifidni %1, cx
    43                              <3>  mov cl, %2
    43                              <3>  xor ch, ch
    43                              <3>  %elifidni %1, dx
    43                              <3>  mov dl, %2
    43                              <3>  xor dh, dh
    43                              <3>  %else
    43                              <3>  push ax
    43                              <3>  mov al, %2
    43                              <3>  xor ah, ah
    43                              <3>  xchg ax, %1
    43                              <3>  pop ax
    43                              <3>  %endif
    43                              <3> 
    43                              <3> %else
    43                              <3>  movzx %1, %2
    43                              <3> %endif
    44 000011F2 93                  <2> 	xchg	bx, ax						; CS:BX now points to IDEVARS
    45                              <2> 	; Fall to .PushAddressingMode
    46                              <2> 
    47                              <2> ;--------------------------------------------------------------------
    48                              <2> ; .PushAddressingMode
    49                              <2> ;	Parameters:
    50                              <2> ;		DS:DI:	Ptr to DPT
    51                              <2> ;		CS:BX:	Ptr to IDEVARS
    52                              <2> ;	Returns:
    53                              <2> ;		Nothing (falls to next push below)
    54                              <2> ;	Corrupts registers:
    55                              <2> ;		AX, CX, DX
    56                              <2> ;--------------------------------------------------------------------
    57                              <2> .PushAddressingMode:
    58                              <2> 	ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF
    58 000011F3 8A05                <3>  mov al, [di+DPT.bFlagsLow]
    58 000011F5 83E00C              <3>  and ax, BYTE MASKL_DPT_TRANSLATEMODE
    59                              <2> 	;;
    60                              <2> 	;; This multiply both shifts the addressing mode bits down to low order bits, and
    61                              <2> 	;; at the same time multiplies by the size of the string displacement.  The result is in AH,
    62                              <2> 	;; with AL clear, and so we exchange AL and AH after the multiply for the final result.
    63                              <2> 	;;
    64 000011F8 B98001              <2> 	mov		cx, g_szAddressingModes_Displacement << (8-TRANSLATEMODE_FIELD_POSITION)
    65 000011FB F7E1                <2> 	mul		cx
    66 000011FD 86C4                <2> 	xchg	al, ah		; AL = always zero after above multiplication
    67 000011FF 05[4101]            <2> 	add		ax, g_szAddressingModes
    68 00001202 50                  <2> 	push	ax
    69                              <2> 	; Fall to .PushBlockMode
    70                              <2> 
    71                              <2> ;--------------------------------------------------------------------
    72                              <2> ; .PushBlockMode
    73                              <2> ;	Parameters:
    74                              <2> ;		DS:DI:	Ptr to DPT
    75                              <2> ;		CS:BX:	Ptr to IDEVARS
    76                              <2> ;	Returns:
    77                              <2> ;		Nothing (falls to next push below)
    78                              <2> ;	Corrupts registers:
    79                              <2> ;		AX
    80                              <2> ;--------------------------------------------------------------------
    81                              <2> .PushBlockMode:
    82 00001203 B80100              <2> 	mov		ax, 1
    83 00001206 F6450102            <2> 	test	BYTE [di+DPT.bFlagsHigh], FLGH_DPT_BLOCK_MODE_SUPPORTED
    84 0000120A 7403                <2> 	jz		SHORT .PushBlockSizeFromAX
    85 0000120C 8A450D              <2> 	mov		al, [di+DPT_ATA.bBlockSize]
    86                              <2> .PushBlockSizeFromAX:
    87 0000120F 50                  <2> 	push	ax
    88                              <2> 	; Fall to .PushDeviceType
    89                              <2> 
    90                              <2> ;--------------------------------------------------------------------
    91                              <2> ; .PushDeviceType
    92                              <2> ;	Parameters:
    93                              <2> ;		DS:DI:	Ptr to DPT
    94                              <2> ;		CS:BX:	Ptr to IDEVARS
    95                              <2> ;	Returns:
    96                              <2> ;		Nothing (falls to next push below)
    97                              <2> ;	Corrupts registers:
    98                              <2> ;		AX
    99                              <2> ;--------------------------------------------------------------------
   100                              <2> .PushDeviceType:
   101                              <2> %ifndef MODULE_SERIAL
   102 00001210 B003                <2> 	mov		al, g_szDeviceTypeValues_Displacement
   103 00001212 F6650C              <2> 	mul		BYTE [di+DPT_ATA.bDevice]
   104                              <2> %else
   105                              <2> 	mov		ah, [cs:bx+IDEVARS.bDevice]
   106                              <2> 	test	BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE	; Clears CF
   107                              <2> 	eCMOVZ	ah, [di+DPT_ATA.bDevice]	; DPT_ATA contains up to date device information for IDE drives
   108                              <2> %ifdef USE_UNDOC_INTEL
   109                              <2> 	eSALC	; Clear AL using CF (from TEST above)
   110                              <2> 	eAAD	g_szDeviceTypeValues_Displacement
   111                              <2> %else
   112                              <2> 	mov		al, g_szDeviceTypeValues_Displacement
   113                              <2> 	mul		ah
   114                              <2> %endif ; USE_UNDOC_INTEL
   115                              <2> %endif ; MODULE_SERIAL
   116                              <2> 
   117                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   118                              <2> 	%if (COUNT_OF_ALL_IDE_DEVICES * 2 * g_szDeviceTypeValues_Displacement) > 255
   119                              <2> 		%error "The USE_UNDOC_INTEL block in .PushDeviceType needs to be removed (would cause an overflow)!"
   120                              <2> 	%endif
   121                              <2> %endif
   122                              <2> 
   123 00001215 D1E8                <2> 	shr		ax, 1	; Divide by 2 since IDEVARS.bDevice is multiplied by 2
   124 00001217 05[5201]            <2> 	add		ax, g_szDeviceTypeValues
   125 0000121A 50                  <2> 	push	ax
   126                              <2> 	; Fall to .PushIRQ
   127                              <2> 
   128                              <2> ;--------------------------------------------------------------------
   129                              <2> ; .PushIRQ
   130                              <2> ;	Parameters:
   131                              <2> ;		DS:DI:	Ptr to DPT
   132                              <2> ;		CS:BX:	Ptr to IDEVARS
   133                              <2> ;	Returns:
   134                              <2> ;		Nothing (falls to next push below)
   135                              <2> ;	Corrupts registers:
   136                              <2> ;		AX
   137                              <2> ;--------------------------------------------------------------------
   138                              <2> .PushIRQ:
   139 0000121B 2E8A4705            <2> 	mov		al, [cs:bx+IDEVARS.bIRQ]
   140 0000121F 98                  <2> 	cbw
   141 00001220 50                  <2> 	push	ax
   142                              <2> 	; Fall to .PushResetStatus
   143                              <2> 
   144                              <2> ;--------------------------------------------------------------------
   145                              <2> ; .PushResetStatus
   146                              <2> ;	Parameters:
   147                              <2> ;		DS:DI:	Ptr to DPT
   148                              <2> ;		CS:BX:	Ptr to IDEVARS
   149                              <2> ;	Returns:
   150                              <2> ;		Nothing (falls to next push below)
   151                              <2> ;	Corrupts registers:
   152                              <2> ;		AX, BX, DX, ES
   153                              <2> ;--------------------------------------------------------------------
   154                              <2> .PushResetStatus:
   155 00001221 8A4503              <2> 	mov		al, [di+DPT.bInitError]
   156 00001224 50                  <2> 	push	ax
   157                              <2> 
   158                              <2> ;;; fall-out to BootMenuPrint_HardDiskRefreshInformation.
   216 00001225 E9E2FC              <1> 	jmp		DetectPrint_FormatCSSIfromParamsInSSBP
   217                              <1> 
   218                              <1> 
   219                              <1> FloppyTypes:
   220                              <1> .rgbCapacityMultiplier equ 120		; Multiplier to reduce word sized values to byte size
   221                              <1> .rgbCapacity:
   222 00001228 03                  <1> 	db		360   / FloppyTypes.rgbCapacityMultiplier    ;  type 1
   223 00001229 0A                  <1> 	db		1200  / FloppyTypes.rgbCapacityMultiplier    ;  type 2
   224 0000122A 06                  <1> 	db		720   / FloppyTypes.rgbCapacityMultiplier    ;  type 3
   225 0000122B 0C                  <1> 	db		1440  / FloppyTypes.rgbCapacityMultiplier    ;  type 4
   226 0000122C 18                  <1> 	db		2880  / FloppyTypes.rgbCapacityMultiplier    ;  type 5
   227 0000122D 18                  <1> 	db		2880  / FloppyTypes.rgbCapacityMultiplier    ;  type 6
   228                              <1> 
   229                              <1> 
   230                              <1> ;--------------------------------------------------------------------
   231                              <1> ; GetTotalSectorCount
   232                              <1> ;	Parameters:
   233                              <1> ;		DS:DI:		DPT Pointer
   234                              <1> ;	Returns:
   235                              <1> ;		BX:DX:AX:	48-bit sector count
   236                              <1> ;	Corrupts registers:
   237                              <1> ;		CX
   238                              <1> ;--------------------------------------------------------------------
   239                              <1> %ifdef MODULE_EBIOS
   240                              <1> GetTotalSectorCount		EQU		AccessDPT_GetLbaSectorCountToBXDXAX
   241                              <1> %else
   242                              <1> GetTotalSectorCount		EQU		AH15h_GetSectorCountToBXDXAX
   243                              <1> %endif
   220                                  %endif
   221                                  
   222                                  	; Boot loader
   223                                  	%include "Int19h.asm"			; For Int 19h, Boot Loader
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 19h Handler (Boot Loader).
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int19h_BootLoaderHandler
    25                              <1> ;	Parameters:
    26                              <1> ;		Nothing
    27                              <1> ;	Returns:
    28                              <1> ;		Never returns (loads operating system)
    29                              <1> ;--------------------------------------------------------------------
    30                              <1> Int19h_BootLoaderHandler:
    31 0000122E FB                  <1> 	sti									; Enable interrupts
    32 0000122F FC                  <1> 	cld									; String instructions to increment pointers
    33                              <1> 	LOAD_BDA_SEGMENT_TO	es, ax			; Load BDA segment (zero) to ES
    33                              <2> %ifndef USE_186
    33 00001230 31C0                <2>  xor %2, %2
    33 00001232 8EC0                <2>  mov %1, %2
    33                              <2> %elifidn %3, !
    33                              <2>  xor %2, %2
    33                              <2>  mov %1, %2
    33                              <2> %else
    33                              <2>  push BYTE 0
    33                              <2>  pop %1
    33                              <2> %endif
    34                              <1> 	; Fall to .PrepareBootLoaderStack
    35                              <1> 
    36                              <1> 
    37                              <1> ;--------------------------------------------------------------------
    38                              <1> ; Drive detection and boot menu use lots of stack so it is
    39                              <1> ; wise to relocate stack. Otherwise something important from
    40                              <1> ; interrupt vectors are likely corrupted, likely our own DPTs if
    41                              <1> ; they are located to 30:0h.
    42                              <1> ;
    43                              <1> ; .PrepareBootLoaderStack
    44                              <1> ;	Parameters:
    45                              <1> ;		ES:		BDA and interrupt vector segment (zero)
    46                              <1> ;	Returns:
    47                              <1> ;		Never returns (loads operating system)
    48                              <1> ;--------------------------------------------------------------------
    49                              <1> .PrepareBootLoaderStack:
    50                              <1> 	STORE_POST_STACK_POINTER
    50 00001234 268926007F          <2>  mov [es:BOOTVARS.dwPostStack], sp
    50 00001239 268C16027F          <2>  mov [es:BOOTVARS.dwPostStack+2], ss
    51                              <1> 	SWITCH_TO_BOOT_MENU_STACK
    51                              <2> %ifndef USE_186
    51 0000123E FA                  <2>  cli
    51                              <2> %endif
    51                              <2>  LOAD_BDA_SEGMENT_TO ss, sp
    51                              <3> %ifndef USE_186
    51 0000123F 31E4                <3>  xor %2, %2
    51 00001241 8ED4                <3>  mov %1, %2
    51                              <3> %elifidn %3, !
    51                              <3>  xor %2, %2
    51                              <3>  mov %1, %2
    51                              <3> %else
    51                              <3>  push BYTE 0
    51                              <3>  pop %1
    51                              <3> %endif
    51 00001243 BC007F              <2>  mov sp, BOOTVARS.rgbMnuStack
    51                              <2> %ifndef USE_186
    51 00001246 FB                  <2>  sti
    51                              <2> %endif
    52                              <1> 	; Fall to .InitializeDisplay
    53                              <1> 
    54                              <1> 
    55                              <1> ;--------------------------------------------------------------------
    56                              <1> ; .InitializeDisplay
    57                              <1> ;	Parameters:
    58                              <1> ;		ES:		BDA and interrupt vector segment (zero)
    59                              <1> ;	Returns:
    60                              <1> ;		Never returns (loads operating system)
    61                              <1> ;--------------------------------------------------------------------
    62                              <1> .InitializeDisplay:
    63                              <1> 	; Change display mode if necessary
    64 00001247 2EA14800            <1> 	mov		ax, [cs:ROMVARS.wDisplayMode]	; AH 00h = Set Video Mode
    65 0000124B 3C04                <1> 	cmp		al, DEFAULT_TEXT_MODE
    66 0000124D 7402                <1> 	je		SHORT .InitializeDisplayLibrary
    67 0000124F CD10                <1> 	int		BIOS_VIDEO_INTERRUPT_10h
    68                              <1> .InitializeDisplayLibrary:
    69 00001251 E848FC              <1> 	call	DetectPrint_InitializeDisplayContext
    70                              <1> 	; Fall to .InitializeBiosAndDetectDrives
    71                              <1> 
    72                              <1> 
    73                              <1> ;--------------------------------------------------------------------
    74                              <1> ; .InitializeBiosAndDetectDrives
    75                              <1> ;	Parameters:
    76                              <1> ;		ES:		BDA and interrupt vector segment (zero)
    77                              <1> ;	Returns:
    78                              <1> ;		DS:		RAMVARS segment
    79                              <1> ;--------------------------------------------------------------------
    80                              <1> %ifdef MODULE_HOTKEYS
    81 00001254 E86EF7              <1> 	call	TimerTicks_ReadFromBdaToAX
    82 00001257 26A3067F            <1> 	mov		[es:BOOTVARS.hotkeyVars+HOTKEYVARS.wTimeWhenDisplayed], ax
    83                              <1> %endif
    84                              <1> 
    85 0000125B E857F8              <1> 	call	Initialize_AndDetectDrives
    86                              <1> 
    87                              <1> %ifdef MODULE_HOTKEYS
    88                              <1> .WaitUntilTimeToCloseHotkeyBar:
    89 0000125E E864F7              <1> 	call	TimerTicks_ReadFromBdaToAX
    90 00001261 262B06067F          <1> 	sub		ax, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.wTimeWhenDisplayed]
    91 00001266 83F848              <1> 	cmp		ax, MIN_TIME_TO_DISPLAY_HOTKEY_BAR
    92 00001269 72F3                <1> 	jb		SHORT .WaitUntilTimeToCloseHotkeyBar
    93                              <1> %endif
    94                              <1> 	; Fall to SelectDriveToBootFrom
    95                              <1> 
    96                              <1> 
    97                              <1> ;--------------------------------------------------------------------
    98                              <1> ; SelectDriveToBootFrom
    99                              <1> ;	Parameters:
   100                              <1> ;		DS:		RAMVARS segment
   101                              <1> ;		ES:		BDA and interrupt vector segment (zero)
   102                              <1> ;	Returns:
   103                              <1> ;		Never returns (loads operating system)
   104                              <1> ;--------------------------------------------------------------------
   105                              <1> ; The following macro could be easily inlined below.  Why a macro?  Depending on the combination
   106                              <1> ; of MODULE_HOTKEYS or MODULE_BOOT_MENU, this code needs to either come before or after the
   107                              <1> ; call to the boot menu.
   108                              <1> ;
   109                              <1> %macro TRY_TO_BOOT_DL_AND_DH_DRIVES 0
   110                              <1> 	push	dx									; it's OK if this is left on the stack, if we are
   111                              <1> 												; successful, the following call does not return
   112                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
   113                              <1> 	pop		dx
   114                              <1> 	mov		dl, dh
   115                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
   116                              <1> %endmacro
   117                              <1> 
   118                              <1> 
   119                              <1> SelectDriveToBootFrom:		; Function starts here
   120                              <1> %ifdef MODULE_HOTKEYS
   121 0000126B E8A5FC              <1> 	call	HotkeyBar_UpdateDuringDriveDetection
   122 0000126E 26A00B7F            <1> 	mov		al, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bScancode]
   123 00001272 3C42                <1> 	cmp		al, ROM_BOOT_HOTKEY_SCANCODE
   124 00001274 7428                <1> 	je		SHORT .RomBoot						; CF clear so ROM boot
   125                              <1> %ifdef MODULE_BOOT_MENU
   126 00001276 3C3C                <1> 	cmp		al, BOOT_MENU_HOTKEY_SCANCODE
   127 00001278 741A                <1> 	je		SHORT .BootMenu
   128                              <1> %endif ; MODULE_BOOT_MENU
   129                              <1> 
   130                              <1> .TryUsingHotKeysCode:
   131 0000127A E869FD              <1> 	call	HotkeyBar_GetBootDriveNumbersToDX
   132 0000127D E8CAFD              <1> 	call	DriveXlate_SetDriveToSwap			; Enable primary boot device translation
   133 00001280 86D6                <1> 	xchg	dl, dh
   134 00001282 E8C5FD              <1> 	call	DriveXlate_SetDriveToSwap			; Enable secondary boot device translation
   135 00001285 86D6                <1> 	xchg	dl, dh
   136 00001287 E89DFD              <1> 	call	DriveXlate_ToOrBack					; Tranlate now so boot device will appear as 00h or 80h to OS
   137                              <1> 	TRY_TO_BOOT_DL_AND_DH_DRIVES
   137 0000128A 52                  <2>  push dx
   137                              <2> 
   137 0000128B E83200              <2>  call BootSector_TryToLoadFromDriveDL_AndBoot
   137 0000128E 5A                  <2>  pop dx
   137 0000128F 88F2                <2>  mov dl, dh
   137 00001291 E82C00              <2>  call BootSector_TryToLoadFromDriveDL_AndBoot
   138                              <1> 	;; falls through to boot menu, if it is present.  If not present, falls through to rom boot.
   139                              <1> %endif ; MODULE_HOTKEYS
   140                              <1> 
   141                              <1> 
   142                              <1> %ifdef MODULE_BOOT_MENU
   143                              <1> .BootMenu:
   144 00001294 E8C1FD              <1> 	call	BootMenu_DisplayAndReturnDriveInDLRomBootClearCF
   145 00001297 7305                <1> 	jnc		SHORT .RomBoot						; CF clear so ROM boot
   146                              <1> 
   147 00001299 E8A7FD              <1> 	call	DriveXlate_Reset
   148                              <1> %ifdef MODULE_HOTKEYS
   149 0000129C EBDC                <1> 	jmp		SHORT .TryUsingHotKeysCode			; Selected drive stored as hotkey
   150                              <1> %else ; Boot menu without hotkeys, secondary boot drive is always 00h or 80h
   151                              <1> 	mov		dh, dl								; Setup for secondary drive
   152                              <1> 	not		dh									; Floppy goes to HD, or vice versa
   153                              <1> 	and		dh, 80h								; Go to first drive of the floppy or HD set
   154                              <1> 	call	DriveXlate_SetDriveToSwap
   155                              <1> 	call	DriveXlate_ToOrBack
   156                              <1> 	TRY_TO_BOOT_DL_AND_DH_DRIVES
   157                              <1> 	jmp		SHORT .BootMenu						; Show boot menu again
   158                              <1> %endif ; MODULE_HOTKEYS
   159                              <1> 
   160                              <1> %endif ; MODULE_BOOT_MENU
   161                              <1> 
   162                              <1> ; No hotkeys and no boot menu means fixed "A then C" boot order
   163                              <1> %ifndef MODULE_HOTKEYS OR MODULE_BOOT_MENU
   164                              <1> 	xor		dl, dl							; Try to boot from Floppy Drive A
   165                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
   166                              <1> 	mov		dl, DEFAULT_HARD_DRIVE_LETTER	; Try to boot from Hard Drive C
   167                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
   168                              <1> %endif
   169                              <1> 
   170                              <1> .RomBoot:
   171                              <1> %ifdef MODULE_DRIVEXLATE
   172 0000129E E8A2FD              <1> 	call	DriveXlate_Reset					; Clean up any drive mappings before Rom Boot
   173                              <1> %endif
   174 000012A1 F8                  <1> 	clc
   175                              <1> 	;; fall through to Int19_JumpToBootSectorOrRomBoot
   176                              <1> 
   177                              <1> ;--------------------------------------------------------------------
   178                              <1> ; Int19_JumpToBootSectorOrRomBoot
   179                              <1> ;
   180                              <1> ; Switches back to the POST stack, clears the DS and ES registers,
   181                              <1> ; and either jumps to the MBR (Master Boot Record) that was just read,
   182                              <1> ; or calls the ROM's boot routine on interrupt 18.
   183                              <1> ;
   184                              <1> ;	Parameters:
   185                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
   186                              <1> ;       CF:     Set for Boot Sector Boot
   187                              <1> ;               Clear for ROM Boot
   188                              <1> ;	   	ES:BX:	(if CF set) Ptr to boot sector
   189                              <1> ;
   190                              <1> ;	Returns:
   191                              <1> ;		Never returns
   192                              <1> ;--------------------------------------------------------------------
   193                              <1> Int19_JumpToBootSectorOrRomBoot:
   194 000012A2 8CC1                <1> 	mov		cx, es		; Preserve MBR segment (can't push because of stack change)
   195 000012A4 B80000              <1> 	mov		ax, 0		; NOTE: can't use XOR (LOAD_BDA_SEGMENT_TO) as it impacts CF
   196                              <1> 	SWITCH_BACK_TO_POST_STACK
   196                              <2> %ifndef USE_386
   196 000012A7 FA                  <2>  cli
   196 000012A8 8ED0                <2>  mov ss, ax
   196 000012AA 368B26007F          <2>  mov sp, [ss:BOOTVARS.dwPostStack]
   196 000012AF 368E16027F          <2>  mov ss, [ss:BOOTVARS.dwPostStack+2]
   196 000012B4 FB                  <2>  sti
   196                              <2> %else
   196                              <2>  mov ss, ax
   196                              <2>  lss sp, [ss:BOOTVARS.dwPostStack]
   196                              <2> %endif
   197                              <1> 
   198                              <1> ; clear segment registers before boot sector or rom call
   199 000012B5 8ED8                <1> 	mov		ds, ax
   200 000012B7 8EC0                <1> 	mov		es, ax
   201                              <1> %ifdef USE_386
   202                              <1> 	mov		fs, ax
   203                              <1> 	mov		gs, ax
   204                              <1> %endif
   205 000012B9 7303                <1> 	jnc		SHORT .romboot
   206                              <1> 
   207                              <1> ; jump to boot sector
   208 000012BB 51                  <1> 	push	cx			; sgment address for MBR
   209 000012BC 53                  <1> 	push	bx			; offset address for MBR
   210 000012BD CB                  <1> 	retf				; NOTE:	DL is set to the drive number
   211                              <1> 
   212                              <1> ; Boot by calling INT 18h (ROM Basic of ROM DOS)
   213                              <1> .romboot:
   214 000012BE CD18                <1> 	int		BIOS_BOOT_FAILURE_INTERRUPT_18h	; Never returns
   224                                  	%include "BootSector.asm"		; For loading boot sector
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Reading and jumping to boot sector.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; BootSector_TryToLoadFromDriveDL_AndBoot
    25                              <1> ;	Parameters:
    26                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
    27                              <1> ;		DS:		RAMVARS segment
    28                              <1> ;	Returns:
    29                              <1> ;		ES:BX:	Ptr to boot sector (if successful)
    30                              <1> ;		CF:		Set if boot sector loaded successfully
    31                              <1> ;				Cleared if failed to load boot sector
    32                              <1> ;	Corrupts registers:
    33                              <1> ;		AX, CX, DH, SI, DI, (DL if failed to read boot sector)
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> BootSector_TryToLoadFromDriveDL_AndBoot:
    36 000012C0 E825FC              <1> 	call	DetectPrint_TryToBootFromDL
    37 000012C3 E82B00              <1> 	call	LoadFirstSectorFromDriveDL
    38 000012C6 7311                <1> 	jnc		SHORT .FirstSectorLoadedToESBX
    39                              <1> 
    40                              <1> 	; Do not display timeout error (80h) for floppy drives since
    41                              <1> 	; it most likely mean no diskette in drive. This way we do not
    42                              <1> 	; display error code every time user intends to boot from hard disk
    43                              <1> 	; when A then C boot order is used.
    44 000012C8 780A                <1> 	js		SHORT .PrintFailedToLoadErrorCode	; Hard Drive
    45 000012CA 80FC80              <1> 	cmp		ah, RET_HD_TIMEOUT
    46 000012CD 7420                <1> 	je		SHORT .ReturnWithCFclearSinceFailedToLoadBootSector
    47 000012CF 80FC31              <1> 	cmp		ah, RET_HD_NOMEDIA
    48 000012D2 741B                <1> 	je		SHORT .ReturnWithCFclearSinceFailedToLoadBootSector
    49                              <1> .PrintFailedToLoadErrorCode:
    50                              <1> %ifdef USE_186
    51                              <1> 	push	.ReturnWithCFclearSinceFailedToLoadBootSector
    52                              <1> 	jmp		DetectPrint_FailedToLoadFirstSector
    53                              <1> %else
    54 000012D4 E804FC              <1> 	call	DetectPrint_FailedToLoadFirstSector
    55 000012D7 EB16                <1> 	jmp		.ReturnWithCFclearSinceFailedToLoadBootSector
    56                              <1> %endif
    57                              <1> 
    58                              <1> 
    59                              <1> .FirstSectorLoadedToESBX:
    60 000012D9 84D2                <1> 	test	dl, dl
    61 000012DB 7909                <1> 	jns		SHORT .AlwaysBootFromFloppyDriveForBooterGames
    62 000012DD 2681BFFE0155AA      <1> 	cmp		WORD [es:bx+510], 0AA55h		; Valid boot sector?
    63 000012E4 7503                <1> 	jne		SHORT .FirstHardDiskSectorNotBootable
    64                              <1> .AlwaysBootFromFloppyDriveForBooterGames:
    65 000012E6 F9                  <1> 	stc		; Boot Sector loaded succesfully
    66 000012E7 EBB9                <1> 	jmp		SHORT Int19_JumpToBootSectorOrRomBoot
    67                              <1> 
    68                              <1> .FirstHardDiskSectorNotBootable:
    69 000012E9 BE[DF00]            <1> 	mov		si, g_szBootSectorNotFound
    70 000012EC E818FC              <1> 	call	DetectPrint_NullTerminatedStringFromCSSI
    71                              <1> .ReturnWithCFclearSinceFailedToLoadBootSector:
    72 000012EF F8                  <1> 	clc
    73 000012F0 C3                  <1> 	ret
    74                              <1> 
    75                              <1> 
    76                              <1> ;--------------------------------------------------------------------
    77                              <1> ; LoadFirstSectorFromDriveDL
    78                              <1> ;	Parameters:
    79                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
    80                              <1> ;	Returns:
    81                              <1> ;		AH:		INT 13h error code
    82                              <1> ;		ES:BX:	Ptr to boot sector (if successful)
    83                              <1> ;		CF:		Cleared if read successful
    84                              <1> ;				Set if any error
    85                              <1> ;	Corrupts registers:
    86                              <1> ;		AL, CX, DH, DI
    87                              <1> ;--------------------------------------------------------------------
    88                              <1> LoadFirstSectorFromDriveDL:
    89                              <1> 	LOAD_BDA_SEGMENT_TO	es, bx				; ES:BX now points to...
    89                              <2> %ifndef USE_186
    89 000012F1 31DB                <2>  xor %2, %2
    89 000012F3 8EC3                <2>  mov %1, %2
    89                              <2> %elifidn %3, !
    89                              <2>  xor %2, %2
    89                              <2>  mov %1, %2
    89                              <2> %else
    89                              <2>  push BYTE 0
    89                              <2>  pop %1
    89                              <2> %endif
    90 000012F5 BB007C              <1> 	mov		bx, BOOTVARS.rgbBootSect		; ...boot sector location
    91 000012F8 BF0300              <1> 	mov		di, BOOT_READ_RETRY_TIMES		; Initialize retry counter
    92                              <1> 
    93                              <1> .ReadRetryLoop:
    94 000012FB B80102              <1> 	mov		ax, 0201h						; Read 1 sector
    95 000012FE B90100              <1> 	mov		cx, 1							; Cylinder 0, Sector 1
    96 00001301 30F6                <1> 	xor		dh, dh							; Head 0
    97 00001303 CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h
    98 00001305 7201                <1> 	jc		SHORT .FailedToLoadFirstSector
    99                              <1> .Return:
   100 00001307 C3                  <1> 	ret
   101                              <1> 
   102                              <1> .FailedToLoadFirstSector:
   103 00001308 4F                  <1> 	dec		di								; Decrement retry counter (preserve CF)
   104 00001309 74FC                <1> 	jz		SHORT .Return					; Loop while retries left
   105                              <1> 
   106                              <1> 	; Reset drive and retry
   107 0000130B 31C0                <1> 	xor		ax, ax							; AH=00h, Disk Controller Reset
   108 0000130D 84D2                <1> 	test	dl, dl							; Floppy drive?
   109                              <1> 	eCMOVS	ah, RESET_HARD_DISK				; AH=0Dh, Reset Hard Disk (Alternate reset)
   109 0000130F 7902                <2>  jns SHORT %%Return
   109 00001311 B40D                <2>  mov %1, %2
   109                              <2> %%Return:
   110 00001313 CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h
   111 00001315 EBE4                <1> 	jmp		SHORT .ReadRetryLoop
   112                              <1> 
   225                                  	%include "Int19hReset.asm"		; INT 19h handler for proper system reset
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 19h Handler (Boot Loader).
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; INT 19h handler that properly reboots the computer when
    25                              <1> ; INT 19h is called.
    26                              <1> ;
    27                              <1> ; Int19hReset_Handler
    28                              <1> ;	Parameters:
    29                              <1> ;		Nothing
    30                              <1> ;	Returns:
    31                              <1> ;		Never returns (reboots computer)
    32                              <1> ;--------------------------------------------------------------------
    33                              <1> Int19hReset_Handler:
    34 00001317 B83412              <1> 	mov		ax, BOOT_FLAG_WARM				; Skip memory tests
    35 0000131A E9CAF6              <1> 	jmp		Reboot_ComputerWithBootFlagInAX
   226                                  
   227                                  	; For all device types
   228                                  	%include "Idepack.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for managing IDEPACK struct.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Idepack_FakeToSSBP
    25                              <1> ;	Parameters:
    26                              <1> ;		Nothing
    27                              <1> ;	Returns:
    28                              <1> ;		SS:BP:	Ptr to IDEPACK
    29                              <1> ;	Corrupts registers:
    30                              <1> ;		AX
    31                              <1> ;--------------------------------------------------------------------
    32                              <1> Idepack_FakeToSSBP:
    33 0000131D 58                  <1> 	pop		ax
    34 0000131E 83EC09              <1> 	sub		sp, BYTE SIZE_OF_IDEPACK_WITHOUT_INTPACK
    35 00001321 89E5                <1> 	mov		bp, sp
    36 00001323 FFE0                <1> 	jmp		ax
    37                              <1> 
    38                              <1> 
    39                              <1> ;--------------------------------------------------------------------
    40                              <1> ; Idepack_ConvertDapToIdepackAndIssueCommandFromAH
    41                              <1> ;	Parameters:
    42                              <1> ;		AH:		IDE command to issue
    43                              <1> ;		BH:		Timeout ticks
    44                              <1> ;		BL:		IDE Status Register flag to wait after command
    45                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    46                              <1> ;		ES:SI:	Ptr to DAP (EBIOS Disk Address Packet)
    47                              <1> ;		SS:BP:	Ptr to IDEPACK
    48                              <1> ;	Returns:
    49                              <1> ;		AH:		INT 13h Error Code
    50                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
    51                              <1> ;		CF:		Cleared if success, Set if error
    52                              <1> ;	Corrupts registers:
    53                              <1> ;		AL, BX, (CX), DX, SI, ES
    54                              <1> ;--------------------------------------------------------------------
    55                              <1> %ifdef MODULE_EBIOS
    56                              <1> ALIGN JUMP_ALIGN
    57                              <1> Idepack_ConvertDapToIdepackAndIssueCommandFromAH:
    58                              <1> 	mov		al, [es:si+DAP.wSectorCount]
    59                              <1> 	mov		[bp+IDEPACK.bSectorCount], al
    60                              <1> 	mov		[bp+IDEPACK.bCommand], ah
    61                              <1> 
    62                              <1> 	mov		al, [es:si+DAP.qwLBA]		; LBA byte 0
    63                              <1> 	mov		[bp+IDEPACK.bLbaLow], al
    64                              <1> 	mov		ax, [es:si+DAP.qwLBA+1]		; LBA bytes 1 and 2
    65                              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHigh], ax
    66                              <1> 	mov		ah, [es:si+DAP.qwLBA+3]		; LBA byte 3, LBA28 bits 24...27
    67                              <1> 	mov		[bp+IDEPACK.bLbaLowExt], ah
    68                              <1> 	mov		cx, [es:si+DAP.qwLBA+4]		; LBA bytes 4 and 5
    69                              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHighExt], cx
    70                              <1> 
    71                              <1> 	and		ah, 0Fh						; Limit bits for LBA28
    72                              <1> 	call	AccessDPT_GetDriveSelectByteForEbiosToAL
    73                              <1> 	or		al, ah
    74                              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
    75                              <1> 
    76                              <1> 	; Load data buffer pointer to ES:SI
    77                              <1> 	les		si, [es:si+DAP.dwMemoryAddress]
    78                              <1> 	jmp		SHORT GetDeviceControlByteToIdepackAndStartTransfer
    79                              <1> %endif ; MODULE_EBIOS
    80                              <1> 
    81                              <1> 
    82                              <1> ;--------------------------------------------------------------------
    83                              <1> ; Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
    84                              <1> ;	Parameters:
    85                              <1> ;		AH:		IDE command to issue
    86                              <1> ;		AL:		Number of sectors to transfer (for xfer commands)
    87                              <1> ;		BH:		Timeout ticks
    88                              <1> ;		BL:		IDE Status Register flag to wait after command
    89                              <1> ;		CH:		Cylinder number, bits 7...0
    90                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
    91                              <1> ;				Bits 5...0:	Starting sector number (1...63)
    92                              <1> ;		DH:		Starting head number (0...255)
    93                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    94                              <1> ;		ES:SI:	Ptr to normalized data buffer (for xfer commands)
    95                              <1> ;		SS:BP:	Ptr to IDEPACK (containing INTPACK)
    96                              <1> ;	Returns:
    97                              <1> ;		AH:		INT 13h Error Code
    98                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
    99                              <1> ;		CF:		Cleared if success, Set if error
   100                              <1> ;	Corrupts registers:
   101                              <1> ;		AL, BX, (CX), DX
   102                              <1> ;--------------------------------------------------------------------
   103                              <1> ALIGN JUMP_ALIGN
   104                              <1> Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH:
   105 00001325 884602              <1> 	mov		[bp+IDEPACK.bSectorCount], al
   106 00001328 886606              <1> 	mov		[bp+IDEPACK.bCommand], ah
   107                              <1> 
   108 0000132B 53                  <1> 	push	bx
   109 0000132C E8B309              <1> 	call	Address_OldInt13hAddressToIdeAddress
   110 0000132F E89AF9              <1> 	call	AccessDPT_GetDriveSelectByteForOldInt13hToAL
   111 00001332 08F8                <1> 	or		al, bh			; AL now has Drive and Head Select Byte
   112 00001334 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
   113 00001337 885E03              <1> 	mov		[bp+IDEPACK.bLbaLow], bl
   114 0000133A 894E04              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHigh], cx
   115 0000133D 5B                  <1> 	pop		bx
   116                              <1> 
   117                              <1> GetDeviceControlByteToIdepackAndStartTransfer:
   118 0000133E E89BF9              <1> 	call	AccessDPT_GetDeviceControlByteToAL
   119 00001341 884607              <1> 	mov		[bp+IDEPACK.bDeviceControl], al
   120 00001344 E9C100              <1> 	jmp		Device_OutputCommandWithParameters
   121                              <1> 
   122                              <1> 
   123                              <1> ;--------------------------------------------------------------------
   124                              <1> ; Idepack_StoreNonExtParametersAndIssueCommandFromAL
   125                              <1> ;	Parameters:
   126                              <1> ;		BH:		Timeout ticks
   127                              <1> ;		BL:		IDE Status Register flag to wait after command
   128                              <1> ;		AL:		IDE command to issue
   129                              <1> ;		AH:		Parameter to Drive and Head Select Register (Head bits only)
   130                              <1> ;		DL:		Parameter to Sector Count Register
   131                              <1> ;		DH:		Parameter to LBA Low / Sector Number Register
   132                              <1> ;		CL:		Parameter to LBA Middle / Cylinder Low Register
   133                              <1> ;		CH:		Parameter to LBA High / Cylinder High Register
   134                              <1> ;		SI:		Parameter to Features Register
   135                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   136                              <1> ;		SS:BP:	Ptr to IDEPACK
   137                              <1> ;	Returns:
   138                              <1> ;		AH:		INT 13h Error Code
   139                              <1> ;		CF:		Cleared if success, Set if error
   140                              <1> ;	Corrupts registers:
   141                              <1> ;		AL, BX, CX, DX
   142                              <1> ;--------------------------------------------------------------------
   143                              <1> ALIGN JUMP_ALIGN
   144                              <1> Idepack_StoreNonExtParametersAndIssueCommandFromAL:
   145 00001347 897600              <1> 	mov		[bp+IDEPACK.bFeatures], si
   146 0000134A 884606              <1> 	mov		[bp+IDEPACK.bCommand], al
   147 0000134D 895602              <1> 	mov		[bp+IDEPACK.wSectorCountAndLbaLow], dx
   148 00001350 894E04              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHigh], cx
   149                              <1> 
   150                              <1> 	; Drive and Head select byte
   151 00001353 80E40F              <1> 	and		ah, MASK_DRVNHEAD_HEAD		; Keep head bits only
   152 00001356 E873F9              <1> 	call	AccessDPT_GetDriveSelectByteForOldInt13hToAL
   153 00001359 08E0                <1> 	or		al, ah
   154 0000135B 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
   155                              <1> 
   156                              <1> 	; Device Control byte with interrupts disabled
   157 0000135E C6460702            <1> 	mov		BYTE [bp+IDEPACK.bDeviceControl], FLG_DEVCONTROL_nIEN
   158                              <1> 
   159 00001362 E9A300              <1> 	jmp		Device_OutputCommandWithParameters
   229                                  	%include "Device.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Command and port direction functions for different device types.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> 
    24                              <1> %macro TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE 1
    25                              <1> 	test	BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE
    26                              <1> 	jnz		SHORT %1
    27                              <1> %endmacro
    28                              <1> 
    29                              <1> %macro CMP_USING_IDEVARS_IN_CSBP_AND_JUMP_IF 2
    30                              <1> 	cmp		BYTE [cs:bp+IDEVARS.bDevice], %1
    31                              <1> 	je		SHORT %2
    32                              <1> %endmacro
    33                              <1> 
    34                              <1> 
    35                              <1> 
    36                              <1> ;--------------------------------------------------------------------
    37                              <1> ; Device_FinalizeDPT
    38                              <1> ;	Parameters:
    39                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    40                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    41                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
    42                              <1> ;	Returns:
    43                              <1> ;		Nothing
    44                              <1> ;	Corrupts registers:
    45                              <1> ;		AX, BX, CX, DX
    46                              <1> ;--------------------------------------------------------------------
    47                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
    48                              <1> Device_FinalizeDPT:
    49                              <1> 	; needs to check IDEVARS vs. checking the DPT as the serial bit in the DPT is set in the Finalize routine
    50                              <1> 	CMP_USING_IDEVARS_IN_CSBP_AND_JUMP_IF	DEVICE_SERIAL_PORT, .FinalizeDptForSerialPortDevice
    51                              <1> 	jmp		IdeDPT_Finalize
    52                              <1> .FinalizeDptForSerialPortDevice:
    53                              <1> 	jmp		SerialDPT_Finalize
    54                              <1> 
    55                              <1> %else					; IDE
    56                              <1> 	Device_FinalizeDPT		EQU		IdeDPT_Finalize
    57                              <1> %endif
    58                              <1> 
    59                              <1> 
    60                              <1> ;--------------------------------------------------------------------
    61                              <1> ; Device_ResetMasterAndSlaveController
    62                              <1> ;	Parameters:
    63                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    64                              <1> ;	Returns:
    65                              <1> ;		AH:		INT 13h Error Code
    66                              <1> ;		CF:		Cleared if success, Set if error
    67                              <1> ;	Corrupts registers:
    68                              <1> ;		AL, BX, CX, DX
    69                              <1> ;--------------------------------------------------------------------
    70                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
    71                              <1> Device_ResetMasterAndSlaveController:
    72                              <1> 	TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE	ReturnSuccessForSerialPort
    73                              <1> 	jmp		IdeCommand_ResetMasterAndSlaveController
    74                              <1> 
    75                              <1> %else					; IDE
    76                              <1> 	Device_ResetMasterAndSlaveController	EQU		IdeCommand_ResetMasterAndSlaveController
    77                              <1> %endif
    78                              <1> 
    79                              <1> 
    80                              <1> ;--------------------------------------------------------------------
    81                              <1> ; Device_IdentifyToBufferInESSIwithDriveSelectByteInBH
    82                              <1> ;	Parameters:
    83                              <1> ;		BH:		Drive Select byte for Drive and Head Select Register
    84                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
    85                              <1> ;		DS:		Segment to RAMVARS
    86                              <1> ;		ES:SI:	Ptr to buffer to receive 512-byte IDE Information
    87                              <1> ;		CS:BP:	Ptr to IDEVARS
    88                              <1> ;	Returns:
    89                              <1> ;		AH:		INT 13h Error Code
    90                              <1> ;		CF:		Cleared if success, Set if error
    91                              <1> ;	Corrupts registers:
    92                              <1> ;		AL, BX, CX, DX, SI, DI, ES
    93                              <1> ;--------------------------------------------------------------------
    94                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
    95                              <1> Device_IdentifyToBufferInESSIwithDriveSelectByteInBH:
    96                              <1> 	CMP_USING_IDEVARS_IN_CSBP_AND_JUMP_IF	DEVICE_SERIAL_PORT, .IdentifyDriveFromSerialPort
    97                              <1> 	jmp		IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
    98                              <1> .IdentifyDriveFromSerialPort:
    99                              <1> 	jmp		SerialCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
   100                              <1> 
   101                              <1> %else					; IDE
   102                              <1> 	Device_IdentifyToBufferInESSIwithDriveSelectByteInBH	EQU		IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
   103                              <1> %endif
   104                              <1> 
   105                              <1> 
   106                              <1> ;--------------------------------------------------------------------
   107                              <1> ; Device_OutputCommandWithParameters
   108                              <1> ;	Parameters:
   109                              <1> ;		BH:		Default system timer ticks for timeout (can be ignored)
   110                              <1> ;		BL:		IDE Status Register bit to poll after command
   111                              <1> ;		ES:SI:	Ptr to buffer (for data transfer commands)
   112                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   113                              <1> ;		SS:BP:	Ptr to IDEPACK
   114                              <1> ;	Returns:
   115                              <1> ;		AH:		INT 13h Error Code
   116                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
   117                              <1> ;		CF:		Cleared if success, Set if error
   118                              <1> ;	Corrupts registers:
   119                              <1> ;		AL, BX, (CX), DX, (ES:SI for data transfer commands)
   120                              <1> ;--------------------------------------------------------------------
   121                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
   122                              <1> ALIGN JUMP_ALIGN
   123                              <1> Device_OutputCommandWithParameters:
   124                              <1> 	TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE .OutputCommandToSerialPort
   125                              <1> 	jmp		IdeCommand_OutputWithParameters
   126                              <1> 
   127                              <1> ALIGN JUMP_ALIGN
   128                              <1> .OutputCommandToSerialPort:
   129                              <1> 	jmp		SerialCommand_OutputWithParameters
   130                              <1> 
   131                              <1> %else					; IDE
   132                              <1> 	Device_OutputCommandWithParameters		EQU		IdeCommand_OutputWithParameters
   133                              <1> %endif
   134                              <1> 
   135                              <1> 
   136                              <1> ;--------------------------------------------------------------------
   137                              <1> ; Device_SelectDrive
   138                              <1> ;	Parameters:
   139                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   140                              <1> ;		SS:BP:	Ptr to IDEPACK
   141                              <1> ;	Returns:
   142                              <1> ;		AH:		INT 13h Error Code
   143                              <1> ;		CF:		Cleared if success, Set if error
   144                              <1> ;	Corrupts registers:
   145                              <1> ;		AL, BX, CX, DX
   146                              <1> ;--------------------------------------------------------------------
   147                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
   148                              <1> Device_SelectDrive:
   149                              <1> 	TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE	ReturnSuccessForSerialPort
   150                              <1> 	jmp		IdeCommand_SelectDrive
   151                              <1> 
   152                              <1> %else					; IDE
   153                              <1> 	Device_SelectDrive		EQU		IdeCommand_SelectDrive
   154                              <1> %endif
   155                              <1> 
   156                              <1> 
   157                              <1> %ifdef MODULE_SERIAL
   158                              <1> ALIGN JUMP_ALIGN
   159                              <1> ReturnSuccessForSerialPort:
   160                              <1> 	xor		ax, ax
   161                              <1> 	ret
   162                              <1> %endif
   230                                  	%include "Timer.asm"			; For timeout and delay
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Timeout and delay functions for INT 13h services.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Timer_InitializeTimeoutWithTicksInCL
    25                              <1> ;	Parameters:
    26                              <1> ;		CL:		Timeout value in system timer ticks
    27                              <1> ;		DS:		Segment to RAMVARS
    28                              <1> ;	Returns:
    29                              <1> ;		Nothing
    30                              <1> ;	Corrupts registers:
    31                              <1> ;		CX
    32                              <1> ;--------------------------------------------------------------------
    33                              <1> ALIGN JUMP_ALIGN
    34                              <1> Timer_InitializeTimeoutWithTicksInCL:
    35 00001365 880E0600            <1> 	mov		[RAMVARS.bTimeoutTicksLeft], cl		; Ticks until timeout
    36 00001369 E82900              <1> 	call	ReadTimeFromBdaToCX
    37 0000136C 880E0700            <1> 	mov		[RAMVARS.bLastTimeoutUpdate], cl	; Start time
    38 00001370 C3                  <1> 	ret
    39                              <1> 
    40                              <1> 
    41                              <1> ;--------------------------------------------------------------------
    42                              <1> ; Timer_SetCFifTimeout
    43                              <1> ;	Parameters:
    44                              <1> ;		DS:		Segment to RAMVARS
    45                              <1> ;	Returns:
    46                              <1> ;		CF:		Set if timeout
    47                              <1> ;				Cleared if time left
    48                              <1> ;	Corrupts registers:
    49                              <1> ;		CX
    50                              <1> ;--------------------------------------------------------------------
    51                              <1> ALIGN JUMP_ALIGN
    52                              <1> Timer_SetCFifTimeout:
    53 00001371 E82100              <1> 	call	ReadTimeFromBdaToCX
    54 00001374 3A0E0700            <1> 	cmp		cl, [RAMVARS.bLastTimeoutUpdate]
    55 00001378 7409                <1> 	je		SHORT .StillPollingTheSameTick
    56 0000137A 880E0700            <1> 	mov		[RAMVARS.bLastTimeoutUpdate], cl
    57 0000137E 802E060001          <1> 	sub		BYTE [RAMVARS.bTimeoutTicksLeft], 1	; DEC does not update CF
    58                              <1> .StillPollingTheSameTick:
    59 00001383 C3                  <1> 	ret
    60                              <1> 
    61                              <1> 
    62                              <1> ;--------------------------------------------------------------------
    63                              <1> ; Delay is always at least one millisecond since
    64                              <1> ; RTC resolution is 977 microsecs.
    65                              <1> ;
    66                              <1> ; Timer_DelayMicrosecondsFromAX
    67                              <1> ;	Parameters:
    68                              <1> ;		AX:		Number of microsecs to wait
    69                              <1> ;	Returns:
    70                              <1> ;		Nothing
    71                              <1> ;	Corrupts registers:
    72                              <1> ;		AX
    73                              <1> ;--------------------------------------------------------------------
    74                              <1> Timer_DelayMicrosecondsFromAX:
    75                              <1> %ifndef USE_AT
    76 00001384 B80200              <1> 	mov		ax, 2
    77                              <1> 	; Fall to Timer_DelayTimerTicksFromAX
    78                              <1> %else
    79                              <1> 	push	dx
    80                              <1> 	push	cx
    81                              <1> 
    82                              <1> 	xor		cx, cx
    83                              <1> 	xchg	dx, ax						; Microsecs now in CX:DX
    84                              <1> 	mov		ah, EVENT_WAIT
    85                              <1> 	int		BIOS_SYSTEM_INTERRUPT_15h
    86                              <1> 	sti									; XT BIOSes return with interrupts disabled. TODO: Maybe we can remove this since it's in an AT-only block?
    87                              <1> 
    88                              <1> 	pop		cx
    89                              <1> 	pop		dx
    90                              <1> 	mov		ax, 1								; Prepare to wait 1 timer tick
    91                              <1> 	jc		SHORT Timer_DelayTimerTicksFromAX	; Event Wait was unsupported or busy
    92                              <1> 	ret
    93                              <1> %endif
    94                              <1> 
    95                              <1> 
    96                              <1> ;--------------------------------------------------------------------
    97                              <1> ; First tick might take 0...54.9 ms and remaining ticks
    98                              <1> ; will occur at 54.9 ms intervals.
    99                              <1> ;
   100                              <1> ; Timer_DelayTimerTicksFromAX
   101                              <1> ;	Parameters:
   102                              <1> ;		AX:		Number of timer ticks to wait
   103                              <1> ;	Returns:
   104                              <1> ;		Nothing
   105                              <1> ;	Corrupts registers:
   106                              <1> ;		AX
   107                              <1> ;--------------------------------------------------------------------
   108                              <1> Timer_DelayTimerTicksFromAX:
   109 00001387 FB                  <1> 	sti								; Make sure that interrupts are enabled
   110 00001388 E80A00              <1> 	call	ReadTimeFromBdaToCX
   111 0000138B 01C8                <1> 	add		ax, cx					; AX = end time
   112                              <1> .WaitLoop:
   113 0000138D E80500              <1> 	call	ReadTimeFromBdaToCX
   114 00001390 39C1                <1> 	cmp		cx, ax
   115 00001392 75F9                <1> 	jne		SHORT .WaitLoop			; Loop until end time is reached
   116 00001394 C3                  <1> 	ret
   117                              <1> 
   118                              <1> 
   119                              <1> ;--------------------------------------------------------------------
   120                              <1> ; ReadTimeFromBdaToCX
   121                              <1> ;	Parameters
   122                              <1> ;		Nothing
   123                              <1> ;	Returns:
   124                              <1> ;		CX:		System time in 54.9 ms ticks
   125                              <1> ;	Corrupts registers:
   126                              <1> ;		Nothing
   127                              <1> ;--------------------------------------------------------------------
   128                              <1> ALIGN JUMP_ALIGN
   129                              <1> ReadTimeFromBdaToCX:
   130 00001395 1E                  <1> 	push	ds
   131                              <1> 	LOAD_BDA_SEGMENT_TO	ds, cx
   131                              <2> %ifndef USE_186
   131 00001396 31C9                <2>  xor %2, %2
   131 00001398 8ED9                <2>  mov %1, %2
   131                              <2> %elifidn %3, !
   131                              <2>  xor %2, %2
   131                              <2>  mov %1, %2
   131                              <2> %else
   131                              <2>  push BYTE 0
   131                              <2>  pop %1
   131                              <2> %endif
   132 0000139A 8B0E6C04            <1> 	mov		cx, [BDA.dwTimerTicks]	; Read low WORD only
   133 0000139E 1F                  <1> 	pop		ds
   134 0000139F C3                  <1> 	ret
   231                                  
   232                                  	; IDE Device support
   233                                  %ifdef MODULE_ADVANCED_ATA
   234                                  	%include "AdvAtaInit.asm"		; For initializing VLB and PCI controllers
   235                                  	%include "Vision.asm"			; QDI Vision QD6500 and QD6580 support
   236                                  %endif
   237                                  	%include "IdeCommand.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	IDE Device Command functions.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    21                              <1> 
    22                              <1> ; Section containing code
    23                              <1> SECTION .text
    24                              <1> 
    25                              <1> ;--------------------------------------------------------------------
    26                              <1> ; IdeCommand_ResetMasterAndSlaveController
    27                              <1> ;	Parameters:
    28                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    29                              <1> ;	Returns:
    30                              <1> ;		AH:		INT 13h Error Code
    31                              <1> ;		CF:		Cleared if success, Set if error
    32                              <1> ;	Corrupts registers:
    33                              <1> ;		AL, BX, CX, DX
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> IdeCommand_ResetMasterAndSlaveController:
    36                              <1> 	; HSR0: Set_SRST
    37 000013A0 E839F9              <1> 	call	AccessDPT_GetDeviceControlByteToAL
    38 000013A3 0C06                <1> 	or		al, FLG_DEVCONTROL_SRST | FLG_DEVCONTROL_nIEN	; Set Reset bit
    39                              <1> 	OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER		DEVICE_CONTROL_REGISTER_out
    39                              <2> %ifndef MODULE_8BIT_IDE
    39                              <2> 
    39                              <2>  %ifnidni %1, dx
    39                              <2>  mov dx, %1
    39                              <2>  %endif
    39                              <2>  eMOVZX bx, BYTE [di+DPT.bIdevarsOffset]
    39                              <2>  add dx, [cs:bx+IDEVARS.wControlBlockPort]
    39                              <2>  out dx, al
    39                              <2> 
    39                              <2> %else
    39                              <2> 
    39                              <2>  %ifnidni %1, dl
    39 000013A5 B206                <2>  mov dl, %1
    39                              <2>  %endif
    39 000013A7 E8FC04              <2>  call IdeIO_OutputALtoIdeControlBlockRegisterInDL
    39                              <2> 
    39                              <2> %endif
    40 000013AA B80600              <1> 	mov		ax, HSR0_RESET_WAIT_US
    41 000013AD E8D4FF              <1> 	call	Timer_DelayMicrosecondsFromAX
    42                              <1> 
    43                              <1> 	; HSR1: Clear_wait
    44 000013B0 E829F9              <1> 	call	AccessDPT_GetDeviceControlByteToAL
    45 000013B3 0C02                <1> 	or		al, FLG_DEVCONTROL_nIEN
    46 000013B5 24FB                <1> 	and		al, ~FLG_DEVCONTROL_SRST						; Clear reset bit
    47                              <1> 	OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER		DEVICE_CONTROL_REGISTER_out
    47                              <2> %ifndef MODULE_8BIT_IDE
    47                              <2> 
    47                              <2>  %ifnidni %1, dx
    47                              <2>  mov dx, %1
    47                              <2>  %endif
    47                              <2>  eMOVZX bx, BYTE [di+DPT.bIdevarsOffset]
    47                              <2>  add dx, [cs:bx+IDEVARS.wControlBlockPort]
    47                              <2>  out dx, al
    47                              <2> 
    47                              <2> %else
    47                              <2> 
    47                              <2>  %ifnidni %1, dl
    47 000013B7 B206                <2>  mov dl, %1
    47                              <2>  %endif
    47 000013B9 E8EA04              <2>  call IdeIO_OutputALtoIdeControlBlockRegisterInDL
    47                              <2> 
    47                              <2> %endif
    48 000013BC B83408              <1> 	mov		ax, HSR1_RESET_WAIT_US
    49 000013BF E8C2FF              <1> 	call	Timer_DelayMicrosecondsFromAX
    50                              <1> 
    51                              <1> 	; HSR2: Check_status
    52 000013C2 BB80FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_MAXIMUM, FLG_STATUS_BSY)
    53 000013C5 E92904              <1> 	jmp		IdeWait_PollStatusFlagInBLwithTimeoutInBH
    54                              <1> 
    55                              <1> 
    56                              <1> ;--------------------------------------------------------------------
    57                              <1> ; IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
    58                              <1> ;	Parameters:
    59                              <1> ;		BH:		Drive Select byte for Drive and Head Select Register
    60                              <1> ;		DX:		Autodetected port for XT-CF
    61                              <1> ;		DS:		Segment to RAMVARS
    62                              <1> ;		ES:SI:	Ptr to buffer to receive 512-byte IDE Information
    63                              <1> ;		CS:BP:	Ptr to IDEVARS
    64                              <1> ;	Returns:
    65                              <1> ;		AH:		INT 13h Error Code
    66                              <1> ;		CF:		Cleared if success, Set if error
    67                              <1> ;	Corrupts registers:
    68                              <1> ;		AL, BX, CX, DX, SI, DI, ES
    69                              <1> ;--------------------------------------------------------------------
    70                              <1> IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH:
    71                              <1> 	; Create fake DPT to be able to use Device.asm functions
    72 000013C8 E8D8F8              <1> 	call	FindDPT_ForNewDriveToDSDI
    73                              <1> 	eMOVZX	ax, bh
    73                              <2> %ifndef USE_386
    73                              <2>  %ifidni %1, ax
    73 000013CB 88F8                <2>  mov al, %2
    73 000013CD 30E4                <2>  xor ah, ah
    73                              <2>  %elifidni %1, bx
    73                              <2>  mov bl, %2
    73                              <2>  xor bh, bh
    73                              <2>  %elifidni %1, cx
    73                              <2>  mov cl, %2
    73                              <2>  xor ch, ch
    73                              <2>  %elifidni %1, dx
    73                              <2>  mov dl, %2
    73                              <2>  xor dh, dh
    73                              <2>  %else
    73                              <2>  push ax
    73                              <2>  mov al, %2
    73                              <2>  xor ah, ah
    73                              <2>  xchg ax, %1
    73                              <2>  pop ax
    73                              <2>  %endif
    73                              <2> 
    73                              <2> %else
    73                              <2>  movzx %1, %2
    73                              <2> %endif
    74 000013CF 8905                <1> 	mov		[di+DPT.wFlags], ax
    75 000013D1 E863F8              <1> 	call	CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI
    76 000013D4 E89D04              <1> 	call	IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP
    77 000013D7 C6450D01            <1> 	mov		BYTE [di+DPT_ATA.bBlockSize], 1	; Block = 1 sector
    78                              <1> 
    79                              <1> 	; Wait until drive motors have reached full speed
    80 000013DB 83FD51              <1> 	cmp		bp, BYTE ROMVARS.ideVars0	; First controller?
    81 000013DE 750B                <1> 	jne		SHORT .SkipLongWaitSinceDriveIsNotPrimaryMaster
    82 000013E0 F6C710              <1> 	test		bh, FLG_DRVNHEAD_DRV		; Wait already done for Master
    83 000013E3 7506                <1> 	jnz		SHORT .SkipLongWaitSinceDriveIsNotPrimaryMaster
    84 000013E5 BB40B5              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_MOTOR_STARTUP, FLG_STATUS_DRDY)
    85 000013E8 E80604              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
    86                              <1> .SkipLongWaitSinceDriveIsNotPrimaryMaster:
    87                              <1> 
    88                              <1> 	; Create IDEPACK without INTPACK
    89 000013EB 55                  <1> 	push		bp
    90 000013EC E82EFF              <1> 	call	Idepack_FakeToSSBP
    91                              <1> 
    92                              <1> %ifdef MODULE_8BIT_IDE
    93                              <1> 	; Enable 8-bit PIO mode for 8-bit ATA and XT-CF
    94 000013EF 56                  <1> 	push		si
    95 000013F0 E8D307              <1> 	call	AH9h_Enable8bitModeForDevice8bitAta
    96 000013F3 30C0                <1> 	xor		al, al						; XTCF_8BIT_PIO_MODE
    97 000013F5 E8C707              <1> 	call	AH9h_SetModeFromALtoXTCF
    98 000013F8 5E                  <1> 	pop		si
    99                              <1> %endif ; MODULE_8BIT_IDE
   100                              <1> 
   101                              <1> 	; Prepare to output Identify Device command
   102 000013F9 B201                <1> 	mov		dl, 1						; Sector count (required by IdeTransfer.asm)
   103 000013FB B0EC                <1> 	mov		al, COMMAND_IDENTIFY_DEVICE
   104 000013FD BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
   105 00001400 E844FF              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
   106                              <1> 
   107                              <1> 	; Clean stack and return
   108                              <1> .FailedToSet8bitMode:
   109 00001403 8D6609              <1> 	lea		sp, [bp+SIZE_OF_IDEPACK_WITHOUT_INTPACK]	; This assumes BP hasn't changed between Idepack_FakeToSSBP and here
   110 00001406 5D                  <1> 	pop		bp
   111 00001407 C3                  <1> 	ret
   112                              <1> 
   113                              <1> 
   114                              <1> ;--------------------------------------------------------------------
   115                              <1> ; IdeCommand_OutputWithParameters
   116                              <1> ;	Parameters:
   117                              <1> ;		BH:		System timer ticks for timeout
   118                              <1> ;		BL:		IDE Status Register bit to poll after command
   119                              <1> ;		ES:SI:	Ptr to buffer (for data transfer commands)
   120                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   121                              <1> ;		SS:BP:	Ptr to IDEPACK
   122                              <1> ;	Returns:
   123                              <1> ;		AH:		INT 13h Error Code
   124                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
   125                              <1> ;		CF:		Cleared if success, Set if error
   126                              <1> ;	Corrupts registers:
   127                              <1> ;		AL, BX, (CX), DX, (ES:SI for data transfer commands)
   128                              <1> ;--------------------------------------------------------------------
   129                              <1> ALIGN JUMP_ALIGN
   130                              <1> IdeCommand_OutputWithParameters:
   131 00001408 53                  <1> 	push	bx						; Store status register bits to poll
   132                              <1> 
   133                              <1> 	; Select Master or Slave drive and output head number or LBA28 top bits
   134 00001409 E83700              <1> 	call	IdeCommand_SelectDrive
   135 0000140C 7233                <1> 	jc		SHORT .DriveNotReady
   136                              <1> 
   137                              <1> 	; Output Device Control Byte to enable or disable interrupts
   138 0000140E 8A4607              <1> 	mov		al, [bp+IDEPACK.bDeviceControl]
   139                              <1> %ifdef MODULE_IRQ
   140                              <1> 	test	al, FLG_DEVCONTROL_nIEN	; Interrupts disabled?
   141                              <1> 	jnz		SHORT .DoNotSetInterruptInServiceFlag
   142                              <1> 
   143                              <1> 	; Clear Task Flag and set Interrupt In-Service Flag
   144                              <1> 	or		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_INTERRUPT_IN_SERVICE
   145                              <1> 	push	ds
   146                              <1> 	LOAD_BDA_SEGMENT_TO	ds, dx, !	; Also zero DX
   147                              <1> 	mov		[BDA.bHDTaskFlg], dl
   148                              <1> 	pop		ds
   149                              <1> .DoNotSetInterruptInServiceFlag:
   150                              <1> %endif
   151                              <1> 	OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER		DEVICE_CONTROL_REGISTER_out
   151                              <2> %ifndef MODULE_8BIT_IDE
   151                              <2> 
   151                              <2>  %ifnidni %1, dx
   151                              <2>  mov dx, %1
   151                              <2>  %endif
   151                              <2>  eMOVZX bx, BYTE [di+DPT.bIdevarsOffset]
   151                              <2>  add dx, [cs:bx+IDEVARS.wControlBlockPort]
   151                              <2>  out dx, al
   151                              <2> 
   151                              <2> %else
   151                              <2> 
   151                              <2>  %ifnidni %1, dl
   151 00001411 B206                <2>  mov dl, %1
   151                              <2>  %endif
   151 00001413 E89004              <2>  call IdeIO_OutputALtoIdeControlBlockRegisterInDL
   151                              <2> 
   151                              <2> %endif
   152                              <1> 
   153                              <1> 	; Output Feature Number
   154 00001416 8A4600              <1> 	mov		al, [bp+IDEPACK.bFeatures]
   155                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	FEATURES_REGISTER_out
   155                              <2> %ifndef MODULE_8BIT_IDE
   155                              <2> 
   155                              <2>  %ifnidni %1, dx
   155                              <2>  mov dx, %1
   155                              <2>  %endif
   155                              <2>  add dx, [di+DPT.wBasePort]
   155                              <2>  out dx, al
   155                              <2> 
   155                              <2> %else
   155                              <2> 
   155                              <2>  %ifnidni %1, dl
   155 00001419 B201                <2>  mov dl, %1
   155                              <2>  %endif
   155 0000141B E8B704              <2>  call IdeIO_OutputALtoIdeRegisterInDL
   155                              <2> 
   155                              <2> %endif
   156                              <1> 
   157                              <1> 	; Output Sector Address High (only used by LBA48)
   158                              <1> %ifdef MODULE_EBIOS
   159                              <1> 	eMOVZX	ax, [bp+IDEPACK.bLbaLowExt]		; Zero sector count
   160                              <1> 	mov		cx, [bp+IDEPACK.wLbaMiddleAndHighExt]
   161                              <1> 	call	OutputSectorCountAndAddress
   162                              <1> %endif
   163                              <1> 
   164                              <1> 	; Output Sector Address Low
   165 0000141E 8B4602              <1> 	mov		ax, [bp+IDEPACK.wSectorCountAndLbaLow]
   166 00001421 8B4E04              <1> 	mov		cx, [bp+IDEPACK.wLbaMiddleAndHigh]
   167 00001424 E84000              <1> 	call	OutputSectorCountAndAddress
   168                              <1> 
   169                              <1> 	; Output command
   170 00001427 8A4606              <1> 	mov		al, [bp+IDEPACK.bCommand]
   171                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	COMMAND_REGISTER_out
   171                              <2> %ifndef MODULE_8BIT_IDE
   171                              <2> 
   171                              <2>  %ifnidni %1, dx
   171                              <2>  mov dx, %1
   171                              <2>  %endif
   171                              <2>  add dx, [di+DPT.wBasePort]
   171                              <2>  out dx, al
   171                              <2> 
   171                              <2> %else
   171                              <2> 
   171                              <2>  %ifnidni %1, dl
   171 0000142A B207                <2>  mov dl, %1
   171                              <2>  %endif
   171 0000142C E8A604              <2>  call IdeIO_OutputALtoIdeRegisterInDL
   171                              <2> 
   171                              <2> %endif
   172                              <1> 
   173                              <1> 	; Wait until command completed
   174 0000142F 5B                  <1> 	pop		bx						; Pop status and timeout for polling
   175 00001430 80FB08              <1> 	cmp		bl, FLG_STATUS_DRQ				; Data transfer started?
   176 00001433 7509                <1> 	jne		SHORT .WaitUntilNonTransferCommandCompletes
   177                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   178 00001435 807D0C10            <1> 	cmp		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_JRIDE_ISA
   179 00001439 7347                <1> 	jae		SHORT JrIdeTransfer_StartWithCommandInAL
   180                              <1> %endif
   181 0000143B E97701              <1> 	jmp		IdeTransfer_StartWithCommandInAL
   182                              <1> 
   183                              <1> .WaitUntilNonTransferCommandCompletes:
   184                              <1> %ifdef MODULE_IRQ
   185                              <1> 	test	BYTE [bp+IDEPACK.bDeviceControl], FLG_DEVCONTROL_nIEN
   186                              <1> 	jz		SHORT .PollStatusFlagInsteadOfWaitIrq
   187                              <1> 	jmp		IdeWait_IRQorStatusFlagInBLwithTimeoutInBH
   188                              <1> .PollStatusFlagInsteadOfWaitIrq:
   189                              <1> %endif
   190 0000143E E9B003              <1> 	jmp		IdeWait_PollStatusFlagInBLwithTimeoutInBH
   191                              <1> 
   192                              <1> .DriveNotReady:
   193 00001441 5B                  <1> 	pop		bx							; Clean stack
   194 00001442 C3                  <1> 	ret
   195                              <1> 
   196                              <1> 
   197                              <1> ;--------------------------------------------------------------------
   198                              <1> ; IdeCommand_SelectDrive
   199                              <1> ;	Parameters:
   200                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   201                              <1> ;		SS:BP:	Ptr to IDEPACK
   202                              <1> ;	Returns:
   203                              <1> ;		AH:		INT 13h Error Code
   204                              <1> ;		CF:		Cleared if success, Set if error
   205                              <1> ;	Corrupts registers:
   206                              <1> ;		AL, BX, CX, DX
   207                              <1> ;--------------------------------------------------------------------
   208                              <1> ALIGN JUMP_ALIGN
   209                              <1> IdeCommand_SelectDrive:
   210                              <1> 	; We use different timeout value when detecting drives.
   211                              <1> 	; This prevents unnecessary long delays when drive is not present.
   212 00001443 B9402F              <1> 	mov		cx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRDY, FLG_STATUS_DRDY)
   213 00001446 813E00005A5A        <1> 	cmp		WORD [RAMVARS.wDrvDetectSignature], RAMVARS_DRV_DETECT_SIGNATURE
   214                              <1> 	eCMOVE	ch, TIMEOUT_SELECT_DRIVE_DURING_DRIVE_DETECTION
   214                              <2>  eCMOVZ %1, %2
   214 0000144C 7502                <3>  jnz SHORT %%Return
   214 0000144E B509                <3>  mov %1, %2
   214                              <3> %%Return:
   215                              <1> 
   216                              <1> 	; Select Master or Slave Drive
   217 00001450 8A4601              <1> 	mov		al, [bp+IDEPACK.bDrvAndHead]
   218                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	DRIVE_AND_HEAD_SELECT_REGISTER
   218                              <2> %ifndef MODULE_8BIT_IDE
   218                              <2> 
   218                              <2>  %ifnidni %1, dx
   218                              <2>  mov dx, %1
   218                              <2>  %endif
   218                              <2>  add dx, [di+DPT.wBasePort]
   218                              <2>  out dx, al
   218                              <2> 
   218                              <2> %else
   218                              <2> 
   218                              <2>  %ifnidni %1, dl
   218 00001453 B206                <2>  mov dl, %1
   218                              <2>  %endif
   218 00001455 E87D04              <2>  call IdeIO_OutputALtoIdeRegisterInDL
   218                              <2> 
   218                              <2> %endif
   219 00001458 89CB                <1> 	mov		bx, cx
   220 0000145A E89403              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
   221                              <1> 
   222                              <1> 	; Ignore errors from IDE Error Register (set by previous command)
   223 0000145D 80FC80              <1> 	cmp		ah, RET_HD_TIMEOUT
   224 00001460 7403                <1> 	je		SHORT .FailedToSelectDrive
   225 00001462 31C0                <1> 	xor		ax, ax					; Always success unless timeout
   226 00001464 C3                  <1> 	ret
   227                              <1> .FailedToSelectDrive:
   228 00001465 F9                  <1> 	stc
   229 00001466 C3                  <1> 	ret
   230                              <1> 
   231                              <1> 
   232                              <1> ;--------------------------------------------------------------------
   233                              <1> ; OutputSectorCountAndAddress
   234                              <1> ;	Parameters:
   235                              <1> ;		AH:		LBA low bits (Sector Number)
   236                              <1> ;		AL:		Sector Count
   237                              <1> ;		CL:		LBA middle bits (Cylinder Number low)
   238                              <1> ;		CH:		LBA high bits (Cylinder Number high)
   239                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   240                              <1> ;	Returns:
   241                              <1> ;		Nothing
   242                              <1> ;	Corrupts registers:
   243                              <1> ;		AL, BX, DX
   244                              <1> ;--------------------------------------------------------------------
   245                              <1> ALIGN JUMP_ALIGN
   246                              <1> OutputSectorCountAndAddress:
   247                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	SECTOR_COUNT_REGISTER
   247                              <2> %ifndef MODULE_8BIT_IDE
   247                              <2> 
   247                              <2>  %ifnidni %1, dx
   247                              <2>  mov dx, %1
   247                              <2>  %endif
   247                              <2>  add dx, [di+DPT.wBasePort]
   247                              <2>  out dx, al
   247                              <2> 
   247                              <2> %else
   247                              <2> 
   247                              <2>  %ifnidni %1, dl
   247 00001467 B202                <2>  mov dl, %1
   247                              <2>  %endif
   247 00001469 E86904              <2>  call IdeIO_OutputALtoIdeRegisterInDL
   247                              <2> 
   247                              <2> %endif
   248                              <1> 
   249 0000146C 88E0                <1> 	mov		al, ah
   250                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	LBA_LOW_REGISTER
   250                              <2> %ifndef MODULE_8BIT_IDE
   250                              <2> 
   250                              <2>  %ifnidni %1, dx
   250                              <2>  mov dx, %1
   250                              <2>  %endif
   250                              <2>  add dx, [di+DPT.wBasePort]
   250                              <2>  out dx, al
   250                              <2> 
   250                              <2> %else
   250                              <2> 
   250                              <2>  %ifnidni %1, dl
   250 0000146E B203                <2>  mov dl, %1
   250                              <2>  %endif
   250 00001470 E86204              <2>  call IdeIO_OutputALtoIdeRegisterInDL
   250                              <2> 
   250                              <2> %endif
   251                              <1> 
   252 00001473 88C8                <1> 	mov		al, cl
   253                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	LBA_MIDDLE_REGISTER
   253                              <2> %ifndef MODULE_8BIT_IDE
   253                              <2> 
   253                              <2>  %ifnidni %1, dx
   253                              <2>  mov dx, %1
   253                              <2>  %endif
   253                              <2>  add dx, [di+DPT.wBasePort]
   253                              <2>  out dx, al
   253                              <2> 
   253                              <2> %else
   253                              <2> 
   253                              <2>  %ifnidni %1, dl
   253 00001475 B204                <2>  mov dl, %1
   253                              <2>  %endif
   253 00001477 E85B04              <2>  call IdeIO_OutputALtoIdeRegisterInDL
   253                              <2> 
   253                              <2> %endif
   254                              <1> 
   255 0000147A 88E8                <1> 	mov		al, ch
   256                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	LBA_HIGH_REGISTER
   256                              <2> %ifndef MODULE_8BIT_IDE
   256                              <2> 
   256                              <2>  %ifnidni %1, dx
   256                              <2>  mov dx, %1
   256                              <2>  %endif
   256                              <2>  add dx, [di+DPT.wBasePort]
   256                              <2>  out dx, al
   256                              <2> 
   256                              <2> %else
   256                              <2> 
   256                              <2>  %ifnidni %1, dl
   256 0000147C B205                <2>  mov dl, %1
   256                              <2>  %endif
   256 0000147E E85404              <2>  call IdeIO_OutputALtoIdeRegisterInDL
   256                              <2> 
   256                              <2> %endif
   257 00001481 C3                  <1> 	ret
   238                                  %ifdef MODULE_8BIT_IDE_ADVANCED
   239                                  	%include "JrIdeTransfer.asm"	; Must be included after IdeCommand.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Memory mapped IDE Device transfer functions.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    21                              <1> ; Note mods are actually stripping out old XT-CFv2 memory-mapped IO code.
    22                              <1> 
    23                              <1> ; Structure containing variables for PIO transfer functions.
    24                              <1> ; This struct must not be larger than IDEPACK without INTPACK.
    25                              <1> struc MEMPIOVARS	; Must not be larger than 9 bytes! See IDEPACK in RamVars.inc.
    26 00000000 <res 00000002>      <1> 	.wSectorsInBlock		resb	2	; 0-1, Block size in sectors
    27 00000002 <res 00000004>      <1> 	.fpDPT				resb	4	; 2-5, Far pointer to DPT
    28 00000006 <res 00000001>      <1> 	.bSectorsLeft			resb	1	; 6, Sectors left to transfer
    29 00000007 <res 00000001>      <1> 					resb	1	; 7, IDEPACK.bDeviceControl
    30 00000008 <res 00000001>      <1> 	.bSectorsDone			resb	1	; 8, Number of sectors xferred
    31                              <1> endstruc
    32                              <1> 
    33                              <1> SECTOR_ACCESS_WINDOW_SIZE		EQU	512	; 512 bytes
    34                              <1> 
    35                              <1> 
    36                              <1> ; Section containing code
    37                              <1> SECTION .text
    38                              <1> 
    39                              <1> ;--------------------------------------------------------------------
    40                              <1> ; JrIdeTransfer_StartWithCommandInAL
    41                              <1> ;	Parameters:
    42                              <1> ;		AL:	IDE command that was used to start the transfer
    43                              <1> ;			(all PIO read and write commands including Identify Device)
    44                              <1> ;		ES:SI:	Ptr to data buffer
    45                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    46                              <1> ;		SS:BP:	Ptr to IDEPACK
    47                              <1> ;	Returns:
    48                              <1> ;		AH:	INT 13h Error Code
    49                              <1> ;		CX:	Number of successfully transferred sectors
    50                              <1> ;		CF:	Cleared if success, Set if error
    51                              <1> ;	Corrupts registers:
    52                              <1> ;		AL, BX, DX, SI, ES
    53                              <1> ;--------------------------------------------------------------------
    54                              <1> ALIGN JUMP_ALIGN
    55                              <1> JrIdeTransfer_StartWithCommandInAL:
    56                              <1> 	; Initialize MEMPIOVARS
    57 00001482 91                  <1> 	xchg		cx, ax				; IDE command to CL
    58 00001483 31C0                <1> 	xor		ax, ax
    59 00001485 884608              <1> 	mov		[bp+MEMPIOVARS.bSectorsDone], al
    60 00001488 8A4602              <1> 	mov		al, [bp+IDEPACK.bSectorCount]
    61 0000148B 884606              <1> 	mov		[bp+MEMPIOVARS.bSectorsLeft], al
    62 0000148E 8A450D              <1> 	mov		al, [di+DPT_ATA.bBlockSize]
    63 00001491 894600              <1> 	mov		[bp+MEMPIOVARS.wSectorsInBlock], ax
    64 00001494 897E02              <1> 	mov		[bp+MEMPIOVARS.fpDPT], di
    65 00001497 8C5E04              <1> 	mov		[bp+MEMPIOVARS.fpDPT+2], ds
    66                              <1> 
    67                              <1> 	; Normalize pointer
    68 0000149A E8E501              <1> 	call	IdeTransfer_NormalizePointerInESSI
    69                              <1> 
    70                              <1> 	; Get far pointer to Sector Access Window
    71 0000149D 8B5504              <1> 	mov		dx, [di+DPT.wBasePort]
    72                              <1> 
    73                              <1> 	; Get Sector Access Window for JR-IDE/ISA
    74 000014A0 BF003C              <1> 	mov		di, JRIDE_SECTOR_ACCESS_WINDOW_OFFSET
    75 000014A3 8EDA                <1> 	mov		ds, dx				; Segment for JR-IDE/ISA
    76                              <1> 
    77                              <1> 	; Are we reading or writing?
    78 000014A5 F6C110              <1> 	test		cl, 16				; Bit 4 is cleared on all the read commands,
    79                              <1> 							; but set on 3 of the 4 write commands
    80 000014A8 754A                <1> 	jnz		SHORT WriteToSectorAccessWindow
    81 000014AA 80F9C5              <1> 	cmp		cl, COMMAND_WRITE_MULTIPLE
    82 000014AD 7445                <1> 	je		SHORT WriteToSectorAccessWindow
    83                              <1> 	; Fall to ReadFromSectorAccessWindow
    84                              <1> 
    85                              <1> ;--------------------------------------------------------------------
    86                              <1> ; ReadFromSectorAccessWindow
    87                              <1> ;	Parameters:
    88                              <1> ;		DS:DI:	Ptr to Sector Access Window
    89                              <1> ;		ES:SI:	Normalized ptr to buffer to receive data
    90                              <1> ;		SS:BP:	Ptr to MEMPIOVARS
    91                              <1> ;	Returns:
    92                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    93                              <1> ;		AH:	BIOS Error code
    94                              <1> ;		CX:	Number of successfully transferred sectors
    95                              <1> ;		CF:	0 if transfer successful
    96                              <1> ;			1 if any error
    97                              <1> ;	Corrupts registers:
    98                              <1> ;		AL, BX, DX, SI
    99                              <1> ;--------------------------------------------------------------------
   100                              <1> ReadFromSectorAccessWindow:
   101 000014AF 87F7                <1> 	xchg		si, di					; DS:SI = source, ES:DI = Destination
   102 000014B1 E88F00              <1> 	call	WaitUntilReadyToTransferNextBlock
   103 000014B4 7235                <1> 	jc		SHORT ReturnWithMemoryIOtransferErrorInAH
   104                              <1> 
   105 000014B6 8B4E00              <1> 	mov		cx, [bp+MEMPIOVARS.wSectorsInBlock]	; Clears CH
   106 000014B9 384E06              <1> 	cmp		[bp+MEMPIOVARS.bSectorsLeft], cl
   107 000014BC 7616                <1> 	jbe		SHORT .ReadLastBlockFromDrive
   108                              <1> 
   109                              <1> ALIGN JUMP_ALIGN
   110                              <1> .ReadNextBlockFromDrive:
   111 000014BE E87200              <1> 	call	ReadSingleBlockFromSectorAccessWindowInDSSItoESDI
   112 000014C1 E87F00              <1> 	call	WaitUntilReadyToTransferNextBlock
   113 000014C4 7225                <1> 	jc	SHORT ReturnWithMemoryIOtransferErrorInAH
   114                              <1> 
   115                              <1> 	; Update number of successfully read sectors and sectors left to transfer.
   116                              <1> 	; We cannot use SUB instruction as a comparison since it will not
   117                              <1> 	; work in this situation:
   118                              <1> 	; Before SUB we have 2 full blocks left to transfer. SUB command
   119                              <1> 	; then compares 2 full blocks against one full block and updates
   120                              <1> 	; sectors left to one full block and jumps to .ReadNextBlockFromDrive,
   121                              <1> 	; since we have one full block left to transfer. After it has been
   122                              <1> 	; transferred, there will be a wait for next block but DRQ is never
   123                              <1> 	; set since all is transferred! Then we get timeout error.
   124 000014C6 8B4E00              <1> 	mov		cx, [bp+MEMPIOVARS.wSectorsInBlock]
   125 000014C9 284E06              <1> 	sub		[bp+MEMPIOVARS.bSectorsLeft], cl
   126 000014CC 004E08              <1> 	add		[bp+MEMPIOVARS.bSectorsDone], cl
   127 000014CF 384E06              <1> 	cmp		[bp+MEMPIOVARS.bSectorsLeft], cl
   128 000014D2 77EA                <1> 	ja		SHORT .ReadNextBlockFromDrive
   129                              <1> 
   130                              <1> ALIGN JUMP_ALIGN
   131                              <1> .ReadLastBlockFromDrive:
   132 000014D4 8A4E06              <1> 	mov		cl, [bp+MEMPIOVARS.bSectorsLeft]
   133 000014D7 51                  <1> 	push		cx
   134 000014D8 E85800              <1> 	call	ReadSingleBlockFromSectorAccessWindowInDSSItoESDI
   135                              <1> 
   136                              <1> 	; Check for errors in last block
   137                              <1> CheckErrorsAfterTransferringLastMemoryMappedBlock:
   138 000014DB C57E02              <1> 	lds		di, [bp+MEMPIOVARS.fpDPT]			; DPT now in DS:DI
   139 000014DE BB80FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_BSY)
   140 000014E1 E80D03              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
   141 000014E4 59                  <1> 	pop		cx	; [bp+MEMPIOVARS.bSectorsLeft]
   142 000014E5 7204                <1> 	jc		SHORT ReturnWithMemoryIOtransferErrorInAH
   143                              <1> 
   144                              <1> 	; All sectors successfully transferred
   145 000014E7 024E08              <1> 	add		cl, [bp+MEMPIOVARS.bSectorsDone]		; Never sets CF
   146 000014EA C3                  <1> 	ret
   147                              <1> 
   148                              <1> 	; Return number of successfully transferred sectors
   149                              <1> ReturnWithMemoryIOtransferErrorInAH:
   150 000014EB C57E02              <1> 	lds		di, [bp+MEMPIOVARS.fpDPT]			; DPT now in DS:DI
   151                              <1> %ifdef USE_386
   152                              <1> 	movzx	cx, BYTE [bp+MEMPIOVARS.bSectorsDone]
   153                              <1> %else
   154 000014EE B500                <1> 	mov		ch, 0						; Preserve CF
   155 000014F0 8A4E08              <1> 	mov		cl, [bp+MEMPIOVARS.bSectorsDone]
   156                              <1> %endif
   157 000014F3 C3                  <1> 	ret
   158                              <1> 
   159                              <1> 
   160                              <1> ;--------------------------------------------------------------------
   161                              <1> ; WriteToSectorAccessWindow
   162                              <1> ;	Parameters:
   163                              <1> ;		DS:DI:	Ptr to Sector Access Window
   164                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
   165                              <1> ;		SS:BP:	Ptr to MEMPIOVARS
   166                              <1> ;	Returns:
   167                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   168                              <1> ;		AH:		BIOS Error code
   169                              <1> ;		CX:		Number of successfully transferred sectors
   170                              <1> ;		CF:		0 if transfer successful
   171                              <1> ;				1 if any error
   172                              <1> ;	Corrupts registers:
   173                              <1> ;		AL, BX, DX, SI, ES
   174                              <1> ;--------------------------------------------------------------------
   175                              <1> ALIGN JUMP_ALIGN
   176                              <1> WriteToSectorAccessWindow:
   177 000014F4 06                  <1> 	push		es
   178 000014F5 1E                  <1> 	push		ds
   179 000014F6 07                  <1> 	pop		es		; ES:DI = Sector Access Window (destination)
   180 000014F7 1F                  <1> 	pop		ds		; DS:SI = Ptr to source buffer
   181                              <1> 
   182                              <1> 	; Always poll when writing first block (IRQs are generated for following blocks)
   183 000014F8 E84800              <1> 	call	WaitUntilReadyToTransferNextBlock
   184 000014FB 72EE                <1> 	jc		SHORT ReturnWithMemoryIOtransferErrorInAH
   185                              <1> 
   186 000014FD 8B4E00              <1> 	mov		cx, [bp+MEMPIOVARS.wSectorsInBlock]
   187 00001500 384E06              <1> 	cmp		[bp+MEMPIOVARS.bSectorsLeft], cl
   188 00001503 7616                <1> 	jbe		SHORT .WriteLastBlockToDrive
   189                              <1> 
   190                              <1> ALIGN JUMP_ALIGN
   191                              <1> .WriteNextBlockToDrive:
   192 00001505 E81B00              <1> 	call	WriteSingleBlockFromDSSIToSectorAccessWindowInESDI
   193 00001508 E83800              <1> 	call	WaitUntilReadyToTransferNextBlock
   194 0000150B 72DE                <1> 	jc		SHORT ReturnWithMemoryIOtransferErrorInAH
   195                              <1> 
   196                              <1> 	; Increment number of successfully written WORDs
   197 0000150D 8B4E00              <1> 	mov		cx, [bp+MEMPIOVARS.wSectorsInBlock]
   198 00001510 284E06              <1> 	sub		[bp+MEMPIOVARS.bSectorsLeft], cl
   199 00001513 004E08              <1> 	add		[bp+MEMPIOVARS.bSectorsDone], cl
   200 00001516 384E06              <1> 	cmp		[bp+MEMPIOVARS.bSectorsLeft], cl
   201 00001519 77EA                <1> 	ja		SHORT .WriteNextBlockToDrive
   202                              <1> 
   203                              <1> ALIGN JUMP_ALIGN
   204                              <1> .WriteLastBlockToDrive:
   205 0000151B 8A4E06              <1> 	mov		cl, [bp+MEMPIOVARS.bSectorsLeft]
   206 0000151E 51                  <1> 	push		cx
   207                              <1> 	ePUSH_T		bx, CheckErrorsAfterTransferringLastMemoryMappedBlock
   207                              <2> %ifndef USE_186
   207                              <2>  %ifidni %2, 0
   207                              <2>  xor %1, %1
   207                              <2>  %else
   207 0000151F BB[DB14]            <2>  mov %1, %2
   207                              <2>  %endif
   207 00001522 53                  <2>  push %1
   207                              <2> 
   207                              <2> %else
   207                              <2>  push %2
   207                              <2> %endif
   208                              <1> 	; Fall to WriteSingleBlockFromDSSIToSectorAccessWindowInESDI
   209                              <1> 
   210                              <1> ;--------------------------------------------------------------------
   211                              <1> ; WriteSingleBlockFromDSSIToSectorAccessWindowInESDI
   212                              <1> ;	Parameters:
   213                              <1> ;		CX:		Number of sectors in block
   214                              <1> ;		DS:SI:	Normalized ptr to source buffer
   215                              <1> ;		ES:DI:	Ptr to Sector Access Window
   216                              <1> ;	Returns:
   217                              <1> ;		CX, DX:	Zero
   218                              <1> ;		SI:		Updated
   219                              <1> ;	Corrupts registers:
   220                              <1> ;		BX
   221                              <1> ;--------------------------------------------------------------------
   222                              <1> ALIGN JUMP_ALIGN
   223                              <1> WriteSingleBlockFromDSSIToSectorAccessWindowInESDI:
   224 00001523 89FB                <1> 	mov		bx, di
   225 00001525 89CA                <1> 	mov		dx, cx
   226 00001527 30C9                <1> 	xor		cl, cl
   227                              <1> ALIGN JUMP_ALIGN
   228                              <1> .WriteNextSector:
   229 00001529 B501                <1> 	mov		ch, SECTOR_ACCESS_WINDOW_SIZE >> 9
   230 0000152B F3A5                <1> 	rep movsw
   231 0000152D 89DF                <1> 	mov		di, bx	; Reset for next sector
   232 0000152F 4A                  <1> 	dec		dx
   233 00001530 75F7                <1> 	jnz		SHORT .WriteNextSector
   234 00001532 C3                  <1> 	ret
   235                              <1> 
   236                              <1> 
   237                              <1> ;--------------------------------------------------------------------
   238                              <1> ; ReadSingleBlockFromSectorAccessWindowInDSSItoESDI
   239                              <1> ;	Parameters:
   240                              <1> ;		CX	Number of sectors in full block or sectors in last partial block
   241                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data (destination)
   242                              <1> ;		DS:SI:	Ptr to Sector Access Window (source)
   243                              <1> ;	Returns:
   244                              <1> ;		CX, DX:	Zero
   245                              <1> ;		DI:	Updated
   246                              <1> ;	Corrupts registers:
   247                              <1> ;		BX
   248                              <1> ;--------------------------------------------------------------------
   249                              <1> ALIGN JUMP_ALIGN
   250                              <1> ReadSingleBlockFromSectorAccessWindowInDSSItoESDI:
   251 00001533 89F3                <1> 	mov		bx, si
   252 00001535 89CA                <1> 	mov		dx, cx
   253 00001537 30C9                <1> 	xor		cl, cl
   254                              <1> ALIGN JUMP_ALIGN
   255                              <1> .ReadNextSector:
   256 00001539 B501                <1> 	mov		ch, SECTOR_ACCESS_WINDOW_SIZE >> 9
   257 0000153B F3A5                <1> 	rep movsw
   258 0000153D 89DE                <1> 	mov		si, bx	; Reset for next sector
   259 0000153F 4A                  <1> 	dec		dx
   260 00001540 75F7                <1> 	jnz		SHORT .ReadNextSector
   261 00001542 C3                  <1> 	ret
   262                              <1> 
   263                              <1> 
   264                              <1> ;--------------------------------------------------------------------
   265                              <1> ; WaitUntilReadyToTransferNextBlock
   266                              <1> ;	Parameters:
   267                              <1> ;		SS:BP:	Ptr to MEMPIOVARS
   268                              <1> ;	Returns:
   269                              <1> ;		AH:		INT 13h Error Code
   270                              <1> ;		CF:		Cleared if success, Set if error
   271                              <1> ;	Corrupts registers:
   272                              <1> ;		AL, BX, CX, DX
   273                              <1> ;--------------------------------------------------------------------
   274                              <1> ALIGN JUMP_ALIGN
   275                              <1> WaitUntilReadyToTransferNextBlock:
   276 00001543 1E                  <1> 	push		ds
   277 00001544 57                  <1> 	push		di
   278 00001545 C57E02              <1> 	lds		di, [bp+MEMPIOVARS.fpDPT]	; DPT now in DS:DI
   279 00001548 E8A302              <1> 	call	IdeWait_IRQorDRQ			; Always polls
   280 0000154B 5F                  <1> 	pop		di
   281 0000154C 1F                  <1> 	pop		ds
   282 0000154D C3                  <1> 	ret
   283                              <1> 
   284                              <1> 
   285                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   286                              <1> %if SECTOR_ACCESS_WINDOW_SIZE <> 512
   287                              <1> 	%error "SECTOR_ACCESS_WINDOW_SIZE is no longer equal to 512. JrIdeTransfer.asm needs changes."
   288                              <1> %endif
   289                              <1> %endif
   290                              <1> 
   240                                  	%include "IdeDmaBlock.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	IDE Read/Write functions for transferring block using DMA
     3                              <1> ;			for XT-CFv3 adapter.
     4                              <1> ;
     5                              <1> ;			These functions should only be called from IdeTransfer.asm.
     6                              <1> 
     7                              <1> ;
     8                              <1> ; XTIDE Universal BIOS and Associated Tools
     9                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
    10                              <1> ;
    11                              <1> ; This program is free software; you can redistribute it and/or modify
    12                              <1> ; it under the terms of the GNU General Public License as published by
    13                              <1> ; the Free Software Foundation; either version 2 of the License, or
    14                              <1> ; (at your option) any later version.
    15                              <1> ;
    16                              <1> ; This program is distributed in the hope that it will be useful,
    17                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                              <1> ; GNU General Public License for more details.
    20                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    21                              <1> ;
    22                              <1> 
    23                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    24                              <1> 
    25                              <1> ; Section containing code
    26                              <1> SECTION .text
    27                              <1> 
    28                              <1> ;--------------------------------------------------------------------
    29                              <1> ; IdeDmaBlock_WriteToXTCF
    30                              <1> ;	Parameters:
    31                              <1> ;		CX:		Block size in 512 byte sectors
    32                              <1> ;		DX:		XTCF Base Port Address
    33                              <1> ;		ES:SI:		Physical address to buffer to receive data
    34                              <1> ;	Returns:
    35                              <1> ;		Nothing
    36                              <1> ;	Corrupts registers:
    37                              <1> ;		AX, BX, CX, DX
    38                              <1> ;--------------------------------------------------------------------
    39                              <1> ALIGN JUMP_ALIGN
    40                              <1> IdeDmaBlock_WriteToXTCF:
    41 0000154E 87F7                <1> 	xchg		si, di
    42 00001550 B30B                <1> 	mov		bl, CHANNEL_3 | READ | AUTOINIT_DISABLE | ADDRESS_INCREMENT | DEMAND_MODE
    43 00001552 E80500              <1> 	call	TransferBlockToOrFromXTCF
    44 00001555 87FE                <1> 	xchg		di, si
    45 00001557 C3                  <1> 	ret
    46                              <1> 
    47                              <1> 
    48                              <1> ;--------------------------------------------------------------------
    49                              <1> ; IdeDmaBlock_ReadFromXTCF
    50                              <1> ;	Parameters:
    51                              <1> ;		CX:		Block size in 512 byte sectors
    52                              <1> ;		DX:		XTCF Base Port Address
    53                              <1> ;		ES:DI:		Physical address to buffer to receive data
    54                              <1> ;	Returns:
    55                              <1> ;		Nothing
    56                              <1> ;	Corrupts registers:
    57                              <1> ;		AX, BX, CX, DX
    58                              <1> ;--------------------------------------------------------------------
    59                              <1> ALIGN JUMP_ALIGN
    60                              <1> IdeDmaBlock_ReadFromXTCF:
    61 00001558 B307                <1> 	mov		bl, CHANNEL_3 | WRITE | AUTOINIT_DISABLE | ADDRESS_INCREMENT | DEMAND_MODE
    62                              <1> 	; Fall to TransferBlockToOrFromXTCF
    63                              <1> 
    64                              <1> 
    65                              <1> ;--------------------------------------------------------------------
    66                              <1> ; TransferBlockToOrFromXTCF
    67                              <1> ; Updated for XT-CFv3, 20-Feb-13
    68                              <1> ;	Parameters:
    69                              <1> ;		BL:		Mode byte for DMA Mode Register
    70                              <1> ;		CX:		Block size in 512 byte sectors
    71                              <1> ;		DX:		XTCF Base Port Address
    72                              <1> ;		ES:DI:		Physical address to buffer to receive data
    73                              <1> ;	Returns:
    74                              <1> ;		Nothing
    75                              <1> ;	Corrupts registers:
    76                              <1> ;		AX, BX, CX, DX
    77                              <1> ;--------------------------------------------------------------------
    78                              <1> TransferBlockToOrFromXTCF:
    79                              <1> 	; 8-bit DMA transfers must be done within 64k physical page.
    80                              <1> 	; XT-CFv3 support maximum of 64 sector (32768 bytes) blocks in DMA mode
    81                              <1> 	; so we never need to separate transfer to more than 2 separate DMA operations.
    82                              <1> 
    83                              <1> 	; Load XT-CFv3 Control Register port to DX
    84 0000155A 80C21F              <1> 	add		dl, XTCF_CONTROL_REGISTER
    85                              <1> 
    86                              <1> 	; Calculate bytes for first page
    87 0000155D 89F8                <1> 	mov		ax, di
    88 0000155F F7D8                <1> 	neg		ax								; AX = Max BYTEs for first page
    89                              <1> %ifdef USE_186
    90                              <1> 	shl		cx, 9								; CX = Block size in BYTEs
    91                              <1> %else
    92 00001561 86CD                <1> 	xchg		cl, ch
    93 00001563 D1E1                <1> 	shl		cx, 1
    94                              <1> %endif
    95 00001565 39C1                <1> 	cmp		cx, ax								; if we won't cross a physical page boundary...
    96 00001567 760F                <1> 	jbe	SHORT .TransferLastDmaPageWithSizeInCX					; ...perform the transfer in one operation
    97                              <1> 
    98                              <1> 	; Calculate how much we can transfer on first and second rounds
    99 00001569 91                  <1> 	xchg		cx, ax								; CX = BYTEs for first transfer
   100 0000156A 29C8                <1> 	sub		ax, cx								; AX = BYTEs for second transfer
   101 0000156C 50                  <1> 	push		ax								; Save bytes for second transfer on stack
   102                              <1> 
   103                              <1> 	; Transfer first DMA page
   104 0000156D E80800              <1> 	call	StartDMAtransferForXTCFwithDmaModeInBL
   105                              <1> 
   106                              <1> 	; Increment physical address in ES:DI - will only ever be wrapping around to next
   107                              <1> 	; physical segment (hence why it was split)
   108 00001570 8CC1                <1> 	mov		cx, es
   109 00001572 41                  <1> 	inc		cx
   110 00001573 8EC1                <1> 	mov		es, cx								; increment CX via ES
   111 00001575 31FF                <1> 	xor		di, di
   112 00001577 59                  <1> 	pop		cx								; Get bytes for second DMA transfer from stack
   113                              <1> 
   114                              <1> .TransferLastDmaPageWithSizeInCX:
   115                              <1> 	; Fall to StartDMAtransferForXTCFwithDmaModeInBL
   116                              <1> 
   117                              <1> ;--------------------------------------------------------------------
   118                              <1> ; StartDMAtransferForXTCFwithDmaModeInBL
   119                              <1> ; Updated for XT-CFv3, 26-Mar-13
   120                              <1> ;	Parameters:
   121                              <1> ;		BL:		Byte for DMA Mode Register
   122                              <1> ;		CX:		Number of BYTEs to transfer (1...32768 since max block size is limited to 64)
   123                              <1> ;		DX:		XT-CFv3 Control Register
   124                              <1> ;		ES:		Bits 0..3 have physical address bits 19..16
   125                              <1> ;		DI:		Physical address bits 15..0
   126                              <1> ;	Returns:
   127                              <1> ;		Nothing
   128                              <1> ;	Corrupts registers:
   129                              <1> ;		AX
   130                              <1> ;--------------------------------------------------------------------
   131                              <1> ALIGN JUMP_ALIGN
   132                              <1> StartDMAtransferForXTCFwithDmaModeInBL:
   133                              <1> 	; Program 8-bit DMA Controller
   134                              <1> 	; Disable Interrupts and DMA Channel 3 during DMA setup
   135 00001578 B007                <1> 	mov		al, SET_CH3_MASK_BIT
   136 0000157A FA                  <1> 	cli									; Disable interrupts - programming must be atomic
   137 0000157B E60A                <1> 	out		MASK_REGISTER_DMA8_out, al				; Disable DMA Channel 3
   138                              <1> 
   139                              <1> 	; Set DMA Mode (read or write using channel 3)
   140 0000157D 88D8                <1> 	mov		al, bl
   141 0000157F E60B                <1> 	out		MODE_REGISTER_DMA8_out, al
   142                              <1> 
   143                              <1> 	; Set address to DMA controller
   144 00001581 E60C                <1> 	out		CLEAR_FLIPFLOP_DMA8_out, al				; Reset flip-flop to low byte
   145 00001583 8CC0                <1> 	mov		ax, es
   146 00001585 E682                <1> 	out		PAGE_DMA8_CH_3, al
   147 00001587 89F8                <1> 	mov		ax, di
   148 00001589 E606                <1> 	out		BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH3_out, al	; Low byte
   149 0000158B 88E0                <1> 	mov		al, ah
   150 0000158D E606                <1> 	out		BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH3_out, al	; High byte
   151                              <1> 
   152                              <1> 	; Set number of bytes to transfer (DMA controller must be programmed number of bytes - 1)
   153 0000158F 89C8                <1> 	mov		ax, cx
   154 00001591 48                  <1> 	dec		ax							; DMA controller is programmed for one byte less
   155 00001592 E607                <1> 	out		BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH3_out, al	; Low byte
   156 00001594 88E0                <1> 	mov		al, ah
   157 00001596 E607                <1> 	out		BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH3_out, al	; High byte
   158                              <1> 
   159                              <1> 	; Enable DMA Channel 3
   160 00001598 B003                <1> 	mov		al, CLEAR_CH3_MASK_BIT
   161 0000159A E60A                <1> 	out		MASK_REGISTER_DMA8_out, al				; Enable DMA Channel 3
   162 0000159C FB                  <1> 	sti									; Enable interrupts
   163                              <1> 
   164                              <1> 	; XT-CF transfers 16 bytes at a time. We need to manually start transfer for every block by writing (anything)
   165                              <1> 	; to the XT-CFv3 Control Register, which raises DRQ thereby passing system control to the 8237 DMA controller.
   166                              <1> 	; The XT-CFv3 logic releases DRQ after 16 transfers, thereby handing control back to the CPU and allowing any other IRQs or
   167                              <1> 	; DRQs to be serviced (which, on the PC and PC/XT will include DRAM refresh via DMA channel 0).  The 16-byte transfers can
   168                              <1> 	; also be interrupted by the DMA controller raising TC (i.e. when done).  Each transfer cannot be otherwise interrupted
   169                              <1> 	; and is therefore atomic (and hence fast).
   170                              <1> 
   171                              <1> %if 0	; Slow DMA code - works by checking 8237 status register after each 16-byte transfer, until it reports TC has been raised.
   172                              <1> ALIGN JUMP_ALIGN
   173                              <1> .TransferNextBlock:
   174                              <1> 	cli								; We want no ISR to read DMA Status Register before we do
   175                              <1> 	out		dx, al						; Transfer up to 16 bytes to/from XT-CF card
   176                              <1> 	in		al, STATUS_REGISTER_DMA8_in
   177                              <1> 	sti
   178                              <1> 	test		al, FLG_CH3_HAS_REACHED_TERMINAL_COUNT
   179                              <1> 	jz		SHORT .TransferNextBlock			; All bytes transferred?
   180                              <1> %endif ; Slow DMA code
   181                              <1> 
   182                              <1> %if 1	; Fast DMA code - perform computed number of transfers, then check DMA status register to be sure
   183 0000159D 51                  <1> 	push		cx						; save number of bytes to transfer
   184 0000159E 83C10F              <1> 	add		cx, BYTE 15					; We'll divide transfers in 16-byte atomic transfers,
   185                              <1> 	eSHR_IM		cx, 4						; so include any partial block
   185                              <2>  eSHIFT_IM %1, %2, shr
   185                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   185                              <3> %ifndef USE_186
   185                              <3>  %ifidni %1, cl
   185                              <3>  times %2 %3 %1, 1
   185                              <3>  %elifidni %1, ch
   185                              <3>  times %2 %3 %1, 1
   185                              <3>  %elifidni %1, cx
   185 000015A1 D1E9<rept>          <3>  times %2 %3 %1, 1
   185                              <3>  %else
   185                              <3>  %if %2 > 3
   185                              <3>  push cx
   185                              <3>  mov cl, %2
   185                              <3>  %3 %1, cl
   185                              <3>  pop cx
   185                              <3>  %else
   185                              <3>  times %2 %3 %1, 1
   185                              <3>  %endif
   185                              <3>  %endif
   185                              <3> 
   185                              <3> %else
   185                              <3>  %3 %1, %2
   185                              <3> %endif
   185                              <3> %endif
   186                              <1> ALIGN JUMP_ALIGN
   187                              <1> .TransferNextDmaBlock:
   188 000015A9 EE                  <1> 	out		dx, al						; Transfer up to 16 bytes to/from XT-CF card
   189 000015AA E2FD                <1> 	loop	.TransferNextDmaBlock					; dec CX and loop if CX > 0, also adds required wait-state
   190 000015AC 41                  <1> 	inc		cx						; set up CX, in case we need to do an extra iteration
   191 000015AD E408                <1> 	in		al, STATUS_REGISTER_DMA8_in			; check 8237 DMA controller status flags...
   192 000015AF A808                <1> 	test		al, FLG_CH3_HAS_REACHED_TERMINAL_COUNT		; ... for channel 3 terminal count
   193 000015B1 74F6                <1> 	jz		SHORT .TransferNextDmaBlock			; If not set, get more bytes
   194 000015B3 59                  <1> 	pop		cx						; restore CX to the number of bytes transferred
   195                              <1> %endif ; Fast DMA code
   196                              <1> 
   197 000015B4 C3                  <1> 	ret
   198                              <1> 
   241                                  %endif
   242                                  	%include "IdeTransfer.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	IDE Device transfer functions.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    21                              <1> 
    22                              <1> ; Structure containing variables for PIO transfer functions.
    23                              <1> ; This struct must not be larger than IDEPACK without INTPACK.
    24                              <1> struc PIOVARS	; Must not be larger than 9 bytes! See IDEPACK in RamVars.inc.
    25 00000000 <res 00000002>      <1> 	.wDataPort			resb	2	; 0-1, IDE Data Port
    26 00000002 <res 00000002>      <1> 	.fnXfer				resb	2	; 2-3, Offset to transfer function
    27 00000004 <res 00000002>      <1> 	.wSectorsInBlock		resb	2	; 4-5, Block size in sectors
    28 00000006 <res 00000001>      <1> 	.bSectorsLeft			resb	1	; 6, Sectors left to transfer
    29 00000007 <res 00000001>      <1> 					resb	1	; 7, IDEPACK.bDeviceControl
    30 00000008 <res 00000001>      <1> 	.bSectorsDone			resb	1	; 8, Number of sectors xferred
    31                              <1> endstruc
    32                              <1> 
    33                              <1> 
    34                              <1> ; Section containing code
    35                              <1> SECTION .text
    36                              <1> 
    37                              <1> ;--------------------------------------------------------------------
    38                              <1> ; IdeTransfer_StartWithCommandInAL
    39                              <1> ;	Parameters:
    40                              <1> ;		AL:		IDE command that was used to start the transfer
    41                              <1> ;				(all PIO read and write commands including Identify Device)
    42                              <1> ;		ES:SI:	Ptr to data buffer
    43                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    44                              <1> ;		SS:BP:	Ptr to IDEPACK
    45                              <1> ;	Returns:
    46                              <1> ;		AH:		INT 13h Error Code
    47                              <1> ;		CX:		Number of successfully transferred sectors
    48                              <1> ;		CF:		Cleared if success, Set if error
    49                              <1> ;	Corrupts registers:
    50                              <1> ;		AL, BX, DX, SI, ES
    51                              <1> ;--------------------------------------------------------------------
    52                              <1> ALIGN JUMP_ALIGN
    53                              <1> IdeTransfer_StartWithCommandInAL:
    54                              <1> 	; Are we reading or writing?
    55 000015B5 A810                <1> 	test	al, 16	; Bit 4 is cleared on all the read commands but set on 3 of the 4 write commands
    56 000015B7 8A6602              <1> 	mov		ah, [bp+IDEPACK.bSectorCount]
    57 000015BA 754F                <1> 	jnz		SHORT WriteToDrive
    58 000015BC 3CC5                <1> 	cmp		al, COMMAND_WRITE_MULTIPLE
    59 000015BE 744B                <1> 	je		SHORT WriteToDrive
    60                              <1> 	; Fall to ReadFromDrive
    61                              <1> 
    62                              <1> ;--------------------------------------------------------------------
    63                              <1> ; ReadFromDrive
    64                              <1> ;	Parameters:
    65                              <1> ;		AH:		Number of sectors to transfer (1...128)
    66                              <1> ;		ES:SI:		Ptr to buffer to receive data
    67                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
    68                              <1> ;		SS:BP:		Ptr to PIOVARS
    69                              <1> ;	Returns:
    70                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
    71                              <1> ;		AH:		BIOS Error code
    72                              <1> ;		CX:		Number of successfully transferred sectors
    73                              <1> ;		CF:		0 if transfer successful
    74                              <1> ;				1 if any error
    75                              <1> ;	Corrupts registers:
    76                              <1> ;		AL, BX, DX, SI, ES
    77                              <1> ;--------------------------------------------------------------------
    78                              <1> ReadFromDrive:
    79                              <1> 	; Prepare to read data to ESSI
    80 000015C0 BB[9416]            <1> 	mov		bx, g_rgfnPioRead
    81 000015C3 E87A00              <1> 	call	InitializePiovarsInSSBPwithSectorCountInAH
    82                              <1> 
    83                              <1> 	; Wait until drive is ready to transfer
    84 000015C6 E82502              <1> 	call	IdeWait_IRQorDRQ					; Wait until ready to transfer
    85 000015C9 723A                <1> 	jc		SHORT ReturnWithTransferErrorInAH
    86 000015CB 87F7                <1> 	xchg	si, di							; ES:DI now points buffer
    87                              <1> 
    88 000015CD 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]		; Max 128
    89                              <1> 
    90                              <1> ALIGN JUMP_ALIGN
    91                              <1> .ReadNextBlockFromDrive:
    92 000015D0 8B5600              <1> 	mov		dx, [bp+PIOVARS.wDataPort]
    93 000015D3 384E06              <1> 	cmp		[bp+PIOVARS.bSectorsLeft], cl
    94 000015D6 7617                <1> 	jbe		SHORT .ReadLastBlockFromDrive
    95 000015D8 FF5602              <1> 	call	[bp+PIOVARS.fnXfer]
    96                              <1> 
    97                              <1> 	; Wait until ready for next block and check for errors
    98 000015DB 87FE                <1> 	xchg		di, si						; DS:DI now points DPT
    99 000015DD E80E02              <1> 	call	IdeWait_IRQorDRQ					; Wait until ready to transfer
   100 000015E0 7223                <1> 	jc		SHORT ReturnWithTransferErrorInAH
   101 000015E2 87F7                <1> 	xchg		si, di						; ES:DI now points buffer
   102                              <1> 
   103                              <1> 	; Increment number of successfully read sectors
   104 000015E4 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]
   105 000015E7 284E06              <1> 	sub		[bp+PIOVARS.bSectorsLeft], cl
   106 000015EA 004E08              <1> 	add		[bp+PIOVARS.bSectorsDone], cl
   107 000015ED EBE1                <1> 	jmp		SHORT .ReadNextBlockFromDrive
   108                              <1> 
   109                              <1> ALIGN JUMP_ALIGN
   110                              <1> .ReadLastBlockFromDrive:
   111 000015EF 8A4E06              <1> 	mov		cl, [bp+PIOVARS.bSectorsLeft]			; CH is already zero
   112 000015F2 51                  <1> 	push	cx
   113 000015F3 FF5602              <1> 	call	[bp+PIOVARS.fnXfer]					; Transfer possibly partial block
   114                              <1> 
   115                              <1> 	; Check for errors in last block
   116 000015F6 89F7                <1> 	mov		di, si						; DS:DI now points DPT
   117                              <1> CheckErrorsAfterTransferringLastBlock:
   118 000015F8 BB80FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_BSY)
   119 000015FB E8F301              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
   120 000015FE 59                  <1> 	pop		cx	; [bp+PIOVARS.bSectorsLeft]
   121 000015FF 7204                <1> 	jc		SHORT ReturnWithTransferErrorInAH
   122                              <1> 
   123                              <1> 	; All sectors successfully transferred
   124 00001601 034E08              <1> 	add		cx, [bp+PIOVARS.bSectorsDone]			; Never sets CF
   125 00001604 C3                  <1> 	ret
   126                              <1> 
   127                              <1> 	; Return number of successfully read sectors
   128                              <1> ReturnWithTransferErrorInAH:
   129                              <1> %ifdef USE_386
   130                              <1> 	movzx	cx, [bp+PIOVARS.bSectorsDone]
   131                              <1> %else
   132 00001605 8A4E08              <1> 	mov		cl, [bp+PIOVARS.bSectorsDone]
   133 00001608 B500                <1> 	mov		ch, 0						; Preserve CF
   134                              <1> %endif
   135 0000160A C3                  <1> 	ret
   136                              <1> 
   137                              <1> 
   138                              <1> ;--------------------------------------------------------------------
   139                              <1> ; WriteToDrive
   140                              <1> ;	Parameters:
   141                              <1> ;		AH:		Number of sectors to transfer (1...128)
   142                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   143                              <1> ;		ES:SI:	Ptr to buffer containing data
   144                              <1> ;		SS:BP:	Ptr to PIOVARS
   145                              <1> ;	Returns:
   146                              <1> ;		AH:		BIOS Error code
   147                              <1> ;		CX:		Number of successfully transferred sectors
   148                              <1> ;		CF:		0 if transfer successful
   149                              <1> ;				1 if any error
   150                              <1> ;	Corrupts registers:
   151                              <1> ;		AL, BX, DX, SI, ES
   152                              <1> ;--------------------------------------------------------------------
   153                              <1> ALIGN JUMP_ALIGN
   154                              <1> WriteToDrive:
   155                              <1> 	; Prepare to write data from ESSI
   156 0000160B BB[A416]            <1> 	mov		bx, g_rgfnPioWrite
   157 0000160E E82F00              <1> 	call	InitializePiovarsInSSBPwithSectorCountInAH
   158                              <1> 
   159                              <1> 	; Always poll when writing first block (IRQs are generated for following blocks)
   160 00001611 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
   161 00001614 E8DA01              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
   162 00001617 72EC                <1> 	jc		SHORT ReturnWithTransferErrorInAH
   163                              <1> 
   164 00001619 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]		; Max 128
   165                              <1> 
   166                              <1> ALIGN JUMP_ALIGN
   167                              <1> .WriteNextBlockToDrive:
   168 0000161C 8B5600              <1> 	mov		dx, [bp+PIOVARS.wDataPort]
   169 0000161F 384E06              <1> 	cmp		[bp+PIOVARS.bSectorsLeft], cl
   170 00001622 7613                <1> 	jbe		SHORT .WriteLastBlockToDrive
   171 00001624 FF5602              <1> 	call	[bp+PIOVARS.fnXfer]
   172                              <1> 
   173                              <1> 	; Wait until ready for next block and check for errors
   174 00001627 E8C401              <1> 	call	IdeWait_IRQorDRQ					; Wait until ready to transfer
   175 0000162A 72D9                <1> 	jc		SHORT ReturnWithTransferErrorInAH
   176                              <1> 
   177                              <1> 	; Increment number of successfully written sectors
   178 0000162C 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]
   179 0000162F 284E06              <1> 	sub		[bp+PIOVARS.bSectorsLeft], cl
   180 00001632 004E08              <1> 	add		[bp+PIOVARS.bSectorsDone], cl
   181 00001635 EBE5                <1> 	jmp		SHORT .WriteNextBlockToDrive
   182                              <1> 
   183                              <1> ALIGN JUMP_ALIGN
   184                              <1> .WriteLastBlockToDrive:
   185 00001637 8A4E06              <1> 	mov		cl, [bp+PIOVARS.bSectorsLeft]			; CH is already zero
   186 0000163A 51                  <1> 	push		cx
   187                              <1> %ifdef USE_186
   188                              <1> 	push		CheckErrorsAfterTransferringLastBlock
   189                              <1> 	jmp		[bp+PIOVARS.fnXfer]				; Transfer possibly partial block
   190                              <1> %else
   191 0000163B FF5602              <1> 	call		[bp+PIOVARS.fnXfer]				; Transfer possibly partial block
   192 0000163E EBB8                <1> 	jmp		SHORT CheckErrorsAfterTransferringLastBlock
   193                              <1> %endif
   194                              <1> 
   195                              <1> 
   196                              <1> ;--------------------------------------------------------------------
   197                              <1> ; InitializePiovarsInSSBPwithSectorCountInAH
   198                              <1> ;	Parameters:
   199                              <1> ;		AH:		Number of sectors to transfer (1...128)
   200                              <1> ;		BX:		Offset to transfer function lookup table
   201                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   202                              <1> ;		ES:SI:	Ptr to data buffer
   203                              <1> ;		SS:BP:	Ptr to PIOVARS
   204                              <1> ;	Returns:
   205                              <1> ;		Nothing
   206                              <1> ;	Corrupts registers:
   207                              <1> ;		AX, BX, DX
   208                              <1> ;--------------------------------------------------------------------
   209                              <1> ALIGN JUMP_ALIGN
   210                              <1> InitializePiovarsInSSBPwithSectorCountInAH:
   211                              <1> 	; Store sizes and Data Port
   212 00001640 886606              <1> 	mov		[bp+PIOVARS.bSectorsLeft], ah
   213 00001643 8B4504              <1> 	mov		ax, [di+DPT.wBasePort]
   214 00001646 894600              <1> 	mov		[bp+PIOVARS.wDataPort], ax
   215                              <1> 	eMOVZX		ax, [di+DPT_ATA.bBlockSize]
   215                              <2> %ifndef USE_386
   215                              <2>  %ifidni %1, ax
   215 00001649 8A450D              <2>  mov al, %2
   215 0000164C 30E4                <2>  xor ah, ah
   215                              <2>  %elifidni %1, bx
   215                              <2>  mov bl, %2
   215                              <2>  xor bh, bh
   215                              <2>  %elifidni %1, cx
   215                              <2>  mov cl, %2
   215                              <2>  xor ch, ch
   215                              <2>  %elifidni %1, dx
   215                              <2>  mov dl, %2
   215                              <2>  xor dh, dh
   215                              <2>  %else
   215                              <2>  push ax
   215                              <2>  mov al, %2
   215                              <2>  xor ah, ah
   215                              <2>  xchg ax, %1
   215                              <2>  pop ax
   215                              <2>  %endif
   215                              <2> 
   215                              <2> %else
   215                              <2>  movzx %1, %2
   215                              <2> %endif
   216 0000164E 894604              <1> 	mov		[bp+PIOVARS.wSectorsInBlock], ax
   217 00001651 886608              <1> 	mov		[bp+PIOVARS.bSectorsDone], ah			; Zero
   218                              <1> 
   219                              <1> 	; Get transfer function based on bus type
   220 00001654 93                  <1> 	xchg		ax, bx						; Lookup table offset to AX
   221 00001655 8A5D0C              <1> 	mov		bl, [di+DPT_ATA.bDevice]			; get device type to BX
   222                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   223 00001658 88DA                <1> 	mov		dl, bl
   224                              <1> %endif
   225 0000165A 01C3                <1> 	add		bx, ax						; add table offset to device type (index)
   226 0000165C 2E8B07              <1> 	mov		ax, [cs:bx]					; Load offset to transfer function
   227 0000165F 894602              <1> 	mov		[bp+PIOVARS.fnXfer], ax
   228                              <1> 
   229                              <1> 	; Normalize pointer for PIO-transfers and convert to physical address for DMA transfers
   230                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   231 00001662 80FA0E              <1> 	cmp		dl, DEVICE_8BIT_XTCF_DMA
   232 00001665 721B                <1> 	jb		SHORT IdeTransfer_NormalizePointerInESSI
   233                              <1> 
   234                              <1> 	; Convert ES:SI to physical address
   235                              <1> %ifdef USE_186			; Bytes	EU Cycles(286)
   236                              <1> 	mov		ax, es		; 2		2
   237                              <1> 	rol		ax, 4		; 3		9
   238                              <1> 	mov		dx, ax		; 2		2
   239                              <1> 	and		ax, BYTE 0Fh	; 3		3
   240                              <1> 	xor		dx, ax		; 2		2
   241                              <1> 	add		si, dx		; 2		2
   242                              <1> 	adc		al, ah		; 2		2
   243                              <1> 	mov		es, ax		; 2		2
   244                              <1> 	;------------------------------------
   245                              <1> 						; 18	24
   246                              <1> %else ; 808x
   247                              <1> 
   248                              <1> %if 0
   249                              <1> 						; Bytes	EU Cycles(808x)
   250                              <1> 	mov		al, 4		; 2		4
   251                              <1> 	mov		dx, es		; 2		2
   252                              <1> 	xchg	cx, ax		; 1		3
   253                              <1> 	rol		dx, cl		; 2		24
   254                              <1> 	mov		cx, dx		; 2		2
   255                              <1> 	xchg	cx, ax		; 1		3
   256                              <1> 	and		ax, BYTE 0Fh; 3		4
   257                              <1> 	xor		dx, ax		; 2		3
   258                              <1> 	add		si, dx		; 2		3
   259                              <1> 	adc		al, ah		; 2		3
   260                              <1> 	mov		es, ax		; 2		2
   261                              <1> 	;------------------------------------
   262                              <1> 						; 21	53
   263                              <1> ;
   264                              <1> ; Judging by the Execution Unit cycle count the above block of code is
   265                              <1> ; apparently slower. However, the shifts and rotates in the block below
   266                              <1> ; execute faster than the Bus Interface Unit on an 8088 can fetch them,
   267                              <1> ; thus causing the EU to starve. The difference in true execution speed
   268                              <1> ; (if any) might not be worth the extra 5 bytes.
   269                              <1> ; In other words, we could use a real world test here.
   270                              <1> ;
   271                              <1> %endif ; 0
   272                              <1> 						; Bytes	EU Cycles(808x/286)
   273 00001667 31D2                <1> 	xor		dx, dx		; 2		3/2
   274 00001669 8CC0                <1> 	mov		ax, es		; 2		2/2
   275                              <1> %rep 4
   276                              <1> 	shl		ax, 1		; 8		8/8
   277                              <1> 	rcl		dx, 1		; 8		8/8
   278                              <1> %endrep
   278 0000166B D1E0                <2>  shl ax, 1
   278 0000166D D1D2                <2>  rcl dx, 1
   278 0000166F D1E0                <2>  shl ax, 1
   278 00001671 D1D2                <2>  rcl dx, 1
   278 00001673 D1E0                <2>  shl ax, 1
   278 00001675 D1D2                <2>  rcl dx, 1
   278 00001677 D1E0                <2>  shl ax, 1
   278 00001679 D1D2                <2>  rcl dx, 1
   279 0000167B 01C6                <1> 	add		si, ax		; 2		3/2
   280 0000167D 10F2                <1> 	adc		dl, dh		; 2		3/2
   281 0000167F 8EC2                <1> 	mov		es, dx		; 2		2/2
   282                              <1> 	;------------------------------------
   283                              <1> %endif					; 26	29/26
   284 00001681 C3                  <1> 	ret
   285                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
   286                              <1> 	; Fall to IdeTransfer_NormalizePointerInESSI if no MODULE_8BIT_IDE
   287                              <1> 
   288                              <1> 
   289                              <1> ;--------------------------------------------------------------------
   290                              <1> ; IdeTransfer_NormalizePointerInESSI
   291                              <1> ;	Parameters:
   292                              <1> ;		ES:SI:	Ptr to be normalized
   293                              <1> ;	Returns:
   294                              <1> ;		ES:SI:	Normalized pointer (SI = 0...15)
   295                              <1> ;	Corrupts registers:
   296                              <1> ;		AX, DX
   297                              <1> ;--------------------------------------------------------------------
   298                              <1> IdeTransfer_NormalizePointerInESSI:
   299                              <1> 	NORMALIZE_FAR_POINTER	es, si, ax, dx
   299 00001682 89F2                <2>  mov %4, %2
   299 00001684 83E60F              <2>  and %2, BYTE 0Fh
   299                              <2>  eSHR_IM %4, 4
   299                              <3>  eSHIFT_IM %1, %2, shr
   299                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   299                              <4> %ifndef USE_186
   299                              <4>  %ifidni %1, cl
   299                              <4>  times %2 %3 %1, 1
   299                              <4>  %elifidni %1, ch
   299                              <4>  times %2 %3 %1, 1
   299                              <4>  %elifidni %1, cx
   299                              <4>  times %2 %3 %1, 1
   299                              <4>  %else
   299                              <4>  %if %2 > 3
   299 00001687 51                  <4>  push cx
   299 00001688 B104                <4>  mov cl, %2
   299 0000168A D3EA                <4>  %3 %1, cl
   299 0000168C 59                  <4>  pop cx
   299                              <4>  %else
   299                              <4>  times %2 %3 %1, 1
   299                              <4>  %endif
   299                              <4>  %endif
   299                              <4> 
   299                              <4> %else
   299                              <4>  %3 %1, %2
   299                              <4> %endif
   299                              <4> %endif
   299 0000168D 8CC0                <2>  mov %3, %1
   299 0000168F 01D0                <2>  add %3, %4
   299 00001691 8EC0                <2>  mov %1, %3
   300 00001693 C3                  <1> 	ret
   301                              <1> 
   302                              <1> 
   303                              <1> ; Lookup tables to get transfer function based on bus type
   304                              <1> ALIGN WORD_ALIGN
   305                              <1> g_rgfnPioRead:
   306 00001694 [2817]              <1> 		dw		IdePioBlock_ReadFrom16bitDataPort	; 0, DEVICE_16BIT_ATA
   307 00001696 [4117]              <1> 		dw		IdePioBlock_ReadFrom32bitDataPort	; 1, DEVICE_32BIT_ATA
   308                              <1> %ifdef MODULE_8BIT_IDE
   309 00001698 [FF16]              <1> 		dw		IdePioBlock_ReadFrom8bitDataPort	; 2, DEVICE_8BIT_ATA
   310 0000169A [B416]              <1> 		dw		IdePioBlock_ReadFromXtideRev1		; 3, DEVICE_8BIT_XTIDE_REV1
   311 0000169C [2817]              <1> 		dw		IdePioBlock_ReadFrom16bitDataPort	; 4, DEVICE_8BIT_XTIDE_REV2
   312 0000169E [FF16]              <1> 		dw		IdePioBlock_ReadFrom8bitDataPort	; 5, DEVICE_8BIT_XTCF_PIO8
   313 000016A0 [2817]              <1> 		dw		IdePioBlock_ReadFrom16bitDataPort	; 6, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
   314 000016A2 [5815]              <1> 		dw		IdeDmaBlock_ReadFromXTCF		; 7, DEVICE_8BIT_XTCF_DMA
   315                              <1> %endif
   316                              <1> 
   317                              <1> 
   318                              <1> g_rgfnPioWrite:
   319 000016A4 [D117]              <1> 		dw		IdePioBlock_WriteTo16bitDataPort	; 0, DEVICE_16BIT_ATA
   320 000016A6 [E617]              <1> 		dw		IdePioBlock_WriteTo32bitDataPort	; 1, DEVICE_32BIT_ATA
   321                              <1> %ifdef MODULE_8BIT_IDE
   322 000016A8 [B417]              <1> 		dw		IdePioBlock_WriteTo8bitDataPort		; 2, DEVICE_8BIT_ATA
   323 000016AA [4817]              <1> 		dw		IdePioBlock_WriteToXtideRev1		; 3, DEVICE_8BIT_XTIDE_REV1
   324 000016AC [8317]              <1> 		dw		IdePioBlock_WriteToXtideRev2		; 4, DEVICE_8BIT_XTIDE_REV2
   325 000016AE [B417]              <1> 		dw		IdePioBlock_WriteTo8bitDataPort		; 5, DEVICE_8BIT_XTCF_PIO8
   326 000016B0 [D117]              <1> 		dw		IdePioBlock_WriteTo16bitDataPort	; 6, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
   327 000016B2 [4E15]              <1> 		dw		IdeDmaBlock_WriteToXTCF			; 7, DEVICE_8BIT_XTCF_DMA
   328                              <1> %endif
   243                                  	%include "IdePioBlock.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	IDE Read/Write functions for transferring
     3                              <1> ;					block using PIO modes.
     4                              <1> ;					These functions should only be called from IdeTransfer.asm.
     5                              <1> 
     6                              <1> ;
     7                              <1> ; XTIDE Universal BIOS and Associated Tools
     8                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     9                              <1> ;
    10                              <1> ; This program is free software; you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation; either version 2 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    20                              <1> ;
    21                              <1> 
    22                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    23                              <1> 
    24                              <1> ; Section containing code
    25                              <1> SECTION .text
    26                              <1> 
    27                              <1> 
    28                              <1> ; --------------------------------------------------------------------------------------------------
    29                              <1> ;
    30                              <1> ; READ routines follow
    31                              <1> ;
    32                              <1> ; --------------------------------------------------------------------------------------------------
    33                              <1> 
    34                              <1> 
    35                              <1> %ifdef MODULE_8BIT_IDE
    36                              <1> 
    37                              <1> ;--------------------------------------------------------------------
    38                              <1> ; IdePioBlock_ReadFromXtideRev1
    39                              <1> ;	Parameters:
    40                              <1> ;		CX:		Block size in 512 byte sectors
    41                              <1> ;		DX:		IDE Data port address
    42                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data
    43                              <1> ;	Returns:
    44                              <1> ;		Nothing
    45                              <1> ;	Corrupts registers:
    46                              <1> ;		AX, BX, CX
    47                              <1> ;--------------------------------------------------------------------
    48                              <1> ALIGN JUMP_ALIGN
    49                              <1> IdePioBlock_ReadFromXtideRev1:
    50                              <1> 	UNROLL_SECTORS_IN_CX_TO_OWORDS
    50                              <2> %ifdef USE_186
    50                              <2>  shl cx, 5
    50                              <2> %else
    50                              <2> 
    50                              <2> 
    50 000016B4 88CD                <2>  mov ch, cl
    50 000016B6 B103                <2>  mov cl, 3
    50 000016B8 D3E9                <2>  shr cx, cl
    50                              <2> %endif
    51 000016BA B308                <1> 	mov		bl, 8		; Bit mask for toggling data low/high reg
    52                              <1> ALIGN JUMP_ALIGN
    53                              <1> .InswLoop:
    54                              <1> 	%rep 8 ; WORDs
    55                              <1> 		XTIDE_INSW
    56                              <1> 	%endrep
    56                              <2>  XTIDE_INSW
    56                              <3> %ifdef USE_186
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3> %else
    56 000016BC EC                  <3>  in al, dx
    56 000016BD 30DA                <3>  xor dl, bl
    56 000016BF AA                  <3>  stosb
    56 000016C0 EC                  <3>  in al, dx
    56 000016C1 30DA                <3>  xor dl, bl
    56 000016C3 AA                  <3>  stosb
    56                              <3> %endif
    56                              <2>  XTIDE_INSW
    56                              <3> %ifdef USE_186
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3> %else
    56 000016C4 EC                  <3>  in al, dx
    56 000016C5 30DA                <3>  xor dl, bl
    56 000016C7 AA                  <3>  stosb
    56 000016C8 EC                  <3>  in al, dx
    56 000016C9 30DA                <3>  xor dl, bl
    56 000016CB AA                  <3>  stosb
    56                              <3> %endif
    56                              <2>  XTIDE_INSW
    56                              <3> %ifdef USE_186
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3> %else
    56 000016CC EC                  <3>  in al, dx
    56 000016CD 30DA                <3>  xor dl, bl
    56 000016CF AA                  <3>  stosb
    56 000016D0 EC                  <3>  in al, dx
    56 000016D1 30DA                <3>  xor dl, bl
    56 000016D3 AA                  <3>  stosb
    56                              <3> %endif
    56                              <2>  XTIDE_INSW
    56                              <3> %ifdef USE_186
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3> %else
    56 000016D4 EC                  <3>  in al, dx
    56 000016D5 30DA                <3>  xor dl, bl
    56 000016D7 AA                  <3>  stosb
    56 000016D8 EC                  <3>  in al, dx
    56 000016D9 30DA                <3>  xor dl, bl
    56 000016DB AA                  <3>  stosb
    56                              <3> %endif
    56                              <2>  XTIDE_INSW
    56                              <3> %ifdef USE_186
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3> %else
    56 000016DC EC                  <3>  in al, dx
    56 000016DD 30DA                <3>  xor dl, bl
    56 000016DF AA                  <3>  stosb
    56 000016E0 EC                  <3>  in al, dx
    56 000016E1 30DA                <3>  xor dl, bl
    56 000016E3 AA                  <3>  stosb
    56                              <3> %endif
    56                              <2>  XTIDE_INSW
    56                              <3> %ifdef USE_186
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3> %else
    56 000016E4 EC                  <3>  in al, dx
    56 000016E5 30DA                <3>  xor dl, bl
    56 000016E7 AA                  <3>  stosb
    56 000016E8 EC                  <3>  in al, dx
    56 000016E9 30DA                <3>  xor dl, bl
    56 000016EB AA                  <3>  stosb
    56                              <3> %endif
    56                              <2>  XTIDE_INSW
    56                              <3> %ifdef USE_186
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3> %else
    56 000016EC EC                  <3>  in al, dx
    56 000016ED 30DA                <3>  xor dl, bl
    56 000016EF AA                  <3>  stosb
    56 000016F0 EC                  <3>  in al, dx
    56 000016F1 30DA                <3>  xor dl, bl
    56 000016F3 AA                  <3>  stosb
    56                              <3> %endif
    56                              <2>  XTIDE_INSW
    56                              <3> %ifdef USE_186
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3>  insb
    56                              <3>  xor dl, bl
    56                              <3> %else
    56 000016F4 EC                  <3>  in al, dx
    56 000016F5 30DA                <3>  xor dl, bl
    56 000016F7 AA                  <3>  stosb
    56 000016F8 EC                  <3>  in al, dx
    56 000016F9 30DA                <3>  xor dl, bl
    56 000016FB AA                  <3>  stosb
    56                              <3> %endif
    57 000016FC E2BE                <1> 	loop	.InswLoop
    58 000016FE C3                  <1> 	ret
    59                              <1> 
    60                              <1> 
    61                              <1> ;--------------------------------------------------------------------
    62                              <1> ; IdePioBlock_ReadFrom8bitDataPort
    63                              <1> ;
    64                              <1> ; 8-bit PIO from a single data port.
    65                              <1> ;
    66                              <1> ;	Parameters:
    67                              <1> ;		CX:	Block size in 512 byte sectors
    68                              <1> ;		DX:	IDE Data port address
    69                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data
    70                              <1> ;	Returns:
    71                              <1> ;		Nothing
    72                              <1> ;	Corrupts registers:
    73                              <1> ;		AX, BX, CX
    74                              <1> ;--------------------------------------------------------------------
    75                              <1> ALIGN JUMP_ALIGN
    76                              <1> IdePioBlock_ReadFrom8bitDataPort:
    77                              <1> %ifdef USE_186
    78                              <1> 	shl		cx, 9			; Sectors to BYTEs
    79                              <1> 	rep insb
    80                              <1> 	ret
    81                              <1> %else ; If 8088/8086
    82                              <1> 	UNROLL_SECTORS_IN_CX_TO_OWORDS
    82                              <2> %ifdef USE_186
    82                              <2>  shl cx, 5
    82                              <2> %else
    82                              <2> 
    82                              <2> 
    82 000016FF 88CD                <2>  mov ch, cl
    82 00001701 B103                <2>  mov cl, 3
    82 00001703 D3E9                <2>  shr cx, cl
    82                              <2> %endif
    83                              <1> ALIGN JUMP_ALIGN
    84                              <1> .ReadNextOword:
    85                              <1> 	%rep 16	; BYTEs
    86                              <1> 		in		al, dx		; Read BYTE
    87                              <1> 		stosb				; Store BYTE to [ES:DI]
    88                              <1> 	%endrep
    88 00001705 EC                  <2>  in al, dx
    88 00001706 AA                  <2>  stosb
    88 00001707 EC                  <2>  in al, dx
    88 00001708 AA                  <2>  stosb
    88 00001709 EC                  <2>  in al, dx
    88 0000170A AA                  <2>  stosb
    88 0000170B EC                  <2>  in al, dx
    88 0000170C AA                  <2>  stosb
    88 0000170D EC                  <2>  in al, dx
    88 0000170E AA                  <2>  stosb
    88 0000170F EC                  <2>  in al, dx
    88 00001710 AA                  <2>  stosb
    88 00001711 EC                  <2>  in al, dx
    88 00001712 AA                  <2>  stosb
    88 00001713 EC                  <2>  in al, dx
    88 00001714 AA                  <2>  stosb
    88 00001715 EC                  <2>  in al, dx
    88 00001716 AA                  <2>  stosb
    88 00001717 EC                  <2>  in al, dx
    88 00001718 AA                  <2>  stosb
    88 00001719 EC                  <2>  in al, dx
    88 0000171A AA                  <2>  stosb
    88 0000171B EC                  <2>  in al, dx
    88 0000171C AA                  <2>  stosb
    88 0000171D EC                  <2>  in al, dx
    88 0000171E AA                  <2>  stosb
    88 0000171F EC                  <2>  in al, dx
    88 00001720 AA                  <2>  stosb
    88 00001721 EC                  <2>  in al, dx
    88 00001722 AA                  <2>  stosb
    88 00001723 EC                  <2>  in al, dx
    88 00001724 AA                  <2>  stosb
    89 00001725 E2DE                <1> 	loop	.ReadNextOword
    90 00001727 C3                  <1> 	ret
    91                              <1> %endif
    92                              <1> 
    93                              <1> %endif	; MODULE_8BIT_IDE
    94                              <1> 
    95                              <1> 
    96                              <1> ;--------------------------------------------------------------------
    97                              <1> ; IdePioBlock_ReadFrom16bitDataPort
    98                              <1> ;
    99                              <1> ; 16-bit PIO from a single data port.
   100                              <1> ;
   101                              <1> ;	Parameters:
   102                              <1> ;		CX:	Block size in 512 byte sectors
   103                              <1> ;		DX:	IDE Data port address
   104                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data
   105                              <1> ;	Returns:
   106                              <1> ;		Nothing
   107                              <1> ;	Corrupts registers:
   108                              <1> ;		AX, BX, CX
   109                              <1> ;--------------------------------------------------------------------
   110                              <1> ALIGN JUMP_ALIGN
   111                              <1> IdePioBlock_ReadFrom16bitDataPort:
   112                              <1> %ifdef USE_186
   113                              <1> 	xhcg		cl, ch			; Sectors to WORDs
   114                              <1> 	rep
   115                              <1> 	db		6Dh			; INSW
   116                              <1> 	ret
   117                              <1> %else ; If 8088/8086
   118                              <1> 	UNROLL_SECTORS_IN_CX_TO_OWORDS
   118                              <2> %ifdef USE_186
   118                              <2>  shl cx, 5
   118                              <2> %else
   118                              <2> 
   118                              <2> 
   118 00001728 88CD                <2>  mov ch, cl
   118 0000172A B103                <2>  mov cl, 3
   118 0000172C D3E9                <2>  shr cx, cl
   118                              <2> %endif
   119                              <1> ALIGN JUMP_ALIGN
   120                              <1> .ReadNextOword:
   121                              <1> 	%rep 8	; WORDs
   122                              <1> 		in		ax, dx		; Read BYTE
   123                              <1> 		stosw				; Store BYTE to [ES:DI]
   124                              <1> 	%endrep
   124 0000172E ED                  <2>  in ax, dx
   124 0000172F AB                  <2>  stosw
   124 00001730 ED                  <2>  in ax, dx
   124 00001731 AB                  <2>  stosw
   124 00001732 ED                  <2>  in ax, dx
   124 00001733 AB                  <2>  stosw
   124 00001734 ED                  <2>  in ax, dx
   124 00001735 AB                  <2>  stosw
   124 00001736 ED                  <2>  in ax, dx
   124 00001737 AB                  <2>  stosw
   124 00001738 ED                  <2>  in ax, dx
   124 00001739 AB                  <2>  stosw
   124 0000173A ED                  <2>  in ax, dx
   124 0000173B AB                  <2>  stosw
   124 0000173C ED                  <2>  in ax, dx
   124 0000173D AB                  <2>  stosw
   125 0000173E E2EE                <1> 	loop	.ReadNextOword
   126 00001740 C3                  <1> 	ret
   127                              <1> %endif
   128                              <1> 
   129                              <1> 
   130                              <1> ;--------------------------------------------------------------------
   131                              <1> ALIGN JUMP_ALIGN
   132                              <1> IdePioBlock_ReadFrom32bitDataPort:
   133 00001741 C1                  <1> 	db		0C1h			; SHL
   134 00001742 E1                  <1> 	db		0E1h			; CX
   135 00001743 07                  <1> 	db		7			; 7	(Sectors to DWORDs)
   136 00001744 F3                  <1> 	rep
   137 00001745 66                  <1> 	db		66h			; Override operand size to 32-bit
   138 00001746 6D                  <1> 	db		6Dh			; INSW/INSD
   139 00001747 C3                  <1> 	ret
   140                              <1> 
   141                              <1> 
   142                              <1> 
   143                              <1> ; --------------------------------------------------------------------------------------------------
   144                              <1> ;
   145                              <1> ; WRITE routines follow
   146                              <1> ;
   147                              <1> ; --------------------------------------------------------------------------------------------------
   148                              <1> 
   149                              <1> %ifdef MODULE_8BIT_IDE
   150                              <1> 
   151                              <1> ;--------------------------------------------------------------------
   152                              <1> ; IdePioBlock_WriteToXtideRev1
   153                              <1> ;	Parameters:
   154                              <1> ;		CX:	Block size in 512-byte sectors
   155                              <1> ;		DX:	IDE Data port address
   156                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
   157                              <1> ;	Returns:
   158                              <1> ;		Nothing
   159                              <1> ;	Corrupts registers:
   160                              <1> ;		AX, BX, CX, DX
   161                              <1> ;--------------------------------------------------------------------
   162                              <1> ALIGN JUMP_ALIGN
   163                              <1> IdePioBlock_WriteToXtideRev1:
   164 00001748 1E                  <1> 	push	ds
   165                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
   165                              <2> %ifdef USE_186
   165                              <2>  shl cx, 6
   165                              <2> %else
   165                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
   165                              <3> %ifdef USE_186
   165                              <3>  shl cx, 7
   165                              <3> %else
   165 00001749 86CD                <3>  xchg cl, ch
   165 0000174B D1E9                <3>  shr cx, 1
   165                              <3> %endif
   165 0000174D D1E9                <2>  shr cx, 1
   165                              <2> %endif
   166 0000174F B308                <1> 	mov		bl, 8		; Bit mask for toggling data low/high reg
   167 00001751 06                  <1> 	push		es		; Copy ES...
   168 00001752 1F                  <1> 	pop		ds		; ...to DS
   169                              <1> ALIGN JUMP_ALIGN
   170                              <1> .OutswLoop:
   171                              <1> 	%rep 4	; WORDs
   172                              <1> 		XTIDE_OUTSW
   173                              <1> 	%endrep
   173                              <2>  XTIDE_OUTSW
   173                              <3> %ifdef USE_186
   173                              <3>  lodsb
   173                              <3>  xor dl, bl
   173                              <3>  outsb
   173                              <3>  xor dl, bl
   173                              <3>  out dx, al
   173                              <3> %else
   173 00001753 AD                  <3>  lodsw
   173 00001754 30DA                <3>  xor dl, bl
   173 00001756 86C4                <3>  xchg al, ah
   173 00001758 EE                  <3>  out dx, al
   173 00001759 30DA                <3>  xor dl, bl
   173 0000175B 88E0                <3>  mov al, ah
   173 0000175D EE                  <3>  out dx, al
   173                              <3> %endif
   173                              <2>  XTIDE_OUTSW
   173                              <3> %ifdef USE_186
   173                              <3>  lodsb
   173                              <3>  xor dl, bl
   173                              <3>  outsb
   173                              <3>  xor dl, bl
   173                              <3>  out dx, al
   173                              <3> %else
   173 0000175E AD                  <3>  lodsw
   173 0000175F 30DA                <3>  xor dl, bl
   173 00001761 86C4                <3>  xchg al, ah
   173 00001763 EE                  <3>  out dx, al
   173 00001764 30DA                <3>  xor dl, bl
   173 00001766 88E0                <3>  mov al, ah
   173 00001768 EE                  <3>  out dx, al
   173                              <3> %endif
   173                              <2>  XTIDE_OUTSW
   173                              <3> %ifdef USE_186
   173                              <3>  lodsb
   173                              <3>  xor dl, bl
   173                              <3>  outsb
   173                              <3>  xor dl, bl
   173                              <3>  out dx, al
   173                              <3> %else
   173 00001769 AD                  <3>  lodsw
   173 0000176A 30DA                <3>  xor dl, bl
   173 0000176C 86C4                <3>  xchg al, ah
   173 0000176E EE                  <3>  out dx, al
   173 0000176F 30DA                <3>  xor dl, bl
   173 00001771 88E0                <3>  mov al, ah
   173 00001773 EE                  <3>  out dx, al
   173                              <3> %endif
   173                              <2>  XTIDE_OUTSW
   173                              <3> %ifdef USE_186
   173                              <3>  lodsb
   173                              <3>  xor dl, bl
   173                              <3>  outsb
   173                              <3>  xor dl, bl
   173                              <3>  out dx, al
   173                              <3> %else
   173 00001774 AD                  <3>  lodsw
   173 00001775 30DA                <3>  xor dl, bl
   173 00001777 86C4                <3>  xchg al, ah
   173 00001779 EE                  <3>  out dx, al
   173 0000177A 30DA                <3>  xor dl, bl
   173 0000177C 88E0                <3>  mov al, ah
   173 0000177E EE                  <3>  out dx, al
   173                              <3> %endif
   174 0000177F E2D2                <1> 	loop	.OutswLoop
   175 00001781 1F                  <1> 	pop		ds
   176 00001782 C3                  <1> 	ret
   177                              <1> 
   178                              <1> 
   179                              <1> ;--------------------------------------------------------------------
   180                              <1> ; IdePioBlock_WriteToXtideRev2	or rev 1 with swapped A0 and A3 (chuck-mod)
   181                              <1> ;	Parameters:
   182                              <1> ;		CX:	Block size in 512-byte sectors
   183                              <1> ;		DX:	IDE Data port address
   184                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
   185                              <1> ;	Returns:
   186                              <1> ;		Nothing
   187                              <1> ;	Corrupts registers:
   188                              <1> ;		AX, BX, CX, DX
   189                              <1> ;--------------------------------------------------------------------
   190                              <1> ALIGN JUMP_ALIGN
   191                              <1> IdePioBlock_WriteToXtideRev2:
   192                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
   192                              <2> %ifdef USE_186
   192                              <2>  shl cx, 6
   192                              <2> %else
   192                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
   192                              <3> %ifdef USE_186
   192                              <3>  shl cx, 7
   192                              <3> %else
   192 00001783 86CD                <3>  xchg cl, ch
   192 00001785 D1E9                <3>  shr cx, 1
   192                              <3> %endif
   192 00001787 D1E9                <2>  shr cx, 1
   192                              <2> %endif
   193 00001789 1E                  <1> 	push		ds
   194 0000178A 06                  <1> 	push		es			; Copy ES...
   195 0000178B 1F                  <1> 	pop		ds			; ...to DS
   196                              <1> ALIGN JUMP_ALIGN
   197                              <1> .WriteNextQword:
   198                              <1> 	%rep 4	; WORDs
   199                              <1> 		XTIDE_MOD_OUTSW			; special macro
   200                              <1> 	%endrep
   200                              <2>  XTIDE_MOD_OUTSW
   200                              <3> %ifdef USE_186
   200                              <3>  lodsb
   200                              <3>  inc dx
   200                              <3>  outsb
   200                              <3>  dec dx
   200                              <3>  out dx, al
   200                              <3> %else
   200 0000178C AD                  <3>  lodsw
   200 0000178D 42                  <3>  inc dx
   200 0000178E 86C4                <3>  xchg al, ah
   200 00001790 EE                  <3>  out dx, al
   200 00001791 4A                  <3>  dec dx
   200 00001792 88E0                <3>  mov al, ah
   200 00001794 EE                  <3>  out dx, al
   200                              <3> %endif
   200                              <2>  XTIDE_MOD_OUTSW
   200                              <3> %ifdef USE_186
   200                              <3>  lodsb
   200                              <3>  inc dx
   200                              <3>  outsb
   200                              <3>  dec dx
   200                              <3>  out dx, al
   200                              <3> %else
   200 00001795 AD                  <3>  lodsw
   200 00001796 42                  <3>  inc dx
   200 00001797 86C4                <3>  xchg al, ah
   200 00001799 EE                  <3>  out dx, al
   200 0000179A 4A                  <3>  dec dx
   200 0000179B 88E0                <3>  mov al, ah
   200 0000179D EE                  <3>  out dx, al
   200                              <3> %endif
   200                              <2>  XTIDE_MOD_OUTSW
   200                              <3> %ifdef USE_186
   200                              <3>  lodsb
   200                              <3>  inc dx
   200                              <3>  outsb
   200                              <3>  dec dx
   200                              <3>  out dx, al
   200                              <3> %else
   200 0000179E AD                  <3>  lodsw
   200 0000179F 42                  <3>  inc dx
   200 000017A0 86C4                <3>  xchg al, ah
   200 000017A2 EE                  <3>  out dx, al
   200 000017A3 4A                  <3>  dec dx
   200 000017A4 88E0                <3>  mov al, ah
   200 000017A6 EE                  <3>  out dx, al
   200                              <3> %endif
   200                              <2>  XTIDE_MOD_OUTSW
   200                              <3> %ifdef USE_186
   200                              <3>  lodsb
   200                              <3>  inc dx
   200                              <3>  outsb
   200                              <3>  dec dx
   200                              <3>  out dx, al
   200                              <3> %else
   200 000017A7 AD                  <3>  lodsw
   200 000017A8 42                  <3>  inc dx
   200 000017A9 86C4                <3>  xchg al, ah
   200 000017AB EE                  <3>  out dx, al
   200 000017AC 4A                  <3>  dec dx
   200 000017AD 88E0                <3>  mov al, ah
   200 000017AF EE                  <3>  out dx, al
   200                              <3> %endif
   201 000017B0 E2DA                <1> 	loop	.WriteNextQword
   202 000017B2 1F                  <1> 	pop		ds
   203 000017B3 C3                  <1> 	ret
   204                              <1> 
   205                              <1> 
   206                              <1> ;--------------------------------------------------------------------
   207                              <1> ; IdePioBlock_WriteTo8bitDataPort
   208                              <1> ;	Parameters:
   209                              <1> ;		CX:	Block size in 512-byte sectors
   210                              <1> ;		DX:	IDE Data port address
   211                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
   212                              <1> ;	Returns:
   213                              <1> ;		Nothing
   214                              <1> ;	Corrupts registers:
   215                              <1> ;		AX, BX, CX, DX
   216                              <1> ;--------------------------------------------------------------------
   217                              <1> ALIGN JUMP_ALIGN
   218                              <1> IdePioBlock_WriteTo8bitDataPort:
   219                              <1> %ifdef USE_186
   220                              <1> 	shl		cx, 9		; Sectors to BYTEs
   221                              <1> 	es				; Source is ES segment
   222                              <1> 	rep outsb
   223                              <1> 	ret
   224                              <1> %else ; If 8088/8086
   225                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
   225                              <2> %ifdef USE_186
   225                              <2>  shl cx, 6
   225                              <2> %else
   225                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
   225                              <3> %ifdef USE_186
   225                              <3>  shl cx, 7
   225                              <3> %else
   225 000017B4 86CD                <3>  xchg cl, ch
   225 000017B6 D1E9                <3>  shr cx, 1
   225                              <3> %endif
   225 000017B8 D1E9                <2>  shr cx, 1
   225                              <2> %endif
   226 000017BA 1E                  <1> 	push		ds
   227 000017BB 06                  <1> 	push		es
   228 000017BC 1F                  <1> 	pop		ds
   229                              <1> ALIGN JUMP_ALIGN
   230                              <1> .WriteNextQword:
   231                              <1> 	%rep 8	; BYTEs
   232                              <1> 		lodsb			; Load BYTE from [DS:SI]
   233                              <1> 		out	dx, al		; Write BYTE
   234                              <1> 	%endrep
   234 000017BD AC                  <2>  lodsb
   234 000017BE EE                  <2>  out dx, al
   234 000017BF AC                  <2>  lodsb
   234 000017C0 EE                  <2>  out dx, al
   234 000017C1 AC                  <2>  lodsb
   234 000017C2 EE                  <2>  out dx, al
   234 000017C3 AC                  <2>  lodsb
   234 000017C4 EE                  <2>  out dx, al
   234 000017C5 AC                  <2>  lodsb
   234 000017C6 EE                  <2>  out dx, al
   234 000017C7 AC                  <2>  lodsb
   234 000017C8 EE                  <2>  out dx, al
   234 000017C9 AC                  <2>  lodsb
   234 000017CA EE                  <2>  out dx, al
   234 000017CB AC                  <2>  lodsb
   234 000017CC EE                  <2>  out dx, al
   235 000017CD E2EE                <1> 	loop	.WriteNextQword
   236 000017CF 1F                  <1> 	pop		ds
   237 000017D0 C3                  <1> 	ret
   238                              <1> %endif
   239                              <1> 
   240                              <1> %endif ; MODULE_8BIT_IDE
   241                              <1> 
   242                              <1> 
   243                              <1> ;--------------------------------------------------------------------
   244                              <1> ; IdePioBlock_WriteTo16bitDataPort		Normal 16-bit IDE
   245                              <1> ; IdePioBlock_WriteTo32bitDataPort		VLB/PCI 32-bit IDE
   246                              <1> ;	Parameters:
   247                              <1> ;		CX:	Block size in 512-byte sectors
   248                              <1> ;		DX:	IDE Data port address
   249                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
   250                              <1> ;	Returns:
   251                              <1> ;		Nothing
   252                              <1> ;	Corrupts registers:
   253                              <1> ;		AX, BX, CX, DX
   254                              <1> ;--------------------------------------------------------------------
   255                              <1> ALIGN JUMP_ALIGN
   256                              <1> IdePioBlock_WriteTo16bitDataPort:
   257                              <1> %ifdef USE_186
   258                              <1> 	xchg		cl, ch		; Sectors to WORDs
   259                              <1> 	es				; Source is ES segment
   260                              <1> 	rep
   261                              <1> 	db		6Fh		; OUTSW
   262                              <1> 	ret
   263                              <1> %else ; If 8088/8086
   264                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
   264                              <2> %ifdef USE_186
   264                              <2>  shl cx, 6
   264                              <2> %else
   264                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
   264                              <3> %ifdef USE_186
   264                              <3>  shl cx, 7
   264                              <3> %else
   264 000017D1 86CD                <3>  xchg cl, ch
   264 000017D3 D1E9                <3>  shr cx, 1
   264                              <3> %endif
   264 000017D5 D1E9                <2>  shr cx, 1
   264                              <2> %endif
   265 000017D7 1E                  <1> 	push		ds
   266 000017D8 06                  <1> 	push		es
   267 000017D9 1F                  <1> 	pop		ds
   268                              <1> ALIGN JUMP_ALIGN
   269                              <1> .WriteNextQword:
   270                              <1> 	%rep 4	; WORDs
   271                              <1> 		lodsw			; Load BYTE from [DS:SI]
   272                              <1> 		out	dx, ax		; Write BYTE
   273                              <1> 	%endrep
   273 000017DA AD                  <2>  lodsw
   273 000017DB EF                  <2>  out dx, ax
   273 000017DC AD                  <2>  lodsw
   273 000017DD EF                  <2>  out dx, ax
   273 000017DE AD                  <2>  lodsw
   273 000017DF EF                  <2>  out dx, ax
   273 000017E0 AD                  <2>  lodsw
   273 000017E1 EF                  <2>  out dx, ax
   274 000017E2 E2F6                <1> 	loop	.WriteNextQword
   275 000017E4 1F                  <1> 	pop		ds
   276 000017E5 C3                  <1> 	ret
   277                              <1> %endif	; if/else USE_186
   278                              <1> 
   279                              <1> ;--------------------------------------------------------------------
   280                              <1> ALIGN JUMP_ALIGN
   281                              <1> IdePioBlock_WriteTo32bitDataPort:
   282 000017E6 C1                  <1> 	db		0C1h		; SHL
   283 000017E7 E1                  <1> 	db		0E1h		; CX
   284 000017E8 07                  <1> 	db		7		; 7	(Sectors to DWORDs)
   285 000017E9 26                  <1> 	es				; Source is ES segment
   286 000017EA F3                  <1> 	rep
   287 000017EB 66                  <1> 	db		66h		; Override operand size to 32-bit
   288 000017EC 6F                  <1> 	db		6Fh		; OUTSW/OUTSD
   289 000017ED C3                  <1> 	ret
   290                              <1> 
   291                              <1> 
   244                                  	%include "IdeWait.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	IDE Device wait functions.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; IdeWait_IRQorDRQ
    25                              <1> ;	Parameters:
    26                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    27                              <1> ;		SS:BP:	Ptr to IDEPACK, PIOVARS or MEMPIOVARS
    28                              <1> ;	Returns:
    29                              <1> ;		AH:		INT 13h Error Code
    30                              <1> ;		CF:		Cleared if success, Set if error
    31                              <1> ;	Corrupts registers:
    32                              <1> ;		AL, BX, CX, DX
    33                              <1> ;--------------------------------------------------------------------
    34                              <1> IdeWait_IRQorDRQ:
    35 000017EE BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
    36                              <1> 
    37                              <1> %ifdef MODULE_IRQ
    38                              <1> 	test	BYTE [bp+IDEPACK.bDeviceControl], FLG_DEVCONTROL_nIEN
    39                              <1> 	jnz		SHORT IdeWait_PollStatusFlagInBLwithTimeoutInBH	; Interrupt disabled
    40                              <1> %endif
    41                              <1> 	; Fall to IdeWait_IRQorStatusFlagInBLwithTimeoutInBH
    42                              <1> 
    43                              <1> 
    44                              <1> ;--------------------------------------------------------------------
    45                              <1> ; IdeWait_IRQorStatusFlagInBLwithTimeoutInBH
    46                              <1> ;	Parameters:
    47                              <1> ;		BH:		Timeout ticks
    48                              <1> ;		BL:		IDE Status Register bit to wait
    49                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    50                              <1> ;	Returns:
    51                              <1> ;		AH:		INT 13h Error Code
    52                              <1> ;		CF:		Cleared if success, Set if error
    53                              <1> ;	Corrupts registers:
    54                              <1> ;		AL, BX, CX, DX
    55                              <1> ;--------------------------------------------------------------------
    56                              <1> IdeWait_IRQorStatusFlagInBLwithTimeoutInBH:
    57                              <1> %ifdef MODULE_IRQ
    58                              <1> 	call	IdeIrq_WaitForIRQ
    59                              <1> %endif
    60                              <1> 	; Always fall to IdeWait_PollStatusFlagInBLwithTimeoutInBH for error processing
    61                              <1> 
    62                              <1> 
    63                              <1> ;--------------------------------------------------------------------
    64                              <1> ; IdeWait_PollStatusFlagInBLwithTimeoutInBH
    65                              <1> ;	Parameters:
    66                              <1> ;		BH:		Timeout ticks
    67                              <1> ;		BL:		IDE Status Register bit to poll
    68                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    69                              <1> ;	Returns:
    70                              <1> ;		AH:		INT 13h Error Code
    71                              <1> ;		CF:		Cleared if success, Set if error
    72                              <1> ;	Corrupts registers:
    73                              <1> ;		AL, BX, CX, DX
    74                              <1> ;--------------------------------------------------------------------
    75                              <1> IdeWait_PollStatusFlagInBLwithTimeoutInBH:
    76 000017F1 88DC                <1> 	mov		ah, bl
    77 000017F3 88F9                <1> 	mov		cl, bh
    78 000017F5 E86DFB              <1> 	call	Timer_InitializeTimeoutWithTicksInCL
    79 000017F8 80E47F              <1> 	and		ah, ~FLG_STATUS_BSY
    80 000017FB 741C                <1> 	jz		SHORT PollBsyOnly
    81                              <1> 	; Fall to PollBsyAndFlgInAH
    82                              <1> 
    83                              <1> ;--------------------------------------------------------------------
    84                              <1> ; PollBsyAndFlgInAH
    85                              <1> ;	Parameters:
    86                              <1> ;		AH:		Status Register Flag to poll (until set) when device not busy
    87                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    88                              <1> ;	Returns:
    89                              <1> ;		AH:		BIOS Error code
    90                              <1> ;		CF:		Clear if wait completed successfully (no errors)
    91                              <1> ;				Set if any error
    92                              <1> ;	Corrupts registers:
    93                              <1> ;		AL, BX, CX, DX
    94                              <1> ;--------------------------------------------------------------------
    95                              <1> PollBsyAndFlgInAH:
    96 000017FD E87C00              <1> 	call	IdeIO_InputStatusRegisterToAL		; Discard contents of first read
    97                              <1> 
    98                              <1> .PollLoop:
    99 00001800 E87900              <1> 	call	IdeIO_InputStatusRegisterToAL
   100 00001803 A880                <1> 	test	al, FLG_STATUS_BSY					; Controller busy?
   101 00001805 7504                <1> 	jnz		SHORT .UpdateTimeout				;  If so, jump to timeout update
   102 00001807 84E0                <1> 	test	al, ah								; Test secondary flag
   103 00001809 751F                <1> 	jnz		SHORT IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
   104                              <1> .UpdateTimeout:
   105 0000180B E863FB              <1> 	call	Timer_SetCFifTimeout
   106 0000180E 73F0                <1> 	jnc		SHORT .PollLoop						; Loop if time left
   107 00001810 E81700              <1> 	call	IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
   108 00001813 7203                <1> 	jc		SHORT .ReturnErrorCodeInAH
   109 00001815 B480                <1> 	mov		ah, RET_HD_TIMEOUT					; Expected bit never got set
   110 00001817 F9                  <1> 	stc
   111                              <1> .ReturnErrorCodeInAH:
   112 00001818 C3                  <1> 	ret
   113                              <1> 
   114                              <1> 
   115                              <1> ;--------------------------------------------------------------------
   116                              <1> ; PollBsyOnly
   117                              <1> ;	Parameters:
   118                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   119                              <1> ;	Returns:
   120                              <1> ;		AH:		BIOS Error code
   121                              <1> ;		CF:		Clear if wait completed successfully (no errors)
   122                              <1> ;				Set if any error
   123                              <1> ;	Corrupts registers:
   124                              <1> ;		AL, BX, CX, DX
   125                              <1> ;--------------------------------------------------------------------
   126                              <1> PollBsyOnly:
   127 00001819 E86000              <1> 	call	IdeIO_InputStatusRegisterToAL		; Discard contents of first read
   128                              <1> 
   129                              <1> .PollLoop:
   130 0000181C E85D00              <1> 	call	IdeIO_InputStatusRegisterToAL
   131 0000181F A880                <1> 	test	al, FLG_STATUS_BSY					; Controller busy?
   132 00001821 7407                <1> 	jz		SHORT IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
   133 00001823 E84BFB              <1> 	call	Timer_SetCFifTimeout				; Update timeout counter
   134 00001826 73F4                <1> 	jnc		SHORT .PollLoop						; Loop if time left (sets CF on timeout)
   135 00001828 EB00                <1> 	jmp		SHORT IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
   245                                  	%include "IdeError.asm"			; Must be included after IdeWait.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	IDE Device error functions.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
    25                              <1> ;	Parameters:
    26                              <1> ;		AL:		IDE Status Register contents
    27                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    28                              <1> ;	Returns:
    29                              <1> ;		AH:		BIOS error code
    30                              <1> ;		CF:		Set if error
    31                              <1> ;				Cleared if no error
    32                              <1> ;	Corrupts registers:
    33                              <1> ;		AL, BX, DX
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> ALIGN JUMP_ALIGN
    36                              <1> IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL:
    37 0000182A 88C4                <1> 	mov		ah, al			; IDE Status Register to AH
    38                              <1> 	INPUT_TO_AL_FROM_IDE_REGISTER	ERROR_REGISTER_in
    38                              <2> %ifndef MODULE_8BIT_IDE
    38                              <2> 
    38                              <2>  %ifnidni %1, dx
    38                              <2>  mov dx, %1
    38                              <2>  %endif
    38                              <2>  add dx, [di+DPT.wBasePort]
    38                              <2>  in al, dx
    38                              <2> 
    38                              <2> %else
    38                              <2> 
    38                              <2>  %ifnidni %1, dl
    38 0000182C B201                <2>  mov dl, %1
    38                              <2>  %endif
    38 0000182E E84D00              <2>  call IdeIO_InputToALfromIdeRegisterInDL
    38                              <2> 
    38                              <2> %endif
    39 00001831 86C4                <1> 	xchg	al, ah			; Status Register now in AL, Error Register now in AH
    40                              <1> 	; Fall to GetBiosErrorCodeToAHfromStatusAndErrorRegistersInAX
    41                              <1> 
    42                              <1> 
    43                              <1> ;--------------------------------------------------------------------
    44                              <1> ; GetBiosErrorCodeToAHfromStatusAndErrorRegistersInAX
    45                              <1> ;	Parameters:
    46                              <1> ;		AL:		IDE Status Register contents
    47                              <1> ;		AH:		IDE Error Register contents
    48                              <1> ;	Returns:
    49                              <1> ;		AH:		BIOS INT 13h error code
    50                              <1> ;		CF:		Set if error
    51                              <1> ;				Cleared if no error
    52                              <1> ;	Corrupts registers:
    53                              <1> ;		BX
    54                              <1> ;--------------------------------------------------------------------
    55                              <1> ALIGN JUMP_ALIGN
    56                              <1> GetBiosErrorCodeToAHfromStatusAndErrorRegistersInAX:
    57 00001833 A880                <1> 	test	al, FLG_STATUS_BSY
    58 00001835 7404                <1> 	jz		SHORT .CheckErrorBitsFromStatusRegisterInAL
    59 00001837 B480                <1> 	mov		ah, RET_HD_TIMEOUT
    60 00001839 EB25                <1> 	jmp		SHORT .ReturnBiosErrorCodeInAH
    61                              <1> 
    62                              <1> ALIGN JUMP_ALIGN
    63                              <1> .CheckErrorBitsFromStatusRegisterInAL:
    64 0000183B A825                <1> 	test	al, FLG_STATUS_DF | FLG_STATUS_CORR | FLG_STATUS_ERR
    65 0000183D 7503                <1> 	jnz		SHORT .ProcessErrorFromStatusRegisterInAL
    66 0000183F 30E4                <1> 	xor		ah, ah					; No errors, zero AH and CF
    67 00001841 C3                  <1> 	ret
    68                              <1> 
    69                              <1> .ProcessErrorFromStatusRegisterInAL:
    70 00001842 A801                <1> 	test	al, FLG_STATUS_ERR		; Error specified in Error register?
    71 00001844 750A                <1> 	jnz		SHORT .ConvertBiosErrorToAHfromErrorRegisterInAH
    72 00001846 B411                <1> 	mov		ah, RET_HD_ECC			; Assume ECC corrected error
    73 00001848 A804                <1> 	test	al, FLG_STATUS_CORR		; ECC corrected error?
    74 0000184A 7514                <1> 	jnz		SHORT .ReturnBiosErrorCodeInAH
    75 0000184C B420                <1> 	mov		ah, RET_HD_CONTROLLER	; Must be Device Fault
    76 0000184E EB10                <1> 	jmp		SHORT .ReturnBiosErrorCodeInAH
    77                              <1> 
    78                              <1> .ConvertBiosErrorToAHfromErrorRegisterInAH:
    79 00001850 31DB                <1> 	xor		bx, bx					; Clear CF
    80                              <1> .ErrorBitLoop:
    81 00001852 D0DC                <1> 	rcr		ah, 1					; Set CF if error bit set
    82 00001854 7205                <1> 	jc		SHORT .LookupErrorCode
    83 00001856 43                  <1> 	inc		bx
    84 00001857 84E4                <1> 	test	ah, ah					; Clear CF
    85 00001859 75F7                <1> 	jnz		SHORT .ErrorBitLoop
    86                              <1> .LookupErrorCode:
    87 0000185B 2E8AA7[6218]        <1> 	mov		ah, [cs:bx+.rgbRetCodeLookup]
    88                              <1> .ReturnBiosErrorCodeInAH:
    89 00001860 F9                  <1> 	stc								; Set CF since error
    90 00001861 C3                  <1> 	ret
    91                              <1> 
    92                              <1> .rgbRetCodeLookup:
    93 00001862 02                  <1> 	db	RET_HD_ADDRMARK		; Bit0=AMNF, Address Mark Not Found
    94 00001863 40                  <1> 	db	RET_HD_SEEK_FAIL	; Bit1=TK0NF, Track 0 Not Found
    95 00001864 01                  <1> 	db	RET_HD_INVALID		; Bit2=ABRT, Aborted Command
    96 00001865 B0                  <1> 	db	RET_HD_NOTLOCKED	; Bit3=MCR, Media Change Requested
    97 00001866 04                  <1> 	db	RET_HD_NOT_FOUND	; Bit4=IDNF, ID Not Found
    98 00001867 B1                  <1> 	db	RET_HD_LOCKED		; Bit5=MC, Media Changed
    99 00001868 10                  <1> 	db	RET_HD_UNCORRECC	; Bit6=UNC, Uncorrectable Data Error
   100 00001869 0A                  <1> 	db	RET_HD_BADSECTOR	; Bit7=BBK, Bad Block Detected
   101 0000186A E0                  <1> 	db	RET_HD_STATUSERR	; When Error Register is zero
   246                                  	%include "IdeDPT.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Sets IDE Device specific parameters to DPT.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; IdeDPT_Finalize
    25                              <1> ;	Parameters:
    26                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    27                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    28                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
    29                              <1> ;	Returns:
    30                              <1> ;		CF:		Clear, IDE interface only supports hard disks
    31                              <1> ;	Corrupts registers:
    32                              <1> ;		AX, BX, CX, DX
    33                              <1> ;--------------------------------------------------------------------
    34                              <1> IdeDPT_Finalize:
    35                              <1> 
    36                              <1> %ifdef MODULE_FEATURE_SETS
    37                              <1> ;--------------------------------------------------------------------
    38                              <1> ; .DetectPowerManagementSupport
    39                              <1> ;	Parameters:
    40                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    41                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    42                              <1> ;	Returns:
    43                              <1> ;		Nothing
    44                              <1> ;	Corrupts registers:
    45                              <1> ;		Nothing
    46                              <1> ;--------------------------------------------------------------------
    47                              <1> .DetectPowerManagementSupport:
    48                              <1> 	test	BYTE [es:si+ATA6.wSetSup82], A6_wSetSup82_POWERMAN
    49                              <1> 	jz		SHORT .NoPowerManagementSupport
    50                              <1> 	or		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_POWER_MANAGEMENT_SUPPORTED
    51                              <1> .NoPowerManagementSupport:
    52                              <1> %endif ; MODULE_FEATURE_SETS
    53                              <1> 
    54                              <1> 
    55                              <1> ;--------------------------------------------------------------------
    56                              <1> ; .StoreDeviceType
    57                              <1> ;	Parameters:
    58                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    59                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
    60                              <1> ;	Returns:
    61                              <1> ;		Nothing
    62                              <1> ;	Corrupts registers:
    63                              <1> ;		AL
    64                              <1> ;--------------------------------------------------------------------
    65                              <1> .StoreDeviceType:
    66 0000186B E80600              <1> 	call	IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP
    67                              <1> 
    68                              <1> 
    69                              <1> ;--------------------------------------------------------------------
    70                              <1> ; .StoreBlockMode
    71                              <1> ;	Parameters:
    72                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    73                              <1> ;	Returns:
    74                              <1> ;		Nothing
    75                              <1> ;	Corrupts registers:
    76                              <1> ;		Nothing
    77                              <1> ;--------------------------------------------------------------------
    78                              <1> .StoreBlockMode:
    79 0000186E C6450D01            <1> 	mov		BYTE [di+DPT_ATA.bBlockSize], 1
    80                              <1> 
    81                              <1> 
    82                              <1> %ifdef MODULE_ADVANCED_ATA
    83                              <1> ;--------------------------------------------------------------------
    84                              <1> ; .StorePioModeAndTimings
    85                              <1> ;	Parameters:
    86                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    87                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
    88                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
    89                              <1> ;	Returns:
    90                              <1> ;		Nothing
    91                              <1> ;	Corrupts registers:
    92                              <1> ;		AX, BX, CX
    93                              <1> ;--------------------------------------------------------------------
    94                              <1> .StorePioMode:
    95                              <1> 	call	AtaID_GetMaxPioModeToAXandMinCycleTimeToCX
    96                              <1> 	mov		[di+DPT_ADVANCED_ATA.wMinPioCycleTime], cx
    97                              <1> 	mov		[di+DPT_ADVANCED_ATA.bPioMode], al
    98                              <1> 	or		[di+DPT.bFlagsHigh], ah
    99                              <1> 
   100                              <1> 
   101                              <1> ;--------------------------------------------------------------------
   102                              <1> ; .DetectAdvancedIdeController
   103                              <1> ;	Parameters:
   104                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   105                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
   106                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
   107                              <1> ;	Returns:
   108                              <1> ;		Nothing
   109                              <1> ;	Corrupts registers:
   110                              <1> ;		AX, BX, CX, DX
   111                              <1> ;--------------------------------------------------------------------
   112                              <1> .DetectAdvancedIdeController:
   113                              <1> 	mov		bx, [di+DPT.wBasePort]
   114                              <1> 	call	AdvAtaInit_DetectControllerForIdeBaseInBX
   115                              <1> 	mov		[di+DPT_ADVANCED_ATA.wControllerID], ax	; Store zero if none detected
   116                              <1> 	mov		[di+DPT_ADVANCED_ATA.wControllerBasePort], dx
   117                              <1> 	jnc		SHORT .NoAdvancedControllerDetected
   118                              <1> 
   119                              <1> 	; Use highest common PIO mode from controller and drive.
   120                              <1> 	; Many VLB controllers support PIO modes up to 2.
   121                              <1> 	call	AdvAtaInit_GetControllerMaxPioModeToAL
   122                              <1> 	jnc		SHORT .ChangeTo32bitDevice
   123                              <1> 	and		BYTE [di+DPT.bFlagsHigh], ~FLGH_DPT_IORDY	; No IORDY supported if need to limit
   124                              <1> 	MIN_U	[di+DPT_ADVANCED_ATA.bPioMode], al
   125                              <1> 
   126                              <1> 	; We have detected 32-bit controller so change Device Type since
   127                              <1> 	; it might have been set to 16-bit on IDEVARS
   128                              <1> .ChangeTo32bitDevice:
   129                              <1> 	mov		BYTE [di+DPT_ATA.bDevice], DEVICE_32BIT_ATA
   130                              <1> .NoAdvancedControllerDetected:
   131                              <1> %endif	; MODULE_ADVANCED_ATA
   132                              <1> 
   133                              <1> 
   134                              <1> ; End DPT
   135 00001872 F8                  <1> 	clc
   136 00001873 C3                  <1> 	ret
   137                              <1> 
   138                              <1> 
   139                              <1> ;--------------------------------------------------------------------
   140                              <1> ; IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP
   141                              <1> ;	Parameters:
   142                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   143                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
   144                              <1> ;	Returns:
   145                              <1> ;		Nothing
   146                              <1> ;	Corrupts registers:
   147                              <1> ;		AL
   148                              <1> ;--------------------------------------------------------------------
   149                              <1> IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP:
   150 00001874 2E8A4604            <1> 	mov		al, [cs:bp+IDEVARS.bDevice]
   151 00001878 88450C              <1> 	mov		[di+DPT_ATA.bDevice], al
   152 0000187B C3                  <1> 	ret
   247                                  	%include "IdeIO.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	IDE Register I/O functions when supporting 8-bit
     3                              <1> ;					devices that need address translations.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ;
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    22                              <1> 
    23                              <1> ; Section containing code
    24                              <1> SECTION .text
    25                              <1> 
    26                              <1> ;--------------------------------------------------------------------
    27                              <1> ; IdeIO_InputStatusRegisterToAL
    28                              <1> ;	Parameters:
    29                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    30                              <1> ;	Returns:
    31                              <1> ;		AL:		IDE Status Register contents
    32                              <1> ;	Corrupts registers:
    33                              <1> ;		BX, DX
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> ALIGN JUMP_ALIGN
    36                              <1> IdeIO_InputStatusRegisterToAL:
    37                              <1> %ifndef MODULE_8BIT_IDE
    38                              <1> 	INPUT_TO_AL_FROM_IDE_REGISTER STATUS_REGISTER_in
    39                              <1> 	ret
    40                              <1> 
    41                              <1> %else
    42 0000187C B207                <1> 	mov		dl, STATUS_REGISTER_in
    43                              <1> 	; Fall to IdeIO_InputToALfromIdeRegisterInDL
    44                              <1> 
    45                              <1> ;--------------------------------------------------------------------
    46                              <1> ; IdeIO_InputToALfromIdeRegisterInDL
    47                              <1> ;	Parameters:
    48                              <1> ;		DL:		IDE Register
    49                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    50                              <1> ;	Returns:
    51                              <1> ;		AL:		Inputted byte
    52                              <1> ;	Corrupts registers:
    53                              <1> ;		BX, DX
    54                              <1> ;--------------------------------------------------------------------
    55                              <1> IdeIO_InputToALfromIdeRegisterInDL:
    56 0000187E 30F6                <1> 	xor		dh, dh	; IDE Register index now in DX
    57 00001880 89D3                <1> 	mov		bx, dx	; and BX
    58 00001882 8A450C              <1> 	mov		al, [di+DPT_ATA.bDevice]
    59 00001885 3C08                <1> 	cmp		al, DEVICE_8BIT_XTIDE_REV2
    60 00001887 7218                <1> 	jb		SHORT .InputToALfromRegisterInDX	; Standard IDE controllers and XTIDE rev 1
    61                              <1> 
    62                              <1> %ifdef MODULE_8BIT_IDE
    63 00001889 740E                <1> 	je		SHORT .ReverseA0andA3fromRegisterIndexInDX
    64                              <1> 
    65 0000188B 3C10                <1> 	cmp		al, DEVICE_8BIT_JRIDE_ISA
    66 0000188D 7510                <1> 	jne		SHORT .ShlRegisterIndexInDX			; All XT-CF modes
    67                              <1> 	; Fall to .InputToALfromMemoryMappedRegisterInDX
    68                              <1> 
    69                              <1> .InputToALfromMemoryMappedRegisterInDX:
    70 0000188F 1E                  <1> 	push	ds
    71 00001890 8E5D04              <1> 	mov		ds, [di+DPT.wBasePort]	; Segment for JR-IDE/ISA
    72 00001893 8A87003E            <1> 	mov		al, [bx+JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET]
    73 00001897 1F                  <1> 	pop		ds
    74 00001898 C3                  <1> 	ret
    75                              <1> %endif
    76                              <1> 
    77                              <1> .ReverseA0andA3fromRegisterIndexInDX:
    78 00001899 2E8A97[0219]        <1> 	mov		dl, [cs:bx+g_rgbSwapA0andA3fromIdeRegisterIndex]
    79                              <1> 	SKIP2B	bx	; Skip shl dx, 1
    79                              <2>  %ifidni %1, f
    79                              <2>  db 03Dh
    79                              <2> 
    79                              <2>  %elifidni %1, ax
    79                              <2>  db 0B8h
    79                              <2>  %elifidni %1, cx
    79                              <2>  db 0B9h
    79                              <2>  %elifidni %1, dx
    79                              <2>  db 0BAh
    79                              <2>  %elifidni %1, bx
    79 0000189E BB                  <2>  db 0BBh
    79                              <2>  %elifidni %1, sp
    79                              <2>  db 0BCh
    79                              <2>  %elifidni %1, bp
    79                              <2>  db 0BDh
    79                              <2>  %elifidni %1, si
    79                              <2>  db 0BEh
    79                              <2>  %elifidni %1, di
    79                              <2>  db 0BFh
    79                              <2>  %else
    79                              <2>  %error "Invalid parameter passed to SKIP2B"
    79                              <2>  %endif
    80                              <1> 
    81                              <1> .ShlRegisterIndexInDX:
    82                              <1> 	eSHL_IM	dx, 1
    82                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    82                              <2> %ifdef USE_386
    82                              <2>  %if %2 = 1
    82                              <2>  add %1, %1
    82                              <2>  %else
    82                              <2>  eSHIFT_IM %1, %2, shl
    82                              <2>  %endif
    82                              <2> %else
    82                              <2>  eSHIFT_IM %1, %2, shl
    82                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    82                              <3> %ifndef USE_186
    82                              <3>  %ifidni %1, cl
    82                              <3>  times %2 %3 %1, 1
    82                              <3>  %elifidni %1, ch
    82                              <3>  times %2 %3 %1, 1
    82                              <3>  %elifidni %1, cx
    82                              <3>  times %2 %3 %1, 1
    82                              <3>  %else
    82                              <3>  %if %2 > 3
    82                              <3>  push cx
    82                              <3>  mov cl, %2
    82                              <3>  %3 %1, cl
    82                              <3>  pop cx
    82                              <3>  %else
    82 0000189F D1E2                <3>  times %2 %3 %1, 1
    82                              <3>  %endif
    82                              <3>  %endif
    82                              <3> 
    82                              <3> %else
    82                              <3>  %3 %1, %2
    82                              <3> %endif
    82                              <3> %endif
    82                              <2> %endif
    82                              <2> %endif
    83                              <1> 	; Fall to .InputToALfromRegisterInDX
    84                              <1> 
    85                              <1> .InputToALfromRegisterInDX:
    86 000018A1 035504              <1> 	add		dx, [di+DPT.wBasePort]
    87 000018A4 EC                  <1> 	in		al, dx
    88 000018A5 C3                  <1> 	ret
    89                              <1> 
    90                              <1> 
    91                              <1> ;--------------------------------------------------------------------
    92                              <1> ; IdeIO_OutputALtoIdeControlBlockRegisterInDL
    93                              <1> ;	Parameters:
    94                              <1> ;		AL:		Byte to output
    95                              <1> ;		DL:		IDE Control Block Register
    96                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    97                              <1> ;	Returns:
    98                              <1> ;		Nothing
    99                              <1> ;	Corrupts registers:
   100                              <1> ;		BX, DX
   101                              <1> ;--------------------------------------------------------------------
   102                              <1> IdeIO_OutputALtoIdeControlBlockRegisterInDL:
   103 000018A6 30F6                <1> 	xor		dh, dh	; IDE Register index now in DX
   104                              <1> 
   105 000018A8 8A5D0C              <1> 	mov		bl, [di+DPT_ATA.bDevice]
   106 000018AB 80FB08              <1> 	cmp		bl, DEVICE_8BIT_XTIDE_REV2
   107 000018AE 721C                <1> 	jb		SHORT .OutputALtoControlBlockRegisterInDX	; Standard IDE controllers and XTIDE rev 1
   108                              <1> 
   109                              <1> %ifdef MODULE_8BIT_IDE
   110 000018B0 740A                <1> 	je		SHORT .ReverseA0andA3fromRegisterIndexInDX
   111                              <1> 
   112 000018B2 80FB10              <1> 	cmp		bl, DEVICE_8BIT_JRIDE_ISA
   113 000018B5 750E                <1> 	jne		SHORT .ShlRegisterIndexInDX		; All XT-CF modes
   114                              <1> 	; Fall to .OutputALtoMemoryMappedRegisterInDX
   115                              <1> 
   116                              <1> .OutputALtoMemoryMappedRegisterInDX:
   117 000018B7 BB083E              <1> 	mov		bx, JRIDE_CONTROL_BLOCK_REGISTER_WINDOW_OFFSET
   118 000018BA EB2D                <1> 	jmp 	SHORT IdeIO_OutputALtoIdeRegisterInDL.OutputALtoMemoryMappedRegisterInDXwithWindowOffsetInBX
   119                              <1> %endif
   120                              <1> 
   121                              <1> .ReverseA0andA3fromRegisterIndexInDX:
   122                              <1> 	; We cannot use lookup table since A3 will be always set because
   123                              <1> 	; Control Block Registers start from Command Block + 8h. We can do
   124                              <1> 	; a small trick since we only access Device Control Register at
   125                              <1> 	; offset 6h: Always clear A3 and set A0.
   126 000018BC 2E035702            <1> 	add		dx, [cs:bx+IDEVARS.wControlBlockPort]
   127 000018C0 80F209              <1> 	xor		dl, 1001b						; Clear A3, Set A0
   128 000018C3 EB3B                <1> 	jmp		SHORT OutputALtoPortInDX
   129                              <1> 
   130                              <1> .ShlRegisterIndexInDX:
   131                              <1> 	eSHL_IM	dx, 1
   131                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   131                              <2> %ifdef USE_386
   131                              <2>  %if %2 = 1
   131                              <2>  add %1, %1
   131                              <2>  %else
   131                              <2>  eSHIFT_IM %1, %2, shl
   131                              <2>  %endif
   131                              <2> %else
   131                              <2>  eSHIFT_IM %1, %2, shl
   131                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   131                              <3> %ifndef USE_186
   131                              <3>  %ifidni %1, cl
   131                              <3>  times %2 %3 %1, 1
   131                              <3>  %elifidni %1, ch
   131                              <3>  times %2 %3 %1, 1
   131                              <3>  %elifidni %1, cx
   131                              <3>  times %2 %3 %1, 1
   131                              <3>  %else
   131                              <3>  %if %2 > 3
   131                              <3>  push cx
   131                              <3>  mov cl, %2
   131                              <3>  %3 %1, cl
   131                              <3>  pop cx
   131                              <3>  %else
   131 000018C5 D1E2                <3>  times %2 %3 %1, 1
   131                              <3>  %endif
   131                              <3>  %endif
   131                              <3> 
   131                              <3> %else
   131                              <3>  %3 %1, %2
   131                              <3> %endif
   131                              <3> %endif
   131                              <2> %endif
   131                              <2> %endif
   132 000018C7 83C210              <1> 	add		dx, BYTE XTCF_CONTROL_BLOCK_OFFSET
   133 000018CA EB31                <1> 	jmp		SHORT OutputALtoRegisterInDX
   134                              <1> 
   135                              <1> .OutputALtoControlBlockRegisterInDX:
   136 000018CC E837F4              <1> 	call	AccessDPT_GetIdevarsToCSBX
   137 000018CF 2E035702            <1> 	add		dx, [cs:bx+IDEVARS.wControlBlockPort]
   138 000018D3 EB2B                <1> 	jmp		SHORT OutputALtoPortInDX
   139                              <1> 
   140                              <1> 
   141                              <1> ;--------------------------------------------------------------------
   142                              <1> ; IdeIO_OutputALtoIdeRegisterInDL
   143                              <1> ;	Parameters:
   144                              <1> ;		AL:		Byte to output
   145                              <1> ;		DL:		IDE Command Block Register
   146                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   147                              <1> ;	Returns:
   148                              <1> ;		Nothing
   149                              <1> ;	Corrupts registers:
   150                              <1> ;		BX, DX
   151                              <1> ;--------------------------------------------------------------------
   152                              <1> ALIGN JUMP_ALIGN
   153                              <1> IdeIO_OutputALtoIdeRegisterInDL:
   154 000018D5 30F6                <1> 	xor		dh, dh	; IDE Register index now in DX
   155                              <1> 
   156 000018D7 8A5D0C              <1> 	mov		bl, [di+DPT_ATA.bDevice]
   157 000018DA 80FB08              <1> 	cmp		bl, DEVICE_8BIT_XTIDE_REV2
   158 000018DD 721E                <1> 	jb		SHORT OutputALtoRegisterInDX	; Standard IDE controllers and XTIDE rev 1
   159                              <1> 
   160                              <1> %ifdef MODULE_8BIT_IDE
   161 000018DF 7412                <1> 	je		SHORT .ReverseA0andA3fromRegisterIndexInDX
   162                              <1> 
   163 000018E1 80FB10              <1> 	cmp		bl, DEVICE_8BIT_JRIDE_ISA
   164 000018E4 7515                <1> 	jne		SHORT .ShlRegisterIndexInDX		; All XT-CF modes
   165                              <1> 	; Fall to .OutputALtoMemoryMappedRegisterInDX
   166                              <1> 
   167                              <1> .OutputALtoMemoryMappedRegisterInDX:
   168 000018E6 BB003E              <1> 	mov		bx, JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET
   169                              <1> .OutputALtoMemoryMappedRegisterInDXwithWindowOffsetInBX:
   170 000018E9 01D3                <1> 	add		bx, dx
   171 000018EB 1E                  <1> 	push	ds
   172 000018EC 8E5D04              <1> 	mov		ds, [di+DPT.wBasePort]	; Segment for JR-IDE/ISA
   173 000018EF 8807                <1> 	mov		[bx], al
   174 000018F1 1F                  <1> 	pop		ds
   175 000018F2 C3                  <1> 	ret
   176                              <1> %endif
   177                              <1> 
   178                              <1> .ReverseA0andA3fromRegisterIndexInDX:
   179 000018F3 89D3                <1> 	mov		bx, dx
   180 000018F5 2E8A97[0219]        <1> 	mov		dl, [cs:bx+g_rgbSwapA0andA3fromIdeRegisterIndex]
   181                              <1> 	SKIP2B	bx	; Skip shl dx, 1
   181                              <2>  %ifidni %1, f
   181                              <2>  db 03Dh
   181                              <2> 
   181                              <2>  %elifidni %1, ax
   181                              <2>  db 0B8h
   181                              <2>  %elifidni %1, cx
   181                              <2>  db 0B9h
   181                              <2>  %elifidni %1, dx
   181                              <2>  db 0BAh
   181                              <2>  %elifidni %1, bx
   181 000018FA BB                  <2>  db 0BBh
   181                              <2>  %elifidni %1, sp
   181                              <2>  db 0BCh
   181                              <2>  %elifidni %1, bp
   181                              <2>  db 0BDh
   181                              <2>  %elifidni %1, si
   181                              <2>  db 0BEh
   181                              <2>  %elifidni %1, di
   181                              <2>  db 0BFh
   181                              <2>  %else
   181                              <2>  %error "Invalid parameter passed to SKIP2B"
   181                              <2>  %endif
   182                              <1> 
   183                              <1> .ShlRegisterIndexInDX:
   184                              <1> 	eSHL_IM	dx, 1
   184                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   184                              <2> %ifdef USE_386
   184                              <2>  %if %2 = 1
   184                              <2>  add %1, %1
   184                              <2>  %else
   184                              <2>  eSHIFT_IM %1, %2, shl
   184                              <2>  %endif
   184                              <2> %else
   184                              <2>  eSHIFT_IM %1, %2, shl
   184                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   184                              <3> %ifndef USE_186
   184                              <3>  %ifidni %1, cl
   184                              <3>  times %2 %3 %1, 1
   184                              <3>  %elifidni %1, ch
   184                              <3>  times %2 %3 %1, 1
   184                              <3>  %elifidni %1, cx
   184                              <3>  times %2 %3 %1, 1
   184                              <3>  %else
   184                              <3>  %if %2 > 3
   184                              <3>  push cx
   184                              <3>  mov cl, %2
   184                              <3>  %3 %1, cl
   184                              <3>  pop cx
   184                              <3>  %else
   184 000018FB D1E2                <3>  times %2 %3 %1, 1
   184                              <3>  %endif
   184                              <3>  %endif
   184                              <3> 
   184                              <3> %else
   184                              <3>  %3 %1, %2
   184                              <3> %endif
   184                              <3> %endif
   184                              <2> %endif
   184                              <2> %endif
   185                              <1> 	; Fall to OutputALtoRegisterInDX
   186                              <1> 
   187                              <1> ALIGN JUMP_ALIGN
   188                              <1> OutputALtoRegisterInDX:
   189 000018FD 035504              <1> 	add		dx, [di+DPT.wBasePort]
   190                              <1> OutputALtoPortInDX:
   191 00001900 EE                  <1> 	out		dx, al
   192 00001901 C3                  <1> 	ret
   193                              <1> 
   194                              <1> 
   195                              <1> 
   196                              <1> ; A0 <-> A3 lookup table
   197                              <1> g_rgbSwapA0andA3fromIdeRegisterIndex:
   198 00001902 00                  <1> 	db	0000b	; <-> 0000b, 0
   199 00001903 08                  <1> 	db	1000b	; <-> 0001b, 1
   200 00001904 02                  <1> 	db	0010b	; <-> 0010b, 2
   201 00001905 0A                  <1> 	db	1010b	; <-> 0011b, 3
   202 00001906 04                  <1> 	db	0100b	; <-> 0100b, 4
   203 00001907 0C                  <1> 	db	1100b	; <-> 0101b, 5
   204 00001908 06                  <1> 	db	0110b	; <-> 0110b, 6
   205 00001909 0E                  <1> 	db	1110b	; <-> 0111b, 7
   206                              <1> 
   207                              <1> %endif ; MODULE_8BIT_IDE
   248                                  %ifdef MODULE_IRQ
   249                                  	%include "IdeIrq.asm"
   250                                  %endif
   251                                  
   252                                  	; Serial Device support
   253                                  %ifdef MODULE_SERIAL				; Serial Port Device support
   254                                  	%include "SerialCommand.asm"
   255                                  	%include "SerialDPT.asm"
   256                                  %endif
   257                                  
   258                                  	; INT 13h Hard Disk BIOS functions
   259                                  	%include "Int13h.asm"			; For Int 13h, Disk functions
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h BIOS functions (Floppy and Hard disk).
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h software interrupt handler.
    25                              <1> ; This handler changes stack to top of stolen conventional memory
    26                              <1> ; and then calls the actual INT 13h handler (Int13h_DiskFunctionsHandler).
    27                              <1> ;
    28                              <1> ; Int13h_DiskFunctionsHandlerWithStackChange
    29                              <1> ;	Parameters:
    30                              <1> ;		AH:		Bios function
    31                              <1> ;		DL:		Drive number
    32                              <1> ;		Other:	Depends on function
    33                              <1> ;	Returns:
    34                              <1> ;		Depends on function
    35                              <1> ;--------------------------------------------------------------------
    36                              <1> %ifdef RELOCATE_INT13H_STACK
    37                              <1> ALIGN JUMP_ALIGN
    38                              <1> Int13h_DiskFunctionsHandlerWithStackChange:
    39                              <1> 	sti			; Enable interrupts
    40                              <1> 	; TODO: Maybe we need to save Flags (DF) as well?
    41                              <1> 	push	ds	; Save DS:DI on the original stack
    42                              <1> 	push	di
    43                              <1> 	call	RamVars_GetSegmentToDS
    44                              <1> 
    45                              <1> 	; Store entry registers to RAMVARS
    46                              <1> %ifdef USE_386
    47                              <1> 	pop		DWORD [RAMVARS.dwStackChangeDSDI]
    48                              <1> %else
    49                              <1> 	pop		WORD [RAMVARS.wStackChangeDI]	; Pop DS:DI to the top of what
    50                              <1> 	pop		WORD [RAMVARS.wStackChangeDS]	; is to become the new stack
    51                              <1> %endif
    52                              <1> 	mov		[RAMVARS.fpInt13hEntryStack], sp
    53                              <1> 	mov		[RAMVARS.fpInt13hEntryStack+2], ss
    54                              <1> 
    55                              <1> 	; Load new stack and restore DS and DI
    56                              <1> 	mov		di, ds		; We can save 2 bytes by using PUSH/POP but it's slower
    57                              <1> 	mov		ss, di		; No need to wrap with CLI/STI since this is for AT only (286+)
    58                              <1> 	mov		sp, RAMVARS.rgbTopOfStack-4
    59                              <1> 	pop		di			; DI before stack change
    60                              <1> 	pop		ds			; DS before stack change
    61                              <1> 
    62                              <1> 	; Call INT 13h
    63                              <1> 	pushf
    64                              <1> 	push	cs
    65                              <1> 	call	Int13h_DiskFunctionsHandler
    66                              <1> 
    67                              <1> 	; Restore stack (we must not corrupt FLAGS!)
    68                              <1> %ifdef USE_386
    69                              <1> 	lss		sp, [ss:RAMVARS.fpInt13hEntryStack]
    70                              <1> %else
    71                              <1> 	cli
    72                              <1> 	mov		sp, [ss:RAMVARS.fpInt13hEntryStack]
    73                              <1> 	mov		ss, [ss:RAMVARS.fpInt13hEntryStack+2]
    74                              <1> 	sti
    75                              <1> %endif
    76                              <1> 	retf	2			; Skip FLAGS from stack
    77                              <1> %endif ; RELOCATE_INT13H_STACK
    78                              <1> 
    79                              <1> 
    80                              <1> ;--------------------------------------------------------------------
    81                              <1> ; Int 13h software interrupt handler.
    82                              <1> ; Jumps to specific function defined in AH.
    83                              <1> ;
    84                              <1> ; Note to developers: Do not make recursive INT 13h calls!
    85                              <1> ;
    86                              <1> ; Int13h_DiskFunctionsHandler
    87                              <1> ;	Parameters:
    88                              <1> ;		AH:		Bios function
    89                              <1> ;		DL:		Drive number
    90                              <1> ;		Other:	Depends on function
    91                              <1> ;	Returns:
    92                              <1> ;		Depends on function
    93                              <1> ;--------------------------------------------------------------------
    94                              <1> ALIGN JUMP_ALIGN
    95                              <1> Int13h_DiskFunctionsHandler:
    96                              <1> %ifndef RELOCATE_INT13H_STACK
    97 0000190A FB                  <1> 	sti									; Enable interrupts
    98                              <1> %endif
    99 0000190B FC                  <1> 	cld									; String instructions to increment pointers
   100                              <1> 	CREATE_FRAME_INTPACK_TO_SSBP	SIZE_OF_IDEPACK_WITHOUT_INTPACK
   100                              <2>  ePUSHA
   100                              <3> %ifndef USE_186
   100 0000190C 50                  <3>  push ax
   100 0000190D 51                  <3>  push cx
   100 0000190E 52                  <3>  push dx
   100 0000190F 53                  <3>  push bx
   100 00001910 54                  <3>  push sp
   100 00001911 55                  <3>  push bp
   100 00001912 56                  <3>  push si
   100 00001913 57                  <3>  push di
   100                              <3> 
   100                              <3> %else
   100                              <3>  pusha
   100                              <3> %endif
   100 00001914 1E                  <2>  push ds
   100 00001915 06                  <2>  push es
   100                              <2> %ifdef USE_386
   100                              <2> 
   100                              <2> 
   100                              <2> %endif
   100 00001916 83EC09              <2>  sub sp, BYTE %1
   100 00001919 89E5                <2>  mov bp, sp
   101 0000191B E825F2              <1> 	call	RamVars_GetSegmentToDS
   102                              <1> 
   103                              <1> %ifdef MODULE_DRIVEXLATE
   104 0000191E E806F7              <1> 	call	DriveXlate_ToOrBack
   105 00001921 88160B00            <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bXlatedDrv], dl
   106                              <1> %endif
   107 00001925 E83EF3              <1> 	call	FindDPT_ForDriveNumberInDL	; DS:DI points to our DPT, or NULL if not our drive
   108 00001928 7210                <1> 	jc		SHORT .NotOurDrive			; DPT not found so this is not one of our drives
   109                              <1> 
   110                              <1> .OurFunction:
   111                              <1> 	; Jump to correct BIOS function
   112                              <1> 	eMOVZX	bx, ah
   112                              <2> %ifndef USE_386
   112                              <2>  %ifidni %1, ax
   112                              <2>  mov al, %2
   112                              <2>  xor ah, ah
   112                              <2>  %elifidni %1, bx
   112 0000192A 88E3                <2>  mov bl, %2
   112 0000192C 30FF                <2>  xor bh, bh
   112                              <2>  %elifidni %1, cx
   112                              <2>  mov cl, %2
   112                              <2>  xor ch, ch
   112                              <2>  %elifidni %1, dx
   112                              <2>  mov dl, %2
   112                              <2>  xor dh, dh
   112                              <2>  %else
   112                              <2>  push ax
   112                              <2>  mov al, %2
   112                              <2>  xor ah, ah
   112                              <2>  xchg ax, %1
   112                              <2>  pop ax
   112                              <2>  %endif
   112                              <2> 
   112                              <2> %else
   112                              <2>  movzx %1, %2
   112                              <2> %endif
   113                              <1> 	eSHL_IM	bx, 1
   113                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   113                              <2> %ifdef USE_386
   113                              <2>  %if %2 = 1
   113                              <2>  add %1, %1
   113                              <2>  %else
   113                              <2>  eSHIFT_IM %1, %2, shl
   113                              <2>  %endif
   113                              <2> %else
   113                              <2>  eSHIFT_IM %1, %2, shl
   113                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   113                              <3> %ifndef USE_186
   113                              <3>  %ifidni %1, cl
   113                              <3>  times %2 %3 %1, 1
   113                              <3>  %elifidni %1, ch
   113                              <3>  times %2 %3 %1, 1
   113                              <3>  %elifidni %1, cx
   113                              <3>  times %2 %3 %1, 1
   113                              <3>  %else
   113                              <3>  %if %2 > 3
   113                              <3>  push cx
   113                              <3>  mov cl, %2
   113                              <3>  %3 %1, cl
   113                              <3>  pop cx
   113                              <3>  %else
   113 0000192E D1E3                <3>  times %2 %3 %1, 1
   113                              <3>  %endif
   113                              <3>  %endif
   113                              <3> 
   113                              <3> %else
   113                              <3>  %3 %1, %2
   113                              <3> %endif
   113                              <3> %endif
   113                              <2> %endif
   113                              <2> %endif
   114 00001930 80FC25              <1> 	cmp		ah, 25h						; Possible EBIOS function?
   115                              <1> %ifndef MODULE_EBIOS
   116 00001933 7712                <1> 	ja		SHORT UnsupportedFunction
   117 00001935 2EFFA7[E919]        <1> 	jmp		[cs:bx+g_rgw13hFuncJump]	; Jump to BIOS function
   118                              <1> 
   119                              <1> %else ; If using MODULE_EBIOS
   120                              <1> 	ja		SHORT .JumpToEbiosFunction
   121                              <1> 	jmp		[cs:bx+g_rgw13hFuncJump]	; Jump to BIOS function
   122                              <1> 
   123                              <1> ALIGN JUMP_ALIGN
   124                              <1> .JumpToEbiosFunction:
   125                              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_LBA_AND_EBIOS_SUPPORTED
   126                              <1> 	jz		SHORT UnsupportedFunction	; No eINT 13h for CHS drives
   127                              <1> 	sub		bl, 41h<<1					; BX = Offset to eINT 13h jump table
   128                              <1> 	jb		SHORT UnsupportedFunction
   129                              <1> 	cmp		ah, 48h
   130                              <1> 	ja		SHORT UnsupportedFunction
   131                              <1> 	jmp		[cs:bx+g_rgwEbiosFunctionJumpTable]
   132                              <1> %endif	; MODULE_EBIOS
   133                              <1> 
   134                              <1> 
   135                              <1> ALIGN JUMP_ALIGN
   136                              <1> .NotOurDrive:
   137 0000193A 84E4                <1> 	test	ah, ah
   138 0000193C 74EC                <1> 	jz		SHORT .OurFunction			; We handle all function 0h requests (resets)
   139                              <1> 
   140                              <1> %ifndef MODULE_SERIAL_FLOPPY
   141                              <1> ; Without floppy support, we handle only hard disk traffic for function 08h.
   142 0000193E 84D2                <1> 	test	dl, dl
   143 00001940 7905                <1> 	jns		SHORT Int13h_DirectCallToAnotherBios
   144                              <1> %endif
   145                              <1> ; With floppy support, we handle all traffic for function 08h, as we need to wrap both hard disk and floppy drive counts.
   146 00001942 80FC08              <1> 	cmp		ah, 8
   147 00001945 74E3                <1> 	je		SHORT .OurFunction
   148                              <1> 	; Fall to Int13h_DirectCallToAnotherBios
   149                              <1> 
   150                              <1> 
   151                              <1> ;--------------------------------------------------------------------
   152                              <1> ; UnsupportedFunction
   153                              <1> ; Int13h_DirectCallToAnotherBios
   154                              <1> ;	Parameters:
   155                              <1> ;		DL:		Translated drive number
   156                              <1> ;		DS:		RAMVARS segment
   157                              <1> ;		SS:BP:	Ptr to IDEPACK
   158                              <1> ;		BX, DI:	Corrupted on Int13h_DiskFunctionsHandler
   159                              <1> ;		Other:	Function specific INT 13h parameters
   160                              <1> ;	Returns:
   161                              <1> ;		Depends on function
   162                              <1> ;	Corrupts registers:
   163                              <1> ;		Flags
   164                              <1> ;--------------------------------------------------------------------
   165                              <1> ALIGN JUMP_ALIGN
   166                              <1> UnsupportedFunction:
   167                              <1> Int13h_DirectCallToAnotherBios:
   168 00001947 E86000              <1> 	call	ExchangeCurrentInt13hHandlerWithOldInt13hHandler
   169 0000194A 8B5E15              <1> 	mov		bx, [bp+IDEPACK.intpack+INTPACK.bx]
   170 0000194D 8B7E0D              <1> 	mov		di, [bp+IDEPACK.intpack+INTPACK.di]
   171 00001950 8E5E0B              <1> 	mov		ds, [bp+IDEPACK.intpack+INTPACK.ds]
   172 00001953 FF7621              <1> 	push	WORD [bp+IDEPACK.intpack+INTPACK.flags]
   173 00001956 9D                  <1> 	popf
   174 00001957 55                  <1> 	push	bp
   175 00001958 8B6E11              <1> 	mov		bp, [bp+IDEPACK.intpack+INTPACK.bp]
   176 0000195B CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h	; Can safely do as much recursion as it wants
   177                              <1> 
   178                              <1> 	; Store returned values to INTPACK
   179 0000195D 5D                  <1> 	pop		bp	; Standard INT 13h functions never uses BP as return register
   180                              <1> %ifdef USE_386
   181                              <1> ;	mov		[bp+IDEPACK.intpack+INTPACK.gs], gs
   182                              <1> ;	mov		[bp+IDEPACK.intpack+INTPACK.fs], fs
   183                              <1> %endif
   184 0000195E 8C4609              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.es], es
   185 00001961 8C5E0B              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ds], ds
   186 00001964 897E0D              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.di], di
   187 00001967 89760F              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.si], si
   188 0000196A 895E15              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.bx], bx
   189                              <1> %ifdef MODULE_DRIVEXLATE
   190 0000196D 887618              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dh], dh
   191                              <1> %else
   192                              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dx], dx
   193                              <1> %endif
   194 00001970 894E19              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.cx], cx
   195 00001973 89461B              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ax], ax
   196 00001976 9C                  <1> 	pushf
   197 00001977 8F4621              <1> 	pop		WORD [bp+IDEPACK.intpack+INTPACK.flags]
   198 0000197A E8C6F1              <1> 	call	RamVars_GetSegmentToDS
   199                              <1> 
   200                              <1> %ifdef MODULE_DRIVEXLATE
   201 0000197D 3A160B00            <1> 	cmp		dl, [RAMVARS.xlateVars+XLATEVARS.bXlatedDrv]	; DL is still drive number?
   202 00001981 7403                <1> 	je		SHORT .ExchangeInt13hHandlers
   203 00001983 885617              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dl], dl	; Something is returned in DL
   204                              <1> ALIGN JUMP_ALIGN
   205                              <1> .ExchangeInt13hHandlers:
   206                              <1> %endif
   207                              <1> 
   208                              <1> %ifdef USE_186
   209                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
   210                              <1> 	jmp		SHORT ExchangeCurrentInt13hHandlerWithOldInt13hHandler
   211                              <1> %else
   212 00001986 E82100              <1> 	call	ExchangeCurrentInt13hHandlerWithOldInt13hHandler
   213 00001989 EB03                <1> 	jmp		SHORT Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
   214                              <1> %endif
   215                              <1> 
   216                              <1> 
   217                              <1> %ifdef MODULE_SERIAL_FLOPPY
   218                              <1> ;--------------------------------------------------------------------
   219                              <1> ; Int13h_ReturnSuccessForFloppy
   220                              <1> ;
   221                              <1> ; Some operations, such as format of a floppy disk track, should just
   222                              <1> ; return success, while for hard disks it should be treated as unsupported.
   223                              <1> ;--------------------------------------------------------------------
   224                              <1> ALIGN JUMP_ALIGN
   225                              <1> Int13h_ReturnSuccessForFloppy:
   226                              <1> 	test	dl, dl
   227                              <1> 	js		SHORT UnsupportedFunction
   228                              <1> 	xor		ah, ah
   229                              <1> 	jmp		SHORT Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
   230                              <1> %endif
   231                              <1> 
   232                              <1> 
   233                              <1> ;--------------------------------------------------------------------
   234                              <1> ; Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
   235                              <1> ;	Parameters:
   236                              <1> ;		AH:		BIOS Error code
   237                              <1> ;		CL:		Number of sectors actually transferred
   238                              <1> ;		SS:BP:	Ptr to IDEPACK
   239                              <1> ;	Returns:
   240                              <1> ;		All registers are loaded from INTPACK
   241                              <1> ;--------------------------------------------------------------------
   242                              <1> ALIGN JUMP_ALIGN
   243                              <1> Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL:
   244 0000198B 884E1B              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.al], cl
   245                              <1> 	; Fall to Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
   246                              <1> 
   247                              <1> 
   248                              <1> ;--------------------------------------------------------------------
   249                              <1> ; Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
   250                              <1> ; Int13h_ReturnFromHandlerWithoutStoringErrorCode
   251                              <1> ;	Parameters:
   252                              <1> ;		AH:		BIOS Error code
   253                              <1> ;		DS:		RAMVARS segment
   254                              <1> ;		SS:BP:	Ptr to IDEPACK
   255                              <1> ;	Returns:
   256                              <1> ;		All registers are loaded from INTPACK
   257                              <1> ;--------------------------------------------------------------------
   258                              <1> ALIGN JUMP_ALIGN
   259                              <1> Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH:
   260                              <1> %ifdef MODULE_SERIAL_FLOPPY
   261                              <1> 	mov		al, [bp+IDEPACK.intpack+INTPACK.dl]
   262                              <1> Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH_ALHasDriveNumber:
   263                              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH_ALHasDriveNumber
   264                              <1> 
   265                              <1> %else
   266 0000198E E83F00              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH
   267                              <1> %endif
   268                              <1> 
   269                              <1> Int13h_ReturnFromHandlerWithoutStoringErrorCode:
   270                              <1> 	; Always return with interrupts enabled since there are programs that rely
   271                              <1> 	; on INT 13h to enable interrupts.
   272 00001991 804E2202            <1> 	or		BYTE [bp+IDEPACK.intpack+INTPACK.flags+1], (FLG_FLAGS_IF>>8)
   273 00001995 89EC                <1> 	mov		sp, bp	; This makes possible to exit anytime, no matter what is on stack
   274                              <1> 	RESTORE_FRAME_INTPACK_FROM_SSBP		SIZE_OF_IDEPACK_WITHOUT_INTPACK
   274 00001997 83C409              <2>  add sp, BYTE %1
   274                              <2> %ifdef USE_386
   274                              <2> 
   274                              <2> 
   274                              <2> %endif
   274 0000199A 07                  <2>  pop es
   274 0000199B 1F                  <2>  pop ds
   274                              <2>  ePOPA
   274                              <3> %ifndef USE_186
   274 0000199C 5F                  <3>  pop di
   274 0000199D 5E                  <3>  pop si
   274 0000199E 5D                  <3>  pop bp
   274 0000199F 58                  <3>  pop ax
   274 000019A0 5B                  <3>  pop bx
   274 000019A1 5A                  <3>  pop dx
   274 000019A2 59                  <3>  pop cx
   274 000019A3 58                  <3>  pop ax
   274                              <3> 
   274                              <3> %else
   274                              <3>  popa
   274                              <3> %endif
   274 000019A4 CF                  <2>  iret
   275                              <1> 
   276                              <1> 
   277                              <1> ;--------------------------------------------------------------------
   278                              <1> ; Int13h_CallPreviousInt13hHandler
   279                              <1> ;	Parameters:
   280                              <1> ;		AH:		INT 13h function to call
   281                              <1> ;		DL:		Drive number
   282                              <1> ;		DS:		RAMVARS segment
   283                              <1> ;	Returns:
   284                              <1> ;		Depends on function
   285                              <1> ;       NOTE: ES:DI needs to be returned from the previous interrupt
   286                              <1> ;		      handler, for floppy DPT in function 08h
   287                              <1> ;	Corrupts registers:
   288                              <1> ;		None
   289                              <1> ;--------------------------------------------------------------------
   290                              <1> ALIGN JUMP_ALIGN
   291                              <1> Int13h_CallPreviousInt13hHandler:
   292 000019A5 E80200              <1> 	call	ExchangeCurrentInt13hHandlerWithOldInt13hHandler
   293 000019A8 CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h
   294                              <1> ;;;  fall-through to ExchangeCurrentInt13hHandlerWithOldInt13hHandler
   295                              <1> 
   296                              <1> ;--------------------------------------------------------------------
   297                              <1> ; ExchangeCurrentInt13hHandlerWithOldInt13hHandler
   298                              <1> ;	Parameters:
   299                              <1> ;		DS:		RAMVARS segment
   300                              <1> ;	Returns:
   301                              <1> ;		Nothing
   302                              <1> ;	Corrupts registers:
   303                              <1> ;       Nothing
   304                              <1> ;       Note: Flags are preserved
   305                              <1> ;--------------------------------------------------------------------
   306                              <1> ALIGN JUMP_ALIGN
   307                              <1> ExchangeCurrentInt13hHandlerWithOldInt13hHandler:
   308 000019AA 06                  <1> 	push	es
   309 000019AB 56                  <1> 	push	si
   310                              <1> 	LOAD_BDA_SEGMENT_PRESERVE_FLAGS_TO	es, si
   310                              <2> %ifndef USE_186
   310 000019AC BE0000              <2>  mov %2, 0
   310 000019AF 8EC6                <2>  mov %1, %2
   310                              <2> %elifidn %3, !
   310                              <2>  mov %2, 0
   310                              <2>  mov %1, %2
   310                              <2> %else
   310                              <2>  push BYTE 0
   310                              <2>  pop %1
   310                              <2> %endif
   311 000019B1 8B360000            <1> 	mov		si, [RAMVARS.fpOldI13h]
   312 000019B5 FA                  <1> 	cli
   313 000019B6 2687364C00          <1> 	xchg	si, [es:BIOS_DISK_INTERRUPT_13h*4]
   314 000019BB 89360000            <1> 	mov		[RAMVARS.fpOldI13h], si
   315 000019BF 8B360200            <1> 	mov		si, [RAMVARS.fpOldI13h+2]
   316 000019C3 2687364E00          <1> 	xchg	si, [es:BIOS_DISK_INTERRUPT_13h*4+2]
   317 000019C8 FB                  <1> 	sti
   318 000019C9 89360200            <1> 	mov		[RAMVARS.fpOldI13h+2], si
   319 000019CD 5E                  <1> 	pop		si
   320 000019CE 07                  <1> 	pop		es
   321 000019CF C3                  <1> 	ret
   322                              <1> 
   323                              <1> 
   324                              <1> ;--------------------------------------------------------------------
   325                              <1> ; Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH
   326                              <1> ; Int13h_SetErrorCodeToIntpackInSSBPfromAH
   327                              <1> ;	Parameters:
   328                              <1> ;		AH:		BIOS error code (00h = no error)
   329                              <1> ;		SS:BP:	Ptr to IDEPACK
   330                              <1> ;	Returns:
   331                              <1> ;		SS:BP:	Ptr to IDEPACK with error condition set
   332                              <1> ;	Corrupts registers:
   333                              <1> ;		DS, DI
   334                              <1> ;--------------------------------------------------------------------
   335                              <1> ALIGN JUMP_ALIGN
   336                              <1> %ifdef MODULE_SERIAL_FLOPPY
   337                              <1> Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH_ALHasDriveNumber:
   338                              <1> 	; Store error code to BDA
   339                              <1> 	mov		bx, BDA.bHDLastSt
   340                              <1> 	test	al, al
   341                              <1> 	js		SHORT .HardDisk
   342                              <1> 	mov		bl, BDA.bFDRetST & 0xff
   343                              <1> .HardDisk:
   344                              <1> 	LOAD_BDA_SEGMENT_TO	ds, di
   345                              <1> 	mov		[bx], ah
   346                              <1> 	; Fall to Int13h_SetErrorCodeToIntpackInSSBPfromAH
   347                              <1> 
   348                              <1> %else
   349                              <1> Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH:
   350                              <1> 	; Store error code to BDA
   351                              <1> 	LOAD_BDA_SEGMENT_TO	ds, di
   351                              <2> %ifndef USE_186
   351 000019D0 31FF                <2>  xor %2, %2
   351 000019D2 8EDF                <2>  mov %1, %2
   351                              <2> %elifidn %3, !
   351                              <2>  xor %2, %2
   351                              <2>  mov %1, %2
   351                              <2> %else
   351                              <2>  push BYTE 0
   351                              <2>  pop %1
   351                              <2> %endif
   352 000019D4 88267404            <1> 	mov		[BDA.bHDLastSt], ah
   353                              <1> 	; Fall to Int13h_SetErrorCodeToIntpackInSSBPfromAH
   354                              <1> %endif
   355                              <1> 
   356                              <1> 	; Store error code to INTPACK
   357                              <1> Int13h_SetErrorCodeToIntpackInSSBPfromAH:
   358 000019D8 88661C              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ah], ah
   359 000019DB 84E4                <1> 	test	ah, ah
   360 000019DD 7505                <1> 	jnz		SHORT .SetCFtoIntpack
   361 000019DF 806621FE            <1> 	and		BYTE [bp+IDEPACK.intpack+INTPACK.flags], ~FLG_FLAGS_CF
   362 000019E3 C3                  <1> 	ret
   363                              <1> .SetCFtoIntpack:
   364 000019E4 804E2101            <1> 	or		BYTE [bp+IDEPACK.intpack+INTPACK.flags], FLG_FLAGS_CF
   365 000019E8 C3                  <1> 	ret
   366                              <1> 
   367                              <1> 
   368                              <1> ; Jump table for correct BIOS function
   369                              <1> ALIGN WORD_ALIGN
   370                              <1> g_rgw13hFuncJump:
   371 000019E9 [351A]              <1> 	dw	AH0h_HandlerForDiskControllerReset			; 00h, Disk Controller Reset (All)
   372 000019EB [841A]              <1> 	dw	AH1h_HandlerForReadDiskStatus				; 01h, Read Disk Status (All)
   373 000019ED [921A]              <1> 	dw	AH2h_HandlerForReadDiskSectors				; 02h, Read Disk Sectors (All)
   374 000019EF [A61A]              <1> 	dw	AH3h_HandlerForWriteDiskSectors				; 03h, Write Disk Sectors (All)
   375 000019F1 [BA1A]              <1> 	dw	AH4h_HandlerForVerifyDiskSectors			; 04h, Verify Disk Sectors (All)
   376                              <1> %ifdef MODULE_SERIAL_FLOPPY
   377                              <1> 	dw	Int13h_ReturnSuccessForFloppy				; 05h, Format Disk Track (XT, AT, EISA)
   378                              <1> %else
   379 000019F3 [4719]              <1> 	dw	UnsupportedFunction							; 05h, Format Disk Track (XT, AT, EISA)
   380                              <1> %endif
   381 000019F5 [4719]              <1> 	dw	UnsupportedFunction							; 06h, Format Disk Track with Bad Sectors (XT)
   382 000019F7 [4719]              <1> 	dw	UnsupportedFunction							; 07h, Format Multiple Cylinders (XT)
   383 000019F9 [C81A]              <1> 	dw	AH8h_HandlerForReadDiskDriveParameters		; 08h, Read Disk Drive Parameters (All)
   384 000019FB [121B]              <1> 	dw	AH9h_HandlerForInitializeDriveParameters	; 09h, Initialize Drive Parameters (All)
   385 000019FD [4719]              <1> 	dw	UnsupportedFunction							; 0Ah, Read Disk Sectors with ECC (XT, AT, EISA)
   386 000019FF [4719]              <1> 	dw	UnsupportedFunction							; 0Bh, Write Disk Sectors with ECC (XT, AT, EISA)
   387 00001A01 [CF1B]              <1> 	dw	AHCh_HandlerForSeek							; 0Ch, Seek (All)
   388 00001A03 [121B]              <1> 	dw	AH9h_HandlerForInitializeDriveParameters	; 0Dh, Alternate Disk Reset (All)
   389 00001A05 [4719]              <1> 	dw	UnsupportedFunction							; 0Eh, Read Sector Buffer (XT, PS/1), ESDI Undocumented Diagnostic (PS/2)
   390 00001A07 [4719]              <1> 	dw	UnsupportedFunction							; 0Fh, Write Sector Buffer (XT, PS/1), ESDI Undocumented Diagnostic (PS/2)
   391 00001A09 [DD1B]              <1> 	dw	AH10h_HandlerForCheckDriveReady				; 10h, Check Drive Ready (All)
   392 00001A0B [E31B]              <1> 	dw	AH11h_HandlerForRecalibrate					; 11h, Recalibrate (All)
   393 00001A0D [4719]              <1> 	dw	UnsupportedFunction							; 12h, Controller RAM Diagnostic (XT)
   394 00001A0F [4719]              <1> 	dw	UnsupportedFunction							; 13h, Drive Diagnostic (XT)
   395 00001A11 [4719]              <1> 	dw	UnsupportedFunction							; 14h, Controller Internal Diagnostic (All)
   396 00001A13 [F01B]              <1> 	dw	AH15h_HandlerForReadDiskDriveSize			; 15h, Read Disk Drive Size (AT+)
   397 00001A15 [4719]              <1> 	dw	UnsupportedFunction							; 16h,
   398 00001A17 [4719]              <1> 	dw	UnsupportedFunction							; 17h,
   399 00001A19 [4719]              <1> 	dw	UnsupportedFunction							; 18h,
   400 00001A1B [4719]              <1> 	dw	UnsupportedFunction							; 19h, Park Heads (PS/2)
   401 00001A1D [4719]              <1> 	dw	UnsupportedFunction							; 1Ah, Format ESDI Drive (PS/2)
   402 00001A1F [4719]              <1> 	dw	UnsupportedFunction							; 1Bh, Get ESDI Manufacturing Header (PS/2)
   403 00001A21 [4719]              <1> 	dw	UnsupportedFunction							; 1Ch, ESDI Special Functions (PS/2)
   404 00001A23 [4719]              <1> 	dw	UnsupportedFunction							; 1Dh,
   405                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   406 00001A25 [1D1C]              <1> 	dw	AH1Eh_HandlerForXTCFfeatures				; 1Eh, Lo-tech XT-CF features (XTIDE Universal BIOS)
   407                              <1> %else
   408                              <1> 	dw	UnsupportedFunction							; 1Eh,
   409                              <1> %endif
   410 00001A27 [4719]              <1> 	dw	UnsupportedFunction							; 1Fh,
   411 00001A29 [4719]              <1> 	dw	UnsupportedFunction							; 20h,
   412 00001A2B [4719]              <1> 	dw	UnsupportedFunction							; 21h, Read Disk Sectors, Multiple Blocks (PS/1)
   413 00001A2D [4719]              <1> 	dw	UnsupportedFunction							; 22h, Write Disk Sectors, Multiple Blocks (PS/1)
   414 00001A2F [6D1C]              <1> 	dw	AH23h_HandlerForSetControllerFeatures		; 23h, Set Controller Features Register (PS/1)
   415 00001A31 [841C]              <1> 	dw	AH24h_HandlerForSetMultipleBlocks			; 24h, Set Multiple Blocks (PS/1)
   416 00001A33 [AB1C]              <1> 	dw	AH25h_HandlerForGetDriveInformation			; 25h, Get Drive Information (PS/1)
   417                              <1> 
   418                              <1> %ifdef MODULE_EBIOS
   419                              <1> g_rgwEbiosFunctionJumpTable:
   420                              <1> 	dw	AH41h_HandlerForCheckIfExtensionsPresent	; 41h, Check if Extensions Present (EBIOS)*
   421                              <1> 	dw	AH42h_HandlerForExtendedReadSectors			; 42h, Extended Read Sectors (EBIOS)*
   422                              <1> 	dw	AH43h_HandlerForExtendedWriteSectors		; 43h, Extended Write Sectors (EBIOS)*
   423                              <1> 	dw	AH44h_HandlerForExtendedVerifySectors		; 44h, Extended Verify Sectors (EBIOS)*
   424                              <1> 	dw	UnsupportedFunction							; 45h, Lock and Unlock Drive (EBIOS)***
   425                              <1> 	dw	UnsupportedFunction							; 46h, Eject Media Request (EBIOS)***
   426                              <1> 	dw	AH47h_HandlerForExtendedSeek				; 47h, Extended Seek (EBIOS)*
   427                              <1> 	dw	AH48h_HandlerForGetExtendedDriveParameters	; 48h, Get Extended Drive Parameters (EBIOS)*
   428                              <1> ;	dw	UnsupportedFunction							; 49h, Get Extended Disk Change Status (EBIOS)***
   429                              <1> ;	dw	UnsupportedFunction							; 4Ah, Initiate Disk Emulation (Bootable CD-ROM)
   430                              <1> ;	dw	UnsupportedFunction							; 4Bh, Terminate Disk Emulation (Bootable CD-ROM)
   431                              <1> ;	dw	UnsupportedFunction							; 4Ch, Initiate Disk Emulation and Boot (Bootable CD-ROM)
   432                              <1> ;	dw	UnsupportedFunction							; 4Dh, Return Boot Catalog (Bootable CD-ROM)
   433                              <1> ;	dw	UnsupportedFunction							; 4Eh, Set Hardware Configuration (EBIOS)**
   434                              <1> ;
   435                              <1> ;   * = Enhanced Drive Access Support (minimum required EBIOS functions)
   436                              <1> ;  ** = Enhanced Disk Drive (EDD) Support
   437                              <1> ; *** = Drive Locking and Ejecting Support
   438                              <1> %endif
   260                                  	%include "AH0h_HReset.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=0h, Disk Controller Reset.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=0h, Disk Controller Reset.
    25                              <1> ;
    26                              <1> ; Note: We handle all AH=0h calls, even for drives handled by other
    27                              <1> ; BIOSes!
    28                              <1> ;
    29                              <1> ; AH0h_HandlerForDiskControllerReset
    30                              <1> ;	Parameters:
    31                              <1> ;		DL:		Translated Drive number (ignored so all drives are reset)
    32                              <1> ;				If bit 7 is set all hard disks and floppy disks reset.
    33                              <1> ;		DS:DI:	Ptr to DPT (or Null if foreign drive)
    34                              <1> ;		SS:BP:	Ptr to IDEPACK
    35                              <1> ;	Returns with INTPACK:
    36                              <1> ;		AH:		Int 13h return status (from drive requested in DL)
    37                              <1> ;		CF:		0 if successful, 1 if error
    38                              <1> ;--------------------------------------------------------------------
    39                              <1> AH0h_HandlerForDiskControllerReset:
    40                              <1> 	; Reset foreign Floppy and Hard Drives (those handled by other BIOSes)
    41                              <1> 	eMOVZX	bx, dl										; Copy requested drive to BL and zero BH to assume no errors
    41                              <2> %ifndef USE_386
    41                              <2>  %ifidni %1, ax
    41                              <2>  mov al, %2
    41                              <2>  xor ah, ah
    41                              <2>  %elifidni %1, bx
    41 00001A35 88D3                <2>  mov bl, %2
    41 00001A37 30FF                <2>  xor bh, bh
    41                              <2>  %elifidni %1, cx
    41                              <2>  mov cl, %2
    41                              <2>  xor ch, ch
    41                              <2>  %elifidni %1, dx
    41                              <2>  mov dl, %2
    41                              <2>  xor dh, dh
    41                              <2>  %else
    41                              <2>  push ax
    41                              <2>  mov al, %2
    41                              <2>  xor ah, ah
    41                              <2>  xchg ax, %1
    41                              <2>  pop ax
    41                              <2>  %endif
    41                              <2> 
    41                              <2> %else
    41                              <2>  movzx %1, %2
    41                              <2> %endif
    42                              <1> 
    43 00001A39 30E4                <1> 	xor		ah, ah										; Disk Controller Reset
    44 00001A3B E867FF              <1> 	call	Int13h_CallPreviousInt13hHandler			; Reset floppy drives only or floppy drives and foreign hard disks
    45 00001A3E E80C00              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH
    46                              <1> 
    47                              <1> %ifdef MODULE_SERIAL_FLOPPY
    48                              <1> ;
    49                              <1> ; "Reset" emulated serial floppy drives, if any.  There is nothing to actually do for this reset,
    50                              <1> ; but record the proper error return code if one of these floppy drives is the drive requested.
    51                              <1> ;
    52                              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
    53                              <1> 	cbw													; Clears AH (there are flop drives) or ffh (there are not)
    54                              <1> 														; Either AH has success code (flop drives are present)
    55                              <1> 														; or it doesn't matter because we won't match drive ffh
    56                              <1> 
    57                              <1> 	cwd													; clears DX (there are flop drives) or ffffh (there are not)
    58                              <1> 
    59                              <1> 	adc		dl, al										; second drive (CF set) if present
    60                              <1> 														; If no drive is present, this will result in ffh which
    61                              <1> 														; won't match a drive
    62                              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH
    63                              <1> 	mov		dl, al										; We may end up doing the first drive twice (if there is
    64                              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH	; only one drive), but doing it again is not harmful.
    65                              <1> %endif
    66 00001A41 84DB                <1> 	test	bl, bl										; If we were called with a floppy disk, then we are done,
    67 00001A43 7903                <1> 	jns		SHORT .SkipHardDiskReset					; don't do hard disks.
    68                              <1> 
    69                              <1> 	; Resetting our hard disks will modify dl and bl to be idevars offset based instead of drive number based,
    70                              <1> 	; such that this call must be the last in the list of reset routines called.
    71                              <1> 	;
    72                              <1> 	; This needs to happen after ResetForeignDrives, as that call may have set the error code for 80h,
    73                              <1> 	; and we need to override that value if we are xlate'd into 80h with one of our drives.
    74                              <1> 	;
    75 00001A45 E80C00              <1> 	call	ResetHardDisksHandledByOurBIOS
    76                              <1> 
    77                              <1> .SkipHardDiskReset:
    78 00001A48 88FC                <1> 	mov		ah, bh
    79 00001A4A E941FF              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    80                              <1> 
    81                              <1> 
    82                              <1> ;--------------------------------------------------------------------
    83                              <1> ; BackupErrorCodeFromTheRequestedDriveToBH
    84                              <1> ;	Parameters:
    85                              <1> ;		AH:		Error code from the last resetted drive
    86                              <1> ;		DL:		Drive last resetted
    87                              <1> ;		BL:		Requested drive (DL when entering AH=00h)
    88                              <1> ;	Returns:
    89                              <1> ;		BH:		Backuped error code
    90                              <1> ;	Corrupts registers:
    91                              <1> ;		Nothing
    92                              <1> ;--------------------------------------------------------------------
    93                              <1> BackupErrorCodeFromTheRequestedDriveToBH:
    94 00001A4D 38DA                <1> 	cmp		dl, bl				; Requested drive?
    95                              <1> 	eCMOVE	bh, ah
    95                              <2>  eCMOVZ %1, %2
    95 00001A4F 7502                <3>  jnz SHORT %%Return
    95 00001A51 88E7                <3>  mov %1, %2
    95                              <3> %%Return:
    96 00001A53 C3                  <1> 	ret
    97                              <1> 
    98                              <1> 
    99                              <1> 
   100                              <1> ; This defines what is called when resetting our drives at the end of drive detection.
   101                              <1> AH0h_ResetAllOurHardDisksAtTheEndOfDriveInitialization equ ResetHardDisksHandledByOurBIOS.ErrorCodeNotUsed
   102                              <1> 
   103                              <1> ;--------------------------------------------------------------------
   104                              <1> ; ResetHardDisksHandledByOurBIOS
   105                              <1> ;	Parameters:
   106                              <1> ;		BL:		Requested drive (DL when entering AH=00h)
   107                              <1> ;		DS:DI:	Ptr to DPT for requested drive
   108                              <1> ;				If DPT pointer is not available, or error result in BH won't be used anyway,
   109                              <1> ;				enter through .ErrorCodeNotUsed.
   110                              <1> ;		SS:BP:	Ptr to IDEPACK
   111                              <1> ;	Returns:
   112                              <1> ;		BH:		Error code from requested drive (if available)
   113                              <1> ;	Corrupts registers:
   114                              <1> ;		AX, BX, CX, DX, SI, DI
   115                              <1> ;--------------------------------------------------------------------
   116                              <1> ResetHardDisksHandledByOurBIOS:
   117 00001A54 30DB                <1> 	xor		bl, bl										; Assume Null IdevarsOffset for now, assuming foreign drive
   118 00001A56 85FF                <1> 	test	di, di
   119 00001A58 7403                <1> 	jz		SHORT .ErrorCodeNotUsed
   120 00001A5A 8A5D02              <1> 	mov		bl, [di+DPT.bIdevarsOffset]					; replace drive number with Idevars pointer for cmp with dl
   121                              <1> .ErrorCodeNotUsed:										; BH will be garbage on exit if this entry point is used,
   122                              <1> 														; but reset of all drives will still happen
   123 00001A5D B251                <1> 	mov		dl, ROMVARS.ideVars0						; starting Idevars offset
   124                              <1> 
   125                              <1>     ; Get count of ALL Idevars structures, not just the ones that are configured.  This may seem odd,
   126                              <1>     ; but it catches the .ideVarsSerialAuto structure, which would not be scanned if the count from
   127                              <1> 	; RamVars_GetIdeControllerCountToCX was used.  Unused controllers won't make a difference, since no DPT
   128                              <1> 	; will point to them.  Performance isn't an issue, as this is a reset operation.
   129                              <1>     ;
   130 00001A5F B90400              <1> 	mov		cx, NUMBER_OF_IDEVARS
   131                              <1> 
   132                              <1> .loop:
   133 00001A62 E823F2              <1> 	call	FindDPT_MasterOrSingleForIdevarsOffsetInDL
   134 00001A65 7217                <1> 	jc		SHORT .ControllerNotAvailable
   135                              <1> 
   136                              <1> 	; Reset controller (both Master and Slave Drive). We ignore error codes
   137                              <1> 	; here since initialization is the one that matters.
   138 00001A67 51                  <1> 	push	cx
   139 00001A68 52                  <1> 	push	dx
   140 00001A69 53                  <1> 	push	bx
   141                              <1> %ifdef MODULE_IRQ
   142                              <1> 	call	Interrupts_UnmaskInterruptControllerForDriveInDSDI
   143                              <1> %endif
   144 00001A6A E833F9              <1> 	call	Device_ResetMasterAndSlaveController
   145                              <1> %ifdef MODULE_ADVANCED_ATA
   146                              <1> 	call	AdvAtaInit_InitializeControllerForDPTinDSDI
   147                              <1> %endif
   148 00001A6D 5B                  <1> 	pop		bx
   149 00001A6E 5A                  <1> 	pop		dx
   150                              <1> 
   151                              <1> 	; Initialize Master Drive
   152 00001A6F E8A600              <1> 	call	AH9h_InitializeDriveForUse					; Initialize Master drive
   153 00001A72 E8D8FF              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH
   154                              <1> 
   155                              <1> 	; Initialize Slave Drive
   156 00001A75 E815F2              <1> 	call	FindDPT_SlaveForIdevarsOffsetInDL
   157 00001A78 7203                <1> 	jc		SHORT .SlaveDriveNotAvailable
   158 00001A7A E89B00              <1> 	call	AH9h_InitializeDriveForUse
   159                              <1> 	; Here we have a small problem. Since DL now has offset to IDEVARS, it will be the same
   160                              <1> 	; for both Master and Slave Drive. We simply ignore error from slave drive reset since most
   161                              <1> 	; systems do not have slave drives at all and it is unlikely that AH=00h would be called for
   162                              <1> 	; specific drive anyway. AH=Dh is for that.
   163                              <1> 
   164                              <1> .SlaveDriveNotAvailable:
   165 00001A7D 59                  <1> 	pop		cx
   166                              <1> .ControllerNotAvailable:
   167 00001A7E 80C212              <1> 	add		dl, IDEVARS_size							; move Idevars pointer forward
   168 00001A81 E2DF                <1> 	loop	.loop
   169 00001A83 C3                  <1> 	ret
   261                                  	%include "AH1h_HStatus.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=1h, Read Disk Status.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=1h, Read Disk Status.
    25                              <1> ;
    26                              <1> ; AH1h_HandlerForReadDiskStatus
    27                              <1> ;	Parameters:
    28                              <1> ;		DL:		Translated Drive number
    29                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    30                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
    31                              <1> ;	Returns with INTPACK:
    32                              <1> ;		AH:		Int 13h floppy return status
    33                              <1> ;		CF:		0 if AH = RET_HD_SUCCESS, 1 otherwise (error)
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> ALIGN JUMP_ALIGN
    36                              <1> AH1h_HandlerForReadDiskStatus:
    37                              <1> 	LOAD_BDA_SEGMENT_TO	ds, ax, !
    37                              <2> %ifndef USE_186
    37 00001A84 31C0                <2>  xor %2, %2
    37 00001A86 8ED8                <2>  mov %1, %2
    37                              <2> %elifidn %3, !
    37                              <2>  xor %2, %2
    37                              <2>  mov %1, %2
    37                              <2> %else
    37                              <2>  push BYTE 0
    37                              <2>  pop %1
    37                              <2> %endif
    38                              <1> 
    39                              <1> %ifdef MODULE_SERIAL_FLOPPY
    40                              <1> 	test	dl, dl
    41                              <1> 	js		.HardDisk
    42                              <1> 	mov		ah, [BDA.bFDRetST]	; Unlike for hard disks below, floppy version does not clear the status
    43                              <1> 	jmp		.done
    44                              <1> .HardDisk:
    45                              <1> %endif
    46                              <1> 
    47 00001A88 86267404            <1> 	xchg	ah, [BDA.bHDLastSt]	; Load and clear last error (AH is cleared with the LOAD_BDA_SEGMENT_TO above)
    48                              <1> 
    49                              <1> .done:
    50                              <1> %ifndef USE_186
    51 00001A8C E849FF              <1> 	call	Int13h_SetErrorCodeToIntpackInSSBPfromAH
    52 00001A8F E9FFFE              <1> 	jmp		Int13h_ReturnFromHandlerWithoutStoringErrorCode
    53                              <1> %else
    54                              <1> 	push	Int13h_ReturnFromHandlerWithoutStoringErrorCode
    55                              <1> 	jmp		Int13h_SetErrorCodeToIntpackInSSBPfromAH
    56                              <1> %endif
   262                                  	%include "AH2h_HRead.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=2h, Read Disk Sectors.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=2h, Read Disk Sectors.
    25                              <1> ;
    26                              <1> ; AH2h_HandlerForReadDiskSectors
    27                              <1> ;	Parameters:
    28                              <1> ;		AL, CX, DH, ES:	Same as in INTPACK
    29                              <1> ;		DL:		Translated Drive number
    30                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    31                              <1> ;		SS:BP:	Ptr to IDEPACK
    32                              <1> ;	Parameters on INTPACK:
    33                              <1> ;		AL:		Number of sectors to read (1...128)
    34                              <1> ;		CH:		Cylinder number, bits 7...0
    35                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
    36                              <1> ;				Bits 5...0:	Starting sector number (1...63)
    37                              <1> ;		DH:		Starting head number (0...255)
    38                              <1> ;		ES:BX:	Pointer to buffer receiving data
    39                              <1> ;	Returns with INTPACK:
    40                              <1> ;		AH:		Int 13h/40h floppy return status
    41                              <1> ;		AL:		Burst error length if AH returns 11h (we never return error code 11h)
    42                              <1> ;				Number of sectors actually read (only valid if CF set for someBIOSes)
    43                              <1> ;		CF:		0 if successful, 1 if error
    44                              <1> ;--------------------------------------------------------------------
    45                              <1> ALIGN JUMP_ALIGN
    46                              <1> AH2h_HandlerForReadDiskSectors:
    47 00001A92 E88B02              <1> 	call	Prepare_BufferToESSIforOldInt13hTransfer
    48 00001A95 E88102              <1> 	call	Prepare_GetOldInt13hCommandIndexToBX
    49 00001A98 2E8AA7[3E1D]        <1> 	mov		ah, [cs:bx+g_rgbReadCommandLookup]
    50 00001A9D BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
    51                              <1> %ifdef USE_186
    52                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
    53                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
    54                              <1> %else
    55 00001AA0 E882F8              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
    56 00001AA3 E9E5FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
    57                              <1> %endif
    58                              <1> 
   263                                  	%include "AH3h_HWrite.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=3h, Write Disk Sectors.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=3h, Write Disk Sectors.
    25                              <1> ;
    26                              <1> ; AH3h_HandlerForWriteDiskSectors
    27                              <1> ;	Parameters:
    28                              <1> ;		AL, CX, DH, ES:	Same as in INTPACK
    29                              <1> ;		DL:		Translated Drive number
    30                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    31                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
    32                              <1> ;	Parameters on INTPACK:
    33                              <1> ;		AL:		Number of sectors to write (1...128)
    34                              <1> ;		CH:		Cylinder number, bits 7...0
    35                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
    36                              <1> ;				Bits 5...0:	Starting sector number (1...63)
    37                              <1> ;		DH:		Starting head number (0...255)
    38                              <1> ;		ES:BX:	Pointer to source data
    39                              <1> ;	Returns with INTPACK:
    40                              <1> ;		AH:		Int 13h/40h floppy return status
    41                              <1> ;		AL:		Number of sectors actually written (only valid if CF set for someBIOSes)
    42                              <1> ;		CF:		0 if successful, 1 if error
    43                              <1> ;--------------------------------------------------------------------
    44                              <1> ALIGN JUMP_ALIGN
    45                              <1> AH3h_HandlerForWriteDiskSectors:
    46 00001AA6 E87702              <1> 	call	Prepare_BufferToESSIforOldInt13hTransfer
    47 00001AA9 E86D02              <1> 	call	Prepare_GetOldInt13hCommandIndexToBX
    48 00001AAC 2E8AA7[411D]        <1> 	mov		ah, [cs:bx+g_rgbWriteCommandLookup]
    49 00001AB1 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
    50                              <1> %ifdef USE_186
    51                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
    52                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
    53                              <1> %else
    54 00001AB4 E86EF8              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
    55 00001AB7 E9D1FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
    56                              <1> %endif
   264                                  	%include "AH4h_HVerify.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=4h, Verify Disk Sectors.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=4h, Verify Disk Sectors.
    25                              <1> ;
    26                              <1> ; AH4h_HandlerForVerifyDiskSectors
    27                              <1> ;	Parameters:
    28                              <1> ;		AL, CX, DH:	Same as in INTPACK
    29                              <1> ;		DL:		Translated Drive number
    30                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    31                              <1> ;		SS:BP:	Ptr to INTPACK
    32                              <1> ;	Parameters on INTPACK in SS:BP:
    33                              <1> ;		AL:		Number of sectors to verify (1...128)
    34                              <1> ;		CH:		Cylinder number, bits 7...0
    35                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
    36                              <1> ;				Bits 5...0:	Starting sector number (1...63)
    37                              <1> ;		DH:		Starting head number (0...255)
    38                              <1> ;	Returns with INTPACK in SS:BP:
    39                              <1> ;		AH:		Int 13h/40h floppy return status
    40                              <1> ;		AL:		Number of sectors actually verified (only valid if CF set for someBIOSes)
    41                              <1> ;		CF:		0 if successful, 1 if error
    42                              <1> ;--------------------------------------------------------------------
    43                              <1> ALIGN JUMP_ALIGN
    44                              <1> AH4h_HandlerForVerifyDiskSectors:
    45 00001ABA B440                <1> 	mov		ah, COMMAND_VERIFY_SECTORS
    46 00001ABC E86702              <1> 	call	Prepare_ByValidatingSectorsInALforOldInt13h	; Preserves AX
    47 00001ABF BB40FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRDY)
    48                              <1> %ifdef USE_186
    49                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
    50                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
    51                              <1> %else
    52 00001AC2 E860F8              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
    53 00001AC5 E9C3FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
    54                              <1> %endif
   265                                  	%include "AH8h_HParams.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=8h, Read Disk Drive Parameters.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=8h, Read Disk Drive Parameters.
    25                              <1> ;
    26                              <1> ; AH8h_HandlerForReadDiskDriveParameters
    27                              <1> ;	Parameters:
    28                              <1> ;		DL:		Translated Drive number
    29                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    30                              <1> ;		SS:BP:	Ptr to IDEPACK
    31                              <1> ;	Returns with INTPACK:
    32                              <1> ;       BL:     Drive Type (for floppies only)
    33                              <1> ;		CH:		Maximum cylinder number, bits 7...0
    34                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9...8
    35                              <1> ;				Bits 5...0:	Maximum sector number (1...63)
    36                              <1> ;		DH:		Maximum head number (0...254)
    37                              <1> ;		DL:		Number of drives!!!
    38                              <1> ;       ES:DI:  Floppy DPT (for floppies only)
    39                              <1> ;		AH:		Int 13h/40h floppy return status
    40                              <1> ;		CF:		0 if successful, 1 if error
    41                              <1> ;--------------------------------------------------------------------
    42                              <1> AH8h_HandlerForReadDiskDriveParameters:
    43 00001AC8 85FF                <1> 	test	di, di
    44 00001ACA 7425                <1> 	jz		SHORT .NotOurDrive
    45                              <1> 
    46 00001ACC E82A00              <1> 	call	AH8h_GetDriveParameters
    47                              <1> 
    48                              <1> %ifdef MODULE_SERIAL_FLOPPY
    49                              <1> 	push	cs							; setup registers if we are a floppy drive, in all cases
    50                              <1> 	pop		es							; if it is not a floppy drive, these values will not be put in INTPACK
    51                              <1> 	mov		di, AH8h_FloppyDPT
    52                              <1> %endif
    53                              <1> 	;; fall-through
    54                              <1> 
    55                              <1> .MidGame:
    56 00001ACF E8AFF0              <1> 	call	RamVars_GetCountOfKnownDrivesToAX		; assume hard disk for now, will discard if for floppies
    57                              <1> 
    58 00001AD2 F6461780            <1> 	test	byte [bp+IDEPACK.intpack+INTPACK.dl], 080h
    59 00001AD6 750C                <1> 	jnz		.Done
    60                              <1> 
    61 00001AD8 885E15              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.bl], bl
    62                              <1> 
    63 00001ADB 8C4609              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.es], es
    64 00001ADE 897E0D              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.di], di
    65                              <1> 
    66 00001AE1 E8E6F0              <1> 	call	FloppyDrive_GetCountToAX
    67                              <1> 
    68                              <1> .Done:
    69 00001AE4 88F4                <1> 	mov		ah, dh
    70                              <1> 
    71 00001AE6 894E19              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.cx], cx
    72 00001AE9 874617              <1> 	xchg	[bp+IDEPACK.intpack+INTPACK.dx], ax		; recover DL for BDA last status byte determination
    73                              <1> 
    74 00001AEC 30E4                <1> 	xor		ah, ah
    75                              <1> %ifdef MODULE_SERIAL_FLOPPY
    76                              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH_ALHasDriveNumber
    77                              <1> %else
    78 00001AEE E99DFE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    79                              <1> %endif
    80                              <1> 
    81                              <1> .NotOurDrive:
    82 00001AF1 E8B1FE              <1> 	call	Int13h_CallPreviousInt13hHandler
    83 00001AF4 73D9                <1> 	jnc		SHORT .MidGame
    84 00001AF6 E995FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    85                              <1> 
    86                              <1> 
    87                              <1> ;--------------------------------------------------------------------
    88                              <1> ; Returns L-CHS parameters for drive and total hard disk count.
    89                              <1> ;
    90                              <1> ; AH8h_GetDriveParameters
    91                              <1> ;	Parameters:
    92                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    93                              <1> ;	Returns:
    94                              <1> ;		CH:		Maximum cylinder number, bits 7...0
    95                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9...8
    96                              <1> ;				Bits 5...0:	Maximum sector number (1...63)
    97                              <1> ;		DH:		Maximum head number (0...254)
    98                              <1> ;	Corrupts registers:
    99                              <1> ;		AX, BX
   100                              <1> ;--------------------------------------------------------------------
   101                              <1> AH8h_GetDriveParameters:
   102 00001AF9 E8E3F1              <1> 	call	AccessDPT_GetLCHStoAXBLBH
   103                              <1> %ifdef RESERVE_DIAGNOSTIC_CYLINDER
   104                              <1> 	dec		ax
   105                              <1> %endif
   106                              <1> 	MIN_U	ax, MAX_LCHS_CYLINDERS
   106 00001AFC 3D0004              <2>  cmp %1, %2
   106 00001AFF 7203                <2>  jb %%Return
   106 00001B01 B80004              <2>  mov %1, %2
   106                              <2> ALIGN JUMP_ALIGN
   106                              <2> %%Return:
   107                              <1> 	; Fall to .PackReturnValues
   108                              <1> 
   109                              <1> ;--------------------------------------------------------------------
   110                              <1> ; Packs L-CHS values to INT 13h, AH=08h return values.
   111                              <1> ;
   112                              <1> ; .PackReturnValues
   113                              <1> ;	Parameters:
   114                              <1> ;		AX:		Number of L-CHS cylinders available (1...1024)
   115                              <1> ;		BL:		Number of L-CHS heads (1...255)
   116                              <1> ;		BH:		Number of L-CHS sectors per track (1...63)
   117                              <1> ;		DS:		RAMVARS segment
   118                              <1> ;	Returns:
   119                              <1> ;		CH:		Maximum cylinder number, bits 7...0
   120                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9...8
   121                              <1> ;				Bits 5...0:	Maximum sector number (1...63)
   122                              <1> ;		DH:		Maximum head number (0...254)
   123                              <1> ;	Corrupts registers:
   124                              <1> ;		AX, BX
   125                              <1> ;--------------------------------------------------------------------
   126                              <1> .PackReturnValues:
   127 00001B04 48                  <1> 	dec		ax						; AX = Number of last cylinder
   128 00001B05 4B                  <1> 	dec		bx						; BL = Number of last head
   129 00001B06 91                  <1> 	xchg	cx, ax
   130 00001B07 86CD                <1> 	xchg	cl, ch					; CH = Last cylinder bits 0...7
   131                              <1> 	eROR_IM	cl, 2					; CL bits 6...7 = Last cylinder bits 8...9
   131                              <2>  eSHIFT_IM %1, %2, ror
   131                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   131                              <3> %ifndef USE_186
   131                              <3>  %ifidni %1, cl
   131 00001B09 D0C9<rept>          <3>  times %2 %3 %1, 1
   131                              <3>  %elifidni %1, ch
   131                              <3>  times %2 %3 %1, 1
   131                              <3>  %elifidni %1, cx
   131                              <3>  times %2 %3 %1, 1
   131                              <3>  %else
   131                              <3>  %if %2 > 3
   131                              <3>  push cx
   131                              <3>  mov cl, %2
   131                              <3>  %3 %1, cl
   131                              <3>  pop cx
   131                              <3>  %else
   131                              <3>  times %2 %3 %1, 1
   131                              <3>  %endif
   131                              <3>  %endif
   131                              <3> 
   131                              <3> %else
   131                              <3>  %3 %1, %2
   131                              <3> %endif
   131                              <3> %endif
   132 00001B0D 08F9                <1> 	or		cl, bh					; CL bits 0...5 = Sectors per track
   133 00001B0F 88DE                <1> 	mov		dh, bl					; DH = Maximum head number
   134                              <1> 
   135                              <1> %ifdef MODULE_SERIAL_FLOPPY
   136                              <1> 	mov		bl, [di+DPT.bFlagsHigh]
   137                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS             ; not sure why this is needed for preprocessor-only
   138                              <1> 	eSHR_IM	bl, FLGH_DPT_SERIAL_FLOPPY_TYPE_FIELD_POSITION
   139                              <1> %endif
   140                              <1> %endif
   141 00001B11 C3                  <1> 	ret
   142                              <1> 
   143                              <1> %ifdef MODULE_SERIAL_FLOPPY
   144                              <1> ;
   145                              <1> ; Floppy Disk Parameter Table.  There is no way to specify more than one of these
   146                              <1> ; for any given system, so no way to make this drive or media specific.
   147                              <1> ; So we return fixed values out of the ROM for callers who might be expecting this information.
   148                              <1> ;
   149                              <1> ; On AT systems, we return the information for a 1.44 MB disk,
   150                              <1> ; and on XT systems, we return the information for a 360 KB disk.
   151                              <1> ;
   152                              <1> AH8h_FloppyDPT:
   153                              <1> %ifdef USE_AT
   154                              <1> 	db		0ah << 4 | 0fh			; Offset 0: Drive timings, 1.44MB values
   155                              <1> %else
   156                              <1> 	db		0dh << 4 | 0fh			; Offset 0: Drive timings, 360KB values
   157                              <1> %endif
   158                              <1> 
   159                              <1> 	db		1h << 1 | 0				; Offset 1: Typical values of 1 for head load time
   160                              <1> 									;           DMA used (although it actually is not, but is more restrictive)
   161                              <1> 	db		25h						; Offset 2: Inactivity motor turn-off delay,
   162                              <1> 									; 			Typical value of 25h for 2 second delay
   163                              <1> 	db		02h						; Offset 3: Sector size, always 512
   164                              <1> 
   165                              <1> %ifdef USE_AT
   166                              <1> 	db		12h						; Offset 4: Sectors per track, 1.44MB value
   167                              <1> 	db		1bh						; Offset 5: Sector gap, 1.44MB value
   168                              <1> %else
   169                              <1> 	db		09h						; Offset 4: Sectors per track, 360KB value
   170                              <1> 	db		2ah						; Offset 5: Sector gap, 360KB value
   171                              <1> %endif
   172                              <1> 
   173                              <1> 	db		0ffh					; Offset 6: Data length
   174                              <1> 
   175                              <1> %ifdef USE_AT
   176                              <1> 	db		6ch						; Offset 7: Format gap length, 1.44MB value
   177                              <1> %else
   178                              <1> 	db		50h						; Offset 7: Format gap length, 360KB value
   179                              <1> %endif
   180                              <1> 
   181                              <1> 	db		0f6h					; Offset 8: Fill byte for format
   182                              <1> 	db		0fh						; Offset 9: Head setting time
   183                              <1> 	db		08h						; Offset A: Wait for motor startup time
   184                              <1> 
   185                              <1> %ifdef USE_AT
   186                              <1> 	db		79						; Offset B: Maximum track number, 1.44MB value
   187                              <1> 	db		0						; Offset C: Data transfer rate, 1.44MB value
   188                              <1> 	db		4						; Offset D: Diskette CMOS drive type, 1.44MB value
   189                              <1> %else
   190                              <1> 	db		39						; Offset B: Maximum track number, 360KB value
   191                              <1> 	db		80h						; Offset C: Data transfer rate, 360KB value
   192                              <1> 	db		1						; Offset D: Diskette CMOS drive type, 360KB value
   193                              <1> %endif
   194                              <1> %endif
   266                                  	%include "AH9h_HInit.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=9h, Initialize Drive Parameters.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    21                              <1> 
    22                              <1> ; Section containing code
    23                              <1> SECTION .text
    24                              <1> 
    25                              <1> ;--------------------------------------------------------------------
    26                              <1> ; STORE_ERROR_FLAG_TO_DPT
    27                              <1> ;	Parameters:
    28                              <1> ;		%1:		Error flag to set
    29                              <1> ;		AH:		BIOS Error Code
    30                              <1> ;		DS:DI:	Ptr to DPT
    31                              <1> ;		CF:		Set if error code in AH
    32                              <1> ;	Returns:
    33                              <1> ;		CF:		Clear if no error
    34                              <1> ;				Set if error flag was set
    35                              <1> ;	Corrupts registers:
    36                              <1> ;		Nothing
    37                              <1> ;--------------------------------------------------------------------
    38                              <1> %macro STORE_ERROR_FLAG_TO_DPT 1
    39                              <1> 	mov		al, %1
    40                              <1> 	call	SetErrorFlagFromALwithErrorCodeInAH
    41                              <1> %endmacro
    42                              <1> 
    43                              <1> 
    44                              <1> ;--------------------------------------------------------------------
    45                              <1> ; Int 13h function AH=9h, Initialize Drive Parameters.
    46                              <1> ;
    47                              <1> ; AH9h_HandlerForInitializeDriveParameters
    48                              <1> ;	Parameters:
    49                              <1> ;		DL:		Translated Drive number
    50                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    51                              <1> ;		SS:BP:	Ptr to IDEPACK
    52                              <1> ;	Returns with INTPACK:
    53                              <1> ;		AH:		Int 13h return status
    54                              <1> ;		CF:		0 if successful, 1 if error
    55                              <1> ;--------------------------------------------------------------------
    56                              <1> AH9h_HandlerForInitializeDriveParameters:
    57                              <1> %ifndef USE_186
    58                              <1> 	; why is this different for 186+?
    59 00001B12 E80300              <1> 	call	AH9h_InitializeDriveForUse
    60 00001B15 E976FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    61                              <1> %else
    62                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    63                              <1> 	; Fall to AH9h_InitializeDriveForUse
    64                              <1> %endif
    65                              <1> 
    66                              <1> 
    67                              <1> ;--------------------------------------------------------------------
    68                              <1> ; Initialize drive to be ready for use.
    69                              <1> ;
    70                              <1> ; AH9h_InitializeDriveForUse
    71                              <1> ;	Parameters:
    72                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    73                              <1> ;		SS:BP:	Ptr to IDEPACK
    74                              <1> ;	Returns:
    75                              <1> ;		AH:		Int 13h return status
    76                              <1> ;		CF:		0 if successful, 1 if error
    77                              <1> ;	Corrupts registers:
    78                              <1> ;		AL, CX
    79                              <1> ;--------------------------------------------------------------------
    80                              <1> AH9h_InitializeDriveForUse:
    81 00001B18 31C0                <1> 	xor		ax, ax				; Clear AH to assume no errors
    82                              <1> 
    83                              <1> %ifdef MODULE_ADVANCED_ATA
    84                              <1> 	; Clear Initialization Error flags from DPT
    85                              <1> 	mov		[di+DPT.bInitError], al
    86                              <1> %endif
    87                              <1> 
    88                              <1> %ifdef MODULE_SERIAL
    89                              <1> 	; No need to do this for serial devices
    90                              <1> 	test		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE	; Clears CF
    91                              <1> 	jz		SHORT .ContinueInitialization
    92                              <1> 	ret		; With AH and CF cleared
    93                              <1> .ContinueInitialization:
    94                              <1> %endif
    95                              <1> 
    96 00001B1A 06                  <1> 	push	es
    97 00001B1B 56                  <1> 	push	si
    98 00001B1C 52                  <1> 	push	dx
    99 00001B1D 53                  <1> 	push	bx
   100                              <1> 
   101                              <1> 
   102                              <1> ;;;	SelectDrive
   103                              <1> 	; Try to select drive and wait until ready
   104 00001B1E E8ABF1              <1> 	call	AccessDPT_GetDriveSelectByteForOldInt13hToAL
   105 00001B21 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
   106 00001B24 E81CF9              <1> 	call	Device_SelectDrive
   107                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SELECT_DRIVE
   107 00001B27 B001                <2>  mov al, %1
   107 00001B29 E88700              <2>  call SetErrorFlagFromALwithErrorCodeInAH
   108                              <1> %ifdef USE_386
   109                              <1> 	jc		.ReturnWithErrorCodeInAH
   110                              <1> %else
   111 00001B2C 7302                <1> 	jnc		SHORT .ContinueInitializationSinceDriveSelectedSuccesfully
   112 00001B2E EB79                <1> 	jmp		.ReturnWithErrorCodeInAH
   113                              <1> .ContinueInitializationSinceDriveSelectedSuccesfully:
   114                              <1> %endif
   115                              <1> 
   116                              <1> 
   117                              <1> ;;; Set XT-CF mode
   118                              <1> %ifdef MODULE_8BIT_IDE
   119 00001B30 E8D3F1              <1> 	call	AccessDPT_GetIdevarsToCSBX
   120 00001B33 2E8A4702            <1> 	mov		al, [cs:bx+IDEVARS.bXTCFcontrolRegister]
   121 00001B37 E88500              <1> 	call	AH9h_SetModeFromALtoXTCF
   122                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_XTCF_MODE
   122 00001B3A B080                <2>  mov al, %1
   122 00001B3C E87400              <2>  call SetErrorFlagFromALwithErrorCodeInAH
   123                              <1> .DoNotSetXTCFmode:
   124                              <1> %endif	; MODULE_8BIT_IDE
   125                              <1> 
   126                              <1> %ifdef MODULE_8BIT_IDE
   127                              <1> ;;; Set 8-bit PIO mode
   128 00001B3F E88400              <1> 	call	AH9h_Enable8bitModeForDevice8bitAta
   129                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_8BIT_MODE
   129 00001B42 B080                <2>  mov al, %1
   129 00001B44 E86C00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
   130                              <1> .DoNotSet8bitMode:
   131                              <1> %endif ; MODULE_8BIT_IDE
   132                              <1> 
   133                              <1> 
   134                              <1> ;;;	InitializeDeviceParameters
   135                              <1> 	; Initialize CHS parameters if LBA is not used and
   136                              <1> 	; user has specified P-CHS parameters
   137 00001B47 F60508              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_ASSISTED_LBA
   138 00001B4A 751F                <1> 	jnz		SHORT .SkipInitializeDeviceParameters		; No need to initialize CHS parameters if LBA mode enabled
   139 00001B4C E8A8F1              <1> 	call	AccessDPT_GetPointerToDRVPARAMStoCSBX
   140 00001B4F 2EF60720            <1> 	test	BYTE [cs:bx+DRVPARAMS.wFlags], FLG_DRVPARAMS_USERCHS    ; User specified P-CHS?
   141 00001B53 7416                <1> 	jz		SHORT .SkipInitializeDeviceParameters
   142                              <1> 
   143                              <1> 	; Initialize Logical Sectors per Track and Max Head number
   144 00001B55 2E8B4704            <1> 	mov		ax, [cs:bx+DRVPARAMS.wHeadsAndSectors]
   145 00001B59 48                  <1> 	dec		ax						; Max Head number
   146 00001B5A 86C4                <1> 	xchg		al, ah						; Heads now in AH
   147 00001B5C 89C2                <1> 	mov		dx, ax						; Sectors per Track now in DL
   148 00001B5E B091                <1> 	mov		al, COMMAND_INITIALIZE_DEVICE_PARAMETERS
   149 00001B60 BB802F              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_BSY, FLG_STATUS_BSY)
   150 00001B63 E8E1F7              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
   151                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_INITIALIZE_CHS_PARAMETERS
   151 00001B66 B002                <2>  mov al, %1
   151 00001B68 E84800              <2>  call SetErrorFlagFromALwithErrorCodeInAH
   152                              <1> .SkipInitializeDeviceParameters:
   153                              <1> 
   154                              <1> 
   155                              <1> ;;;	SetWriteCache
   156                              <1> 	; Enable or Disable Write Cache
   157 00001B6B E889F1              <1> 	call	AccessDPT_GetPointerToDRVPARAMStoCSBX
   158 00001B6E 2E8A1F              <1> 	mov		bl, [cs:bx+DRVPARAMS.wFlags]
   159 00001B71 53                  <1> 	push		bx	; Save .wFlags for later use in InitializeBlockMode
   160 00001B72 83E303              <1> 	and		bx, BYTE MASK_DRVPARAMS_WRITECACHE
   161 00001B75 740D                <1> 	jz		SHORT .SkipSetWriteCache		; DEFAULT_WRITE_CACHE
   162 00001B77 2E8BB7[AE1B]        <1> 	mov		si, [cs:bx+.rgbWriteCacheCommands]
   163 00001B7C E8F800              <1> 	call	AH23h_SetControllerFeatures
   164                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_WRITE_CACHE
   164 00001B7F B004                <2>  mov al, %1
   164 00001B81 E82F00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
   165                              <1> .SkipSetWriteCache:
   166                              <1> 
   167                              <1> 
   168                              <1> ;;;	RecalibrateDrive
   169                              <1> 	; Recalibrate drive by seeking to cylinder 0
   170 00001B84 E86200              <1> 	call	AH11h_RecalibrateDrive
   171                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_RECALIBRATE_DRIVE
   171 00001B87 B008                <2>  mov al, %1
   171 00001B89 E82700              <2>  call SetErrorFlagFromALwithErrorCodeInAH
   172                              <1> 
   173                              <1> 
   174                              <1> ;;;	InitializeBlockMode
   175                              <1> 	; Initialize block mode transfers
   176 00001B8C 58                  <1> 	pop		ax	; Restore .wFlags saved in SetWriteCache
   177 00001B8D F6450102            <1> 	test		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_BLOCK_MODE_SUPPORTED
   178 00001B91 7416                <1> 	jz		SHORT .BlockModeNotSupportedOrDisabled
   179 00001B93 A810                <1> 	test		al, FLG_DRVPARAMS_BLOCKMODE
   180 00001B95 7412                <1> 	jz		SHORT .BlockModeNotSupportedOrDisabled
   181                              <1> 
   182                              <1> 	; Try block sizes until we find largest possible supported by drive
   183 00001B97 B380                <1> 	mov		bl, 128
   184                              <1> .TryNextBlockSize:
   185 00001B99 88D8                <1> 	mov		al, bl
   186 00001B9B E8EC00              <1> 	call	AH24h_SetBlockSize	; Stores block size to DPT
   187 00001B9E 7309                <1> 	jnc		SHORT .SupportedBlockSizeFound
   188 00001BA0 D0EB                <1> 	shr		bl, 1
   189 00001BA2 73F5                <1> 	jnc		SHORT .TryNextBlockSize
   190                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_BLOCK_MODE
   190 00001BA4 B010                <2>  mov al, %1
   190 00001BA6 E80A00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
   191                              <1> .BlockModeNotSupportedOrDisabled:
   192                              <1> .SupportedBlockSizeFound:
   193                              <1> 
   194                              <1> 
   195                              <1> %ifdef MODULE_ADVANCED_ATA
   196                              <1> ;;;	InitializePioMode
   197                              <1> 	; Initialize fastest supported PIO mode
   198                              <1> 	mov		dl, PIO_DEFAULT_MODE_DISABLE_IORDY
   199                              <1> 	test		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_IORDY
   200                              <1> 	jz		SHORT .IordyNotSupported
   201                              <1> 
   202                              <1> 	; Advanced PIO mode 3 and above
   203                              <1> 	mov		dl, [di+DPT_ADVANCED_ATA.bPioMode]
   204                              <1> 	or		dl, PIO_FLOW_CONTROL_MODE_xxx
   205                              <1> 
   206                              <1> .IordyNotSupported:
   207                              <1> 	mov		si, FEATURE_SET_TRANSFER_MODE
   208                              <1> 	call	AH23h_SetControllerFeatures
   209                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_PIO_MODE
   210                              <1> %endif ; MODULE_ADVANCED_ATA
   211                              <1> 
   212                              <1> 
   213                              <1> %ifdef MODULE_FEATURE_SETS
   214                              <1> ;;;	InitStandbyTimer
   215                              <1> 	; Initialize the standby timer (if supported)
   216                              <1> 	test	BYTE [di+DPT.bFlagsHigh], FLGH_DPT_POWER_MANAGEMENT_SUPPORTED
   217                              <1> 	jz		SHORT .NoPowerManagementSupport
   218                              <1> 
   219                              <1> 	mov		al, COMMAND_IDLE
   220                              <1> 	mov		dl, [cs:ROMVARS.bIdleTimeout]
   221                              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_BSY, FLG_STATUS_BSY)
   222                              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
   223                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_INITIALIZE_STANDBY_TIMER
   224                              <1> .NoPowerManagementSupport:
   225                              <1> %endif ; MODULE_FEATURE_SETS
   226                              <1> 
   227                              <1> 
   228                              <1> 	; There might have been several errors so just return one error code for them all
   229                              <1> .ReturnWithErrorCodeInAH:
   230                              <1> %ifdef MODULE_ADVANCED_ATA
   231                              <1> 	mov		ah, [di+DPT.bInitError]
   232                              <1> 	test		ah, ah	; Clears CF
   233                              <1> 	jz		SHORT .ReturnWithSuccess
   234                              <1> 	mov		ah, RET_HD_RESETFAIL
   235                              <1> 	stc
   236                              <1> .ReturnWithSuccess:
   237                              <1> %endif
   238                              <1> 
   239 00001BA9 5B                  <1> 	pop		bx
   240 00001BAA 5A                  <1> 	pop		dx
   241 00001BAB 5E                  <1> 	pop		si
   242 00001BAC 07                  <1> 	pop		es
   243 00001BAD C3                  <1> 	ret
   244                              <1> 
   245                              <1> 
   246                              <1> .rgbWriteCacheCommands:
   247 00001BAE 00                  <1> 	db		0								; DEFAULT_WRITE_CACHE
   248 00001BAF 82                  <1> 	db		FEATURE_DISABLE_WRITE_CACHE		; DISABLE_WRITE_CACHE
   249 00001BB0 02                  <1> 	db		FEATURE_ENABLE_WRITE_CACHE		; ENABLE_WRITE_CACHE
   250                              <1> 
   251                              <1> 
   252                              <1> 
   253                              <1> ;--------------------------------------------------------------------
   254                              <1> ; SetErrorFlagFromALwithErrorCodeInAH
   255                              <1> ;	Parameters:
   256                              <1> ;		AH:		BIOS Error Code
   257                              <1> ;		AL:		Error flag to set
   258                              <1> ;		DS:DI:		Ptr to DPT
   259                              <1> ;		CF:		Set if error code in AH
   260                              <1> ;				Clear if AH = 0
   261                              <1> ;	Returns:
   262                              <1> ;		CF:		Clear if no error
   263                              <1> ;				Set if error flag was set
   264                              <1> ;	Corrupts registers:
   265                              <1> ;		Nothing
   266                              <1> ;--------------------------------------------------------------------
   267                              <1> IgnoreInvalidCommandError:
   268 00001BB1 30E4                <1> 	xor		ah, ah	; Clears CF
   269                              <1> SetErrorFlagFromALwithErrorCodeInAH:
   270 00001BB3 7309                <1> 	jnc		SHORT .NoErrorFlagToSet
   271 00001BB5 80FC01              <1> 	cmp		ah, RET_HD_INVALID
   272 00001BB8 76F7                <1> 	jbe		SHORT IgnoreInvalidCommandError
   273                              <1> 
   274 00001BBA 084503              <1> 	or		[di+DPT.bInitError], al
   275 00001BBD F9                  <1> 	stc
   276                              <1> .NoErrorFlagToSet:
   277 00001BBE C3                  <1> 	ret
   278                              <1> 
   279                              <1> 
   280                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
   281                              <1> ;--------------------------------------------------------------------
   282                              <1> ; AH9h_SetModeFromALtoXTCF
   283                              <1> ;	Parameters:
   284                              <1> ;		AL:		XT-CF Mode to set
   285                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
   286                              <1> ;		SS:BP:		Ptr to IDEPACK
   287                              <1> ;	Returns:
   288                              <1> ;		AH:		Int 13h return status
   289                              <1> ;		CF:		Clear if successful or device is not XT-CF
   290                              <1> ;				Set if failed to set mode for XT-CF
   291                              <1> ;	Corrupts registers:
   292                              <1> ;		AL, BX, CX, DX, SI
   293                              <1> ;--------------------------------------------------------------------
   294                              <1> AH9h_SetModeFromALtoXTCF:
   295 00001BBF E824F1              <1> 	call		AccessDPT_IsThisDeviceXTCF
   296 00001BC2 75ED                <1> 	jne		SHORT IgnoreInvalidCommandError
   297 00001BC4 EB7A                <1> 	jmp		AH1Eh_ChangeXTCFmodeBasedOnModeInAL
   298                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
   299                              <1> 
   300                              <1> %ifdef MODULE_8BIT_IDE
   301                              <1> ;--------------------------------------------------------------------
   302                              <1> ; AH9h_Enable8bitModeForDevice8bitAta
   303                              <1> ;	Parameters:
   304                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
   305                              <1> ;		SS:BP:	Ptr to IDEPACK
   306                              <1> ;	Returns:
   307                              <1> ;		AH:		Int 13h return status
   308                              <1> ;		CF:		Clear if successful or device is not DEVICE_8BIT_ATA
   309                              <1> ;				Set if failed to set 8-bit mode for DEVICE_8BIT_ATA
   310                              <1> ;	Corrupts registers:
   311                              <1> ;		AL, BX, CX, DX, SI
   312                              <1> ;--------------------------------------------------------------------
   313                              <1> AH9h_Enable8bitModeForDevice8bitAta:
   314 00001BC6 807D0C04            <1> 	cmp		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_ATA
   315 00001BCA 75E5                <1> 	jne		SHORT IgnoreInvalidCommandError
   316 00001BCC E9B000              <1> 	jmp		AH23h_Enable8bitPioMode
   317                              <1> %endif
   267                                  	%include "AHCh_HSeek.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=Ch, Seek.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=Ch, Seek.
    25                              <1> ;
    26                              <1> ; AHCh_HandlerForSeek
    27                              <1> ;	Parameters:
    28                              <1> ;		CX, DH:	Same as in INTPACK
    29                              <1> ;		DL:		Translated Drive number
    30                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    31                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
    32                              <1> ;	Parameters on INTPACK:
    33                              <1> ;		CH:		Cylinder number, bits 7...0
    34                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
    35                              <1> ;				Bits 5...0:	Starting sector number (1...63)
    36                              <1> ;		DH:		Starting head number (0...255)
    37                              <1> ;	Returns with INTPACK:
    38                              <1> ;		AH:		BIOS Error code
    39                              <1> ;		CF:		0 if successful, 1 if error
    40                              <1> ;--------------------------------------------------------------------
    41                              <1> ALIGN JUMP_ALIGN
    42                              <1> AHCh_HandlerForSeek:
    43                              <1> %ifndef USE_186
    44 00001BCF E80300              <1> 	call	AHCh_SeekToCylinder
    45 00001BD2 E9B9FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    46                              <1> %else
    47                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    48                              <1> 	; Fall to AHCh_SeekToCylinder
    49                              <1> %endif
    50                              <1> 
    51                              <1> ;--------------------------------------------------------------------
    52                              <1> ; AHCh_SeekToCylinder
    53                              <1> ;	Parameters:
    54                              <1> ;		CH:		Cylinder number, bits 7...0
    55                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
    56                              <1> ;				Bits 5...0:	Starting sector number (1...63)
    57                              <1> ;		DH:		Starting head number (0...255)
    58                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    59                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
    60                              <1> ;	Returns:
    61                              <1> ;		AH:		BIOS Error code
    62                              <1> ;		CF:		0 if successful, 1 if error
    63                              <1> ;	Corrupts registers:
    64                              <1> ;		AL, BX, CX, DX
    65                              <1> ;--------------------------------------------------------------------
    66                              <1> AHCh_SeekToCylinder:
    67 00001BD5 B470                <1> 	mov		ah, COMMAND_SEEK
    68 00001BD7 BB40FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRDY)
    69 00001BDA E948F7              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
   268                                  	%include "AH10h_HReady.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=10h, Check Drive Ready.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=10h, Check Drive Ready.
    25                              <1> ;
    26                              <1> ; AH10h_HandlerForCheckDriveReady
    27                              <1> ;	Parameters:
    28                              <1> ;		DL:		Translated Drive number
    29                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    30                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
    31                              <1> ;	Returns with INTPACK:
    32                              <1> ;		AH:		Int 13h return status
    33                              <1> ;		CF:		0 if successful, 1 if error
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> ALIGN JUMP_ALIGN
    36                              <1> AH10h_HandlerForCheckDriveReady:
    37                              <1> %ifdef USE_186
    38                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    39                              <1> 	jmp		Device_SelectDrive
    40                              <1> %else
    41 00001BDD E863F8              <1> 	call	Device_SelectDrive
    42 00001BE0 E9ABFD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    43                              <1> %endif
   269                                  	%include "AH11h_HRecal.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=11h, Recalibrate.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=11h, Recalibrate.
    25                              <1> ;
    26                              <1> ; AH11h_HandlerForRecalibrate
    27                              <1> ;	Parameters:
    28                              <1> ;		DL:		Translated Drive number
    29                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    30                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
    31                              <1> ;	Returns with INTPACK:
    32                              <1> ;		AH:		BIOS Error code
    33                              <1> ;		CF:		0 if successful, 1 if error
    34                              <1> ;--------------------------------------------------------------------
    35                              <1> AH11h_HandlerForRecalibrate:
    36                              <1> %ifndef USE_186
    37 00001BE3 E80300              <1> 	call	AH11h_RecalibrateDrive
    38 00001BE6 E9A5FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    39                              <1> %else
    40                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    41                              <1> 	; Fall to AH11h_RecalibrateDrive
    42                              <1> %endif
    43                              <1> 
    44                              <1> 
    45                              <1> ;--------------------------------------------------------------------
    46                              <1> ; AH11h_HRecalibrate
    47                              <1> ;	Parameters:
    48                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    49                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
    50                              <1> ;	Returns:
    51                              <1> ;		AH:		BIOS Error code
    52                              <1> ;		CF:		0 if successful, 1 if error
    53                              <1> ;	Corrupts registers:
    54                              <1> ;		AL, BX, CX, DX
    55                              <1> ;--------------------------------------------------------------------
    56                              <1> AH11h_RecalibrateDrive:
    57                              <1> 	; Recalibrate command is optional, vendor specific and not even
    58                              <1> 	; supported on later ATA-standards. Let's do seek instead.
    59 00001BE9 B90100              <1> 	mov		cx, 1						; Seek to Cylinder 0, Sector 1
    60 00001BEC 30F6                <1> 	xor		dh, dh						; Head 0
    61 00001BEE EBE5                <1> 	jmp		AHCh_SeekToCylinder
   270                                  	%include "AH15h_HSize.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=15h, Read Disk Drive Size.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=15h, Read Disk Drive Size.
    25                              <1> ;
    26                              <1> ; AH15h_HandlerForReadDiskDriveSize
    27                              <1> ;	Parameters:
    28                              <1> ;		DL:		Translated Drive number
    29                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    30                              <1> ;		SS:BP:	Ptr to IDEPACK
    31                              <1> ;	Returns with INTPACK:
    32                              <1> ;		If successful:
    33                              <1> ;			AH:		Hard Disk: 3 (Hard disk accessible)
    34                              <1> ;                   Floppy:    1 (Floppy disk, without change detection)
    35                              <1> ;			CX:DX:	Total number of sectors
    36                              <1> ;			CF:		0
    37                              <1> ;		If failed:
    38                              <1> ;			AH:		0 (Drive not present)
    39                              <1> ;			CX:DX:	0
    40                              <1> ;			CF:		1
    41                              <1> ;--------------------------------------------------------------------
    42                              <1> AH15h_HandlerForReadDiskDriveSize:
    43                              <1> %ifdef MODULE_SERIAL_FLOPPY
    44                              <1> 	mov		cl, 1										; 1 = floppy disk, no change detection
    45                              <1> 
    46                              <1> 	test	dl,dl										; DO NOT store the sector count if this is a
    47                              <1> 	jns		.FloppyDrive								; floppy disk, some OS's depend on this not
    48                              <1> 														; happening for floppies in order to boot.
    49                              <1> %endif
    50                              <1> 
    51 00001BF0 E81900              <1> 	call	AH15h_GetSectorCountToBXDXAX
    52 00001BF3 895619              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.cx], dx			; HIWORD to CX
    53 00001BF6 874617              <1> 	xchg	[bp+IDEPACK.intpack+INTPACK.dx], ax			; LOWORD to DX, AL gets drive number
    54                              <1> 
    55 00001BF9 30E4                <1> 	xor		ah, ah
    56                              <1> %ifdef MODULE_SERIAL_FLOPPY
    57                              <1> 	mov		cl, 3										; 3 = Hard Disk Accessible
    58                              <1> .FloppyDrive:
    59                              <1> 
    60                              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH_ALHasDriveNumber	; Store success to BDA and CF
    61                              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ah], cl
    62                              <1> %else
    63 00001BFB E8D2FD              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH	; Store success to BDA and CF
    64 00001BFE C6461C03            <1> 	mov		BYTE [bp+IDEPACK.intpack+INTPACK.ah], 3
    65                              <1> %endif
    66                              <1> 
    67 00001C02 E98CFD              <1> 	jmp		Int13h_ReturnFromHandlerWithoutStoringErrorCode
    68                              <1> 
    69                              <1> 
    70                              <1> ;--------------------------------------------------------------------
    71                              <1> ; AH15h_GetSectorCountFromForeignDriveToDXAX:
    72                              <1> ; AH15h_GetSectorCountToBXDXAX:
    73                              <1> ;	Parameters:
    74                              <1> ;		DL:		Drive number (AH15h_GetSectorCountFromForeignDriveToDXAX only)
    75                              <1> ;		DS:		RAMVARS segment
    76                              <1> ;		DS:DI:	Ptr to DPT (AH15h_GetSectorCountToDXAX only)
    77                              <1> ;	Returns:
    78                              <1> ;		DX:AX:	Total sector count
    79                              <1> ;		BX:		Zero
    80                              <1> ;	Corrupts registers:
    81                              <1> ;		CX
    82                              <1> ;--------------------------------------------------------------------
    83                              <1> %ifdef MODULE_BOOT_MENU
    84                              <1> AH15h_GetSectorCountFromForeignDriveToDXAX:
    85 00001C05 B408                <1> 	mov		ah, GET_DRIVE_PARAMETERS
    86 00001C07 E89BFD              <1> 	call	Int13h_CallPreviousInt13hHandler
    87 00001C0A EB03                <1> 	jmp		SHORT ConvertAH08hReturnValuesToSectorCount
    88                              <1> %endif
    89                              <1> 
    90                              <1> AH15h_GetSectorCountToBXDXAX:
    91 00001C0C E8EAFE              <1> 	call	AH8h_GetDriveParameters
    92                              <1> 	; Fall to ConvertAH08hReturnValuesToSectorCount
    93                              <1> 
    94                              <1> ConvertAH08hReturnValuesToSectorCount:
    95 00001C0F E8A800              <1> 	call	Address_ExtractLCHSparametersFromOldInt13hAddress
    96 00001C12 88F8                <1> 	mov		al, bh		; AL = Max head number
    97 00001C14 41                  <1> 	inc		cx			; Max cylinder number to cylinder count
    98 00001C15 40                  <1> 	inc		ax			; Max head number to head count (AH=8h returns max 254 so no overflow to AH)
    99 00001C16 F6E3                <1> 	mul		bl			; AX = Head count * Sectors per track
   100 00001C18 F7E1                <1> 	mul		cx			; DX:AX = Total sector count for AH=0xh transfer functions
   101 00001C1A 31DB                <1> 	xor		bx, bx
   102 00001C1C C3                  <1> 	ret
   271                                  %ifdef MODULE_8BIT_IDE_ADVANCED
   272                                  	%include "AH1Eh_XTCF.asm"
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=1Eh, Lo-tech XT-CF features
     3                              <1> ;
     4                              <1> ; More information at http://www.lo-tech.co.uk/XT-CF
     5                              <1> 
     6                              <1> ;
     7                              <1> ; XTIDE Universal BIOS and Associated Tools
     8                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     9                              <1> ;
    10                              <1> ; This program is free software; you can redistribute it and/or modify
    11                              <1> ; it under the terms of the GNU General Public License as published by
    12                              <1> ; the Free Software Foundation; either version 2 of the License, or
    13                              <1> ; (at your option) any later version.
    14                              <1> ;
    15                              <1> ; This program is distributed in the hope that it will be useful,
    16                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                              <1> ; GNU General Public License for more details.
    19                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    20                              <1> ;
    21                              <1> 
    22                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    23                              <1> 
    24                              <1> ; Section containing code
    25                              <1> SECTION .text
    26                              <1> 
    27                              <1> ;--------------------------------------------------------------------
    28                              <1> ; Int 13h function AH=1Eh, Lo-tech XT-CF features.
    29                              <1> ; This function is supported only by XTIDE Universal BIOS.
    30                              <1> ;
    31                              <1> ; AH1Eh_HandlerForXTCFfeatures
    32                              <1> ;	Parameters:
    33                              <1> ;		AL, CX:		Same as in INTPACK
    34                              <1> ;		DL:		Translated Drive number
    35                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
    36                              <1> ;		SS:BP:		Ptr to IDEPACK
    37                              <1> ;	Parameters on INTPACK:
    38                              <1> ;		AL:		XT-CF subcommand (see XTCF.inc for more info)
    39                              <1> ;	Returns with INTPACK:
    40                              <1> ;		AH:		Int 13h return status
    41                              <1> ;		CF:		0 if successful, 1 if error
    42                              <1> ;--------------------------------------------------------------------
    43                              <1> AH1Eh_HandlerForXTCFfeatures:
    44                              <1> %ifndef USE_186
    45 00001C1D E80300              <1> 	call	ProcessXTCFsubcommandFromAL
    46 00001C20 E96BFD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    47                              <1> %else
    48                              <1> 	push		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    49                              <1> 	; Fall to ProcessXTCFsubcommandFromAL
    50                              <1> %endif
    51                              <1> 
    52                              <1> 
    53                              <1> ;--------------------------------------------------------------------
    54                              <1> ; ProcessXTCFsubcommandFromAL
    55                              <1> ;	Parameters:
    56                              <1> ;		AL:		XT-CF subcommand (see XTCF.inc for more info)
    57                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
    58                              <1> ;		SS:BP:		Ptr to IDEPACK
    59                              <1> ;	Returns:
    60                              <1> ;		AH:		Int 13h return status
    61                              <1> ;		CF:		0 if successful, 1 if error
    62                              <1> ;	Corrupts registers:
    63                              <1> ;		AL, BX, CX, DX, SI
    64                              <1> ;--------------------------------------------------------------------
    65                              <1> ProcessXTCFsubcommandFromAL:
    66                              <1> 	; IS_THIS_DRIVE_XTCF. We check this for all commands.
    67 00001C23 E8C0F0              <1> 	call	AccessDPT_IsThisDeviceXTCF
    68 00001C26 7541                <1> 	jne	XTCFnotFound
    69 00001C28 83E07F              <1> 	and		ax, BYTE 7Fh				; Subcommand now in AX (clears AH and CF)
    70 00001C2B 7408                <1> 	jz	.ReturnWithSuccess				; Sub-function IS_THIS_DRIVE_XTCF (=0)
    71                              <1> 
    72 00001C2D 48                  <1> 	dec		ax					; Test subcommand...
    73 00001C2E 7406                <1> 	jz	.GetXTCFtransferMode				; ...for value 1 (GET_XTCF_TRANSFER_MODE)
    74 00001C30 48                  <1> 	dec		ax					; Test subcommand...
    75 00001C31 740A                <1> 	jz	.SetXTCFtransferMode				; ...for value 2 (SET_XTCF_TRANSFER_MODE)
    76 00001C33 EB34                <1> 	jmp	XTCFnotFound					; otherwise, invalid sub-function requested
    77                              <1> 
    78                              <1> .ReturnWithSuccess:
    79 00001C35 C3                  <1> 	ret							; return with AH and CF cleared
    80                              <1> 
    81                              <1> .GetXTCFtransferMode:
    82 00001C36 8A450C              <1> 	mov		al, BYTE [di+DPT_ATA.bDevice]		; get current mode from DPT
    83 00001C39 884618              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dh], al	; and return mode via INTPACK...
    84 00001C3C C3                  <1> 	ret							; ...with AH and CF cleared
    85                              <1> 
    86                              <1> .SetXTCFtransferMode:
    87 00001C3D 8A4618              <1> 	mov		al, [bp+IDEPACK.intpack+INTPACK.dh]	; get specified mode (eg XTCF_DMA_MODE) 
    88                              <1> 	; and fall to AH1Eh_ChangeXTCFmodeBasedOnControlRegisterInAL
    89                              <1> 
    90                              <1> 
    91                              <1> ;--------------------------------------------------------------------
    92                              <1> ; AH1Eh_ChangeXTCFmodeBasedOnModeInAL
    93                              <1> ;	Parameters:
    94                              <1> ;		AL:		XT-CF Mode (see XTCF.inc)
    95                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
    96                              <1> ;		SS:BP:		Ptr to IDEPACK
    97                              <1> ;	Returns:	
    98                              <1> ;		AH:		Int 13h return status
    99                              <1> ;		CF:		0 if successful, 1 if error
   100                              <1> ;	Corrupts registers:
   101                              <1> ;		AL, BX, CX, DX, SI
   102                              <1> ;--------------------------------------------------------------------
   103                              <1> AH1Eh_ChangeXTCFmodeBasedOnModeInAL:
   104                              <1> 	; Note: Control register (as of XT-CFv3) is now a write-only register,
   105                              <1> 	;       whos purpose is *only* to raise DRQ.  The register cannot be read.
   106                              <1> 	;       Selected transfer mode is stored in BIOS variable (DPT_ATA.bDevice).
   107                              <1> 
   108                              <1> 	; We always need to enable 8-bit mode since 16-bit mode is restored
   109                              <1> 	; when controller is reset (AH=00h or 0Dh)
   110                              <1> 	; 
   111                              <1> 	; Note that when selecting 'DEVICE_8BIT_PIO_MODE_WITH_BIU_OFFLOAD' mode,
   112                              <1> 	; the ATA device (i.e. CompactFlash card) will operate in 8-bit mode, but
   113                              <1> 	; data will be transferred from it's data register using 16-bit CPU instructions
   114                              <1> 	; like REP INSW.  This works because XT-CF adapters are 8-bit cards, and
   115                              <1> 	; the BIU in the machine splits each WORD requested by the CPU into two 8-bit
   116                              <1> 	; ISA cycles at base+0h and base+1h.  The XT-CF cards do not decode A0, hence
   117                              <1> 	; both accesses appear the same to the card and the BIU then re-constructs
   118                              <1> 	; the data for presentation to the CPU.
   119                              <1> 	;
   120                              <1> 	; Also note though that some machines, noteably AT&T PC6300, have hardware
   121                              <1> 	; errors in the BIU logic, resulting in reversed byte ordering.  Therefore,
   122                              <1> 	; mode DEVICE_8BIT_PIO is the default transfer mode for best system
   123                              <1> 	; compatibility.
   124                              <1> 
   125                              <1> 	ePUSH_T	bx, AH23h_Enable8bitPioMode
   125                              <2> %ifndef USE_186
   125                              <2>  %ifidni %2, 0
   125                              <2>  xor %1, %1
   125                              <2>  %else
   125 00001C40 BB[7F1C]            <2>  mov %1, %2
   125                              <2>  %endif
   125 00001C43 53                  <2>  push %1
   125                              <2> 
   125                              <2> %else
   125                              <2>  push %2
   125                              <2> %endif
   126                              <1> 
   127                              <1> 	; Convert mode to device type (see XTCF.inc for full details)
   128 00001C44 0400                <1> 	add		al, 0			; XTCF_8BIT_PIO_MODE = 0
   129 00001C46 7408                <1> 	jz	.Set8bitPioMode
   130 00001C48 FEC8                <1> 	dec		al			; XTCF_8BIT_PIO_MODE_WITH_BIU_OFFLOAD = 1
   131 00001C4A 7409                <1> 	jz	.Set8bitPioModeWithBIUOffload
   132 00001C4C FEC8                <1> 	dec		al			; XTCF_DMA_MODE = 2
   133 00001C4E 740A                <1> 	jz	.SetDMATransferMode
   134                              <1> 	; any other value, set PIO 8-bit mode anyway so fall to .Set8bitPioMode
   135                              <1> 
   136                              <1> .Set8bitPioMode:
   137 00001C50 C6450C0A            <1> 	mov		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_XTCF_PIO8
   138 00001C54 C3                  <1> 	ret		; through AH23h_Enable8bitPioMode
   139                              <1> 
   140                              <1> .Set8bitPioModeWithBIUOffload:
   141 00001C55 C6450C0C            <1> 	mov		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
   142 00001C59 C3                  <1> 	ret		; through AH23h_Enable8bitPioMode
   143                              <1> 
   144                              <1> .SetDMATransferMode:
   145 00001C5A C6450C0E            <1> 	mov		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_XTCF_DMA
   146                              <1> 	; DMA transfers have limited block size, which is checked in AH24h_SetBlockSize
   147 00001C5E 8A450D              <1> 	mov		al, [di+DPT_ATA.bBlockSize]
   148 00001C61 EB27                <1> 	jmp	AH24h_SetBlockSize
   149                              <1> 	; exit via ret in AH24_SetBlockSize then through AH23h_Enable8bitPioMode
   150                              <1> 
   151                              <1> 
   152                              <1> ;--------------------------------------------------------------------
   153                              <1> ; AH1Eh_DetectXTCFwithBasePortInDX
   154                              <1> ;	Parameters:
   155                              <1> ;		DX:		Base I/O port address to check
   156                              <1> ;	Returns:
   157                              <1> ;		AH:		RET_HD_SUCCESS if XT-CF is found from port
   158                              <1> ;				RET_HD_INVALID if XT-CF is not found
   159                              <1> ;		CF:		Cleared if XT-CF found
   160                              <1> ;				Set if XT-CF not found
   161                              <1> ;	Corrupts registers:
   162                              <1> ;		AL
   163                              <1> ;--------------------------------------------------------------------
   164                              <1> AH1Eh_DetectXTCFwithBasePortInDX:
   165                              <1> ; Note this detection routine is not possible now, since the control
   166                              <1> ; register cannot be read.
   167                              <1> ; 
   168                              <1> ; Hard-coded to return found at 300h, to enable testing of the rest of the
   169                              <1> ; BIOS.
   170                              <1> ;
   171                              <1> ;	push		dx
   172                              <1> ;	add		dl, XTCF_CONTROL_REGISTER_INVERTED_in	; set DX to XT-CF config register (inverted)
   173                              <1> ;	in		al, dx		; get value
   174                              <1> ;	mov		ah, al		; save in ah
   175                              <1> ;	inc		dx			; set DX to XT-CF config register (non-inverted)
   176                              <1> ;	in		al, dx		; get value
   177                              <1> ;	not		al			; invert value
   178                              <1> ;	pop		dx
   179                              <1> ;	sub		ah, al		; do they match? (clear AH if they do)
   180                              <1> ;	jz		SHORT XTCFfound
   181                              <1> ;
   182 00001C63 81FA0003            <1> 	cmp		dx, 300h
   183 00001C67 7403                <1> 	je	XTCFfound
   184                              <1> 
   185                              <1> XTCFnotFound:
   186                              <1> AH1Eh_LoadInvalidCommandToAHandSetCF:
   187 00001C69 F9                  <1> 	stc					; set carry flag since XT-CF not found
   188 00001C6A B401                <1> 	mov		ah, RET_HD_INVALID
   189                              <1> XTCFfound:
   190 00001C6C C3                  <1> 	ret					; and return
   191                              <1> 
   273                                  %endif
   274                                  	%include "AH23h_HFeatures.asm"	; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=23h,
     3                              <1> ;					Set Controller Features Register.
     4                              <1> 
     5                              <1> ;
     6                              <1> ; XTIDE Universal BIOS and Associated Tools
     7                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     8                              <1> ;
     9                              <1> ; This program is free software; you can redistribute it and/or modify
    10                              <1> ; it under the terms of the GNU General Public License as published by
    11                              <1> ; the Free Software Foundation; either version 2 of the License, or
    12                              <1> ; (at your option) any later version.
    13                              <1> ;
    14                              <1> ; This program is distributed in the hope that it will be useful,
    15                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    16                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17                              <1> ; GNU General Public License for more details.
    18                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    19                              <1> ;
    20                              <1> 
    21                              <1> ; Section containing code
    22                              <1> SECTION .text
    23                              <1> 
    24                              <1> ;--------------------------------------------------------------------
    25                              <1> ; Int 13h function AH=23h, Set Controller Features Register.
    26                              <1> ;
    27                              <1> ; AH23h_HandlerForSetControllerFeatures
    28                              <1> ;	Parameters:
    29                              <1> ;		AL, CX:	Same as in INTPACK
    30                              <1> ;		DL:		Translated Drive number
    31                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    32                              <1> ;		SS:BP:	Ptr to IDEPACK
    33                              <1> ;	Parameters on INTPACK:
    34                              <1> ;		AL:		Feature Number (parameter to Features Register = subcommand)
    35                              <1> ;	(Parameter registers are undocumented, these are specific for this BIOS):
    36                              <1> ;		BL:		Parameter to Sector Count Register (subcommand specific)
    37                              <1> ;		BH:		Parameter to LBA Low / Sector Number Register (subcommand specific)
    38                              <1> ;		CL:		Parameter to LBA Middle / Cylinder Low Register (subcommand specific)
    39                              <1> ;		CH:		Parameter to LBA High / Cylinder High Register (subcommand specific)
    40                              <1> ;	Returns with INTPACK:
    41                              <1> ;		AH:		Int 13h return status
    42                              <1> ;		CF:		0 if successful, 1 if error
    43                              <1> ;--------------------------------------------------------------------
    44                              <1> AH23h_HandlerForSetControllerFeatures:
    45 00001C6D 96                  <1> 	xchg	si, ax		; SI = Feature Number
    46 00001C6E 8B5615              <1> 	mov		dx, [bp+IDEPACK.intpack+INTPACK.bx]
    47                              <1> %ifndef USE_186
    48 00001C71 E80300              <1> 	call	AH23h_SetControllerFeatures
    49 00001C74 E917FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    50                              <1> %else
    51                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    52                              <1> 	; Fall to AH23h_SetControllerFeatures
    53                              <1> %endif
    54                              <1> 
    55                              <1> 
    56                              <1> ;--------------------------------------------------------------------
    57                              <1> ; AH23h_SetControllerFeatures
    58                              <1> ;	Parameters:
    59                              <1> ;		DL:		Parameter to Sector Count Register (subcommand specific)
    60                              <1> ;		DH:		Parameter to LBA Low / Sector Number Register (subcommand specific)
    61                              <1> ;		CL:		Parameter to LBA Middle / Cylinder Low Register (subcommand specific)
    62                              <1> ;		CH:		Parameter to LBA High / Cylinder High Register (subcommand specific)
    63                              <1> ;		SI:		Feature Number (parameter to Features Register = subcommand)
    64                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    65                              <1> ;		SS:BP:	Ptr to IDEPACK
    66                              <1> ;	Returns:
    67                              <1> ;		AH:		Int 13h return status
    68                              <1> ;		CF:		0 if successful, 1 if error
    69                              <1> ;	Corrupts registers:
    70                              <1> ;		AL, BX, CX, DX
    71                              <1> ;--------------------------------------------------------------------
    72                              <1> AH23h_SetControllerFeatures:
    73 00001C77 B0EF                <1> 	mov		al, COMMAND_SET_FEATURES
    74 00001C79 BB802F              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_BSY, FLG_STATUS_BSY)
    75 00001C7C E9C8F6              <1> 	jmp		Idepack_StoreNonExtParametersAndIssueCommandFromAL
    76                              <1> 
    77                              <1> 
    78                              <1> ;--------------------------------------------------------------------
    79                              <1> ; AH23h_Enable8bitPioMode
    80                              <1> ;	Parameters:
    81                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    82                              <1> ;		SS:BP:	Ptr to IDEPACK
    83                              <1> ;	Returns:
    84                              <1> ;		AH:		Int 13h return status
    85                              <1> ;		CF:		0 if successful, 1 if error
    86                              <1> ;	Corrupts registers:
    87                              <1> ;		AL, BX, CX, DX, SI
    88                              <1> ;--------------------------------------------------------------------
    89                              <1> %ifdef MODULE_8BIT_IDE
    90                              <1> AH23h_Enable8bitPioMode:
    91 00001C7F BE0100              <1> 	mov		si, FEATURE_ENABLE_8BIT_PIO_TRANSFER_MODE
    92 00001C82 EBF3                <1> 	jmp		SHORT AH23h_SetControllerFeatures
    93                              <1> %endif
   275                                  	%include "AH24h_HSetBlocks.asm"	; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=24h, Set Multiple Blocks.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
    21                              <1> 
    22                              <1> ; Section containing code
    23                              <1> SECTION .text
    24                              <1> 
    25                              <1> ;--------------------------------------------------------------------
    26                              <1> ; Int 13h function AH=24h, Set Multiple Blocks.
    27                              <1> ;
    28                              <1> ; AH24h_HandlerForSetMultipleBlocks
    29                              <1> ;	Parameters:
    30                              <1> ;		AL:		Same as in INTPACK
    31                              <1> ;		DL:		Translated Drive number
    32                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    33                              <1> ;		SS:BP:	Ptr to IDEPACK
    34                              <1> ;	Parameters on INTPACK:
    35                              <1> ;		AL:		Number of Sectors per Block (1, 2, 4, 8, 16, 32, 64 or 128)
    36                              <1> ;	Returns with INTPACK:
    37                              <1> ;		AH:		Int 13h return status
    38                              <1> ;		CF:		0 if successful, 1 if error
    39                              <1> ;--------------------------------------------------------------------
    40                              <1> AH24h_HandlerForSetMultipleBlocks:
    41                              <1> %ifndef USE_186
    42 00001C84 E80300              <1> 	call	AH24h_SetBlockSize
    43 00001C87 E904FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    44                              <1> %else
    45                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    46                              <1> 	; Fall to AH24h_SetBlockSize
    47                              <1> %endif
    48                              <1> 
    49                              <1> 
    50                              <1> ;--------------------------------------------------------------------
    51                              <1> ; AH24h_SetBlockSize
    52                              <1> ;	Parameters:
    53                              <1> ;		AL:		Number of Sectors per Block (1, 2, 4, 8, 16, 32, 64 or 128)
    54                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
    55                              <1> ;		SS:BP:		Ptr to IDEPACK
    56                              <1> ;	Returns:
    57                              <1> ;		AH:		Int 13h return status
    58                              <1> ;		CF:		0 if successful, 1 if error
    59                              <1> ;	Corrupts registers:
    60                              <1> ;		AL, CX, DX
    61                              <1> ;--------------------------------------------------------------------
    62                              <1> AH24h_SetBlockSize:
    63                              <1> %ifdef MODULE_8BIT_IDE
    64                              <1> 	; XT-CFv3 does not support largest block size in DMA mode,
    65                              <1> 	; so check for that device:
    66 00001C8A 807D0C0E            <1> 	cmp		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_XTCF_DMA
    67 00001C8E 7506                <1> 	jne	.SetBlockSize
    68                              <1> 	; XT-CFv3 in DMA mode selected - check requested block size
    69 00001C90 3C40                <1> 	cmp		al, XTCF_DMA_MODE_MAX_BLOCK_SIZE
    70 00001C92 7602                <1> 	jbe	.SetBlockSize
    71                              <1> 	; Otherwise, limit block size to maximum permitted
    72 00001C94 B040                <1> 	mov		al, XTCF_DMA_MODE_MAX_BLOCK_SIZE
    73                              <1> .SetBlockSize:
    74                              <1> %endif ; MODULE_8BIT_IDE
    75 00001C96 53                  <1> 	push		bx
    76 00001C97 50                  <1> 	push		ax
    77 00001C98 92                  <1> 	xchg		dx, ax				; DL = Block size (Sector Count Register)
    78 00001C99 B0C6                <1> 	mov		al, COMMAND_SET_MULTIPLE_MODE
    79 00001C9B BB402F              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRDY, FLG_STATUS_DRDY)
    80 00001C9E E8A6F6              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
    81 00001CA1 5B                  <1> 	pop		bx				; BL = Block size (preserve AH)
    82 00001CA2 7302                <1> 	jnc	SHORT .StoreBlockSize
    83 00001CA4 B301                <1> 	mov		bl, 1				; Block size 1 will always work
    84                              <1> .StoreBlockSize:					; Store new block size to DPT and return
    85 00001CA6 885D0D              <1> 	mov		[di+DPT_ATA.bBlockSize], bl
    86 00001CA9 5B                  <1> 	pop		bx
    87 00001CAA C3                  <1> 	ret
    88                              <1> 
   276                                  	%include "AH25h_HDrvID.asm"		; Required by Int13h_Jump.asm
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Int 13h function AH=25h, Get Drive Information.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Int 13h function AH=25h, Get Drive Information.
    25                              <1> ;
    26                              <1> ; AH25h_HandlerForGetDriveInformation
    27                              <1> ;	Parameters:
    28                              <1> ;		ES:		Same as in INTPACK
    29                              <1> ;		DL:		Translated Drive number
    30                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    31                              <1> ;		SS:BP:	Ptr to IDEPACK
    32                              <1> ;	Parameters on INTPACK:
    33                              <1> ;		ES:BX:	Ptr to buffer to receive 512-byte drive information
    34                              <1> ;	Returns with INTPACK:
    35                              <1> ;		AH:		Int 13h return status
    36                              <1> ;		CF:		0 if successful, 1 if error
    37                              <1> ;--------------------------------------------------------------------
    38                              <1> AH25h_HandlerForGetDriveInformation:
    39 00001CAB B801EC              <1> 	mov		ax, (COMMAND_IDENTIFY_DEVICE << 8 | 1)		; Read 1 sector
    40 00001CAE E86F00              <1> 	call	Prepare_BufferToESSIforOldInt13hTransfer	; Preserves AX
    41 00001CB1 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
    42                              <1> %ifdef USE_186
    43                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    44                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
    45                              <1> %else
    46 00001CB4 E86EF6              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
    47 00001CB7 E9D4FC              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
    48                              <1> %endif
   277                                  	%include "Address.asm"			; For sector address translations
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for address translations.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;---------------------------------------------------------------------
    24                              <1> ; Address_ExtractLCHSparametersFromOldInt13hAddress
    25                              <1> ;	Parameters:
    26                              <1> ;		CH:		Cylinder number, bits 7...0
    27                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
    28                              <1> ;				Bits 5...0:	Sector number
    29                              <1> ;		DH:		Head number
    30                              <1> ;	Returns:
    31                              <1> ;		BL:		Sector number (1...63)
    32                              <1> ;		BH:		Head number (0...255)
    33                              <1> ;		CX:		Cylinder number (0...1023)
    34                              <1> ;	Corrupts registers:
    35                              <1> ;		Nothing
    36                              <1> ;--------------------------------------------------------------------
    37                              <1> ALIGN JUMP_ALIGN
    38                              <1> Address_ExtractLCHSparametersFromOldInt13hAddress:
    39 00001CBA 88CB                <1> 	mov		bl, cl				; Copy sector number...
    40 00001CBC 80E33F              <1> 	and		bl, 3Fh				; ...and limit to 1...63
    41 00001CBF 28D9                <1> 	sub		cl, bl				; Remove from cylinder number high
    42                              <1> 	eROL_IM	cl, 2				; High bits to beginning
    42                              <2>  eSHIFT_IM %1, %2, rol
    42                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
    42                              <3> %ifndef USE_186
    42                              <3>  %ifidni %1, cl
    42 00001CC1 D0C1<rept>          <3>  times %2 %3 %1, 1
    42                              <3>  %elifidni %1, ch
    42                              <3>  times %2 %3 %1, 1
    42                              <3>  %elifidni %1, cx
    42                              <3>  times %2 %3 %1, 1
    42                              <3>  %else
    42                              <3>  %if %2 > 3
    42                              <3>  push cx
    42                              <3>  mov cl, %2
    42                              <3>  %3 %1, cl
    42                              <3>  pop cx
    42                              <3>  %else
    42                              <3>  times %2 %3 %1, 1
    42                              <3>  %endif
    42                              <3>  %endif
    42                              <3> 
    42                              <3> %else
    42                              <3>  %3 %1, %2
    42                              <3> %endif
    42                              <3> %endif
    43 00001CC5 88F7                <1> 	mov		bh, dh				; Copy Head number
    44 00001CC7 86CD                <1> 	xchg	cl, ch				; Cylinder number now in CX
    45 00001CC9 C3                  <1> 	ret
    46                              <1> 
    47                              <1> 
    48                              <1> ;---------------------------------------------------------------------
    49                              <1> ; Converts LARGE addressing mode LCHS parameters to IDE P-CHS parameters.
    50                              <1> ; PCylinder	= (LCylinder << n) + (LHead / PHeadCount)
    51                              <1> ; PHead		= LHead % PHeadCount
    52                              <1> ; PSector	= LSector
    53                              <1> ;
    54                              <1> ; ConvertLargeModeLCHStoPCHS:
    55                              <1> ;	Parameters:
    56                              <1> ;		BL:		Sector number (1...63)
    57                              <1> ;		BH:		Head number (0...239)
    58                              <1> ;		CX:		Cylinder number (0...1023)
    59                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
    60                              <1> ;	Returns:
    61                              <1> ;		BL:		Sector number (1...63)
    62                              <1> ;		BH:		Head number (0...15)
    63                              <1> ;		CX:		Cylinder number (0...16382)
    64                              <1> ;	Corrupts registers:
    65                              <1> ;		AX, DX
    66                              <1> ;--------------------------------------------------------------------
    67                              <1> ALIGN JUMP_ALIGN
    68                              <1> ConvertLargeModeLCHStoPCHS:
    69                              <1> 	; LHead / PHeadCount and LHead % PHeadCount
    70                              <1> 	eMOVZX	ax, bh					; Copy L-CHS Head number to AX
    70                              <2> %ifndef USE_386
    70                              <2>  %ifidni %1, ax
    70 00001CCA 88F8                <2>  mov al, %2
    70 00001CCC 30E4                <2>  xor ah, ah
    70                              <2>  %elifidni %1, bx
    70                              <2>  mov bl, %2
    70                              <2>  xor bh, bh
    70                              <2>  %elifidni %1, cx
    70                              <2>  mov cl, %2
    70                              <2>  xor ch, ch
    70                              <2>  %elifidni %1, dx
    70                              <2>  mov dl, %2
    70                              <2>  xor dh, dh
    70                              <2>  %else
    70                              <2>  push ax
    70                              <2>  mov al, %2
    70                              <2>  xor ah, ah
    70                              <2>  xchg ax, %1
    70                              <2>  pop ax
    70                              <2>  %endif
    70                              <2> 
    70                              <2> %else
    70                              <2>  movzx %1, %2
    70                              <2> %endif
    71 00001CCE F6750A              <1> 	div		BYTE [di+DPT.bPchsHeads]; AL = LHead / PHeadCount, AH = LHead % PHeadCount
    72 00001CD1 88E7                <1> 	mov		bh, ah					; Copy P-CHS Head number to BH
    73 00001CD3 30E4                <1> 	xor		ah, ah					; AX = LHead / PHeadCount
    74                              <1> 
    75                              <1> 	; (LCylinder << n) + (LHead / PHeadCount)
    76 00001CD5 89CA                <1> 	mov		dx, cx					; Copy L-CHS Cylinder number to DX
    77 00001CD7 8A0D                <1> 	mov		cl, [di+DPT.bFlagsLow]	; Load shift count
    78 00001CD9 80E103              <1> 	and		cl, MASKL_DPT_CHS_SHIFT_COUNT
    79 00001CDC D3E2                <1> 	shl		dx, cl					; DX = LCylinder << n
    80 00001CDE 01D0                <1> 	add		ax, dx					; AX = P-CHS Cylinder number
    81 00001CE0 91                  <1> 	xchg	cx, ax					; Move P-CHS Cylinder number to CX
    82                              <1> DoNotConvertLCHS:
    83 00001CE1 C3                  <1> 	ret
    84                              <1> 
    85                              <1> 
    86                              <1> ;--------------------------------------------------------------------
    87                              <1> ; Address_OldInt13hAddressToIdeAddress
    88                              <1> ;	Parameters:
    89                              <1> ;		CH:		Cylinder number, bits 7...0
    90                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
    91                              <1> ;				Bits 5...0:	Starting sector number (1...63)
    92                              <1> ;		DH:		Starting head number (0...255)
    93                              <1> ;		DS:DI:	Ptr to DPT
    94                              <1> ;	Returns:
    95                              <1> ;		BL:		LBA Low Register / Sector Number Register (LBA 7...0)
    96                              <1> ;		CL:		LBA Mid Register / Low Cylinder Register (LBA 15...8)
    97                              <1> ;		CH:		LBA High Register / High Cylinder Register (LBA 23...16)
    98                              <1> ;		BH:		Drive and Head Register (LBA 27...24)
    99                              <1> ;	Corrupts registers:
   100                              <1> ;		AX, DX
   101                              <1> ;--------------------------------------------------------------------
   102                              <1> ALIGN JUMP_ALIGN
   103                              <1> Address_OldInt13hAddressToIdeAddress:
   104 00001CE2 E8D5FF              <1> 		call	Address_ExtractLCHSparametersFromOldInt13hAddress
   105                              <1> 		ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF
   105 00001CE5 8A05                <2>  mov al, [di+DPT.bFlagsLow]
   105 00001CE7 83E00C              <2>  and ax, BYTE MASKL_DPT_TRANSLATEMODE
   106                              <1> 
   107                              <1> ;;; 0: ADDRESSING_MODE_NORMAL
   108 00001CEA 74F5                <1> 		jz		SHORT DoNotConvertLCHS
   109                              <1> 
   110                              <1> ;;; 1: ADDRESSING_MODE_LARGE
   111 00001CEC A808                <1> 		test	al, FLGL_DPT_ASSISTED_LBA
   112 00001CEE 74DA                <1> 		jz		SHORT ConvertLargeModeLCHStoPCHS
   113                              <1> 
   114                              <1> ;;; 2: ADDRESSING_MODE_ASSISTED_LBA
   115                              <1> 		; Fall through to ConvertAssistedLBAModeLCHStoLBARegisterValues
   116                              <1> 
   117                              <1> 
   118                              <1> ;---------------------------------------------------------------------
   119                              <1> ; Converts LCHS parameters to 28-bit LBA address.
   120                              <1> ; Only 24-bits are used since LHCS to LBA28 conversion has 8.4GB limit.
   121                              <1> ; LBA = ((cylToSeek*headsPerCyl+headToSeek)*sectPerTrack)+sectToSeek-1
   122                              <1> ;
   123                              <1> ; Returned address is in same registers that
   124                              <1> ; DoNotConvertLCHS and ConvertLargeModeLCHStoPCHS returns.
   125                              <1> ;
   126                              <1> ; ConvertAssistedLBAModeLCHStoLBARegisterValues:
   127                              <1> ;	Parameters:
   128                              <1> ;		BL:		Sector number (1...63)
   129                              <1> ;		BH:		Head number (0...254)
   130                              <1> ;		CX:		Cylinder number (0...1023)
   131                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
   132                              <1> ;	Returns:
   133                              <1> ;		BL:		LBA Low Register / Sector Number Register (LBA 7...0)
   134                              <1> ;		CL:		LBA Mid Register / Low Cylinder Register (LBA 15...8)
   135                              <1> ;		CH:		LBA High Register / High Cylinder Register (LBA 23...16)
   136                              <1> ;		BH:		Drive and Head Register (LBA 27...24)
   137                              <1> ;	Corrupts registers:
   138                              <1> ;		AX, DX
   139                              <1> ;--------------------------------------------------------------------
   140                              <1> ConvertAssistedLBAModeLCHStoLBARegisterValues:
   141                              <1> 	; cylToSeek*headsPerCyl (18-bit result)
   142                              <1> 	; Max = 1023 * 255 = 260,865 = 3FB01h
   143 00001CF0 B83F00              <1> 	mov		ax, LBA_ASSIST_SPT		; Load Sectors per Track
   144 00001CF3 91                  <1> 	xchg	cx, ax					; Cylinder number to AX, Sectors per Track to CX
   145                              <1> %ifdef USE_386
   146                              <1> 	movzx	dx, [di+DPT.bLchsHeads]
   147                              <1> %else
   148 00001CF4 99                  <1> 	cwd
   149 00001CF5 8A5508              <1> 	mov		dl, [di+DPT.bLchsHeads]
   150                              <1> %endif
   151 00001CF8 F7E2                <1> 	mul		dx						; DX:AX = cylToSeek*headsPerCyl
   152                              <1> 
   153                              <1> 	; +=headToSeek (18-bit result)
   154                              <1> 	; Max = 260,865 + 254 = 261,119 = 3FBFFh
   155 00001CFA 00F8                <1> 	add		al, bh					; Add Head number to DX:AX
   156 00001CFC 10F4                <1> 	adc		ah, dh					; DH = Zero after previous multiplication
   157 00001CFE 10F2                <1> 	adc		dl, dh
   158                              <1> 
   159                              <1> 	; *=sectPerTrack (18-bit by 6-bit multiplication with 24-bit result)
   160                              <1> 	; Max = 261,119 * 63 = 16,450,497 = FB03C1h
   161 00001D00 92                  <1> 	xchg	ax, dx					; Hiword to AX, loword to DX
   162 00001D01 F6E1                <1> 	mul		cl						; AX = hiword * Sectors per Track
   163 00001D03 88C7                <1> 	mov		bh, al					; Backup hiword * Sectors per Track
   164 00001D05 92                  <1> 	xchg	ax, dx					; Loword back to AX
   165 00001D06 F7E1                <1> 	mul		cx						; DX:AX = loword * Sectors per Track
   166 00001D08 00FA                <1> 	add		dl, bh					; DX:AX = (cylToSeek*headsPerCyl+headToSeek)*sectPerTrack
   167                              <1> 
   168                              <1> 	; +=sectToSeek-1 (24-bit result)
   169                              <1> 	; Max = 16,450,497 + 63 - 1 = 16,450,559 = FB03FFh
   170 00001D0A 30FF                <1> 	xor		bh, bh					; Sector number now in BX
   171 00001D0C 4B                  <1> 	dec		bx						; sectToSeek-=1
   172 00001D0D 01D8                <1> 	add		ax, bx					; Add to loword
   173 00001D0F 10FA                <1> 	adc		dl, bh					; Add possible carry to byte2, BH=zero
   174                              <1> 
   175                              <1> 	; Copy DX:AX to proper return registers
   176 00001D11 93                  <1> 	xchg	bx, ax					; BL = Sector Number Register (LBA 7...0)
   177 00001D12 88F9                <1> 	mov		cl, bh					; Low Cylinder Register (LBA 15...8)
   178 00001D14 88D5                <1> 	mov		ch, dl					; High Cylinder Register (LBA 23...16)
   179 00001D16 88F7                <1> 	mov		bh, dh					; Drive and Head Register (LBA 27...24)
   180 00001D18 C3                  <1> 	ret
   278                                  	%include "Prepare.asm"			; For buffer pointer normalization
     1                              <1> ; Project name	:	XTIDE Universal BIOS
     2                              <1> ; Description	:	Functions for preparing data buffer for transfer.
     3                              <1> 
     4                              <1> ;
     5                              <1> ; XTIDE Universal BIOS and Associated Tools
     6                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
     7                              <1> ;
     8                              <1> ; This program is free software; you can redistribute it and/or modify
     9                              <1> ; it under the terms of the GNU General Public License as published by
    10                              <1> ; the Free Software Foundation; either version 2 of the License, or
    11                              <1> ; (at your option) any later version.
    12                              <1> ;
    13                              <1> ; This program is distributed in the hope that it will be useful,
    14                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    15                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    16                              <1> ; GNU General Public License for more details.
    17                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    18                              <1> ;
    19                              <1> 
    20                              <1> ; Section containing code
    21                              <1> SECTION .text
    22                              <1> 
    23                              <1> ;--------------------------------------------------------------------
    24                              <1> ; Prepare_ByLoadingDapToESSIandVerifyingForTransfer
    25                              <1> ;	Parameters:
    26                              <1> ;		SI:		Offset to DAP
    27                              <1> ;		DS:DI:	Ptr to DPT
    28                              <1> ;		SS:BP:	Ptr to IDEPACK
    29                              <1> ;	Parameters on INTPACK:
    30                              <1> ;		DS:SI:	Ptr to Disk Address Packet
    31                              <1> ;	Returns:
    32                              <1> ;		BX:		Index to command lookup table
    33                              <1> ;		ES:SI:	Ptr to Disk Address Packet (DAP)
    34                              <1> ;		Exits from INT 13h if invalid DAP
    35                              <1> ;	Corrupts registers:
    36                              <1> ;		AX, DX
    37                              <1> ;--------------------------------------------------------------------
    38                              <1> %ifdef MODULE_EBIOS
    39                              <1> ALIGN JUMP_ALIGN
    40                              <1> Prepare_ByLoadingDapToESSIandVerifyingForTransfer:
    41                              <1> 	; Load pointer to DAP to ES:SI and make sure it is valid
    42                              <1> 	mov		es, [bp+IDEPACK.intpack+INTPACK.ds]	; ES:SI to point Disk Address Packet
    43                              <1> 	cmp		BYTE [es:si+DAP.bSize], MINIMUM_DAP_SIZE
    44                              <1> 	jb		SHORT InvalidDAP
    45                              <1> 
    46                              <1> 	; Make sure that sector count is valid
    47                              <1> 	mov		ax, [es:si+DAP.wSectorCount]
    48                              <1> 	test	ax, ax
    49                              <1> 	jz		SHORT ZeroSectorsRequestedSoNoErrors
    50                              <1> 	cmp		ax, BYTE 127
    51                              <1> 	ja		SHORT InvalidNumberOfSectorsRequested
    52                              <1> 
    53                              <1> 	; Get EBIOS command index to BX
    54                              <1> 	; LBA28 or LBA48 command
    55                              <1> 	call	Prepare_GetOldInt13hCommandIndexToBX
    56                              <1> 	mov		al, [di+DPT.bFlagsLow]
    57                              <1> 	eSHL_IM	al, 1					; Set CF if LBA48 supported
    58                              <1> 	adc		bl, bh					; LBA48 EXT commands
    59                              <1> 	ret
    60                              <1> %endif ; MODULE_EBIOS
    61                              <1> 
    62                              <1> 
    63                              <1> ;--------------------------------------------------------------------
    64                              <1> ; Prepare_GetOldInt13hCommandIndexToBX
    65                              <1> ;	Parameters:
    66                              <1> ;		DS:DI:	Ptr to DPT
    67                              <1> ;	Returns:
    68                              <1> ;		BX:		Index to command lookup table
    69                              <1> ;	Corrupts registers:
    70                              <1> ;		Nothing
    71                              <1> ;--------------------------------------------------------------------
    72                              <1> ALIGN JUMP_ALIGN
    73                              <1> Prepare_GetOldInt13hCommandIndexToBX:
    74                              <1> 	; Block mode or single sector
    75 00001D19 8A5D01              <1> 	mov		bl, [di+DPT.bFlagsHigh]
    76 00001D1C 83E302              <1> 	and		bx, BYTE FLGH_DPT_BLOCK_MODE_SUPPORTED	; Bit 1
    77 00001D1F C3                  <1> 	ret
    78                              <1> 
    79                              <1> 
    80                              <1> ;---------------------------------------------------------------------
    81                              <1> ; Prepare_BufferToESSIforOldInt13hTransfer
    82                              <1> ;	Parameters:
    83                              <1> ;		AL:		Number of sectors to transfer
    84                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
    85                              <1> ;		SS:BP:	Ptr to IDEPACK
    86                              <1> ;	Parameters on INTPACK:
    87                              <1> ;		ES:BX:	Ptr to data buffer
    88                              <1> ;	Returns:
    89                              <1> ;		ES:SI:	Ptr to normalized data buffer
    90                              <1> ;		Exits INT 13h if error
    91                              <1> ;	Corrupts registers:
    92                              <1> ;		BX
    93                              <1> ;--------------------------------------------------------------------
    94                              <1> ALIGN JUMP_ALIGN
    95                              <1> Prepare_BufferToESSIforOldInt13hTransfer:
    96 00001D20 8B7615              <1> 	mov		si, [bp+IDEPACK.intpack+INTPACK.bx]	; Load offset
    97 00001D23 8E4609              <1> 	mov		es, [bp+IDEPACK.intpack+INTPACK.es]	; Load segment
    98                              <1> 	; Fall to Prepare_ByValidatingSectorsInALforOldInt13h
    99                              <1> 
   100                              <1> ;---------------------------------------------------------------------
   101                              <1> ; Prepare_ByValidatingSectorsInALforOldInt13h
   102                              <1> ;	Parameters:
   103                              <1> ;		AL:		Number of sectors to transfer
   104                              <1> ;	Returns:
   105                              <1> ;		Exits INT 13h if invalid number of sectors in AL
   106                              <1> ;	Corrupts registers:
   107                              <1> ;		Nothing
   108                              <1> ;--------------------------------------------------------------------
   109                              <1> Prepare_ByValidatingSectorsInALforOldInt13h:
   110 00001D26 84C0                <1> 	test	al, al
   111 00001D28 7803                <1> 	js		SHORT .CheckZeroOffsetFor128Sectors		; 128 or more
   112 00001D2A 740A                <1> 	jz		SHORT InvalidNumberOfSectorsRequested	; Zero not allowed for old INT 13h
   113 00001D2C C3                  <1> 	ret		; Continue with transfer
   114                              <1> 
   115                              <1> ALIGN JUMP_ALIGN
   116                              <1> .CheckZeroOffsetFor128Sectors:
   117 00001D2D 3C80                <1> 	cmp		al, 128
   118 00001D2F 7705                <1> 	ja		SHORT InvalidNumberOfSectorsRequested
   119 00001D31 85F6                <1> 	test	si, si								; Offset must be zero to xfer 128 sectors
   120 00001D33 7504                <1> 	jnz		SHORT CannotAlignPointerProperly
   121 00001D35 C3                  <1> 	ret		; Continue with transfer
   122                              <1> 
   123                              <1> InvalidDAP:
   124                              <1> InvalidNumberOfSectorsRequested:
   125                              <1> Prepare_ReturnFromInt13hWithInvalidFunctionError:
   126 00001D36 B401                <1> 	mov		ah, RET_HD_INVALID
   127                              <1> 	SKIP2B	f
   127                              <2>  %ifidni %1, f
   127 00001D38 3D                  <2>  db 03Dh
   127                              <2> 
   127                              <2>  %elifidni %1, ax
   127                              <2>  db 0B8h
   127                              <2>  %elifidni %1, cx
   127                              <2>  db 0B9h
   127                              <2>  %elifidni %1, dx
   127                              <2>  db 0BAh
   127                              <2>  %elifidni %1, bx
   127                              <2>  db 0BBh
   127                              <2>  %elifidni %1, sp
   127                              <2>  db 0BCh
   127                              <2>  %elifidni %1, bp
   127                              <2>  db 0BDh
   127                              <2>  %elifidni %1, si
   127                              <2>  db 0BEh
   127                              <2>  %elifidni %1, di
   127                              <2>  db 0BFh
   127                              <2>  %else
   127                              <2>  %error "Invalid parameter passed to SKIP2B"
   127                              <2>  %endif
   128                              <1> CannotAlignPointerProperly:
   129 00001D39 B409                <1> 	mov		ah, RET_HD_BOUNDARY
   130                              <1> ZeroSectorsRequestedSoNoErrors:
   131 00001D3B E950FC              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
   132                              <1> 
   133                              <1> 
   134                              <1> 
   135                              <1> ; Command lookup tables
   136                              <1> g_rgbReadCommandLookup:
   137 00001D3E 20                  <1> 	db		COMMAND_READ_SECTORS		; 00b, CHS or LBA28 single sector
   138 00001D3F 24                  <1> 	db		COMMAND_READ_SECTORS_EXT	; 01b, LBA48 single sector
   139 00001D40 C4                  <1> 	db		COMMAND_READ_MULTIPLE		; 10b, CHS or LBA28 block mode
   140                              <1> %ifdef MODULE_EBIOS
   141                              <1> 	db		COMMAND_READ_MULTIPLE_EXT	; 11b, LBA48 block mode
   142                              <1> %endif
   143                              <1> 
   144                              <1> g_rgbWriteCommandLookup:
   145 00001D41 30                  <1> 	db		COMMAND_WRITE_SECTORS
   146 00001D42 34                  <1> 	db		COMMAND_WRITE_SECTORS_EXT
   147 00001D43 C5                  <1> 	db		COMMAND_WRITE_MULTIPLE
   148                              <1> %ifdef MODULE_EBIOS
   149                              <1> 	db		COMMAND_WRITE_MULTIPLE_EXT
   150                              <1> %endif
   151                              <1> 
   152                              <1> g_rgbVerifyCommandLookup:
   153 00001D44 40                  <1> 	db		COMMAND_VERIFY_SECTORS
   154 00001D45 42                  <1> 	db		COMMAND_VERIFY_SECTORS_EXT
   155 00001D46 40                  <1> 	db		COMMAND_VERIFY_SECTORS
   156                              <1> %ifdef MODULE_EBIOS
   157                              <1> 	db		COMMAND_VERIFY_SECTORS_EXT
   158                              <1> %endif
   279                                  %ifdef MODULE_EBIOS
   280                                  	%include "AH42h_ExtendedReadSectors.asm"
   281                                  	%include "AH43h_ExtendedWriteSectors.asm"
   282                                  	%include "AH44h_ExtendedVerifySectors.asm"
   283                                  	%include "AH47h_ExtendedSeek.asm"
   284                                  	%include "AH48h_GetExtendedDriveParameters.asm"
   285                                  	%include "AH41h_CheckIfExtensionsPresent.asm"
   286                                  %endif
