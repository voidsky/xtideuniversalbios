     1                                  ; Project name	:	XTIDE Universal BIOS
     2                                  ; Authors		:	Tomi Tilli
     3                                  ;				:	aitotat@gmail.com
     4                                  ;				:
     5                                  ;				:	Greg Lindhorst
     6                                  ;				:	gregli@hotmail.com
     7                                  ;				;
     8                                  ;				:	Krister Nordvall
     9                                  ;				:	krille_n_@hotmail.com
    10                                  ;				:
    11                                  ; Description	:	Main file for BIOS. This is the only file that needs
    12                                  ;					to be compiled since other files are included to this
    13                                  ;					file (so no linker needed, Nasm does it all).
    14                                  
    15                                  ;
    16                                  ; XTIDE Universal BIOS and Associated Tools
    17                                  ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
    18                                  ;
    19                                  ; This program is free software; you can redistribute it and/or modify
    20                                  ; it under the terms of the GNU General Public License as published by
    21                                  ; the Free Software Foundation; either version 2 of the License, or
    22                                  ; (at your option) any later version.
    23                                  ;
    24                                  ; This program is distributed in the hope that it will be useful,
    25                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    26                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    27                                  ; GNU General Public License for more details.
    28                                  ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
    29                                  ;
    30                                  
    31                                  	ORG 0							; Code start offset 0000h
    32                                  
    33                                  	; We must define included libraries before including "AssemblyLibrary.inc".
    34                                  %define	EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS	; Exclude unused library functions
    35                                  %ifdef MODULE_BOOT_MENU
    36                                  	%define MENUEVENT_INLINE_OFFSETS    	; Only one menu required, save space and inline offsets
    37                                  	%define INCLUDE_MENU_LIBRARY
    38                                  	%define MENU_NO_ESC					    ; User cannot 'esc' out of the menu
    39                                  %else	; If no boot menu included
    40                                  	%define	INCLUDE_DISPLAY_LIBRARY
    41                                  	%define INCLUDE_KEYBOARD_LIBRARY
    42                                  	%define INCLUDE_TIME_LIBRARY
    43                                  %endif
    44                                  
    45                                  
    46                                  	; Included .inc files
    47                                  	%include "AssemblyLibrary.inc"	; Assembly Library. Must be included first!
    48                              <1> ; Project name	:	Assembly Library
    49                              <1> ; Description	:	Common defines for all library functions.
    50                              <1> %ifndef ASSEMBLY_LIBRARY_INC
    51                              <1> %define ASSEMBLY_LIBRARY_INC
    52                              <1> 
    53                              <1> ; Include .inc files
    54                              <1> %include "Emulate.inc"			; Must be included first!
    55                              <2> ; Project name	:	Emulation library
    56                              <2> ; Description	:	Macros for emulating later x86 instructions with older
    57                              <2> ;					processors.
    58                              <2> ;					Macros are used so optimized builds can be done
    59                              <2> ;					easily for different processors.
    60                              <2> ;
    61                              <2> ;					This file must be first to be included to
    62                              <2> ;					any source file.
    63                              <2> %ifndef EMULATE_INC
    64                              <2> %define EMULATE_INC
    65                              <2> 
    66                              <2> ; Defines for processor support (should be set in makefile).
    67                              <2> ; Unsupported instructions will be emulated using macros.
    68                              <2> ; If AT class PC is used (instead of XT), define USE_AT
    69                              <2> 
    70                              <2> ;%define USE_186				; Define to use 18x/V20/V30 instructions
    71                              <2> ;%define USE_286				; Define to use 286 instructions
    72                              <2> ;%define USE_386				; Define to use 386 instructions
    73                              <2> ;%define USE_AT					; Define for AT class machine
    74                              <2> 
    75                              <2> %ifdef USE_386
    76                              <2> 	%define USE_286				; Define to use 286 instructions
    77                              <2> %endif
    78                              <2> %ifdef USE_286
    79                              <2> 	%define USE_186				; Define to use 18x/V20/V30 instructions
    80                              <2> 	%define USE_UNDOC_INTEL		; Not supported by NEC V20/V30
    81                              <2> %endif
    82                              <2> 
    83                              <2> %ifdef USE_386
    84                              <2> 	CPU 386						; Allow instructions up to 386
    85                              <2> %elifdef USE_286
    86                              <2> 	CPU 286						; Allow instructions up to 286
    87                              <2> %elifdef USE_186
    88                              <2> 	CPU 186						; Allow instructions up to 188/186/V20/V30
    89                              <2> %else
    90                              <2> 	CPU 8086					; Allow 8088/8086 instructions only
    91                              <2> %endif
    92                              <2> 
    93                              <2> BITS 16							; Set 16 bit code generation
    94                              <2> 
    95                              <2> ; Alignments for jump targets.
    96                              <2> ; Following values are optimal for different processor types:
    97                              <2> ; 286 and 386SX			WORD (16-bit, 2 bytes)
    98                              <2> ; 386DX and 486			DWORD (32-bit, 4 bytes)
    99                              <2> ; Pentium and later		QWORD (64-bit, 8 bytes)
   100                              <2> %ifdef USE_AT
   101                              <2> 	%ifdef USE_386
   102                              <2> 		JUMP_ALIGN		EQU		4
   103                              <2> 		WORD_ALIGN		EQU		2
   104                              <2> 	%else ; USE_286
   105                              <2> 		JUMP_ALIGN		EQU		2
   106                              <2> 		WORD_ALIGN		EQU		2
   107                              <2> 	%endif
   108                              <2> %else ; XT
   109                              <2> 	JUMP_ALIGN		EQU		1
   110                              <2> 	WORD_ALIGN		EQU		1
   111                              <2> %endif
   112                              <2> 
   113                              <2> ;==========================================================================
   114                              <2> 
   115                              <2> ;--------------------------------------------------------------------
   116                              <2> ; The undocumented instruction SALC (Set AL According to CF).
   117                              <2> ; Available on all Intel processors and truly compatible clones.
   118                              <2> ; Does not work on the NEC V20/V30 or Sony CXQ70108 processors.
   119                              <2> ;
   120                              <2> ; eSALC
   121                              <2> ;	Parameters:
   122                              <2> ;		Nothing
   123                              <2> ;	Returns:
   124                              <2> ;		AL:		FFh if CF=1
   125                              <2> ;				00h if CF=0
   126                              <2> ;	Corrupts registers:
   127                              <2> ;		Nothing
   128                              <2> ;--------------------------------------------------------------------
   129                              <2> %macro eSALC 0
   130                              <2> 	db		0D6h
   131                              <2> %endmacro
   132                              <2> 
   133                              <2> 
   134                              <2> ;--------------------------------------------------------------------
   135                              <2> ; The AAD instruction (ASCII Adjust before Division).
   136                              <2> ; Available on all Intel processors and truly compatible clones.
   137                              <2> ; Does not work on the NEC V20/V30 or Sony CXQ70108 processors
   138                              <2> ; unless %1 is 10 (0Ah).
   139                              <2> ;
   140                              <2> ; eAAD
   141                              <2> ;	Parameters:
   142                              <2> ;		%1:		Any 8 bit number (0...255)
   143                              <2> ;	Returns:
   144                              <2> ;		AL:		AH * %1 + AL
   145                              <2> ;		AH:		0
   146                              <2> ;		Flags:	Set according to result
   147                              <2> ;	Corrupts registers:
   148                              <2> ;		Nothing
   149                              <2> ;--------------------------------------------------------------------
   150                              <2> %macro eAAD 1
   151                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   152                              <2> 	%if %1 > 255
   153                              <2> 		%error Invalid parameter passed to eAAD (%1 > 255)
   154                              <2> 	%else
   155                              <2> 		db		0D5h, %1
   156                              <2> 	%endif
   157                              <2> %endif
   158                              <2> %endmacro
   159                              <2> 
   160                              <2> 
   161                              <2> ;--------------------------------------------------------------------
   162                              <2> ; The AAM instruction (ASCII Adjust after Multiplication).
   163                              <2> ; Available on all Intel processors and truly compatible clones.
   164                              <2> ; Does not work on the NEC V20/V30 or Sony CXQ70108 processors
   165                              <2> ; unless %1 is 10 (0Ah).
   166                              <2> ;
   167                              <2> ; eAAM
   168                              <2> ;	Parameters:
   169                              <2> ;		%1:		Any 8 bit number except 0 (1...255)
   170                              <2> ;	Returns:
   171                              <2> ;		AL:		AL MOD %1
   172                              <2> ;		AH:		AL / %1
   173                              <2> ;		Flags:	Set according to result
   174                              <2> ;	Corrupts registers:
   175                              <2> ;		Nothing
   176                              <2> ;--------------------------------------------------------------------
   177                              <2> %macro eAAM 1
   178                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   179                              <2> 	%if %1 > 255
   180                              <2> 		%error Invalid parameter passed to eAAM (%1 > 255)
   181                              <2> 	%elif %1 = 0
   182                              <2> 		%error Invalid parameter passed to eAAM (%1 = 0). This would cause a divide-by-zero exception!
   183                              <2> 	%else
   184                              <2> 		db		0D4h, %1
   185                              <2> 	%endif
   186                              <2> %endif
   187                              <2> %endmacro
   188                              <2> 
   189                              <2> 
   190                              <2> ;--------------------------------------------------------------------
   191                              <2> ; Emulates BSF (Bit Scan Forward) instruction when necessary.
   192                              <2> ; BSF is used to find index of least significant bit.
   193                              <2> ;
   194                              <2> ; eBSF
   195                              <2> ;	Parameters:
   196                              <2> ;		%1:		Destination WORD Register for bit index (not CX or same as %2!)
   197                              <2> ;		%2:		Source WORD operand where to search bit (not CX or same as %1!)
   198                              <2> ;	Returns:
   199                              <2> ;		%1:		Index of highest order bit from %2
   200                              <2> ;		ZF:		Set if %2 is zero
   201                              <2> ;				Cleared if %2 is non-zero
   202                              <2> ;	Corrupts registers:
   203                              <2> ;		Nothing
   204                              <2> ;--------------------------------------------------------------------
   205                              <2> %macro eBSF 2
   206                              <2> %ifndef USE_386
   207                              <2> 	push	cx
   208                              <2> 	cmp		WORD %2, BYTE 0		; Source operand is zero?
   209                              <2> 	je		SHORT %%Return		;  If so, return with ZF set
   210                              <2> 
   211                              <2> 	; Set destination to zero and load mask for bit 0
   212                              <2> 	xor		%1, %1
   213                              <2> 	mov		cx, 1
   214                              <2> 
   215                              <2> ALIGN JUMP_ALIGN
   216                              <2> %%BitLoop:
   217                              <2> 	test	%2, cx				; Bit set?
   218                              <2> 	jnz		SHORT %%Return		;  If so, return with ZF cleared
   219                              <2> 	shl		cx, 1				; Prepare to test next bit
   220                              <2> 	inc		%1					; Increment bit index
   221                              <2> 	jmp		SHORT %%BitLoop		; Loop until bit found
   222                              <2> %%Return:
   223                              <2> 	pop		cx
   224                              <2> ;-----------------------------------
   225                              <2> %else
   226                              <2> 	bsf		%1, %2
   227                              <2> %endif
   228                              <2> %endmacro
   229                              <2> 
   230                              <2> 
   231                              <2> ;--------------------------------------------------------------------
   232                              <2> ; Emulates BSR (Bit Scan Reverse) instruction when necessary.
   233                              <2> ; BSR is used to find index of most significant bit.
   234                              <2> ;
   235                              <2> ; eBSR
   236                              <2> ;	Parameters:
   237                              <2> ;		%1:		Destination WORD Register for bit index (not CX or same as %2!)
   238                              <2> ;		%2:		Source WORD operand where to search bit (not CX or same as %1!)
   239                              <2> ;	Returns:
   240                              <2> ;		%1:		Index of highest order bit from %2
   241                              <2> ;		ZF:		Set if %2 is zero
   242                              <2> ;				Cleared if %2 is non-zero
   243                              <2> ;	Corrupts registers:
   244                              <2> ;		Nothing
   245                              <2> ;--------------------------------------------------------------------
   246                              <2> %macro eBSR 2
   247                              <2> %ifndef USE_386
   248                              <2> 	push	cx
   249                              <2> 	cmp		WORD %2, BYTE 0		; Source operand is zero?
   250                              <2> 	je		SHORT %%Return		;  If so, return with ZF set
   251                              <2> 
   252                              <2> 	; Load mask for highest order bit
   253                              <2> 	mov		cx, 1<<15
   254                              <2> 	mov		%1, 15
   255                              <2> 
   256                              <2> ALIGN JUMP_ALIGN
   257                              <2> %%BitLoop:
   258                              <2> 	test	%2, cx				; Bit set?
   259                              <2> 	jnz		SHORT %%Return		;  If so, return with ZF cleared
   260                              <2> 	shr		cx, 1				; Prepare to test next bit
   261                              <2> 	dec		%1					; Decrement bit index
   262                              <2> 	jmp		SHORT %%BitLoop		; Loop until bit found
   263                              <2> %%Return:
   264                              <2> 	pop		cx
   265                              <2> ;-----------------------------------
   266                              <2> %else
   267                              <2> 	bsr		%1, %2
   268                              <2> %endif
   269                              <2> %endmacro
   270                              <2> 
   271                              <2> 
   272                              <2> ;--------------------------------------------------------------------
   273                              <2> ; Conditional Move.
   274                              <2> ;
   275                              <2> ; eCMOVcc
   276                              <2> ;	Parameters:
   277                              <2> ;		%1:		Destination data
   278                              <2> ;		%2:		Source data
   279                              <2> ;	Returns:
   280                              <2> ;		Nothing
   281                              <2> ;	Corrupts registers:
   282                              <2> ;		Nothing
   283                              <2> ;--------------------------------------------------------------------
   284                              <2> %macro eCMOVA 2
   285                              <2> 	jbe		SHORT %%Return
   286                              <2> 	mov		%1, %2
   287                              <2> %%Return:
   288                              <2> %endmacro
   289                              <2> 
   290                              <2> %macro eCMOVC 2
   291                              <2> 	jnc		SHORT %%Return
   292                              <2> 	mov		%1, %2
   293                              <2> %%Return:
   294                              <2> %endmacro
   295                              <2> 
   296                              <2> %macro eCMOVNC 2
   297                              <2> 	jc		SHORT %%Return
   298                              <2> 	mov		%1, %2
   299                              <2> %%Return:
   300                              <2> %endmacro
   301                              <2> 
   302                              <2> %macro eCMOVZ 2
   303                              <2> 	jnz		SHORT %%Return
   304                              <2> 	mov		%1, %2
   305                              <2> %%Return:
   306                              <2> %endmacro
   307                              <2> 
   308                              <2> %macro eCMOVNZ 2
   309                              <2> 	jz		SHORT %%Return
   310                              <2> 	mov		%1, %2
   311                              <2> %%Return:
   312                              <2> %endmacro
   313                              <2> 
   314                              <2> %macro eCMOVE 2
   315                              <2> 	eCMOVZ %1, %2
   316                              <2> %endmacro
   317                              <2> 
   318                              <2> %macro eCMOVNE 2
   319                              <2> 	eCMOVNZ %1, %2
   320                              <2> %endmacro
   321                              <2> 
   322                              <2> %macro eCMOVB 2
   323                              <2> 	jnb		SHORT %%Return
   324                              <2> 	mov		%1, %2
   325                              <2> %%Return:
   326                              <2> %endmacro
   327                              <2> 
   328                              <2> %macro eCMOVS 2
   329                              <2> 	jns		SHORT %%Return
   330                              <2> 	mov		%1, %2
   331                              <2> %%Return:
   332                              <2> %endmacro
   333                              <2> 
   334                              <2> %macro eCMOVNS 2
   335                              <2> 	js		SHORT %%Return
   336                              <2> 	mov		%1, %2
   337                              <2> %%Return:
   338                              <2> %endmacro
   339                              <2> 
   340                              <2> 
   341                              <2> ;--------------------------------------------------------------------
   342                              <2> ; Conditional Set.
   343                              <2> ;
   344                              <2> ; eCSETcc
   345                              <2> ;	Parameters:
   346                              <2> ;		%1:		Destination data
   347                              <2> ;	Returns:
   348                              <2> ;		Nothing
   349                              <2> ;	Corrupts registers:
   350                              <2> ;		Flags
   351                              <2> ;--------------------------------------------------------------------
   352                              <2> %macro eCSETZ 1
   353                              <2> 	mov		%1, 0			; Clear while preserving flags
   354                              <2> 	jnz		SHORT %%Return	; Nothing to set
   355                              <2> 	inc		%1
   356                              <2> %%Return:
   357                              <2> %endmacro
   358                              <2> 
   359                              <2> 
   360                              <2> ;--------------------------------------------------------------------
   361                              <2> ; Moves byte with zero-extending to any Register.
   362                              <2> ;
   363                              <2> ; eMOVZX
   364                              <2> ;	Parameters:
   365                              <2> ;		%1:		Destination Register (SP not supported)
   366                              <2> ;		%2:		Byte register or byte address
   367                              <2> ;	Returns:
   368                              <2> ;		Nothing
   369                              <2> ;	Corrupts registers:
   370                              <2> ;		FLAGS
   371                              <2> ;--------------------------------------------------------------------
   372                              <2> %macro eMOVZX 2
   373                              <2> %ifndef USE_386
   374                              <2> 	%ifidni %1, ax
   375                              <2> 		mov		al, %2
   376                              <2> 		xor		ah, ah
   377                              <2> 	%elifidni %1, bx
   378                              <2> 		mov		bl, %2
   379                              <2> 		xor		bh, bh		; %2 may use BX in effective address
   380                              <2> 	%elifidni %1, cx
   381                              <2> 		mov		cl, %2
   382                              <2> 		xor		ch, ch
   383                              <2> 	%elifidni %1, dx
   384                              <2> 		mov		dl, %2
   385                              <2> 		xor		dh, dh
   386                              <2> 	%else	; SI, DI, BP (all may be used in effective address)
   387                              <2> 		push	ax
   388                              <2> 		mov		al, %2
   389                              <2> 		xor		ah, ah
   390                              <2> 		xchg	ax, %1
   391                              <2> 		pop		ax
   392                              <2> 	%endif
   393                              <2> ;-----------------------------------
   394                              <2> %else
   395                              <2> 	movzx	%1, %2
   396                              <2> %endif
   397                              <2> %endmacro
   398                              <2> 
   399                              <2> 
   400                              <2> ;--------------------------------------------------------------------
   401                              <2> ; Emulates PUSHA instruction when necessary.
   402                              <2> ;
   403                              <2> ; ePUSHA
   404                              <2> ;	Parameters:
   405                              <2> ;		Nothing
   406                              <2> ;	Returns:
   407                              <2> ;		Nothing
   408                              <2> ;	Corrupts registers:
   409                              <2> ;		Nothing
   410                              <2> ;--------------------------------------------------------------------
   411                              <2> %macro ePUSHA 0
   412                              <2> %ifndef USE_186
   413                              <2> 	push	ax
   414                              <2> 	push	cx
   415                              <2> 	push	dx
   416                              <2> 	push	bx
   417                              <2> 	push	sp
   418                              <2> 	push	bp
   419                              <2> 	push	si
   420                              <2> 	push	di
   421                              <2> ;-----------------------------------
   422                              <2> %else
   423                              <2> 	pusha
   424                              <2> %endif
   425                              <2> %endmacro
   426                              <2> 
   427                              <2> 
   428                              <2> ;--------------------------------------------------------------------
   429                              <2> ; Emulates POPA instruction when necessary.
   430                              <2> ;
   431                              <2> ; ePOPA
   432                              <2> ;	Parameters:
   433                              <2> ;		Nothing
   434                              <2> ;	Returns:
   435                              <2> ;		Nothing
   436                              <2> ;	Corrupts registers:
   437                              <2> ;		Nothing
   438                              <2> ;--------------------------------------------------------------------
   439                              <2> %macro ePOPA 0
   440                              <2> %ifndef USE_186
   441                              <2> 	pop		di
   442                              <2> 	pop		si
   443                              <2> 	pop		bp
   444                              <2> 	pop		ax		; Skip SP
   445                              <2> 	pop		bx
   446                              <2> 	pop		dx
   447                              <2> 	pop		cx
   448                              <2> 	pop		ax
   449                              <2> ;-----------------------------------
   450                              <2> %else
   451                              <2> 	popa
   452                              <2> %endif
   453                              <2> %endmacro
   454                              <2> 
   455                              <2> 
   456                              <2> ;--------------------------------------------------------------------
   457                              <2> ; Emulates ENTER instruction when necessary.
   458                              <2> ;
   459                              <2> ; eENTER
   460                              <2> ;	Parameters:
   461                              <2> ;		%1:		Number of bytes to reserve from stack
   462                              <2> ;		%2:		The lexical nesting level (not emulated, set to 0)
   463                              <2> ;	Returns:
   464                              <2> ;		SS:BP:	Ptr to old BP
   465                              <2> ;				([bp-2] points to highest local stack frame word)
   466                              <2> ;	Corrupts registers:
   467                              <2> ;		FLAGS
   468                              <2> ;--------------------------------------------------------------------
   469                              <2> %macro eENTER 2
   470                              <2> %ifndef USE_186
   471                              <2> 	push	bp
   472                              <2> 	mov		bp, sp
   473                              <2> 	sub		sp, %1
   474                              <2> ;-----------------------------------
   475                              <2> %else
   476                              <2> 	enter	%1, %2
   477                              <2> %endif
   478                              <2> %endmacro
   479                              <2> 
   480                              <2> ;--------------------------------------------------------------------
   481                              <2> ; Emulates LEAVE instruction when necessary.
   482                              <2> ;
   483                              <2> ; eLEAVE
   484                              <2> ;	Parameters:
   485                              <2> ;		Nothing
   486                              <2> ;	Returns:
   487                              <2> ;		BP:		What it was before eENTER
   488                              <2> ;	Corrupts registers:
   489                              <2> ;		Nothing
   490                              <2> ;--------------------------------------------------------------------
   491                              <2> %macro eLEAVE 0
   492                              <2> %ifndef USE_186
   493                              <2> 	mov		sp, bp
   494                              <2> 	pop		bp
   495                              <2> ;-----------------------------------
   496                              <2> %else
   497                              <2> 	leave
   498                              <2> %endif
   499                              <2> %endmacro
   500                              <2> 
   501                              <2> 
   502                              <2> ;--------------------------------------------------------------------
   503                              <2> ; Emulates LSS instruction when necessary.
   504                              <2> ;
   505                              <2> ; eLSS
   506                              <2> ;	Parameters:
   507                              <2> ;		%1:		Destination register
   508                              <2> ;		%2:		Source memory address without brackets
   509                              <2> ;	Returns:
   510                              <2> ;		IF:		0 (interrupts disabled)
   511                              <2> ;	Corrupts registers:
   512                              <2> ;		Nothing
   513                              <2> ;--------------------------------------------------------------------
   514                              <2> %macro eLSS 2
   515                              <2> %ifndef USE_386
   516                              <2> 	cli							; Disable interrupts
   517                              <2> 	mov		%1, [%2]			; Load offset
   518                              <2> 	mov		ss, [%2+2]			; Load segment
   519                              <2> ;-----------------------------------
   520                              <2> %else
   521                              <2> 	lss		%1, [%2]
   522                              <2> %endif
   523                              <2> %endmacro
   524                              <2> 
   525                              <2> 
   526                              <2> ;--------------------------------------------------------------------
   527                              <2> ; Repeats string instruction with segment override.
   528                              <2> ; This macro prevents 8088/8086 restart bug.
   529                              <2> ;
   530                              <2> ; eSEG_STR
   531                              <2> ;	Parameters:
   532                              <2> ;		%1:		REP/REPNE or REPE prefix
   533                              <2> ;		%2:		Source segment override (destination is always ES)
   534                              <2> ;		%3:		String instruction
   535                              <2> ;		CX:		Repeat count
   536                              <2> ;	Returns:
   537                              <2> ;		FLAGS for cmps and scas only
   538                              <2> ;	Corrupts registers:
   539                              <2> ;		Nothing
   540                              <2> ;--------------------------------------------------------------------
   541                              <2> %macro eSEG_STR 3
   542                              <2> %ifndef USE_186	; 8088/8086 has string instruction restart bug when more than one prefix
   543                              <2> 	%%Loop:
   544                              <2> 		%1						; REP is the prefix that can be lost
   545                              <2> 		%2						; SEG is the prefix that won't be lost
   546                              <2> 		%3						; String instruction
   547                              <2> 		jcxz	%%End			; Jump to end if no repeats left (preserves FLAGS)
   548                              <2> 		jmp		SHORT %%Loop	; Loop while repeats left
   549                              <2> 	%%End:
   550                              <2> %else	; No bug on V20/V30 and later, don't know about 188/186
   551                              <2> 	%2
   552                              <2> 	%1 %3
   553                              <2> %endif
   554                              <2> %endmacro
   555                              <2> 
   556                              <2> 
   557                              <2> ;--------------------------------------------------------------------
   558                              <2> ; Bit shifts and rotates with immediate.
   559                              <2> ;
   560                              <2> ; eSHIFT_IM
   561                              <2> ;	Parameters:
   562                              <2> ;		%1:		Shift target
   563                              <2> ;		%2:		Number of bits to shift
   564                              <2> ;		%3:		Instruction (SHL, SHR, ROL, ROR, RCL, RCR)
   565                              <2> ;	Returns:
   566                              <2> ;		FLAGS
   567                              <2> ;	Corrupts registers:
   568                              <2> ;		Nothing
   569                              <2> ;--------------------------------------------------------------------
   570                              <2> %macro eSHIFT_IM 3
   571                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   572                              <2> %ifndef USE_186
   573                              <2> 	%ifidni %1, cl
   574                              <2> 		times %2	%3		%1, 1
   575                              <2> 	%elifidni %1, ch
   576                              <2> 		times %2	%3		%1, 1
   577                              <2> 	%elifidni %1, cx
   578                              <2> 		times %2	%3		%1, 1
   579                              <2> 	%else
   580                              <2> 		%if %2 > 3	; Size optimized value
   581                              <2> 			push	cx
   582                              <2> 			mov		cl, %2
   583                              <2> 			%3		%1, cl
   584                              <2> 			pop		cx
   585                              <2> 		%else
   586                              <2> 			times %2	%3		%1, 1
   587                              <2> 		%endif
   588                              <2> 	%endif
   589                              <2> ;-----------------------------------
   590                              <2> %else
   591                              <2> 	%3		%1, %2
   592                              <2> %endif
   593                              <2> %endif
   594                              <2> %endmacro
   595                              <2> 
   596                              <2> %macro eSHR_IM 2
   597                              <2> 	eSHIFT_IM	%1, %2, shr
   598                              <2> %endmacro
   599                              <2> 
   600                              <2> %macro eSHL_IM 2
   601                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
   602                              <2> %ifdef USE_386
   603                              <2> 	%if %2 = 1
   604                              <2> 		add		%1, %1	; Same size but faster on 386 and 486. Fails if %1 is a memory operand.
   605                              <2> 	%else
   606                              <2> 		eSHIFT_IM	%1, %2, shl
   607                              <2> 	%endif
   608                              <2> %else
   609                              <2> 	eSHIFT_IM	%1, %2, shl
   610                              <2> %endif
   611                              <2> %endif
   612                              <2> %endmacro
   613                              <2> 
   614                              <2> %macro eROR_IM 2
   615                              <2> 	eSHIFT_IM	%1, %2, ror
   616                              <2> %endmacro
   617                              <2> 
   618                              <2> %macro eROL_IM 2
   619                              <2> 	eSHIFT_IM	%1, %2, rol
   620                              <2> %endmacro
   621                              <2> 
   622                              <2> %macro eRCR_IM 2
   623                              <2> 	eSHIFT_IM	%1, %2, rcr
   624                              <2> %endmacro
   625                              <2> 
   626                              <2> %macro eRCL_IM 2
   627                              <2> 	eSHIFT_IM	%1, %2, rcl
   628                              <2> %endmacro
   629                              <2> 
   630                              <2> 
   631                              <2> ;--------------------------------------------------------------------
   632                              <2> ; Emulates PUSH imm instruction when necessary.
   633                              <2> ;
   634                              <2> ; ePUSH_I
   635                              <2> ;	Parameters:
   636                              <2> ;		%1:		Immediate to push
   637                              <2> ;	Returns:
   638                              <2> ;		Nothing
   639                              <2> ;	Corrupts registers:
   640                              <2> ;		Nothing
   641                              <2> ;--------------------------------------------------------------------
   642                              <2> %macro ePUSH_I 1
   643                              <2> %ifndef USE_186
   644                              <2> 	push	bp					; Immediate goes here
   645                              <2> 	push	bp
   646                              <2> 	mov		bp, sp
   647                              <2> 	mov		WORD [bp+2], %1
   648                              <2> 	pop		bp
   649                              <2> ;-----------------------------------
   650                              <2> %else
   651                              <2> 	push	%1
   652                              <2> %endif
   653                              <2> %endmacro
   654                              <2> 
   655                              <2> 
   656                              <2> ;--------------------------------------------------------------------
   657                              <2> ; Emulates PUSH imm instruction when necessary.
   658                              <2> ; ePUSH_T uses temporary register for faster performance
   659                              <2> ; and smaller code size than ePUSH_I.
   660                              <2> ;
   661                              <2> ; ePUSH_T
   662                              <2> ;	Parameters:
   663                              <2> ;		%1:		Temporary Register
   664                              <2> ;		%2:		Immediate to push
   665                              <2> ;	Returns:
   666                              <2> ;		Nothing
   667                              <2> ;	Corrupts registers:
   668                              <2> ;		%1
   669                              <2> ;--------------------------------------------------------------------
   670                              <2> %macro ePUSH_T 2
   671                              <2> %ifndef USE_186
   672                              <2> 	%ifidni %2, 0
   673                              <2> 		xor		%1, %1
   674                              <2> 	%else
   675                              <2> 		mov		%1, %2
   676                              <2> 	%endif
   677                              <2> 	push	%1
   678                              <2> ;-----------------------------------
   679                              <2> %else
   680                              <2> 	push	%2
   681                              <2> %endif
   682                              <2> %endmacro
   683                              <2> 
   684                              <2> 
   685                              <2> %endif ; EMULATE_INC
   686                              <1> %include "Macros.inc"
   687                              <2> ; Project name	:	Assembly Library
   688                              <2> ; Description	:	This is the place to put various generic macros.
   689                              <2> ;					Should be included immediately after emulate.inc
   690                              <2> %ifndef MACROS_INC
   691                              <2> %define MACROS_INC
   692                              <2> 
   693                              <2> ;--------------------------------------------------------------------
   694                              <2> ; Skips the immediately following 2 byte instruction by using it
   695                              <2> ; as an immediate value to a dummy instruction.
   696                              <2> ; Destroys the contents of %1.
   697                              <2> ;
   698                              <2> ; SKIP2B
   699                              <2> ;	Parameters:
   700                              <2> ;		%1:		Any 16 bit general purpose register or F for flags.
   701                              <2> ;	Returns:
   702                              <2> ;		Nothing
   703                              <2> ;	Corrupts registers:
   704                              <2> ;		%1
   705                              <2> ;--------------------------------------------------------------------
   706                              <2> %macro SKIP2B 1
   707                              <2> 	%ifidni		%1, f
   708                              <2> 		db	03Dh					; Opcode byte for CMP AX, <immed>
   709                              <2> 		;db	0A9h					; Alt. version TEST AX, <immed>
   710                              <2> 	%elifidni	%1, ax
   711                              <2> 		db	0B8h					; Opcode byte for MOV AX, <immed>
   712                              <2> 	%elifidni	%1, cx
   713                              <2> 		db	0B9h					; Opcode byte for MOV CX, <immed>
   714                              <2> 	%elifidni	%1, dx
   715                              <2> 		db	0BAh					; Opcode byte for MOV DX, <immed>
   716                              <2> 	%elifidni	%1, bx
   717                              <2> 		db	0BBh					; Opcode byte for MOV BX, <immed>
   718                              <2> 	%elifidni	%1, sp
   719                              <2> 		db	0BCh					; Opcode byte for MOV SP, <immed>
   720                              <2> 	%elifidni	%1, bp
   721                              <2> 		db	0BDh					; Opcode byte for MOV BP, <immed>
   722                              <2> 	%elifidni	%1, si
   723                              <2> 		db	0BEh					; Opcode byte for MOV SI, <immed>
   724                              <2> 	%elifidni	%1, di
   725                              <2> 		db	0BFh					; Opcode byte for MOV DI, <immed>
   726                              <2> 	%else
   727                              <2> 		%error "Invalid parameter passed to SKIP2B"
   728                              <2> 	%endif
   729                              <2> %endmacro
   730                              <2> 
   731                              <2> 
   732                              <2> ;--------------------------------------------------------------------
   733                              <2> ; Load BDA (Bios Data Area) segment to wanted segment register.
   734                              <2> ;
   735                              <2> ; Use an exclamation point (!) as the third parameter when you want
   736                              <2> ; to force the use of the register in the second parameter. This is
   737                              <2> ; useful when that register needs to be zeroed in subsequent code or
   738                              <2> ; when stack usage is undesirable (ie speed is critical).
   739                              <2> ;
   740                              <2> ; The PRESERVE_FLAGS version will zero the register with a MOV instead
   741                              <2> ; of an XOR, thus preserving the flags.  It is one byte larger on
   742                              <2> ; non-186 or higher systems.
   743                              <2> ;
   744                              <2> ; LOAD_BDA_SEGMENT_TO
   745                              <2> ; LOAD_BDA_SEGMENT_PRESERVE_FLAGS_TO
   746                              <2> ;	Parameters:
   747                              <2> ;		%1:		Destination Segment Register
   748                              <2> ;		%2:		Temporary WORD Register
   749                              <2> ;		%3:		Can be ! or empty
   750                              <2> ;	Returns:
   751                              <2> ;		%1:		BDA segment (zero)
   752                              <2> ;	Corrupts registers:
   753                              <2> ;		%2
   754                              <2> ;--------------------------------------------------------------------
   755                              <2> %macro LOAD_BDA_SEGMENT_TO 2-3
   756                              <2> %ifndef USE_186
   757                              <2> 	xor		%2, %2
   758                              <2> 	mov		%1, %2
   759                              <2> %elifidn %3, !
   760                              <2> 	xor		%2, %2
   761                              <2> 	mov		%1, %2
   762                              <2> %else
   763                              <2> 	push	BYTE 0
   764                              <2> 	pop		%1
   765                              <2> %endif
   766                              <2> %endmacro
   767                              <2> 
   768                              <2> %macro LOAD_BDA_SEGMENT_PRESERVE_FLAGS_TO 2-3
   769                              <2> %ifndef USE_186
   770                              <2> 	mov		%2, 0
   771                              <2> 	mov		%1, %2
   772                              <2> %elifidn %3, !
   773                              <2> 	mov		%2, 0
   774                              <2> 	mov		%1, %2
   775                              <2> %else
   776                              <2> 	push	BYTE 0
   777                              <2> 	pop		%1
   778                              <2> %endif
   779                              <2> %endmacro
   780                              <2> 
   781                              <2> 
   782                              <2> ;--------------------------------------------------------------------
   783                              <2> ; eENTER_STRUCT
   784                              <2> ;	Parameters:
   785                              <2> ;		%1:		Number of bytes to reserve from stack
   786                              <2> ;	Returns:
   787                              <2> ;		SS:BP:	Ptr to beginning of struct reserved from stack
   788                              <2> ;	Corrupts registers:
   789                              <2> ;		FLAGS
   790                              <2> ;--------------------------------------------------------------------
   791                              <2> %macro eENTER_STRUCT 1
   792                              <2> 	push	bp
   793                              <2> 	sub		sp, %1
   794                              <2> 	mov		bp, sp
   795                              <2> %endmacro
   796                              <2> 
   797                              <2> ;--------------------------------------------------------------------
   798                              <2> ; eLEAVE_STRUCT
   799                              <2> ;	Parameters:
   800                              <2> ;		%1:		Number of bytes reserved with eENTER_STRUCT
   801                              <2> ;	Returns:
   802                              <2> ;		BP:		What it was before eENTER_STRUCT
   803                              <2> ;	Corrupts registers:
   804                              <2> ;		FLAGS
   805                              <2> ;--------------------------------------------------------------------
   806                              <2> %macro eLEAVE_STRUCT 1
   807                              <2> 	add		sp, %1
   808                              <2> 	pop		bp
   809                              <2> %endmacro
   810                              <2> 
   811                              <2> 
   812                              <2> %endif ; MACROS_INC
   813                              <1> %include "BiosData.inc"
   814                              <2> ; Project name	:	XTIDE Universal BIOS
   815                              <2> ; Description	:	Equates for BIOS Data Area.
   816                              <2> %ifndef BIOSDATA_INC
   817                              <2> %define BIOSDATA_INC
   818                              <2> 
   819                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   820                              <2> ; BIOS DATA AREA VARIABLES ;
   821                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   822                              <2> 
   823                              <2> ; BIOS Data Area (related to floppy drives and hard disks)
   824                              <2> struc BDA
   825 00000000 <res 00000400>      <2> 					resb	400h	; 40:0h, Start of BDA
   826 00000400 <res 00000002>      <2> 	.wCOM1			resb	2		; 0:400h, Serial I/O Address, Port 1
   827 00000402 <res 00000002>      <2> 	.wCOM2			resb	2		; 0:402h, Serial I/O Address, Port 2
   828 00000404 <res 00000002>      <2> 	.wCOM3			resb	2		; 0:404h, Serial I/O Address, Port 3
   829 00000406 <res 00000002>      <2> 	.wCOM4			resb	2		; 0:406h, Serial I/O Address, Port 4
   830 00000408 <res 00000002>      <2> 	.wLPT1			resb	2		; 0:408h, Parallel I/O Address, Port 1
   831 0000040A <res 00000002>      <2> 	.wLPT2			resb	2		; 0:40Ah, Parallel I/O Address, Port 2
   832 0000040C <res 00000002>      <2> 	.wLPT3			resb	2		; 0:40Ch, Parallel I/O Address, Port 3
   833                              <2> 	.wLPT4:							; 0:40Eh, Parallel I/O Address, Port 4 (PC/XT)
   834 0000040E <res 00000002>      <2> 	.wSegEBDA		resb	2		; 0:40Eh, Extended BIOS Data Area segment (AT+)
   835                              <2> 
   836 00000410 <res 00000002>      <2> 	.wEquipment		resb	2		; 0:410h, Equipment Word
   837 00000412 <res 00000001>      <2> 	.bTest			resb	1		; 0:412h, Manufacturing test
   838 00000413 <res 00000002>      <2> 	.wBaseMem		resb	2		; 0:413h, Base Memory Size in kB
   839                              <2> 	.wAdptrMem:						; 0:415h, Adapter Memory Size (PC/XT)
   840 00000415 <res 00000002>      <2> 	.wError			resb	2		; 0:415h, Error Codes (AT+)
   841 00000417 <res 00000001>      <2> 	.bKBFlgs1		resb	1		; 0:417h, Keyboard, Shift Flags, Set 1
   842 00000418 <res 00000001>      <2> 	.bKBFlgs2		resb	1		; 0:418h, Keyboard, Shift Flags, Set 2
   843 00000419 <res 00000001>      <2> 	.bKBNumpad		resb	1		; 0:419h, Keyboard, ALT+Numpad work area
   844 0000041A <res 00000002>      <2> 	.wKBHead		resb	2		; 0:41Ah, Keyboard, Head of buffer pointer
   845 0000041C <res 00000002>      <2> 	.wKBTail		resb	2		; 0:41Ch, Keyboard, Tail of buffer pointer
   846 0000041E <res 00000020>      <2> 	.rgwKBBuff		resb	32		; 0:41Eh, Keyboard, 16-word buffer
   847                              <2> 
   848 0000043E <res 00000001>      <2> 	.bFDRecal		resb	1		; 0:43Eh, Diskette, Recalibrate status
   849 0000043F <res 00000001>      <2> 	.bFDMotor		resb	1		; 0:43Fh, Diskette, Motor status
   850                              <2> 
   851 00000440 <res 00000001>      <2> 	.bFDMotTime		resb	1		; 0:440h, Diskette, Motor timeout counter
   852 00000441 <res 00000001>      <2> 	.bFDRetST		resb	1		; 0:441h, Diskette, Controller status return code
   853 00000442 <res 00000007>      <2> 	.rgbFDStatus	resb	7		; 0:442h, Diskette, Diskette and Disk Controller status bytes
   854 00000449 <res 00000001>      <2> 	.bVidMode		resb	1		; 0:449h, Video, Mode
   855 0000044A <res 00000002>      <2> 	.wVidColumns	resb	2		; 0:44Ah, Video, Number of columns
   856 0000044C <res 00000002>      <2> 	.wVidBpP		resb	2		; 0:44Ch, Video, Total number of bytes per page
   857 0000044E <res 00000002>      <2> 	.wVidPageOff	resb	2		; 0:44Eh, Video, Current page offset
   858                              <2> 
   859 00000450 <res 00000010>      <2> 	.rgwVidCurPos	resb	16		; 0:450h, Video, Cursor position, pages 0...7
   860                              <2> 
   861 00000460 <res 00000002>      <2> 	.wVidCurShape	resb	2		; 0:460h, Video, Cursor shape
   862 00000462 <res 00000001>      <2> 	.bVidPageIdx	resb	1		; 0:462h, Video, Active display page
   863 00000463 <res 00000002>      <2> 	.wVidPort		resb	2		; 0:463h, Video, I/O Port number base
   864 00000465 <res 00000001>      <2> 	.bVidModeReg	resb	1		; 0:465h, Video, Internal mode register
   865 00000466 <res 00000001>      <2> 	.bVidPalette	resb	1		; 0:466h, Video, Color palette
   866                              <2> 	.wCasTimeCnt:					; 0:467h, Cassette, Time count at data edge (PC)
   867 00000467 <res 00000002>      <2> 	.wGenOff		resb	2		; 0:467h, General use offset (XT+)
   868                              <2> 	.wCasCRC:						; 0:469h, Cassette, CRC register (PC)
   869 00000469 <res 00000002>      <2> 	.wGenSeg		resb	2		; 0:469h, General use segment (XT+)
   870                              <2> 	.bCasLast:						; 0:46Bh, Cassette, Last value read
   871 0000046B <res 00000001>      <2> 	.bLastIRQ		resb	1		; 0:46Bh, Last interrupt that occurred (XT+)
   872 0000046C <res 00000004>      <2> 	.dwTimerTicks	resb	4		; 0:46Ch, Timer ticks count
   873                              <2> 
   874 00000470 <res 00000001>      <2> 	.bTimer24h		resb	1		; 0:470h, Timer ticks rollover flag
   875 00000471 <res 00000001>      <2> 	.bKBCtrlBrk		resb	1		; 0:471h, Keyboard, Ctrl+Break flag
   876 00000472 <res 00000002>      <2> 	.wBoot			resb	2		; 0:472h, Warm boot flag
   877 00000474 <res 00000001>      <2> 	.bHDLastSt		resb	1		; 0:474h, Hard Disk, Status of Last Operation (XT+)
   878 00000475 <res 00000001>      <2> 	.bHDCount		resb	1		; 0:475h, Hard Disk, Number of HDs Attached (XT+)
   879 00000476 <res 00000001>      <2> 	.bHDCtrl		resb	1		; 0:476h, Hard Disk, Control Byte (temp, XT+)
   880 00000477 <res 00000001>      <2> 	.bHDPortOff		resb	1		; 0:477h, Hard Disk, Port Offset (XT)
   881 00000478 <res 00000001>      <2> 	.bLPT1Timeout	resb	1		; 0:478h, Parallel Printer 1, Timeout (XT+)
   882 00000479 <res 00000001>      <2> 	.bLPT2Timeout	resb	1		; 0:479h, Parallel Printer 2, Timeout (XT+)
   883 0000047A <res 00000001>      <2> 	.bLPT3Timeout	resb	1		; 0:47Ah, Parallel Printer 3, Timeout (XT+)
   884 0000047B <res 00000001>      <2> 	.bLPT4Timeout	resb	1		; 0:47Bh, Parallel Printer 4, Timeout (XT+)
   885 0000047C <res 00000001>      <2> 	.bCOM1Timeout	resb	1		; 0:47Ch, Serial 1, Timeout (XT+)
   886 0000047D <res 00000001>      <2> 	.bCOM2Timeout	resb	1		; 0:47Dh, Serial 2, Timeout (XT+)
   887 0000047E <res 00000001>      <2> 	.bCOM3Timeout	resb	1		; 0:47Eh, Serial 3, Timeout (XT+)
   888 0000047F <res 00000001>      <2> 	.bCOM4Timeout	resb	1		; 0:47Fh, Serial 4, Timeout (XT+)
   889                              <2> 
   890 00000480 <res 00000002>      <2> 	.wKBPtrStart	resb	2		; 0:480h, Keyboard, Pointer to start of buffer (XT+)
   891 00000482 <res 00000002>      <2> 	.wKBPtrEnd		resb	2		; 0:482h, Keyboard, Pointer to end of buffer (XT+)
   892 00000484 <res 00000001>      <2> 	.bVidRows		resb	1		; 0:484h, Video, Number of rows (EGA+)
   893 00000485 <res 00000002>      <2> 	.wVidPpC		resb	2		; 0:485h, Video, Pixels per character (EGA+)
   894 00000487 <res 00000001>      <2> 	.bVidOptns		resb	1		; 0:487h, Video, Options (EGA+)
   895 00000488 <res 00000001>      <2> 	.bVidSwitches	resb	1		; 0:488h, Video, Switches (EGA+)
   896 00000489 <res 00000001>      <2> 	.bVidSave1		resb	1		; 0:489h, Video, Save area 1 (VGA+)
   897 0000048A <res 00000001>      <2> 	.bVidSave2		resb	1		; 0:48Ah, Video, Save area 2 (VGA+)
   898 0000048B <res 00000001>      <2> 	.bFDCfgData		resb	1		; 0:48Bh, Diskette, Configuration data (AT+)
   899 0000048C <res 00000001>      <2> 	.bHDStatus		resb	1		; 0:48Ch, Hard Disk, Status Register (AT+)
   900 0000048D <res 00000001>      <2> 	.bHDError		resb	1		; 0:48Dh, Hard Disk, Error Register (AT+)
   901 0000048E <res 00000001>      <2> 	.bHDTaskFlg		resb	1		; 0:48Eh, Hard Disk, Task Complete Flag (AT+)
   902 0000048F <res 00000001>      <2> 	.bFDCtrlInfo	resb	1		; 0:48Fh, Diskette, Controller information (AT+)
   903                              <2> 
   904 00000490 <res 00000001>      <2> 	.bFDMedia0		resb	1		; 0:490h, Diskette 0, Media state (AT+)
   905 00000491 <res 00000001>      <2> 	.bFDMedia1		resb	1		; 0:491h, Diskette 1, Media state (AT+)
   906 00000492 <res 00000001>      <2> 	.bFDOpStart0	resb	1		; 0:492h, Diskette 0, Operational starting state (AT+)
   907 00000493 <res 00000001>      <2> 	.bFDOpStart1	resb	1		; 0:493h, Diskette 1, Operational starting state (AT+)
   908 00000494 <res 00000001>      <2> 	.bFDCurCyl0		resb	1		; 0:494h, Diskette 0, Current cylinder (AT+)
   909 00000495 <res 00000001>      <2> 	.bFDCurCyl1		resb	1		; 0:495h, Diskette 1, Current cylinder (AT+)
   910 00000496 <res 00000001>      <2> 	.bKBFlgs3		resb	1		; 0:496h, Keyboard, Status flags 3 (AT+)
   911 00000497 <res 00000001>      <2> 	.bKBFlgs4		resb	1		; 0:497h, Keyboard, Status flags 4 (AT+)
   912 00000498 <res 00000004>      <2> 	.dwWaitPtr		resb	4		; 0:498h, User's wait flag pointer (AT+)
   913 0000049C <res 00000004>      <2> 	.dwWaitCnt		resb	4		; 0:49Ch, User's wait count (AT+)
   914                              <2> 
   915 000004A0 <res 00000001>      <2> 	.bWaitFlg		resb	1		; 0:4A0h, Wait flag (AT+)
   916 000004A1 <res 00000007>      <2> 	.rgbLAN			resb	7		; 0:4A1h, Local Area Network (AT+)
   917 000004A8 <res 00000004>      <2> 	.dwVidPtr		resb	4		; 0:4A8h, Video, Parameter Control Block Pointer (EGA+)
   918 000004AC <res 00000022>      <2> 					resb	22h		; Reserved from 0:4ACh...0:4CDh
   919                              <2> 
   920 000004CE <res 00000004>      <2> 	.dwDays			resb	4		; 0:4CEh, Clock, Days since 1980 (some BIOSes, AT+)
   921 000004D2 <res 0000002E>      <2> 					resb	2Eh		; Reserved from 0:4D2h...0:4FFh
   922                              <2> 
   923 00000500 <res 00000001>      <2> 	.bPrntScrn		resb	1		; 0:500, Print screen status
   924                              <2> endstruc
   925                              <2> 
   926                              <2> ; BDA struct with only Hard Disk related locations
   927                              <2> struc HDBDA
   928 00000000 <res 00000474>      <2> 					resb	474h
   929 00000474 <res 00000001>      <2> 	.bHDLastSt		resb	1		; 0:474h, Status of Last Operation (XT+)
   930 00000475 <res 00000001>      <2> 	.bHDCount		resb	1		; 0:475h, Number of HDs Attached (XT+)
   931 00000476 <res 00000001>      <2> 	.bHDCtrl		resb	1		; 0:476h, Control Byte (temp, XT+)
   932 00000477 <res 00000001>      <2> 	.bHDPortOff		resb	1		; 0:477h, Port Offset (XT)
   933 00000478 <res 00000015>      <2> 					resb	15h
   934                              <2> 	.bHDStatus:						; 0:48Ch, Status Register (AT+)
   935                              <2> 	.bHDError:						; 0:48Dh, Error Register (AT+)
   936 0000048D <res 00000002>      <2> 	.wHDStAndErr	resb	2
   937 0000048F <res 00000001>      <2> 	.bHDTaskFlg		resb	1		; 0:48Eh, Task Complete Flag (AT+)
   938                              <2> endstruc
   939                              <2> 
   940                              <2> 
   941                              <2> ; Warm Boot Flags for BDA.wBoot
   942                              <2> BOOT_FLAG_COLD			EQU	0
   943                              <2> BOOT_FLAG_WARM			EQU	1234h	; Same effect as CTRL + ALT + DEL, skips memory tests
   944                              <2> BOOT_FLAG_PRESERVE_RAM	EQU	4321h	; No mem test, leave memory unchanged (AT+)
   945                              <2> 
   946                              <2> 
   947                              <2> %endif ; BIOSDATA_INC
   948                              <1> %include "BiosFunctions.inc"
   949                              <2> ; Project name	:	AssemblyLibrary
   950                              <2> ; Description	:	Defines for BIOS functions.
   951                              <2> %ifndef BIOS_FUNCTIONS_INC
   952                              <2> %define BIOS_FUNCTIONS_INC
   953                              <2> 
   954                              <2> ; BIOS interrupts
   955                              <2> BIOS_VIDEO_INTERRUPT_10h		EQU		10h
   956                              <2> BIOS_DISK_INTERRUPT_13h			EQU		13h
   957                              <2> BIOS_SYSTEM_INTERRUPT_15h		EQU		15h
   958                              <2> BIOS_KEYBOARD_INTERRUPT_16h		EQU		16h
   959                              <2> BIOS_BOOT_FAILURE_INTERRUPT_18h	EQU		18h
   960                              <2> BIOS_BOOT_LOADER_INTERRUPT_19h	EQU		19h
   961                              <2> BIOS_DISKETTE_INTERRUPT_40h		EQU		40h
   962                              <2> HD0_DPT_POINTER_41h				EQU		41h
   963                              <2> HD1_DPT_POINTER_46h				EQU		46h
   964                              <2> 
   965                              <2> ; Hardware interrupts
   966                              <2> HARDWARE_IRQ_0_INTERRUPT_08h	EQU		08h		; System timer
   967                              <2> HARDWARE_IRQ_1_INTERRUPT_09h	EQU		09h		; Keyboard
   968                              <2> HARDWARE_IRQ_2_INTERRUPT_0Ah	EQU		0Ah
   969                              <2> HARDWARE_IRQ_3_INTERRUPT_0Bh	EQU		0Bh
   970                              <2> HARDWARE_IRQ_4_INTERRUPT_0Ch	EQU		0Ch
   971                              <2> HARDWARE_IRQ_5_INTERRUPT_0Dh	EQU		0Dh
   972                              <2> HARDWARE_IRQ_6_INTERRUPT_0Eh	EQU		0Eh
   973                              <2> HARDWARE_IRQ_7_INTERRUPT_0Fh	EQU		0Fh
   974                              <2> HARDWARE_IRQ_8_INTERRUPT_70h	EQU		70h
   975                              <2> HARDWARE_IRQ_9_INTERRUPT_71h	EQU		71h
   976                              <2> HARDWARE_IRQ_10_INTERRUPT_72h	EQU		72h
   977                              <2> HARDWARE_IRQ_11_INTERRUPT_73h	EQU		73h
   978                              <2> HARDWARE_IRQ_12_INTERRUPT_74h	EQU		74h
   979                              <2> HARDWARE_IRQ_13_INTERRUPT_75h	EQU		75h
   980                              <2> HARDWARE_IRQ_14_INTERRUPT_76h	EQU		76h
   981                              <2> HARDWARE_IRQ_15_INTERRUPT_77h	EQU		77h
   982                              <2> 
   983                              <2> 
   984                              <2> ; BIOS video functions
   985                              <2> SET_VIDEO_MODE					EQU		00h
   986                              <2> SET_TEXT_MODE_CURSOR_SHAPE		EQU		01h
   987                              <2> SET_CURSOR_POSITION				EQU		02h
   988                              <2> GET_CURSOR_POSITION_AND_SIZE	EQU		03h
   989                              <2> SELECT_ACTIVE_DISPLAY_PAGE		EQU		05h
   990                              <2> TELETYPE_OUTPUT					EQU		0Eh
   991                              <2> 
   992                              <2> ; BIOS disk functions
   993                              <2> READ_SECTORS_INTO_MEMORY		EQU		02h
   994                              <2> GET_DRIVE_PARAMETERS			EQU		08h
   995                              <2> RESET_HARD_DISK					EQU		0Dh
   996                              <2> GET_DISK_TYPE					EQU		15h
   997                              <2> LOTECH_XTCF_FEATURES			EQU		1Eh
   998                              <2> GET_DRIVE_INFORMATION			EQU		25h
   999                              <2> CHECK_EXTENSIONS_PRESENT		EQU		41h
  1000                              <2> GET_EXTENDED_DRIVE_INFORMATION	EQU		48h
  1001                              <2> 
  1002                              <2> ; BIOS system functions
  1003                              <2> OS_HOOK_DEVICE_BUSY				EQU		90h
  1004                              <2> OS_HOOK_DEVICE_POST				EQU		91h
  1005                              <2> 
  1006                              <2> ; BIOS keyboard functions
  1007                              <2> GET_KEYSTROKE					EQU		00h
  1008                              <2> CHECK_FOR_KEYSTROKE				EQU		01h
  1009                              <2> 
  1010                              <2> ; BIOS system functions
  1011                              <2> EVENT_WAIT						EQU		86h
  1012                              <2> 
  1013                              <2> 
  1014                              <2> %endif ; BIOS_FUNCTIONS_INC
  1015                              <1> %include "CgaSnow.inc"
  1016                              <2> ; File name		:	CgaSnow.inc
  1017                              <2> ; Project name	:	AssemblyLibrary
  1018                              <2> ; Created date	:	8.10.2010
  1019                              <2> ; Last update	:	11.10.2010
  1020                              <2> ; Author		:	Tomi Tilli
  1021                              <2> ; Description	:	Macros for preventing CGA snow.
  1022                              <2> %ifndef CGASNOW_INC
  1023                              <2> %define CGASNOW_INC
  1024                              <2> 
  1025                              <2> ;--------------------------------------------------------------------
  1026                              <2> ; WAIT_RETRACE_IF_NECESSARY_THEN
  1027                              <2> ;	Parameters:
  1028                              <2> ;		%1:		Instruction that accessed CGA memory
  1029                              <2> ;		AL:		Character to output
  1030                              <2> ;		AH:		Attribute to output (stosw only)
  1031                              <2> ;		DS:		BDA segment (zero)
  1032                              <2> ;		ES:SI:	Ptr to video memory where to read from (if %1 reads)
  1033                              <2> ;		ES:DI:	Ptr to video memory where to output (if %1 writes)
  1034                              <2> ;	Returns:
  1035                              <2> ;		SI, DI:	Updated according to instruction
  1036                              <2> ;	Corrupts registers:
  1037                              <2> ;		AX, DX
  1038                              <2> ;--------------------------------------------------------------------
  1039                              <2> %macro WAIT_RETRACE_IF_NECESSARY_THEN 1
  1040                              <2> %ifdef ELIMINATE_CGA_SNOW
  1041                              <2> 	%ifidn %1, stosb
  1042                              <2> 		call	CgaSnow_Stosb
  1043                              <2> 	%elifidn %1, stosw
  1044                              <2> 		call	CgaSnow_Stosw
  1045                              <2> 	%elifidn %1, rep movsb
  1046                              <2> 		call	CgaSnow_RepMovsb
  1047                              <2> 	%else
  1048                              <2> 		%error	"Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  1049                              <2> 	%endif
  1050                              <2> %else	; No CGA snow prevention
  1051                              <2> 	%ifidn %1, rep movsb
  1052                              <2> 		eSEG_STR rep, es, movsb
  1053                              <2> 	%else
  1054                              <2> 		%1	; Single instruction
  1055                              <2> 	%endif
  1056                              <2> %endif
  1057                              <2> %endmacro
  1058                              <2> 
  1059                              <2> 
  1060                              <2> ;--------------------------------------------------------------------
  1061                              <2> ; WAIT_UNTIL_SAFE_CGA_WRITE
  1062                              <2> ;	Parameters:
  1063                              <2> ;		DX:		CGA Status Register Address (3DAh)
  1064                              <2> ;	Returns:
  1065                              <2> ;		Nothing
  1066                              <2> ;	Corrupts registers:
  1067                              <2> ;		AL
  1068                              <2> ;--------------------------------------------------------------------
  1069                              <2> %macro WAIT_UNTIL_SAFE_CGA_WRITE 0
  1070                              <2> %%WaitUntilNotInRetrace:
  1071                              <2> 	in		al, dx
  1072                              <2> 	shr		al, 1	; 1 = Bit 0: A 1 indicates that regen-buffer memory access can be
  1073                              <2> 					; made without interfering with the display. (H or V retrace)
  1074                              <2> 	jc		SHORT %%WaitUntilNotInRetrace
  1075                              <2> %%WaitUntilNextRetraceStarts:
  1076                              <2> 	in		al, dx
  1077                              <2> 	shr		al, 1
  1078                              <2> 	jnc		SHORT %%WaitUntilNextRetraceStarts
  1079                              <2> %endmacro
  1080                              <2> 
  1081                              <2> 
  1082                              <2> %endif ; CGASNOW_INC
  1083                              <1> %include "Debug.inc"
  1084                              <2> ; Project name	:	Assembly Library
  1085                              <2> ; Description	:	Debugging macros.
  1086                              <2> %ifndef DEBUG_INC
  1087                              <2> %define DEBUG_INC
  1088                              <2> 
  1089                              <2> 
  1090                              <2> ;--------------------------------------------------------------------
  1091                              <2> ; DISPLAY_DEBUG_WORD_AND_WAIT_ANY_KEY
  1092                              <2> ;	Parameters:
  1093                              <2> ;		%1:		Debug word
  1094                              <2> ;		%2:		Numeric base (2, 10, 16)
  1095                              <2> ;	Returns:
  1096                              <2> ;		Nothing
  1097                              <2> ;	Corrupts registers:
  1098                              <2> ;		Nothing
  1099                              <2> ;--------------------------------------------------------------------
  1100                              <2> %macro DISPLAY_DEBUG_WORD_AND_WAIT_ANY_KEY 2
  1101                              <2> 	pushf
  1102                              <2> 	push	di
  1103                              <2> 	push	bx
  1104                              <2> 	push	ax
  1105                              <2> 
  1106                              <2> 	mov		ax, %1
  1107                              <2> 	mov		bx, %2
  1108                              <2> 	CALL_DISPLAY_LIBRARY PrintWordFromAXwithBaseInBX
  1109                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1110                              <2> 	call	Keyboard_RemoveAllKeystrokesFromBuffer
  1111                              <2> %endif
  1112                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary
  1113                              <2> 
  1114                              <2> 	pop		ax
  1115                              <2> 	pop		bx
  1116                              <2> 	pop		di
  1117                              <2> 	popf
  1118                              <2> %endmacro
  1119                              <2> 
  1120                              <2> 
  1121                              <2> ;--------------------------------------------------------------------
  1122                              <2> ; DISPLAY_DEBUG_CHARACTER_AND_WAIT_ANY_KEY
  1123                              <2> ;	Parameters:
  1124                              <2> ;		%1:		Character to print
  1125                              <2> ;	Returns:
  1126                              <2> ;		Nothing
  1127                              <2> ;	Corrupts registers:
  1128                              <2> ;		Nothing
  1129                              <2> ;--------------------------------------------------------------------
  1130                              <2> %macro DISPLAY_DEBUG_CHARACTER_AND_WAIT_ANY_KEY 1
  1131                              <2> 	pushf
  1132                              <2> 	push	di
  1133                              <2> 	push	ax
  1134                              <2> 
  1135                              <2> 	mov		al, %1
  1136                              <2> 	CALL_DISPLAY_LIBRARY PrintCharacterFromAL
  1137                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1138                              <2> 	call	Keyboard_RemoveAllKeystrokesFromBuffer
  1139                              <2> %endif
  1140                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary
  1141                              <2> 
  1142                              <2> 	pop		ax
  1143                              <2> 	pop		di
  1144                              <2> 	popf
  1145                              <2> %endmacro
  1146                              <2> 
  1147                              <2> 
  1148                              <2> ;--------------------------------------------------------------------
  1149                              <2> ; DISPLAY_DEBUG_CHARACTER
  1150                              <2> ;	Parameters:
  1151                              <2> ;		%1:		Character to print
  1152                              <2> ;	Returns:
  1153                              <2> ;		Nothing
  1154                              <2> ;	Corrupts registers:
  1155                              <2> ;		Nothing
  1156                              <2> ;--------------------------------------------------------------------
  1157                              <2> %macro DISPLAY_DEBUG_CHARACTER 1
  1158                              <2> 	pushf
  1159                              <2> 	push	di
  1160                              <2> 	push	ax
  1161                              <2> 	mov		al, %1
  1162                              <2> 	CALL_DISPLAY_LIBRARY PrintCharacterFromAL
  1163                              <2> 	pop		ax
  1164                              <2> 	pop		di
  1165                              <2> 	popf
  1166                              <2> %endmacro
  1167                              <2> 
  1168                              <2> 
  1169                              <2> ;--------------------------------------------------------------------
  1170                              <2> ; WAIT_ANY_KEY_TO_CONTINUE
  1171                              <2> ;	Parameters:
  1172                              <2> ;		Nothing
  1173                              <2> ;	Returns:
  1174                              <2> ;		Nothing
  1175                              <2> ;	Corrupts registers:
  1176                              <2> ;		Nothing
  1177                              <2> ;--------------------------------------------------------------------
  1178                              <2> %macro WAIT_ANY_KEY_TO_CONTINUE 0
  1179                              <2> 	push	ax
  1180                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1181                              <2> 	call	Keyboard_RemoveAllKeystrokesFromBuffer
  1182                              <2> %endif
  1183                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary
  1184                              <2> 	pop		ax
  1185                              <2> %endmacro
  1186                              <2> 
  1187                              <2> 
  1188                              <2> %endif ; DEBUG_INC
  1189                              <1> %include "Delay.inc"
  1190                              <2> ; Project name	:	Assembly Library
  1191                              <2> ; Description	:	Delay macros.
  1192                              <2> %ifndef DELAY_INC
  1193                              <2> %define DELAY_INC
  1194                              <2> 
  1195                              <2> ;--------------------------------------------------------------------
  1196                              <2> ; Clears prefetch queue by jumping to next instruction.
  1197                              <2> ; This delays much more than nop instruction of fast systems.
  1198                              <2> ;
  1199                              <2> ; JMP_DELAY
  1200                              <2> ;	Parameters
  1201                              <2> ;		Nothing
  1202                              <2> ;	Returns:
  1203                              <2> ;		Nothing
  1204                              <2> ;	Corrupts registers:
  1205                              <2> ;		Nothing
  1206                              <2> ;--------------------------------------------------------------------
  1207                              <2> %macro JMP_DELAY 0
  1208                              <2> 	jmp		SHORT %%NextInstruction
  1209                              <2> %%NextInstruction:
  1210                              <2> %endmacro
  1211                              <2> 
  1212                              <2> 
  1213                              <2> ;--------------------------------------------------------------------
  1214                              <2> ; Mimimun delays (without fetching) with some CPU architectures:
  1215                              <2> ;	8088/8086:	17 cycles for jump + 5 cycles for last comparison
  1216                              <2> ;	286:		10 cycles for jump + 4 cycles for last comparison
  1217                              <2> ;	386:		13 cycles for jump + ? cycles for last comparison
  1218                              <2> ;	486:		 7 cycles for jump + 6 cycles for last comparison
  1219                              <2> ;
  1220                              <2> ; LOOP instruction uses two bytes so aligned fetching will require:
  1221                              <2> ;   8088:		8 cycles (two BYTE reads)
  1222                              <2> ;   8086:		4 cycles (one WORD read)
  1223                              <2> ;   286:		2 cycles + wait states (usually 1)
  1224                              <2> ;   386:		?
  1225                              <2> ;	486:		Fetched only once to internal cache
  1226                              <2> ;
  1227                              <2> ; DELAY_WITH_LOOP_INSTRUCTION_NA	; No JUMP_ALIGN
  1228                              <2> ; DELAY_WITH_LOOP_INSTRUCTION
  1229                              <2> ;	Parameters
  1230                              <2> ;		CX:		Loop iterations (0 is maximum delay with 65536 iterations)
  1231                              <2> ;	Returns:
  1232                              <2> ;		CX:		Zero
  1233                              <2> ;	Corrupts registers:
  1234                              <2> ;		Nothing
  1235                              <2> ;--------------------------------------------------------------------
  1236                              <2> %macro DELAY_WITH_LOOP_INSTRUCTION_NA 0
  1237                              <2> %%StartOfLoop:
  1238                              <2> 	loop	%%StartOfLoop
  1239                              <2> %endmacro
  1240                              <2> 
  1241                              <2> %macro DELAY_WITH_LOOP_INSTRUCTION 0
  1242                              <2> ALIGN JUMP_ALIGN
  1243                              <2> %%StartOfLoop:
  1244                              <2> 	loop	%%StartOfLoop
  1245                              <2> %endmacro
  1246                              <2> 
  1247                              <2> 
  1248                              <2> %endif ; DELAY_INC
  1249                              <1> %include "DosFunctions.inc"
  1250                              <2> ; Project name	:	AssemblyLibrary
  1251                              <2> ; Description	:	Defines for MS-DOS functions.
  1252                              <2> %ifndef DOS_FUNCTIONS_INC
  1253                              <2> %define DOS_FUNCTIONS_INC
  1254                              <2> 
  1255                              <2> ; DOS interrupts
  1256                              <2> DOS_INTERRUPT_21h									EQU		21h
  1257                              <2> DOS_CRITICAL_ERROR_HANDLER_24h						EQU		24h
  1258                              <2> DOS_TSR_MULTIPLEX_INTERRUPT_2Fh						EQU		2Fh
  1259                              <2> 
  1260                              <2> ; DOS drive and file functions
  1261                              <2> SELECT_DEFAULT_DRIVE								EQU		0Eh
  1262                              <2> GET_CURRENT_DEFAULT_DRIVE							EQU		19h
  1263                              <2> GET_DISK_TRANSFER_AREA_ADDRESS						EQU		2Fh
  1264                              <2> GET_DOS_DRIVE_PARAMETER_BLOCK_FOR_SPECIFIC_DRIVE	EQU		32h
  1265                              <2> SET_CURRENT_DIRECTORY								EQU		3Bh
  1266                              <2> CREATE_OR_TRUNCATE_FILE								EQU		3Ch
  1267                              <2> OPEN_EXISTING_FILE									EQU		3Dh
  1268                              <2> CLOSE_FILE											EQU		3Eh
  1269                              <2> READ_FROM_FILE_OR_DEVICE							EQU		3Fh
  1270                              <2> WRITE_TO_FILE_OR_DEVICE								EQU		40h
  1271                              <2> SET_CURRENT_FILE_POSITION							EQU		42h
  1272                              <2> GET_CURRENT_DIRECTORY								EQU		47h
  1273                              <2> FIND_FIRST_MATCHING_FILE							EQU		4Eh
  1274                              <2> FIND_NEXT_MATCHING_FILE								EQU		4Fh
  1275                              <2> 
  1276                              <2> ; DOS functions for TSRs
  1277                              <2> SET_INTERRUPT_VECTOR								EQU		25h
  1278                              <2> GET_INTERRUPT_VECTOR								EQU		35h
  1279                              <2> 
  1280                              <2> ; DOS errors
  1281                              <2> ERR_DOS_DRIVE_NOT_READY								EQU		15h
  1282                              <2> 
  1283                              <2> 
  1284                              <2> 
  1285                              <2> ; DOS Program Segment Prefix (PSP, first 256 (100h) bytes on top of program)
  1286                              <2> struc PSP
  1287 00000000 <res 00000002>      <2> 	.int20hInstruction				resb	2
  1288 00000002 <res 00000002>      <2> 	.wSizeOfMemoryInParagraphs		resb	2
  1289 00000004 <res 00000001>      <2> 	.reservedAt4h					resb	1
  1290 00000005 <res 00000005>      <2> 	.callToDosFunctionDispatcher	resb	5
  1291 0000000A <res 00000004>      <2> 	.fpInt22hTerminate				resb	4
  1292 0000000E <res 00000004>      <2> 	.fpInt23hCtrlC					resb	4
  1293 00000012 <res 00000004>      <2> 	.fpInt24hCriticalError			resb	4
  1294 00000016 <res 00000016>      <2> 	.reservedAt16h					resb	22
  1295 0000002C <res 00000002>      <2> 	.wEnvironmentSegment			resb	2
  1296 0000002E <res 00000022>      <2> 	.reservedAt2Eh					resb	34
  1297 00000050 <res 00000003>      <2> 	.int21hAndRetfInstructions		resb	3
  1298 00000053 <res 00000009>      <2> 	.reservedAt53h					resb	9
  1299 0000005C <res 00000010>      <2> 	.FCB1							resb	16
  1300 0000006C <res 00000014>      <2> 	.FCB2							resb	20
  1301                              <2> 	.DiskTransferArea:
  1302 00000080 <res 00000001>      <2> 	.bCommandLineLength				resb	1
  1303 00000081 <res 0000007F>      <2> 	.szCommandLine					resb	127
  1304                              <2> endstruc
  1305                              <2> 
  1306                              <2> 
  1307                              <2> ; DOS DTA (Disk Transfer Area)
  1308                              <2> struc DTA
  1309                              <2> 	; Undocumented fields
  1310 00000000 <res 00000015>      <2> 	.reservedAt0h		resb	21
  1311                              <2> 	; Documented fields
  1312 00000015 <res 00000001>      <2> 	.bFileAttributes	resb	1	; 15h, Attribute of matching file
  1313 00000016 <res 00000002>      <2> 	.wFileTime			resb	2	; 16h, File time
  1314 00000018 <res 00000002>      <2> 	.wFileDate			resb	2	; 18h, File date
  1315 0000001A <res 00000004>      <2> 	.dwFileSize			resb	4	; 1Ah, File size in bytes
  1316 0000001E <res 0000000D>      <2> 	.szFile				resb	13	; 1Eh, ASCIZ filename + extension
  1317                              <2> endstruc
  1318                              <2> 
  1319                              <2> 
  1320                              <2> %endif ; DOS_FUNCTIONS_INC
  1321                              <1> %include "File.inc"
  1322                              <2> ; File name		:	File.inc
  1323                              <2> ; Project name	:	Assembly Library
  1324                              <2> ; Created date	:	8.10.2010
  1325                              <2> ; Last update	:	6.12.2010
  1326                              <2> ; Author		:	Tomi Tilli
  1327                              <2> ; Description	:	File library defines.
  1328                              <2> %ifndef FILE_INC
  1329                              <2> %define FILE_INC
  1330                              <2> 
  1331                              <2> ; File access and sharing modes
  1332                              <2> struc FILE_ACCESS
  1333 00000000 <res 00000001>      <2> 	.ReadOnly		resb	1
  1334 00000001 <res 00000001>      <2> 	.WriteOnly		resb	1
  1335 00000002 <res 00000001>      <2> 	.ReadAndWrite	resb	1
  1336                              <2> endstruc
  1337                              <2> 
  1338                              <2> ; Origin of file seek
  1339                              <2> struc SEEK_FROM
  1340 00000000 <res 00000001>      <2> 	.startOfFile			resb	1	; 00h
  1341 00000001 <res 00000001>      <2> 	.currentFilePosition	resb	1	; 01h
  1342 00000002 <res 00000001>      <2> 	.endOfFile				resb	1	; 02h
  1343                              <2> endstruc
  1344                              <2> 
  1345                              <2> ; File attribute flags
  1346                              <2> FLG_FILEATTR_READ_ONLY			EQU		(1<<0)
  1347                              <2> FLG_FILEATTR_HIDDEN				EQU		(1<<1)
  1348                              <2> FLG_FILEATTR_SYSTEM				EQU		(1<<2)
  1349                              <2> FLG_FILEATTR_VOLUME_LABEL		EQU		(1<<3)
  1350                              <2> FLG_FILEATTR_DIRECTORY			EQU		(1<<4)
  1351                              <2> FLG_FILEATTR_ARCHIVE			EQU		(1<<5)
  1352                              <2> 
  1353                              <2> 
  1354                              <2> ; Max number of bytes to read/write per DOS call when transferring DX:CX bytes
  1355                              <2> SPLIT_SIZE_FOR_LARGE_TRANSFERS	EQU		(32<<10)
  1356                              <2> 
  1357                              <2> 
  1358                              <2> %endif ; FILE_INC
  1359                              <1> %include "Math.inc"
  1360                              <2> ; Project name	:	Assembly Library
  1361                              <2> ; Description	:	Math related macros.
  1362                              <2> %ifndef MATH_INC
  1363                              <2> %define MATH_INC
  1364                              <2> 
  1365                              <2> FALSE		EQU		0
  1366                              <2> TRUE		EQU		1
  1367                              <2> 
  1368                              <2> 
  1369                              <2> ;--------------------------------------------------------------------
  1370                              <2> ; MIN_U		Unsigned comparison
  1371                              <2> ; MIN_S		Signed comparison
  1372                              <2> ;	Parameters:
  1373                              <2> ;		%1:		Operand 1
  1374                              <2> ;		%2:		Operand 2
  1375                              <2> ;	Returns:
  1376                              <2> ;		%1:		Lesser operand
  1377                              <2> ;	Corrupts registers:
  1378                              <2> ;		Nothing
  1379                              <2> ;--------------------------------------------------------------------
  1380                              <2> %macro MIN_U 2
  1381                              <2> 	cmp		%1, %2				; Is %1 smaller?
  1382                              <2> 	jb		%%Return			;  If so, return
  1383                              <2> 	mov		%1, %2				; Copy %2 to %1
  1384                              <2> ALIGN JUMP_ALIGN
  1385                              <2> %%Return:
  1386                              <2> %endmacro
  1387                              <2> 
  1388                              <2> %macro MIN_S 2
  1389                              <2> 	cmp		%1, %2				; Is %1 smaller?
  1390                              <2> 	jl		%%Return			;  If so, return
  1391                              <2> 	mov		%1, %2				; Copy %2 to %1
  1392                              <2> ALIGN JUMP_ALIGN
  1393                              <2> %%Return:
  1394                              <2> %endmacro
  1395                              <2> 
  1396                              <2> 
  1397                              <2> ;--------------------------------------------------------------------
  1398                              <2> ; MAX_U		Unsigned comparison
  1399                              <2> ; MAX_S		Signed comparison
  1400                              <2> ;	Parameters:
  1401                              <2> ;		%1:		Operand 1
  1402                              <2> ;		%2:		Operand 2
  1403                              <2> ;	Returns:
  1404                              <2> ;		%1:		Greater operand
  1405                              <2> ;	Corrupts registers:
  1406                              <2> ;		Nothing
  1407                              <2> ;--------------------------------------------------------------------
  1408                              <2> %macro MAX_U 2
  1409                              <2> 	cmp		%1, %2				; Is %1 greater?
  1410                              <2> 	ja		%%Return			;  If so, return
  1411                              <2> 	mov		%1, %2				; Copy %2 to %1
  1412                              <2> ALIGN JUMP_ALIGN
  1413                              <2> %%Return:
  1414                              <2> %endmacro
  1415                              <2> 
  1416                              <2> %macro MAX_S 2
  1417                              <2> 	cmp		%1, %2				; Is %1 greater?
  1418                              <2> 	jg		%%Return			;  If so, return
  1419                              <2> 	mov		%1, %2				; Copy %2 to %1
  1420                              <2> ALIGN JUMP_ALIGN
  1421                              <2> %%Return:
  1422                              <2> %endmacro
  1423                              <2> 
  1424                              <2> 
  1425                              <2> ;--------------------------------------------------------------------
  1426                              <2> ; SHL_DXAX
  1427                              <2> ;	Parameters:
  1428                              <2> ;		%1:		Number of bits to shift
  1429                              <2> ;	Returns:
  1430                              <2> ;		DX:AX	Shifted value
  1431                              <2> ;	Corrupts registers:
  1432                              <2> ;		CX
  1433                              <2> ;--------------------------------------------------------------------
  1434                              <2> %macro SHL_DXAX 1
  1435                              <2> 	%ifnidni %1, cx
  1436                              <2> 		mov		cx, %1
  1437                              <2> 	%endif
  1438                              <2> ALIGN JUMP_ALIGN
  1439                              <2> .ShiftNextBit:
  1440                              <2> 	eSHL_IM	ax, 1
  1441                              <2> 	rcl		dx, 1
  1442                              <2> 	loop	.ShiftNextBit
  1443                              <2> %endmacro
  1444                              <2> 
  1445                              <2> 
  1446                              <2> ;--------------------------------------------------------------------
  1447                              <2> ; SHR_DXAX
  1448                              <2> ;	Parameters:
  1449                              <2> ;		%1:		Number of bits to shift
  1450                              <2> ;	Returns:
  1451                              <2> ;		DX:AX	Shifted value
  1452                              <2> ;	Corrupts registers:
  1453                              <2> ;		CX
  1454                              <2> ;--------------------------------------------------------------------
  1455                              <2> %macro SHR_DXAX 1
  1456                              <2> 	%ifnidni %1, cx
  1457                              <2> 		mov		cx, %1
  1458                              <2> 	%endif
  1459                              <2> ALIGN JUMP_ALIGN
  1460                              <2> .ShiftNextBit:
  1461                              <2> 	shr		dx, 1
  1462                              <2> 	rcr		ax, 1
  1463                              <2> 	loop	.ShiftNextBit
  1464                              <2> %endmacro
  1465                              <2> 
  1466                              <2> 
  1467                              <2> %endif ; MATH_INC
  1468                              <1> %include "Registers.inc"
  1469                              <2> ; Project name	:	Assembly Library
  1470                              <2> ; Description	:	Register related macros.
  1471                              <2> %ifndef REGISTERS_INC
  1472                              <2> %define REGISTERS_INC
  1473                              <2> 
  1474                              <2> struc INTPACK
  1475                              <2> %ifdef USE_386
  1476                              <2> ;	.gs				resb	2
  1477                              <2> ;	.fs				resb	2
  1478                              <2> %endif
  1479 00000000 <res 00000002>      <2> 	.es				resb	2
  1480 00000002 <res 00000002>      <2> 	.ds				resb	2
  1481 00000004 <res 00000002>      <2> 	.di				resb	2
  1482 00000006 <res 00000002>      <2> 	.si				resb	2
  1483 00000008 <res 00000002>      <2> 	.bp				resb	2
  1484 0000000A <res 00000002>      <2> 	.sp				resb	2
  1485                              <2> 	.bx:
  1486 0000000C <res 00000001>      <2> 	.bl				resb	1
  1487 0000000D <res 00000001>      <2> 	.bh				resb	1
  1488                              <2> 	.dx:
  1489 0000000E <res 00000001>      <2> 	.dl				resb	1
  1490 0000000F <res 00000001>      <2> 	.dh				resb	1
  1491                              <2> 	.cx:
  1492 00000010 <res 00000001>      <2> 	.cl				resb	1
  1493 00000011 <res 00000001>      <2> 	.ch				resb	1
  1494                              <2> 	.ax:
  1495 00000012 <res 00000001>      <2> 	.al				resb	1
  1496 00000013 <res 00000001>      <2> 	.ah				resb	1
  1497 00000014 <res 00000002>      <2> 	.ip				resb	2
  1498 00000016 <res 00000002>      <2> 	.cs				resb	2
  1499 00000018 <res 00000002>      <2> 	.flags			resb	2
  1500                              <2> endstruc
  1501                              <2> 
  1502                              <2> ; 8086/8088 FLAGS
  1503                              <2> FLG_FLAGS_CF		EQU (1<<0)
  1504                              <2> FLG_FLAGS_PF		EQU (1<<2)
  1505                              <2> FLG_FLAGS_AF		EQU (1<<4)
  1506                              <2> FLG_FLAGS_ZF		EQU (1<<6)
  1507                              <2> FLG_FLAGS_SF		EQU (1<<7)
  1508                              <2> FLG_FLAGS_TF		EQU (1<<8)
  1509                              <2> FLG_FLAGS_IF		EQU (1<<9)
  1510                              <2> FLG_FLAGS_DF		EQU (1<<10)
  1511                              <2> FLG_FLAGS_OF		EQU (1<<11)
  1512                              <2> 
  1513                              <2> 
  1514                              <2> ;--------------------------------------------------------------------
  1515                              <2> ; This macro must be the first thing to call on Interrupt Service Routine.
  1516                              <2> ;
  1517                              <2> ; CREATE_INTPACK_TO_SSBP
  1518                              <2> ;	Parameters
  1519                              <2> ;		Nothing
  1520                              <2> ;	Returns:
  1521                              <2> ;		SS:BP:	Points to INTPACK
  1522                              <2> ;	Corrupts registers:
  1523                              <2> ;		Nothing
  1524                              <2> ;--------------------------------------------------------------------
  1525                              <2> %macro CREATE_INTPACK_TO_SSBP 0
  1526                              <2> 	ePUSHA
  1527                              <2> 	push	ds
  1528                              <2> 	push	es
  1529                              <2> %ifdef USE_386
  1530                              <2> ;	push	fs
  1531                              <2> ;	push	gs
  1532                              <2> %endif
  1533                              <2> 	mov		bp, sp
  1534                              <2> %endmacro
  1535                              <2> 
  1536                              <2> ;--------------------------------------------------------------------
  1537                              <2> ; This macro must be the last thing to call on Interrupt Service Routine.
  1538                              <2> ;
  1539                              <2> ; RESTORE_INTPACK_FROM_SSBP
  1540                              <2> ;	Parameters
  1541                              <2> ;		SS:BP:	Ptr to INTPACK
  1542                              <2> ;	Returns:
  1543                              <2> ;		All Registers will be loaded from INTPACK
  1544                              <2> ;--------------------------------------------------------------------
  1545                              <2> %macro RESTORE_INTPACK_FROM_SSBP 0
  1546                              <2> %ifdef USE_386
  1547                              <2> ;	pop		gs
  1548                              <2> ;	pop		fs
  1549                              <2> %endif
  1550                              <2> 	pop		es
  1551                              <2> 	pop		ds
  1552                              <2> 	ePOPA
  1553                              <2> 	iret
  1554                              <2> %endmacro
  1555                              <2> 
  1556                              <2> 
  1557                              <2> ;--------------------------------------------------------------------
  1558                              <2> ; This macro must be the first thing to call on Interrupt Service Routine.
  1559                              <2> ;
  1560                              <2> ; CREATE_FRAME_INTPACK_TO_SSBP
  1561                              <2> ;	Parameters
  1562                              <2> ;		%1:		Number of extra bytes to reserve before INTPACK
  1563                              <2> ;	Returns:
  1564                              <2> ;		SS:BP:	Points to INTPACK
  1565                              <2> ;	Corrupts registers:
  1566                              <2> ;		Nothing
  1567                              <2> ;--------------------------------------------------------------------
  1568                              <2> %macro CREATE_FRAME_INTPACK_TO_SSBP 1
  1569                              <2> 	ePUSHA
  1570                              <2> 	push	ds
  1571                              <2> 	push	es
  1572                              <2> %ifdef USE_386
  1573                              <2> ;	push	fs
  1574                              <2> ;	push	gs
  1575                              <2> %endif
  1576                              <2> 	sub		sp, BYTE %1
  1577                              <2> 	mov		bp, sp
  1578                              <2> %endmacro
  1579                              <2> 
  1580                              <2> ;--------------------------------------------------------------------
  1581                              <2> ; This macro must be the last thing to call on Interrupt Service Routine.
  1582                              <2> ;
  1583                              <2> ; RESTORE_FRAME_INTPACK_FROM_SSBP
  1584                              <2> ;	Parameters
  1585                              <2> ;		%1:		Number of extra bytes in INTPACK
  1586                              <2> ;		SS:BP:	Ptr to INTPACK
  1587                              <2> ;	Returns:
  1588                              <2> ;		All Registers will be loaded from INTPACK
  1589                              <2> ;--------------------------------------------------------------------
  1590                              <2> %macro RESTORE_FRAME_INTPACK_FROM_SSBP 1
  1591                              <2> 	add		sp, BYTE %1
  1592                              <2> %ifdef USE_386
  1593                              <2> ;	pop		gs
  1594                              <2> ;	pop		fs
  1595                              <2> %endif
  1596                              <2> 	pop		es
  1597                              <2> 	pop		ds
  1598                              <2> 	ePOPA
  1599                              <2> 	iret
  1600                              <2> %endmacro
  1601                              <2> 
  1602                              <2> 
  1603                              <2> ;--------------------------------------------------------------------
  1604                              <2> ; NORMALIZE_FAR_POINTER
  1605                              <2> ;	Parameters:
  1606                              <2> ;		%1:%2:		Far pointer to normalize
  1607                              <2> ;		%3:			Scratch register
  1608                              <2> ;		%4:			Scratch register
  1609                              <2> ;	Returns:
  1610                              <2> ;		%1:%2:		Normalized far pointer
  1611                              <2> ;	Corrupts registers:
  1612                              <2> ;		%3, %4
  1613                              <2> ;--------------------------------------------------------------------
  1614                              <2> %macro NORMALIZE_FAR_POINTER 4
  1615                              <2> 	mov		%4, %2				; Copy offset to scratch reg
  1616                              <2> 	and		%2, BYTE 0Fh		; Clear offset bits 15...4
  1617                              <2> 	eSHR_IM	%4, 4				; Divide offset by 16
  1618                              <2> 	mov		%3, %1				; Copy segment to scratch reg
  1619                              <2> 	add		%3, %4				; Add shifted offset to segment
  1620                              <2> 	mov		%1, %3				; Set normalized segment
  1621                              <2> %endmacro
  1622                              <2> 
  1623                              <2> 
  1624                              <2> ;--------------------------------------------------------------------
  1625                              <2> ; COPY_SSBP_TO_ESDI
  1626                              <2> ; COPY_SSBP_TO_DSSI
  1627                              <2> ; COPY_DSSI_TO_ESDI
  1628                              <2> ; COPY_ESDI_to_DSSI
  1629                              <2> ;	Parameters
  1630                              <2> ;		Nothing
  1631                              <2> ;	Returns:
  1632                              <2> ;		Copies farm pointer to different segment/pointer register pair
  1633                              <2> ;	Corrupts registers:
  1634                              <2> ;		Nothing
  1635                              <2> ;--------------------------------------------------------------------
  1636                              <2> %macro COPY_SSBP_TO_ESDI 0
  1637                              <2> 	push	ss
  1638                              <2> 	pop		es
  1639                              <2> 	mov		di, bp
  1640                              <2> %endmacro
  1641                              <2> 
  1642                              <2> %macro COPY_SSBP_TO_DSSI 0
  1643                              <2> 	push	ss
  1644                              <2> 	pop		ds
  1645                              <2> 	mov		si, bp
  1646                              <2> %endmacro
  1647                              <2> 
  1648                              <2> %macro COPY_DSSI_TO_ESDI 0
  1649                              <2> 	push	ds
  1650                              <2> 	pop		es
  1651                              <2> 	mov		di, si
  1652                              <2> %endmacro
  1653                              <2> 
  1654                              <2> %macro COPY_ESDI_to_DSSI 0
  1655                              <2> 	push	es
  1656                              <2> 	pop		ds
  1657                              <2> 	mov		si, di
  1658                              <2> %endmacro
  1659                              <2> 
  1660                              <2> 
  1661                              <2> 
  1662                              <2> %endif ; REGISTERS_INC
  1663                              <1> %include "SystemTimer.inc"
  1664                              <2> ; Project name	:	Assembly Library
  1665                              <2> ; Description	:	System Timer (8254) relates equates and macros.
  1666                              <2> %ifndef SYSTEMTIMER_INC
  1667                              <2> %define SYSTEMTIMER_INC
  1668                              <2> 
  1669                              <2> ; Timer/Counter to program
  1670                              <2> TIMER_0									EQU	(0<<6)
  1671                              <2> TIMER_1									EQU	(1<<6)
  1672                              <2> TIMER_2									EQU	(2<<6)
  1673                              <2> 
  1674                              <2> ; Counter commands
  1675                              <2> LATCH									EQU	(0<<4)	; Counter Latch Command (latches the count for reading)
  1676                              <2> READ_OR_WRITE_LSB_ONLY					EQU	(1<<4)	; MSB is always zero
  1677                              <2> READ_OR_WRITE_MSB_ONLY					EQU	(2<<4)	; LSB is always zero
  1678                              <2> READ_OR_WRITE_LSB_THEN_MSB				EQU	(3<<4)
  1679                              <2> 
  1680                              <2> ; Timer modes
  1681                              <2> MODE_0_SINGLE_TIMEOUT					EQU	(0<<1)	; Interrupt on Terminal Count
  1682                              <2> MODE_1_ONE_SHOT							EQU	(1<<1)	; Hardware Retriggerable One-Shot
  1683                              <2> MODE_2_RATE_GENERATOR					EQU	(2<<1)
  1684                              <2> MODE_3_SQUARE_WAVE_MODE					EQU	(3<<1)
  1685                              <2> MODE_4_SOFTWARE_TRIGGERED_STROBE		EQU	(4<<1)
  1686                              <2> MODE_5_HARDWARE_RETRIGGERABLE_STROBE	EQU	(5<<1)
  1687                              <2> 
  1688                              <2> ; Binary / BCD Mode
  1689                              <2> BINARY_COUNTER							EQU	0
  1690                              <2> BCD_COUNTER								EQU	1
  1691                              <2> 
  1692                              <2> 
  1693                              <2> ; Ports
  1694                              <2> COUNT_REGISTER_0						EQU	40h		; Timer 0 Count Register (System Timer Ticks)
  1695                              <2> COUNT_REGISTER_1						EQU	41h		; Timer 1 Count Register (DRAM Refresh)
  1696                              <2> COUNT_REGISTER_2						EQU	42h		; Timer 2 Count Register (General Use)
  1697                              <2> CONTROL_WORD_REGISTER_out				EQU	43h
  1698                              <2> 
  1699                              <2> ; Timer 2 is connected to PC Speaker that can be controller from port 61h.
  1700                              <2> SPEAKER_CONTROL_REGISTER				EQU	61h
  1701                              <2> FLG_TIMER_2_OUTPUT_in					EQU	(1<<5)	; AT+ only
  1702                              <2> FLG_SPEAKER_DATA_ENABLED				EQU	(1<<1)
  1703                              <2> FLG_SPEAKER_GATE_TIMER_2_ON				EQU	(1<<0)
  1704                              <2> 
  1705                              <2> 
  1706                              <2> ; The duration of one tick
  1707                              <2> TIMER_CYCLE_TIME						EQU	838		; nanosecs
  1708                              <2> 
  1709                              <2> 
  1710                              <2> 
  1711                              <2> 
  1712                              <2> ;--------------------------------------------------------------------
  1713                              <2> ; OUTPUT_COUNTER_COMMAND_TO
  1714                              <2> ;	Parameters:
  1715                              <2> ;		%1:		TIMER_0, TIMER_1 or TIMER_2
  1716                              <2> ;		%2:		Command to counter
  1717                              <2> ;		%3:		Timer mode
  1718                              <2> ;		%4:		BINARY_COUNTER or BCD_COUNTER
  1719                              <2> ;	Returns:
  1720                              <2> ;		Nothing
  1721                              <2> ;	Corrupts registers:
  1722                              <2> ;		AL
  1723                              <2> ;--------------------------------------------------------------------
  1724                              <2> %macro OUTPUT_COUNTER_COMMAND_TO 4
  1725                              <2> 	mov		al, %1 | %2 | %3 | %4
  1726                              <2> 	out		CONTROL_WORD_REGISTER_out, al
  1727                              <2> %endmacro
  1728                              <2> 
  1729                              <2> 
  1730                              <2> ;--------------------------------------------------------------------
  1731                              <2> ; WRITE_COUNT_FROM_AL_TO
  1732                              <2> ; WRITE_COUNT_FROM_AX_TO
  1733                              <2> ;	Parameters:
  1734                              <2> ;		%1:		TIMER_0, TIMER_1 or TIMER_2
  1735                              <2> ;		AX:		Count to write to timer
  1736                              <2> ;	Returns:
  1737                              <2> ;		Nothing
  1738                              <2> ;	Corrupts registers:
  1739                              <2> ;		AL (WRITE_COUNT_FROM_AX_TO only)
  1740                              <2> ;--------------------------------------------------------------------
  1741                              <2> %macro WRITE_COUNT_FROM_AL_TO 1
  1742                              <2> 	%ifidni %1, TIMER_0
  1743                              <2> 		out		COUNT_REGISTER_0, al
  1744                              <2> 	%elifidni %1, TIMER_1
  1745                              <2> 		out		COUNT_REGISTER_1, al
  1746                              <2> 	%elifidni %1, TIMER_2
  1747                              <2> 		out		COUNT_REGISTER_2, al
  1748                              <2> 	%else
  1749                              <2> 		%error "Invalid timer name passed to WRITE_COUNT_FROM_AL_TO"
  1750                              <2> 	%endif
  1751                              <2> %endmacro
  1752                              <2> 
  1753                              <2> %macro WRITE_COUNT_FROM_AX_TO 1
  1754                              <2> 	%ifidni %1, TIMER_0
  1755                              <2> 		out		COUNT_REGISTER_0, al
  1756                              <2> 		mov		al, ah
  1757                              <2> 		out		COUNT_REGISTER_0, al
  1758                              <2> 	%elifidni %1, TIMER_1
  1759                              <2> 		out		COUNT_REGISTER_1, al
  1760                              <2> 		mov		al, ah
  1761                              <2> 		out		COUNT_REGISTER_1, al
  1762                              <2> 	%elifidni %1, TIMER_2
  1763                              <2> 		out		COUNT_REGISTER_2, al
  1764                              <2> 		mov		al, ah
  1765                              <2> 		out		COUNT_REGISTER_2, al
  1766                              <2> 	%else
  1767                              <2> 		%error "Invalid timer name passed to WRITE_COUNT_FROM_AX_TO"
  1768                              <2> 	%endif
  1769                              <2> %endmacro
  1770                              <2> 
  1771                              <2> 
  1772                              <2> ;--------------------------------------------------------------------
  1773                              <2> ; READ_COUNT_TO_AL_FROM
  1774                              <2> ; READ_COUNT_TO_AX_FROM
  1775                              <2> ;	Parameters:
  1776                              <2> ;		%1:		TIMER_0, TIMER_1 or TIMER_2
  1777                              <2> ;	Returns:
  1778                              <2> ;		AL/AX:	Counter value
  1779                              <2> ;	Corrupts registers:
  1780                              <2> ;		Nothing
  1781                              <2> ;--------------------------------------------------------------------
  1782                              <2> %macro READ_COUNT_TO_AL_FROM 1
  1783                              <2> 	%ifidni %1, TIMER_0
  1784                              <2> 		in		al, COUNT_REGISTER_0
  1785                              <2> 	%elifidni %1, TIMER_1
  1786                              <2> 		in		al, COUNT_REGISTER_1
  1787                              <2> 	%elifidni %1, TIMER_2
  1788                              <2> 		in		al, COUNT_REGISTER_2
  1789                              <2> 	%else
  1790                              <2> 		%error "Invalid timer name passed to READ_COUNT_TO_AL_FROM"
  1791                              <2> 	%endif
  1792                              <2> %endmacro
  1793                              <2> 
  1794                              <2> %macro READ_COUNT_TO_AX_FROM 1
  1795                              <2> 	%ifidni %1, TIMER_0
  1796                              <2> 		in		al, COUNT_REGISTER_0
  1797                              <2> 		mov		ah, al
  1798                              <2> 		in		al, COUNT_REGISTER_0
  1799                              <2> 	%elifidni %1, TIMER_1
  1800                              <2> 		in		al, COUNT_REGISTER_1
  1801                              <2> 		mov		ah, al
  1802                              <2> 		in		al, COUNT_REGISTER_1
  1803                              <2> 	%elifidni %1, TIMER_2
  1804                              <2> 		in		al, COUNT_REGISTER_2
  1805                              <2> 		mov		ah, al
  1806                              <2> 		in		al, COUNT_REGISTER_2
  1807                              <2> 	%else
  1808                              <2> 		%error "Invalid timer name passed to READ_COUNT_TO_AX_FROM"
  1809                              <2> 	%endif
  1810                              <2> 		xchg	al, ah
  1811                              <2> %endmacro
  1812                              <2> 
  1813                              <2> 
  1814                              <2> ;--------------------------------------------------------------------
  1815                              <2> ; START_PRECISE_EVENT_TIMER
  1816                              <2> ;	Parameters:
  1817                              <2> ;		Nothing
  1818                              <2> ;	Returns:
  1819                              <2> ;		Nothing
  1820                              <2> ;	Corrupts registers:
  1821                              <2> ;		AL
  1822                              <2> ;--------------------------------------------------------------------
  1823                              <2> %macro START_PRECISE_EVENT_TIMER 0
  1824                              <2> 	in		al, SPEAKER_CONTROL_REGISTER
  1825                              <2> 	or		al, FLG_SPEAKER_GATE_TIMER_2_ON
  1826                              <2> 	out		SPEAKER_CONTROL_REGISTER, al
  1827                              <2> %endmacro
  1828                              <2> 
  1829                              <2> 
  1830                              <2> ;--------------------------------------------------------------------
  1831                              <2> ; STOP_PRECISE_EVENT_TIMER
  1832                              <2> ;	Parameters:
  1833                              <2> ;		Nothing
  1834                              <2> ;	Returns:
  1835                              <2> ;		Nothing
  1836                              <2> ;	Corrupts registers:
  1837                              <2> ;		AL
  1838                              <2> ;--------------------------------------------------------------------
  1839                              <2> %macro STOP_PRECISE_EVENT_TIMER 0
  1840                              <2> 	in		al, SPEAKER_CONTROL_REGISTER
  1841                              <2> 	and		al, ~(FLG_SPEAKER_DATA_ENABLED | FLG_SPEAKER_GATE_TIMER_2_ON)
  1842                              <2> 	out		SPEAKER_CONTROL_REGISTER, al
  1843                              <2> %endmacro
  1844                              <2> 
  1845                              <2> 
  1846                              <2> %endif ; SYSTEMTIMER_INC
  1847                              <1> 
  1848                              <1> 
  1849                              <1> ; Library dependencies
  1850                              <1> %ifdef INCLUDE_MENU_DIALOGS
  1851                              <1> 	%include "Dialog.inc"
  1852                              <1> 	%define INCLUDE_MENU_LIBRARY
  1853                              <1> 	%define INCLUDE_FILE_LIBRARY
  1854                              <1> %endif
  1855                              <1> 
  1856                              <1> %ifdef INCLUDE_MENU_LIBRARY
  1857                              <1> 	%include "Menu.inc"
  1858                              <1> 	%include "MenuEvents.inc"
  1859                              <1> 	%define INCLUDE_KEYBOARD_LIBRARY
  1860                              <1> 	%define INCLUDE_TIME_LIBRARY
  1861                              <1> %endif
  1862                              <1> 
  1863                              <1> %ifdef INCLUDE_KEYBOARD_LIBRARY
  1864                              <1> 	%define INCLUDE_DISPLAY_LIBRARY
  1865                              <1> 	%define INCLUDE_UTIL_LIBRARY
  1866                              <1> %endif
  1867                              <1> 
  1868                              <1> %ifdef INCLUDE_DISPLAY_LIBRARY
  1869                              <1> 	%include "Display.inc"
  1870                              <2> ; Project name	:	AssemblyLibrary
  1871                              <2> ; Description	:	Defines for display library.
  1872                              <2> %ifndef DISPLAY_INC
  1873                              <2> %define DISPLAY_INC
  1874                              <2> 
  1875                              <2> %ifndef MODULE_STRINGS_COMPRESSED_PRECOMPRESS
  1876                              <2> ;--------------------------------------------------------------------
  1877                              <2> ; Display Library users need to use these macros since it will provide
  1878                              <2> ; compatibility with future library versions.
  1879                              <2> ;
  1880                              <2> ; CALL_DISPLAY_LIBRARY
  1881                              <2> ; JMP_DISPLAY_LIBRARY
  1882                              <2> ;	Parameters:
  1883                              <2> ;		%1:			Function to call (functionName from DISPLAY_LIB)
  1884                              <2> ;		Registers:	Depends on function to call
  1885                              <2> ;	Returns:
  1886                              <2> ;		Depends on function to call
  1887                              <2> ;	Corrupts registers:
  1888                              <2> ;		AX (unless used as a return register), DI
  1889                              <2> ;--------------------------------------------------------------------
  1890                              <2> %macro CALL_DISPLAY_LIBRARY 1
  1891                              <2> 	%ifidn %1, PushDisplayContext
  1892                              <2> 		call	DisplayContext_Push
  1893                              <2> 	%elifidn %1, PopDisplayContext
  1894                              <2> 		call	DisplayContext_Pop
  1895                              <2> 	%elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
  1896                              <2> 		call	DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
  1897                              <2> 	%else
  1898                              <2> 		mov		di, %1
  1899                              <2> 		call	Display_FunctionFromDI
  1900                              <2> 	%endif
  1901                              <2> %endmacro
  1902                              <2> 
  1903                              <2> %macro JMP_DISPLAY_LIBRARY 1
  1904                              <2> 	%ifidn %1, PushDisplayContext
  1905                              <2> 		jmp		DisplayContext_Push
  1906                              <2> 	%elifidn %1, PopDisplayContext
  1907                              <2> 		call	DisplayContext_Pop
  1908                              <2> 		ret
  1909                              <2> 	%elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
  1910                              <2> 		jmp		DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
  1911                              <2> 	%elifidn %1, FormatNullTerminatedStringFromCSSI
  1912                              <2> 		mov		di, %1
  1913                              <2> 		call	Display_FunctionFromDI
  1914                              <2> 		ret
  1915                              <2> 	%else
  1916                              <2> 		mov		di, %1
  1917                              <2> 		jmp		Display_FunctionFromDI
  1918                              <2> 	%endif
  1919                              <2> %endmacro
  1920                              <2> 
  1921                              <2> %if 0
  1922                              <2> ;;;
  1923                              <2> ;;; struc no longer needed with direct calls to functions
  1924                              <2> ;;;
  1925                              <2> 
  1926                              <2> ; Display library functions
  1927                              <2> struc DISPLAY_LIB
  1928                              <2> 	.PushDisplayContext:
  1929                              <2> 	.PopDisplayContext:
  1930                              <2> 	.InitializeDisplayContext						resb	2
  1931                              <2> 
  1932                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1933                              <2> 	.SetCharacterPointerFromBXAX					resb	2
  1934                              <2> %endif
  1935                              <2> 	.SetCharOutputFunctionFromAXwithAttribFlagInBL	resb	2
  1936                              <2> 	.SetCharacterOutputParameterFromAX				resb	2
  1937                              <2> 	.SetCharacterAttributeFromAL					resb	2
  1938                              <2> 	.SetCursorShapeFromAX							resb	2
  1939                              <2> 	.SetCursorCoordinatesFromAX						resb	2
  1940                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  1941                              <2> 	.SetNewPageFromAL								resb	2
  1942                              <2> %endif
  1943                              <2> 	.SynchronizeDisplayContextToHardware			resb	2
  1944                              <2> 
  1945                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1946                              <2> 	.GetCharacterPointerToBXAX						resb	2
  1947                              <2> %endif
  1948                              <2> 	.GetSoftwareCoordinatesToAX						resb	2
  1949                              <2> 	.GetColumnsToALandRowsToAH						resb	2
  1950                              <2> 
  1951                              <2> 	.FormatNullTerminatedStringFromCSSI				resb	2
  1952                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1953                              <2> 	.PrintSignedWordFromAXWithBaseInBX				resb	2
  1954                              <2> %endif
  1955                              <2> 	.PrintWordFromAXwithBaseInBX					resb	2
  1956                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  1957                              <2> 	.PrintQWordFromSSBPwithBaseInBX					resb	2
  1958                              <2> %endif
  1959                              <2> 	.PrintCharBufferFromBXSIwithLengthInCX			resb	2
  1960                              <2> 	.PrintNullTerminatedStringFromBXSI				resb	2
  1961                              <2> 	.PrintNullTerminatedStringFromCSSI				resb	2
  1962                              <2> 	.PrintRepeatedCharacterFromALwithCountInCX		resb	2
  1963                              <2> 	.PrintCharacterFromAL							resb	2
  1964                              <2> 	.PrintNewlineCharacters							resb	2
  1965                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  1966                              <2> 	.ClearAreaWithHeightInAHandWidthInAL			resb	2
  1967                              <2> %endif
  1968                              <2> 	.ClearScreenWithCharInALandAttrInAH				resb	2
  1969                              <2> endstruc
  1970                              <2> %endif
  1971                              <2> 
  1972                              <2> ; Attribute flags for DISPLAY_LIB.SetCharacterOutputFunctionFromAXwithAttributeFlagInBL
  1973                              <2> ATTRIBUTES_NOT_USED							EQU		0
  1974                              <2> ATTRIBUTES_ARE_USED							EQU		FLG_CONTEXT_ATTRIBUTES
  1975                              <2> 
  1976                              <2> ; Character output functions for DISPLAY_LIB.SetCharacterOutputFunctionFromAXwithAttributeFlagInBL
  1977                              <2> TELETYPE_OUTPUT_WITH_ATTRIBUTE				EQU		DisplayCharOut_TeletypeOutputWithAttribute
  1978                              <2> TELETYPE_OUTPUT_WITHOUT_ATTRIBUTE			EQU		DisplayCharOut_TeletypeOutput
  1979                              <2> TELETYPE_OUTPUT_USING_BIOS					EQU		DisplayCharOut_BiosTeletypeOutput
  1980                              <2> FAST_OUTPUT_WITH_ATTRIBUTE_ONLY				EQU		DisplayCharOut_Attribute
  1981                              <2> FAST_OUTPUT_WITH_CHAR_ONLY					EQU		DisplayCharOut_Character
  1982                              <2> FAST_OUTPUT_WITH_CHAR_AND_ATTRIBUTE			EQU		DisplayCharOut_CharacterWithAttribute
  1983                              <2> BUFFER_OUTPUT_WITH_CHAR_ONLY				EQU		DisplayCharOut_WriteCharacterToBuffer
  1984                              <2> 
  1985                              <2> DEFAULT_CHARACTER_OUTPUT					EQU		TELETYPE_OUTPUT_WITH_ATTRIBUTE
  1986                              <2> 
  1987                              <2> 
  1988                              <2> struc VIDEO_BDA
  1989 00000000 <res 00000449>      <2> 						resb	449h
  1990 00000449 <res 00000001>      <2> 	.bMode				resb	1		; 0:449h, Video, Mode
  1991 0000044A <res 00000002>      <2> 	.wColumns			resb	2		; 0:44Ah, Video, Number of columns
  1992 0000044C <res 00000002>      <2> 	.wBytesPerPage		resb	2		; 0:44Ch, Video, Total number of bytes per page
  1993 0000044E <res 00000002>      <2> 	.wPageOffset		resb	2		; 0:44Eh, Video, Current page offset
  1994 00000450 <res 00000004>      <2> 	.rgwCursors			resb	4		; 0:450h, Video, Cursor position, pages 0...1
  1995 00000454 <res 0000000C>      <2> 	.displayContext		resb	12		; Our own display context (normally cursors for pages 2...7)
  1996 00000460 <res 00000002>      <2> 	.wCursorShape		resb	2		; 0:460h, Video, Cursor shape
  1997 00000462 <res 00000001>      <2> 	.bActivePage		resb	1		; 0:462h, Video, Active display page
  1998 00000463 <res 00000002>      <2> 	.wVideoPort			resb	2		; 0:463h, Video, I/O Port number base
  1999 00000465 <res 00000001>      <2> 	.bInternalModeReg	resb	1		; 0:465h, Video, Internal mode register
  2000 00000466 <res 00000001>      <2> 	.bColorPalette		resb	1		; 0:466h, Video, Color palette
  2001                              <2> endstruc
  2002                              <2> 
  2003                              <2> struc DISPLAY_CONTEXT
  2004 00000000 <res 00000004>      <2> 	.fpCursorPosition	resb	4	; Far pointer to cursor position in video memory
  2005 00000004 <res 00000002>      <2> 	.fnCharOut			resb	2	; Function to draw character with
  2006 00000006 <res 00000002>      <2> 	.wCharOutParam		resb	2	; User parameter for custom character output function
  2007 00000008 <res 00000002>      <2> 	.wCursorShape		resb	2	; Current cursor shape
  2008 0000000A <res 00000001>      <2> 	.bAttribute			resb	1	; Selected character attribute
  2009 0000000B <res 00000001>      <2> 	.bFlags				resb	1	; Display context flags
  2010                              <2> endstruc
  2011                              <2> 
  2012                              <2> ; Display context flags
  2013                              <2> FLG_CONTEXT_ATTRIBUTES		EQU		(1<<0)	; Character output function uses attributes
  2014                              <2> FLG_CONTEXT_CGA				EQU		(1<<1)	; CGA detected so prevent CGA snow
  2015                              <2> 
  2016                              <2> 
  2017                              <2> ; Text mode character attribute byte bits for CGA+ (color adapters)
  2018                              <2> FLG_COLOR_FORE_BLUE			EQU		(1<<0)
  2019                              <2> FLG_COLOR_FORE_GREEN		EQU		(1<<1)
  2020                              <2> FLG_COLOR_FORE_RED			EQU		(1<<2)
  2021                              <2> FLG_COLOR_FORE_INTENSITY	EQU		(1<<3)
  2022                              <2> FLG_COLOR_FORE_FONT_B		EQU		(1<<3)	; Select font set B (if available, EGA+)
  2023                              <2> FLG_COLOR_BACK_BLUE			EQU		(1<<4)
  2024                              <2> FLG_COLOR_BACK_GREEN		EQU		(1<<5)
  2025                              <2> FLG_COLOR_BACK_RED			EQU		(1<<6)
  2026                              <2> FLG_COLOR_BACK_INTENSITY	EQU		(1<<7)	; Intensity when blinking is disabled
  2027                              <2> FLG_COLOR_BLINK				EQU		(1<<7)	; Blinking color when enabled (enabled by default)
  2028                              <2> 
  2029                              <2> ; CGA colors
  2030                              <2> %define COLOR_ATTRIBUTE(foreground, background)	( (foreground) | ((background)<<4) )
  2031                              <2> COLOR_BLACK					EQU		0
  2032                              <2> COLOR_BLUE					EQU		1
  2033                              <2> COLOR_GREEN					EQU		2
  2034                              <2> COLOR_CYAN					EQU		3
  2035                              <2> COLOR_RED					EQU		4
  2036                              <2> COLOR_MAGENTA				EQU		5
  2037                              <2> COLOR_BROWN					EQU		6
  2038                              <2> COLOR_WHITE					EQU		7		; Last background color if blinking enabled
  2039                              <2> COLOR_GRAY					EQU		8
  2040                              <2> COLOR_LIGHT_BLUE			EQU		9
  2041                              <2> COLOR_LIGHT_GREEN			EQU		10
  2042                              <2> COLOR_LIGHT_CYAN			EQU		11
  2043                              <2> COLOR_LIGHT_RED				EQU		12
  2044                              <2> COLOR_LIGHT_MAGENTA			EQU		13
  2045                              <2> COLOR_YELLOW				EQU		14
  2046                              <2> COLOR_BRIGHT_WHITE			EQU		15
  2047                              <2> 
  2048                              <2> 
  2049                              <2> ; Text mode character attribute byte bits for MDA (monochrome adapters)
  2050                              <2> ; (attributes 00h, 08h, 80h, 88h, 70h, 78h, F0h and F8h are exceptions)
  2051                              <2> FLG_MONO_UNDERLINE			EQU		(1<<1)
  2052                              <2> FLG_MONO_INTENSITY			EQU		(1<<3)
  2053                              <2> FLG_MONO_BLINK				EQU		(1<<7)
  2054                              <2> 
  2055                              <2> ; Text mode character attribute bytes for MDA/Hercules (monochrome adapters)
  2056                              <2> ; *Not displayed on some monitors
  2057                              <2> MONO_HIDDEN					EQU		00h		; Not displayed (same for 08h, 80h and 88h)
  2058                              <2> MONO_UNDERLINE				EQU		01h		; Underlined
  2059                              <2> MONO_NORMAL					EQU		07h		; Normal (white on black)
  2060                              <2> MONO_BRIGHT_UNDERLINE		EQU		09h		; High intensity, underlined
  2061                              <2> MONO_BRIGHT					EQU		0Fh		; High intensity
  2062                              <2> MONO_REVERSE				EQU		70h		; Reverse video (black on white)
  2063                              <2> MONO_REVERSE_DARK			EQU		78h		; (dark green on green)
  2064                              <2> MONO_BLINK					EQU		87h		; Blinking white on black*
  2065                              <2> MONO_BRIGHT_BLINK			EQU		8Fh		; Blinking high intensity*
  2066                              <2> MONO_REVERSE_BLINK			EQU		0F0h	; Blinking reverse video
  2067                              <2> MONO_REVERSE_DARK_BLINK		EQU		0F8h	; (blinking dark green on green)
  2068                              <2> 
  2069                              <2> 
  2070                              <2> ; Cursor position macro for DX register
  2071                              <2> %define CURSOR_XY(x, y)	( (x) | ((y)<<8) )
  2072                              <2> 
  2073                              <2> ; Cursor shapes
  2074                              <2> CURSOR_NORMAL_COLOR			EQU		0607h		; Two line cursor near or at the bottom of cell (not valid for IBM MDA)
  2075                              <2> CURSOR_NORMAL_MDA			EQU		0B0Ch		; Scanlines 11 and 12
  2076                              <2> CURSOR_HIDDEN				EQU		2000h
  2077                              <2> 
  2078                              <2> 
  2079                              <2> ; Display modes
  2080                              <2> CGA_TEXT_MODE_BW40			EQU		0		; Applications should use...
  2081                              <2> CGA_TEXT_MODE_CO40			EQU		1
  2082                              <2> CGA_TEXT_MODE_BW80			EQU		2		; ..black, white and bright white attributes only
  2083                              <2> CGA_TEXT_MODE_CO80			EQU		3
  2084                              <2> MDA_TEXT_MODE				EQU		7		; Real monochrome attributes available
  2085                              <2> 
  2086                              <2> 
  2087                              <2> ; Display segments
  2088                              <2> COLOR_TEXT_SEGMENT			EQU		0B800h	; Text modes 0...3 (CGA+)
  2089                              <2> MONO_TEXT_SEGMENT			EQU		0B000h	; Text mode 7 (MDA, Hercules)
  2090                              <2> 
  2091                              <2> OFFSET_TO_CGA_STATUS_REGISTER	EQU		6	; Base port 3D4h + 6 = 3DAh
  2092                              <2> CGA_STATUS_REGISTER				EQU		3DAh
  2093                              <2> 
  2094                              <2> %endif ; MODULE_STRINGS_COMPRESS_PRECOMPRESS
  2095                              <2> 
  2096                              <2> ; Control characters for teletype output
  2097                              <2> NULL						EQU		00h
  2098                              <2> SOH							EQU		01h		; Start of heading
  2099                              <2> STX							EQU		02h		; Start of text
  2100                              <2> BELL						EQU		07h		; Bell
  2101                              <2> BS							EQU		08h		; Backspace
  2102                              <2> TAB							EQU		09h		; Horizontal TAB
  2103                              <2> LF							EQU		0Ah		; Line feed (newline)
  2104                              <2> CR							EQU		0Dh		; Carriage return
  2105                              <2> ESC							EQU		1Bh		; Escape
  2106                              <2> 
  2107                              <2> ; Non ASCII characters (code page 437)
  2108                              <2> BETA										EQU		225
  2109                              <2> QUOTATION_MARK								EQU		34
  2110                              <2> DOUBLE_TOP_RIGHT_CORNER						EQU		187
  2111                              <2> DOUBLE_TOP_LEFT_CORNER						EQU		201
  2112                              <2> DOUBLE_BOTTOM_RIGHT_CORNER					EQU		188
  2113                              <2> DOUBLE_BOTTOM_LEFT_CORNER					EQU		200
  2114                              <2> DOUBLE_VERTICAL								EQU		186
  2115                              <2> DOUBLE_HORIZONTAL							EQU		205
  2116                              <2> DOUBLE_VERTICAL_TO_RIGHT_SINGLE				EQU		199
  2117                              <2> DOUBLE_VERTICAL_TO_LEFT_SINGLE				EQU		182
  2118                              <2> DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL	EQU		181
  2119                              <2> DOUBLE_RIGHT_HORIZONTAL_TO_SINGLE_VERTICAL	EQU		198
  2120                              <2> SINGLE_VERTICAL								EQU		179
  2121                              <2> SINGLE_HORIZONTAL							EQU		196
  2122                              <2> SINGLE_LEFT_HORIZONTAL_TO_VERTICAL			EQU		180
  2123                              <2> SINGLE_RIGHT_HORIZONTAL_TO_VERTICAL			EQU		195
  2124                              <2> ANGLE_QUOTE_LEFT							EQU		174
  2125                              <2> ANGLE_QUOTE_RIGHT							EQU		175
  2126                              <2> BLOCK_MOSTLY_BACKGROUND						EQU		176
  2127                              <2> BLOCK_EVEN_BACKGROUND_AND_FOREGROUND		EQU		177
  2128                              <2> BLOCK_MOSTLY_FOREGROUND						EQU		178
  2129                              <2> BLOCK_FULL_FOREGROUND						EQU		219
  2130                              <2> ONE_HALF									EQU		171
  2131                              <2> ONE_QUARTER									EQU		172
  2132                              <2> 
  2133                              <2> 
  2134                              <2> ; Background character for clearing screen
  2135                              <2> %ifndef SCREEN_BACKGROUND_CHARACTER
  2136                              <2> 	%define	SCREEN_BACKGROUND_CHARACTER		BLOCK_MOSTLY_BACKGROUND
  2137                              <2> %endif
  2138                              <2> %ifndef SCREEN_BACKGROUND_ATTRIBUTE
  2139                              <2> 	%define	SCREEN_BACKGROUND_ATTRIBUTE		MONO_NORMAL
  2140                              <2> %endif
  2141                              <2> %define SCREEN_BACKGROUND_CHARACTER_AND_ATTRIBUTE	(SCREEN_BACKGROUND_CHARACTER | (SCREEN_BACKGROUND_ATTRIBUTE<<8))
  2142                              <2> %define DOS_BACKGROUND_CHARACTER_AND_ATTRIBUTE		(' ' | (MONO_NORMAL<<8))
  2143                              <2> 
  2144                              <2> %endif ; DISPLAY_INC
  2145                              <1> 	%define INCLUDE_STRING_LIBRARY
  2146                              <1> %endif
  2147                              <1> 
  2148                              <1> %ifdef INCLUDE_STRING_LIBRARY
  2149                              <1> 	%define INCLUDE_UTIL_LIBRARY
  2150                              <1> %endif
  2151                              <1> 
  2152                              <1> %ifdef INCLUDE_FILE_LIBRARY
  2153                              <1> 	%define INCLUDE_UTIL_LIBRARY
  2154                              <1> %endif
  2155                              <1> 
  2156                              <1> 
  2157                              <1> %endif ; ASSEMBLY_LIBRARY_INC
  2158                                  	%include "ModuleDependency.inc"	; Dependency checks for optional modules. Must be included second!
  2159                              <1> ; Project name	:	XTIDE Universal BIOS
  2160                              <1> ; Description	:	Dependencies for optional modules.
  2161                              <1> 
  2162                              <1> ;
  2163                              <1> ; XTIDE Universal BIOS and Associated Tools
  2164                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2165                              <1> ;
  2166                              <1> ; This program is free software; you can redistribute it and/or modify
  2167                              <1> ; it under the terms of the GNU General Public License as published by
  2168                              <1> ; the Free Software Foundation; either version 2 of the License, or
  2169                              <1> ; (at your option) any later version.
  2170                              <1> ;
  2171                              <1> ; This program is distributed in the hope that it will be useful,
  2172                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2173                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2174                              <1> ; GNU General Public License for more details.
  2175                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2176                              <1> ;
  2177                              <1> 
  2178                              <1> ; Allow RELOCATE_INT13H_STACK only for AT builds
  2179                              <1> %ifndef USE_AT
  2180                              <1> 	%ifdef RELOCATE_INT13H_STACK
  2181                              <1> 		%undef RELOCATE_INT13H_STACK
  2182                              <1> 		%warning "RELOCATE_INT13H_STACK is not supported for XT builds!"
  2183                              <1> 	%endif
  2184                              <1> %endif
  2185                              <1> 
  2186                              <1> 
  2187                              <1> %ifdef MODULE_SERIAL_FLOPPY
  2188                              <1> 	%ifndef MODULE_SERIAL
  2189                              <1> 		%define MODULE_SERIAL
  2190                              <1> 	%endif
  2191                              <1> %endif
  2192                              <1> 
  2193                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
  2194                              <1> 	%define MODULE_8BIT_IDE
  2195                              <1> 	%include "DmaController.inc"
  2196                              <2> ; Project name	:	XTIDE Universal BIOS
  2197                              <2> ; Description	:	Equates for 8237 DMA Controllers.
  2198                              <2> 
  2199                              <2> ;
  2200                              <2> ; XTIDE Universal BIOS and Associated Tools
  2201                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2202                              <2> ;
  2203                              <2> ; This program is free software; you can redistribute it and/or modify
  2204                              <2> ; it under the terms of the GNU General Public License as published by
  2205                              <2> ; the Free Software Foundation; either version 2 of the License, or
  2206                              <2> ; (at your option) any later version.
  2207                              <2> ;
  2208                              <2> ; This program is distributed in the hope that it will be useful,
  2209                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2210                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2211                              <2> ; GNU General Public License for more details.
  2212                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2213                              <2> ;
  2214                              <2> 
  2215                              <2> %ifndef DMA_CONTROLLER_INC
  2216                              <2> %define DMA_CONTROLLER_INC
  2217                              <2> 
  2218                              <2> ; 8237 Master (8-bit) and Slave (16-bit) DMA Controller Ports
  2219                              <2> 
  2220                              <2> ; Page Registers
  2221                              <2> PAGE_DMA8_CH_1		EQU		83h
  2222                              <2> PAGE_DMA8_CH_2		EQU		81h
  2223                              <2> PAGE_DMA8_CH_3		EQU		82h
  2224                              <2> PAGE_DMA16_CH_5		EQU		8Bh		; AT+
  2225                              <2> PAGE_DMA16_CH_6		EQU		89h		; AT+
  2226                              <2> PAGE_DMA16_CH_7		EQU		8Ah		; AT+
  2227                              <2> 
  2228                              <2> ; Base and Current Address Registers
  2229                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH1_out	EQU		02h
  2230                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH2_out	EQU		04h
  2231                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH3_out	EQU		06h
  2232                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA16_CH5_out	EQU		0C4h	; AT+
  2233                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA16_CH6_out	EQU		0C8h	; AT+
  2234                              <2> BASE_AND_CURRENT_ADDRESS_REGISTER_DMA16_CH7_out	EQU		0CCh	; AT+
  2235                              <2> CURRENT_ADDRESS_REGISTER_DMA8_CH1_in			EQU		02h
  2236                              <2> CURRENT_ADDRESS_REGISTER_DMA8_CH2_in			EQU		04h
  2237                              <2> CURRENT_ADDRESS_REGISTER_DMA8_CH3_in			EQU		06h
  2238                              <2> CURRENT_ADDRESS_REGISTER_DMA16_CH5_in			EQU		0C4h	; AT+
  2239                              <2> CURRENT_ADDRESS_REGISTER_DMA16_CH6_in			EQU		0C8h	; AT+
  2240                              <2> CURRENT_ADDRESS_REGISTER_DMA16_CH7_in			EQU		0CCh	; AT+
  2241                              <2> 
  2242                              <2> ; Base and Current Count Registers
  2243                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH1_out	EQU		03h
  2244                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH2_out	EQU		05h
  2245                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH3_out	EQU		07h
  2246                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA16_CH5_out	EQU		0C6h	; AT+
  2247                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA16_CH6_out	EQU		0CAh	; AT+
  2248                              <2> BASE_AND_CURRENT_COUNT_REGISTER_DMA16_CH7_out	EQU		0CEh	; AT+
  2249                              <2> CURRENT_COUNT_REGISTER_DMA8_CH1_in				EQU		03h
  2250                              <2> CURRENT_COUNT_REGISTER_DMA8_CH2_in				EQU		05h
  2251                              <2> CURRENT_COUNT_REGISTER_DMA8_CH3_in				EQU		07h
  2252                              <2> CURRENT_COUNT_REGISTER_DMA16_CH5_in				EQU		0C6h	; AT+
  2253                              <2> CURRENT_COUNT_REGISTER_DMA16_CH6_in				EQU		0CAh	; AT+
  2254                              <2> CURRENT_COUNT_REGISTER_DMA16_CH7_in				EQU		0CEh	; AT+
  2255                              <2> 
  2256                              <2> ; Command Registers (Command Value used by PCs is 0)
  2257                              <2> COMMAND_REGISTER_DMA8_out		EQU		08h
  2258                              <2> COMMAND_REGISTER_DMA16_out		EQU		0D0h	; AT+
  2259                              <2> 	MEM_TO_MEM_XFERS_DISABLE	EQU		0
  2260                              <2> 	MEM_TO_MEM_XFERS_ENABLE		EQU		(1<<0)
  2261                              <2> 
  2262                              <2> 	CH0_ADDRESS_HOLD_DISABLE	EQU		0
  2263                              <2> 	CH0_ADDRESS_HOLD_ENABLE		EQU		(1<<1)	; When MEM_TO_MEM_XFERS_ENABLE
  2264                              <2> 
  2265                              <2> 	CONTROLLER_ENABLE			EQU		0
  2266                              <2> 	CONTROLLER_DISABLE			EQU		(1<<2)	; Instead of Controller Enable
  2267                              <2> 
  2268                              <2> 	NORMAL_TIMING				EQU		0
  2269                              <2> 	COMPRESSED_TIMING			EQU		(1<<3)	; Instead of Normal Timing when MEM_TO_MEM_XFERS_DISABLE
  2270                              <2> 
  2271                              <2> 	FIXED_PRIORITY				EQU		0
  2272                              <2> 	ROTATING_PRIORITY			EQU		(1<<4)	; Instead of Fixed Priority
  2273                              <2> 
  2274                              <2> 	LATE_WRITE_SELECTION		EQU		0
  2275                              <2> 	EXTENDED_WRITE_SELECTION	EQU		(1<<5)	; Instead of Late Write Selection
  2276                              <2> 
  2277                              <2> 	DREQ_SENSE_ACTIVE_HIGH		EQU		0
  2278                              <2> 	DREQ_SENSE_ACTIVE_LOW		EQU		(1<<6)	; Instead of DREQ Sense Active High
  2279                              <2> 
  2280                              <2> 	DACK_SENSE_ACTIVE_LOW		EQU		0
  2281                              <2> 	DACK_SENSE_ACTIVE_HIGH		EQU		(1<<7)	; Instead of DACK Sense Active Low
  2282                              <2> 
  2283                              <2> 
  2284                              <2> ; Status Registers (reading will clear Terminal Count flags)
  2285                              <2> STATUS_REGISTER_DMA8_in			EQU		COMMAND_REGISTER_DMA8_out
  2286                              <2> 	FLG_CH1_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<1)
  2287                              <2> 	FLG_CH2_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<2)
  2288                              <2> 	FLG_CH3_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<3)
  2289                              <2> 	FLG_CH1_REQUEST							EQU		(1<<5)
  2290                              <2> 	FLG_CH2_REQUEST							EQU		(1<<6)
  2291                              <2> 	FLG_CH3_REQUEST							EQU		(1<<7)
  2292                              <2> STATUS_REGISTER_DMA16_in		EQU		COMMAND_REGISTER_DMA16_out	; AT+
  2293                              <2> 	FLG_CH5_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<1)
  2294                              <2> 	FLG_CH6_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<2)
  2295                              <2> 	FLG_CH7_HAS_REACHED_TERMINAL_COUNT		EQU		(1<<3)
  2296                              <2> 	FLG_CH5_REQUEST							EQU		(1<<5)
  2297                              <2> 	FLG_CH6_REQUEST							EQU		(1<<6)
  2298                              <2> 	FLG_CH7_REQUEST							EQU		(1<<7)
  2299                              <2> 
  2300                              <2> 
  2301                              <2> ; Request Registers (Software DMA Request)
  2302                              <2> REQUEST_REGISTER_DMA8_out		EQU		09h
  2303                              <2> 	FLG_SET_REQUEST		EQU		(1<<2)
  2304                              <2> 	CLEAR_CH1_REQUEST	EQU		CHANNEL_1
  2305                              <2> 	CLEAR_CH2_REQUEST	EQU		CHANNEL_2
  2306                              <2> 	CLEAR_CH3_REQUEST	EQU		CHANNEL_3
  2307                              <2> 	SET_CH1_REQUEST		EQU		(CHANNEL_1 | FLG_SET_REQUEST)
  2308                              <2> 	SET_CH2_REQUEST		EQU		(CHANNEL_2 | FLG_SET_REQUEST)
  2309                              <2> 	SET_CH3_REQUEST		EQU		(CHANNEL_3 | FLG_SET_REQUEST)
  2310                              <2> REQUEST_REGISTER_DMA16_out		EQU		0D2h	; AT+
  2311                              <2> 	CLEAR_CH5_REQUEST	EQU		CLEAR_CH1_REQUEST
  2312                              <2> 	CLEAR_CH6_REQUEST	EQU		CLEAR_CH2_REQUEST
  2313                              <2> 	CLEAR_CH7_REQUEST	EQU		CLEAR_CH3_REQUEST
  2314                              <2> 	SET_CH5_REQUEST		EQU		SET_CH1_REQUEST
  2315                              <2> 	SET_CH6_REQUEST		EQU		SET_CH2_REQUEST
  2316                              <2> 	SET_CH7_REQUEST		EQU		SET_CH3_REQUEST
  2317                              <2> 
  2318                              <2> 
  2319                              <2> ; Mask Registers (setting a mask bit disables DMA channel)
  2320                              <2> MASK_REGISTER_DMA8_out			EQU		0Ah
  2321                              <2> 	FLG_SET_MASK		EQU		FLG_SET_REQUEST
  2322                              <2> 	CLEAR_CH1_MASK_BIT	EQU		CLEAR_CH1_REQUEST
  2323                              <2> 	CLEAR_CH2_MASK_BIT	EQU		CLEAR_CH2_REQUEST
  2324                              <2> 	CLEAR_CH3_MASK_BIT	EQU		CLEAR_CH3_REQUEST
  2325                              <2> 	SET_CH1_MASK_BIT	EQU		SET_CH1_REQUEST
  2326                              <2> 	SET_CH2_MASK_BIT	EQU		SET_CH2_REQUEST
  2327                              <2> 	SET_CH3_MASK_BIT	EQU		SET_CH3_REQUEST
  2328                              <2> MASK_REGISTER_DMA16_out			EQU		0D4h	; AT+
  2329                              <2> 	CLEAR_CH5_MASK_BIT	EQU		CLEAR_CH5_REQUEST
  2330                              <2> 	CLEAR_CH6_MASK_BIT	EQU		CLEAR_CH6_REQUEST
  2331                              <2> 	CLEAR_CH7_MASK_BIT	EQU		CLEAR_CH7_REQUEST
  2332                              <2> 	SET_CH5_MASK_BIT	EQU		SET_CH5_REQUEST
  2333                              <2> 	SET_CH6_MASK_BIT	EQU		SET_CH6_REQUEST
  2334                              <2> 	SET_CH7_MASK_BIT	EQU		SET_CH7_REQUEST
  2335                              <2> 
  2336                              <2> 
  2337                              <2> ; Mode Registers
  2338                              <2> MODE_REGISTER_DMA8_out			EQU		0Bh
  2339                              <2> 	; Select channel number (bits 0...1)
  2340                              <2> 	CHANNEL_1			EQU		1
  2341                              <2> 	CHANNEL_2			EQU		2
  2342                              <2> 	CHANNEL_3			EQU		3
  2343                              <2> MODE_REGISTER_DMA16_out			EQU		0D6h	; AT+
  2344                              <2> 	CHANNEL_5			EQU		CHANNEL_1
  2345                              <2> 	CHANNEL_6			EQU		CHANNEL_2
  2346                              <2> 	CHANNEL_7			EQU		CHANNEL_3
  2347                              <2> 	; Transfer type (bits 2...3)
  2348                              <2> 	VERIFY				EQU		(0<<2)
  2349                              <2> 	WRITE				EQU		(1<<2)	; To memory
  2350                              <2> 	READ				EQU		(2<<2)	; From memory
  2351                              <2> 	; Autoinitialization enable/disable (bit 4)
  2352                              <2> 	AUTOINIT_DISABLE	EQU		0
  2353                              <2> 	AUTOINIT_ENABLE		EQU		(1<<4)	; Instead of autoinitialization disable
  2354                              <2> 	; Address increment/decrement select (bit 5)
  2355                              <2> 	ADDRESS_INCREMENT	EQU		0
  2356                              <2> 	ADDRESS_DECREMENT	EQU		(1<<5)	; Instead of address increment
  2357                              <2> 	; Mode type selection (bits 6...7)
  2358                              <2> 	DEMAND_MODE			EQU		(0<<6)
  2359                              <2> 	SINGLE_MODE			EQU		(1<<6)
  2360                              <2> 	BLOCK_MODE			EQU		(2<<6)
  2361                              <2> 	CASCADE_MODE		EQU		(3<<6)
  2362                              <2> 
  2363                              <2> 
  2364                              <2> ; Clear Byte Flip-Flops (any byte resets low/high byte flip-flop to low)
  2365                              <2> CLEAR_FLIPFLOP_DMA8_out			EQU		0Ch
  2366                              <2> CLEAR_FLIPFLOP_DMA16_out		EQU		0D8h	; AT+
  2367                              <2> 
  2368                              <2> 
  2369                              <2> ; Temporary Registers
  2370                              <2> TEMP_REGISTER_DMA8_in			EQU		0Dh
  2371                              <2> TEMP_REGISTER_DMA16_in			EQU		0DAh	; AT+
  2372                              <2> 
  2373                              <2> 
  2374                              <2> ; Master Clear (any byte does the same as hardware reset)
  2375                              <2> MASTER_CLEAR_DMA8_out			EQU		TEMP_REGISTER_DMA8_in
  2376                              <2> MASTER_CLEAR_DMA16_out			EQU		TEMP_REGISTER_DMA16_in	; AT+
  2377                              <2> 
  2378                              <2> 
  2379                              <2> ; Clear all mask bits (any byte enables all DMA channels)
  2380                              <2> CLEAR_ALL_MASK_BITS_DMA8_out	EQU		0Eh
  2381                              <2> CLEAR_ALL_MASK_BITS_DMA16_out	EQU		0DCh	; AT+
  2382                              <2> 
  2383                              <2> 
  2384                              <2> ; Write All Mask Bits
  2385                              <2> WRITE_ALL_MASK_BITS_DMA8_out	EQU		0Fh
  2386                              <2> 	ALL_MASK_BITS_SET_CH0		EQU		(1<<0)
  2387                              <2> 	ALL_MASK_BITS_SET_CH1		EQU		(1<<CHANNEL_1)
  2388                              <2> 	ALL_MASK_BITS_SET_CH2		EQU		(1<<CHANNEL_2)
  2389                              <2> 	ALL_MASK_BITS_SET_CH3		EQU		(1<<CHANNEL_3)
  2390                              <2> WRITE_ALL_MASK_BITS_DMA16_out	EQU		0DEh	; AT+
  2391                              <2> 	ALL_MASK_BITS_SET_CH4		EQU		ALL_MASK_BITS_SET_CH0
  2392                              <2> 	ALL_MASK_BITS_SET_CH5		EQU		(1<<CHANNEL_5)
  2393                              <2> 	ALL_MASK_BITS_SET_CH6		EQU		(1<<CHANNEL_6)
  2394                              <2> 	ALL_MASK_BITS_SET_CH7		EQU		(1<<CHANNEL_7)
  2395                              <2> 
  2396                              <2> 
  2397                              <2> %endif ; DMA_CONTROLLER_INC
  2398                              <1> 	%include "XTCF.inc"				; For Lo-tech XT-CF
  2399                              <2> ; Project name	:	XTIDE Universal BIOS
  2400                              <2> ; Description	:	Lo-tech XT-CFv2 board specifications.
  2401                              <2> ;
  2402                              <2> ; More information at http://www.lo-tech.co.uk/XT-CF
  2403                              <2> 
  2404                              <2> ;
  2405                              <2> ; XTIDE Universal BIOS and Associated Tools
  2406                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2407                              <2> ;
  2408                              <2> ; This program is free software; you can redistribute it and/or modify
  2409                              <2> ; it under the terms of the GNU General Public License as published by
  2410                              <2> ; the Free Software Foundation; either version 2 of the License, or
  2411                              <2> ; (at your option) any later version.
  2412                              <2> ;
  2413                              <2> ; This program is distributed in the hope that it will be useful,
  2414                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2415                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2416                              <2> ; GNU General Public License for more details.
  2417                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2418                              <2> ;
  2419                              <2> 
  2420                              <2> ; Modified by JJP for XT-CFv3 support, Mar-13
  2421                              <2> 
  2422                              <2> 
  2423                              <2> %ifndef XTCF_INC
  2424                              <2> %define XTCF_INC
  2425                              <2> 
  2426                              <2> ; XT-CF requires that block must be less than 128 sectors (64 kiB) for DMA
  2427                              <2> ; transfers.
  2428                              <2> ; 
  2429                              <2> ; Note: XT-CFv3 DMA will not interfere with PC & PC/XT memory refresh,
  2430                              <2> ; since the XT-CFv3 detaches itself from the bus every 16 bytes transferred.
  2431                              <2> ;
  2432                              <2> XTCF_DMA_MODE_MAX_BLOCK_SIZE		EQU		64		; Sectors
  2433                              <2> 
  2434                              <2> ; Possible base addresses. Note that all XT-CF IDE registers are SHL 1 compared
  2435                              <2> ; to standard IDE registers.
  2436                              <2> XTCF_BASE_PORT_DETECTION_SEED		EQU		140h		; Not a valid base address but needed for autodetection
  2437                              <2> XTCF_BASE_PORT_1			EQU		200h
  2438                              <2> XTCF_BASE_PORT_2			EQU		240h
  2439                              <2> XTCF_BASE_PORT_3			EQU		300h		; Default setting
  2440                              <2> XTCF_BASE_PORT_4			EQU		340h
  2441                              <2> 
  2442                              <2> 
  2443                              <2> ; XT-CF Control Register (do not SHL 1 these!)
  2444                              <2> ; Note: XT-CFv3 control register is used *only* to raise DRQ.  The register cannot be read.
  2445                              <2> ;
  2446                              <2> XTCF_CONTROL_REGISTER			EQU		1Fh
  2447                              <2> 
  2448                              <2> ; Transfer Mode Constants
  2449                              <2> ;
  2450                              <2> ; Available transfer modes depend on the controller.  All XT-CF controllers
  2451                              <2> ; support 8-bit PIO, either with 8-bit or 16-bit instructions (i.e., data
  2452                              <2> ; can be fetched from the controller with REP INSW or REP INSB since A0 is
  2453                              <2> ; not decoded).  However, errors in the implementation of the BIU on some
  2454                              <2> ; machines will prevent 16-bit instructions delivering data correctly.
  2455                              <2> ;
  2456                              <2> ; For XT-CFv3 adapter, DMA transfers are also supported via channel 3.
  2457                              <2> ;
  2458                              <2> ; XT-CFv3 cannot be distinguised by software, so user must decide and set
  2459                              <2> ; the mode via a call to Int 13h function 1Eh accordingly (see AH1E_XTCF.asm).
  2460                              <2> ;;
  2461                              <2> XTCF_8BIT_PIO_MODE			EQU		00h
  2462                              <2> XTCF_8BIT_PIO_MODE_WITH_BIU_OFFLOAD	EQU		01h
  2463                              <2> XTCF_DMA_MODE				EQU		02h
  2464                              <2> 
  2465                              <2> ; Subcommands for AH=1Eh, Lo-tech XT-CF features.
  2466                              <2> ; Return values common for all subcommands:
  2467                              <2> ;		AH:		RET_HD_SUCCESS if drive is XT-CF
  2468                              <2> ;				RET_HD_INVALID if drive is not XT-CF
  2469                              <2> ;		CF:		0 if successful, 1 if error
  2470                              <2> 
  2471                              <2> ;--------------------------------------------------------------------
  2472                              <2> ; IS_THIS_DRIVE_XTCF
  2473                              <2> ;	Parameters:
  2474                              <2> ;		DL:		Drive Number
  2475                              <2> ;--------------------------------------------------------------------
  2476                              <2> IS_THIS_DRIVE_XTCF			EQU		0
  2477                              <2> 
  2478                              <2> ;--------------------------------------------------------------------
  2479                              <2> ; GET_XTCF_TRANSFER_MODE
  2480                              <2> ;	Parameters:
  2481                              <2> ;		DL:		Drive Number
  2482                              <2> ;	Returns:
  2483                              <2> ;		DH:		One of the mode values listed above,
  2484                              <2> ;                               i.e. XTCF_8BIT_PIO_MODE
  2485                              <2> ;--------------------------------------------------------------------
  2486                              <2> GET_XTCF_TRANSFER_MODE			EQU		1
  2487                              <2> 
  2488                              <2> ;--------------------------------------------------------------------
  2489                              <2> ; SET_XTCF_TRANSFER_MODE
  2490                              <2> ;	Parameters:
  2491                              <2> ;		DH:		Mode to select,
  2492                              <2> ;                               i.e. XTCF_8BIT_PIO_MODE
  2493                              <2> ;				Note there's no way to know if an
  2494                              <2> ;				XT-CF adapter supports DMA, so the
  2495                              <2> ;				user should enable DMA only if a
  2496                              <2> ;				DMA-enabled XT-CFv3 is fitted.
  2497                              <2> ;		DL:		Drive Number
  2498                              <2> ;--------------------------------------------------------------------
  2499                              <2> SET_XTCF_TRANSFER_MODE			EQU		2
  2500                              <2> 
  2501                              <2> 
  2502                              <2> %endif ; XTCF_INC
  2503                              <2> 
  2504                              <1> 	%include "JRIDE_ISA.inc"		; For JR-IDE/ISA
  2505                              <2> ; Project name	:	XTIDE Universal BIOS
  2506                              <2> ; Description	:	JR-IDE/ISA specifications.
  2507                              <2> 
  2508                              <2> ;
  2509                              <2> ; XTIDE Universal BIOS and Associated Tools
  2510                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2511                              <2> ;
  2512                              <2> ; This program is free software; you can redistribute it and/or modify
  2513                              <2> ; it under the terms of the GNU General Public License as published by
  2514                              <2> ; the Free Software Foundation; either version 2 of the License, or
  2515                              <2> ; (at your option) any later version.
  2516                              <2> ;
  2517                              <2> ; This program is distributed in the hope that it will be useful,
  2518                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2519                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2520                              <2> ; GNU General Public License for more details.
  2521                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2522                              <2> ;
  2523                              <2> 
  2524                              <2> %ifndef JRIDEISA_INC
  2525                              <2> %define JRIDEISA_INC
  2526                              <2> 
  2527                              <2> JRIDE_DEFAULT_SEGMENT_ADDRESS				EQU	0D800h
  2528                              <2> JRIDE_SECTOR_ACCESS_WINDOW_OFFSET			EQU	3C00h	; 512 byte IDE Sector Access Window
  2529                              <2> JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET	EQU	3E00h	; 8 byte CS0 IDE Register Window
  2530                              <2> JRIDE_CONTROL_BLOCK_REGISTER_WINDOW_OFFSET	EQU	3E08h	; 8 byte CS1 IDE Register Window
  2531                              <2> 
  2532                              <2> 
  2533                              <2> %endif ; JRIDEISA_INC
  2534                              <1> %endif
  2535                              <1> 
  2536                              <1> ; Include module specific .INC files
  2537                              <1> %ifdef MODULE_8BIT_IDE
  2538                              <1> 	%include "IDE_8bit.inc"			; For IDE 8-bit data port macros
  2539                              <2> ; Project name	:	XTIDE Universal BIOS
  2540                              <2> ; Description	:	Macros for accessing data port(s) on 8-bit
  2541                              <2> ;					IDE controllers.
  2542                              <2> 
  2543                              <2> ;
  2544                              <2> ; XTIDE Universal BIOS and Associated Tools
  2545                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2546                              <2> ;
  2547                              <2> ; This program is free software; you can redistribute it and/or modify
  2548                              <2> ; it under the terms of the GNU General Public License as published by
  2549                              <2> ; the Free Software Foundation; either version 2 of the License, or
  2550                              <2> ; (at your option) any later version.
  2551                              <2> ;
  2552                              <2> ; This program is distributed in the hope that it will be useful,
  2553                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2554                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2555                              <2> ; GNU General Public License for more details.
  2556                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2557                              <2> ;
  2558                              <2> 
  2559                              <2> %ifndef IDE_8BIT_INC
  2560                              <2> %define IDE_8BIT_INC
  2561                              <2> 
  2562                              <2> ;--------------------------------------------------------------------
  2563                              <2> ; UNROLL_SECTORS_IN_CX_TO_DWORDS
  2564                              <2> ; UNROLL_SECTORS_IN_CX_TO_QWORDS
  2565                              <2> ; UNROLL_SECTORS_IN_CX_TO_OWORDS
  2566                              <2> ;	Parameters:
  2567                              <2> ;		CX:		Number of sectors in block
  2568                              <2> ;	Returns:
  2569                              <2> ;		CX:		Number of DWORDs, QWORDs or OWORDs in block
  2570                              <2> ;	Corrupts registers:
  2571                              <2> ;		Nothing
  2572                              <2> ;--------------------------------------------------------------------
  2573                              <2> %macro UNROLL_SECTORS_IN_CX_TO_DWORDS 0
  2574                              <2> %ifdef USE_186
  2575                              <2> 	shl		cx, 7
  2576                              <2> %else
  2577                              <2> 	xchg	cl, ch		; Sectors to WORDs (SHL CX, 8)
  2578                              <2> 	shr		cx, 1
  2579                              <2> %endif
  2580                              <2> %endmacro
  2581                              <2> 
  2582                              <2> %macro UNROLL_SECTORS_IN_CX_TO_QWORDS 0
  2583                              <2> %ifdef USE_186
  2584                              <2> 	shl		cx, 6
  2585                              <2> %else
  2586                              <2> 	UNROLL_SECTORS_IN_CX_TO_DWORDS
  2587                              <2> 	shr		cx, 1
  2588                              <2> %endif
  2589                              <2> %endmacro
  2590                              <2> 
  2591                              <2> %macro UNROLL_SECTORS_IN_CX_TO_OWORDS 0
  2592                              <2> %ifdef USE_186
  2593                              <2> 	shl		cx, 5
  2594                              <2> %else
  2595                              <2> ;	UNROLL_SECTORS_IN_CX_TO_QWORDS
  2596                              <2> ;	shr		cx, 1
  2597                              <2> 	mov		ch, cl		; 2 bytes shorter but possibly slower
  2598                              <2> 	mov		cl, 3
  2599                              <2> 	shr		cx, cl
  2600                              <2> %endif
  2601                              <2> %endmacro
  2602                              <2> 
  2603                              <2> 
  2604                              <2> ;--------------------------------------------------------------------
  2605                              <2> ; Emulates INSW for XTIDE.
  2606                              <2> ;
  2607                              <2> ; XTIDE_INSW
  2608                              <2> ;	Parameters:
  2609                              <2> ;		BL:		Bit mask for toggling XTIDE data low/high reg
  2610                              <2> ;		DX:		XTIDE Data Low Register address
  2611                              <2> ;		ES:DI:	Ptr to destination buffer
  2612                              <2> ;	Returns:
  2613                              <2> ;		ES:DI:	Incremented/decremented for next word
  2614                              <2> ;	Corrupts registers:
  2615                              <2> ;		AL, FLAGS
  2616                              <2> ;--------------------------------------------------------------------
  2617                              <2> %macro XTIDE_INSW 0
  2618                              <2> %ifdef USE_186	; INS instruction available
  2619                              <2> 	insb						; Load low byte from port DX to [ES:DI]
  2620                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
  2621                              <2> 	insb						; Load high byte from port DX to [ES:DI]
  2622                              <2> 	xor		dl, bl				; Restore to IDE Data Register
  2623                              <2> %else	; If 8088/8086
  2624                              <2> 	in		al, dx				; Load low byte from port
  2625                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
  2626                              <2> 	stosb						; Store byte to [ES:DI]
  2627                              <2> 	in		al, dx				; Load high byte from port
  2628                              <2> 	xor		dl, bl				; Restore to IDE Data Register
  2629                              <2> 	stosb						; Store byte to [ES:DI]
  2630                              <2> %endif
  2631                              <2> %endmacro
  2632                              <2> 
  2633                              <2> 
  2634                              <2> ;--------------------------------------------------------------------
  2635                              <2> ; Emulates OUTSW for XTIDE.
  2636                              <2> ;
  2637                              <2> ; XTIDE_OUTSW
  2638                              <2> ;	Parameters:
  2639                              <2> ;		BL:		Bit mask for toggling XTIDE data low/high reg
  2640                              <2> ;		DX:		XTIDE Data Low Register address
  2641                              <2> ;		DS:SI:	Ptr to source buffer
  2642                              <2> ;	Returns:
  2643                              <2> ;		SI:		Incremented/decremented for next word
  2644                              <2> ;	Corrupts registers:
  2645                              <2> ;		AX, FLAGS
  2646                              <2> ;--------------------------------------------------------------------
  2647                              <2> %macro XTIDE_OUTSW 0
  2648                              <2> %ifdef USE_186	; OUTS instruction available
  2649                              <2> 	lodsb						; Load low byte from [DS:SI] to AL
  2650                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
  2651                              <2> 	outsb						; Output high byte from [DS:SI]
  2652                              <2> 	xor		dl, bl				; XTIDE Data High Reg to Data Low Reg
  2653                              <2> 	out		dx, al				; Output low byte from AL
  2654                              <2> %else	; If 8088/8086
  2655                              <2> 	lodsw						; Load word from [DS:SI]
  2656                              <2> 	xor		dl, bl				; IDE Data Reg to XTIDE Data High Reg
  2657                              <2> 	xchg	al, ah				; => AL=high byte, AH=low byte
  2658                              <2> 	out		dx, al				; Output high byte
  2659                              <2> 	xor		dl, bl				; XTIDE Data High Reg to Data Low Reg
  2660                              <2> 	mov		al, ah				; Copy low byte to AL
  2661                              <2> 	out		dx, al				; Output low byte
  2662                              <2> %endif
  2663                              <2> %endmacro
  2664                              <2> 
  2665                              <2> 
  2666                              <2> ;--------------------------------------------------------------------
  2667                              <2> ; Emulates OUTSW for modified XTIDE.
  2668                              <2> ;
  2669                              <2> ; XTIDE_MOD_OUTSW
  2670                              <2> ;	Parameters:
  2671                              <2> ;		DX:		XTIDE Data Low Register address
  2672                              <2> ;		DS:SI:	Ptr to source buffer
  2673                              <2> ;	Returns:
  2674                              <2> ;		SI:		Incremented/decremented for next word
  2675                              <2> ;	Corrupts registers:
  2676                              <2> ;		AX, FLAGS
  2677                              <2> ;--------------------------------------------------------------------
  2678                              <2> %macro XTIDE_MOD_OUTSW 0
  2679                              <2> %ifdef USE_186	; OUTS instruction available
  2680                              <2> 	lodsb						; Load low byte from [DS:SI] to AL
  2681                              <2> 	inc		dx					; IDE Data Reg to XTIDE MOD Data High Reg
  2682                              <2> 	outsb						; Output high byte from [DS:SI]
  2683                              <2> 	dec		dx					; XTIDE Data High Reg to Data Low Reg
  2684                              <2> 	out		dx, al				; Output low byte from AL
  2685                              <2> %else	; If 8088/8086
  2686                              <2> 	lodsw						; Load word from [DS:SI]
  2687                              <2> 	inc		dx					; IDE Data Reg to XTIDE MOD Data High Reg
  2688                              <2> 	xchg	al, ah				; => AL=high byte, AH=low byte
  2689                              <2> 	out		dx, al				; Output high byte
  2690                              <2> 	dec		dx					; XTIDE Data High Reg to Data Low Reg
  2691                              <2> 	mov		al, ah				; Copy low byte to AL
  2692                              <2> 	out		dx, al				; Output low byte
  2693                              <2> %endif
  2694                              <2> %endmacro
  2695                              <2> 
  2696                              <2> 
  2697                              <2> %endif ; IDE_8BIT_INC
  2698                              <1> %endif
  2699                              <1> 
  2700                              <1> %ifdef MODULE_ADVANCED_ATA
  2701                              <1> 	%include "Vision.inc"			; For QDI Vision QD65xx VLB IDE Controllers
  2702                              <1> %endif
  2703                              <1> 
  2704                              <1> %ifdef MODULE_EBIOS
  2705                              <1> 	%include "EBIOS.inc"			; Equates for EBIOS functions
  2706                              <2> ; Project name	:	XTIDE Universal BIOS
  2707                              <2> ; Description	:	Equates used in Enhanced INT 13h functions (EBIOS).
  2708                              <2> 
  2709                              <2> ;
  2710                              <2> ; XTIDE Universal BIOS and Associated Tools
  2711                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2712                              <2> ;
  2713                              <2> ; This program is free software; you can redistribute it and/or modify
  2714                              <2> ; it under the terms of the GNU General Public License as published by
  2715                              <2> ; the Free Software Foundation; either version 2 of the License, or
  2716                              <2> ; (at your option) any later version.
  2717                              <2> ;
  2718                              <2> ; This program is distributed in the hope that it will be useful,
  2719                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2720                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2721                              <2> ; GNU General Public License for more details.
  2722                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2723                              <2> ;
  2724                              <2> 
  2725                              <2> %ifndef EBIOS_INC
  2726                              <2> %define EBIOS_INC
  2727                              <2> 
  2728                              <2> ; EBIOS specification returned by INT 13h, AH=41h
  2729                              <2> EBIOS_VERSION						EQU	21h		; 21h = EDD version 1.1
  2730                              <2> 
  2731                              <2> ; Support bits returned by INT 13h, AH=41h
  2732                              <2> ENHANCED_DRIVE_ACCESS_SUPPORT		EQU	(1<<0)	; 41h, 42h, 43h 44h, 47h and 48h are available
  2733                              <2> DRIVE_LOCKING_AND_EJECTING_SUPPORT	EQU	(1<<1)	; 41h, 45h, 46h, 48h, 49h are available and INT 15h, AH=52h
  2734                              <2> ENHANCED_DISK_DRIVE_SUPPORT			EQU	(1<<2)	; 41h, 48h, 4Eh are available (EDD)
  2735                              <2> 
  2736                              <2> 
  2737                              <2> ; Extended Drive Information returned by AH=48h
  2738                              <2> struc EDRIVE_INFO
  2739 00000000 <res 00000002>      <2> 	.wSize					resb	2	; 0, Size of this buffer, at least 26
  2740 00000002 <res 00000002>      <2> 	.wFlags					resb	2	; 2, Information flags
  2741 00000004 <res 00000004>      <2> 	.dwCylinders			resb	4	; 4, Total number of addressable cylinders
  2742 00000008 <res 00000004>      <2> 	.dwHeads				resb	4	; 8, Total number of addressable heads
  2743 0000000C <res 00000004>      <2> 	.dwSectorsPerTrack		resb	4	; 12, Number of sectors per track
  2744 00000010 <res 00000008>      <2> 	.qwTotalSectors			resb	8	; 16, Total number of addressable sectors
  2745 00000018 <res 00000002>      <2> 	.wSectorSize			resb	2	; 24, Number of bytes per sector
  2746 0000001A <res 00000008>      <2> 	.fpEDDparams			resb	8	; 26, Optional pointer to Enhanced Disk Drive (EDD) configuration parameters
  2747                              <2> endstruc
  2748                              <2> 
  2749                              <2> MINIMUM_EDRIVEINFO_SIZE		EQU		26	; 26 bytes does not include EDD pointer
  2750                              <2> 
  2751                              <2> ; Flags for EDRIVE_INFO.wFlags
  2752                              <2> FLG_DMA_BOUNDARY_ERRORS_HANDLED_BY_BIOS				EQU	(1<<0)
  2753                              <2> FLG_CHS_INFORMATION_IS_VALID						EQU	(1<<1)
  2754                              <2> FLG_REMOVABLE_DRIVE									EQU	(1<<2)
  2755                              <2> FLG_WRITE_WITH_VERIFY_SUPPORTED						EQU	(1<<3)
  2756                              <2> FLG_CHANGE_LINE_SUPPORT								EQU	(1<<4)	; Removable media only
  2757                              <2> FLG_LOCKABLE										EQU	(1<<5)	; Removable media only
  2758                              <2> FLG_NO_MEDIA_PRESENT_AND_CHS_SET_TO_MAX				EQU	(1<<6)	; Removable media only
  2759                              <2> 
  2760                              <2> 
  2761                              <2> ; Disk Address Packet for read, write and verify functions
  2762                              <2> struc DAP
  2763 00000000 <res 00000001>      <2> 	.bSize					resb	1	; 0, Size of this packet in bytes
  2764 00000001 <res 00000001>      <2> 	.bReservedAt1			resb	1	; 1, Currently unused, must be zero
  2765 00000002 <res 00000002>      <2> 	.wSectorCount			resb	2	; 2, Number of sectors to process (0...127)
  2766                              <2> 	.dwMemoryAddress:
  2767 00000004 <res 00000002>      <2> 	.wOffset				resb	2	; 4, Memory offset for transfer
  2768 00000006 <res 00000002>      <2> 	.wSegment				resb	2	; 6, Memory segment for transfer
  2769 00000008 <res 00000008>      <2> 	.qwLBA					resb	8	; 8, Starting sector for transfer
  2770                              <2> endstruc
  2771                              <2> 
  2772                              <2> MINIMUM_DAP_SIZE			EQU		16
  2773                              <2> 
  2774                              <2> 
  2775                              <2> %endif ; EBIOS_INC
  2776                              <1> %endif
  2777                              <1> 
  2778                              <1> %ifdef MODULE_HOTKEYS
  2779                              <1> 	%include "HotkeyBar.inc"		; For Hotkeys
  2780                              <2> ; Project name	:	XTIDE Universal BIOS
  2781                              <2> ; Description	:	Equates and structs used in Hotkey Bar.
  2782                              <2> 
  2783                              <2> ;
  2784                              <2> ; XTIDE Universal BIOS and Associated Tools
  2785                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2786                              <2> ;
  2787                              <2> ; This program is free software; you can redistribute it and/or modify
  2788                              <2> ; it under the terms of the GNU General Public License as published by
  2789                              <2> ; the Free Software Foundation; either version 2 of the License, or
  2790                              <2> ; (at your option) any later version.
  2791                              <2> ;
  2792                              <2> ; This program is distributed in the hope that it will be useful,
  2793                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2794                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2795                              <2> ; GNU General Public License for more details.
  2796                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2797                              <2> ;
  2798                              <2> 
  2799                              <2> %ifndef HOTKEYBAR_INC
  2800                              <2> %define HOTKEYBAR_INC
  2801                              <2> 
  2802                              <2> MIN_TIME_TO_DISPLAY_HOTKEY_BAR			EQU	(4000/55)	; 4000 ms
  2803                              <2> 
  2804                              <2> ROM_BOOT_HOTKEY_SCANCODE				EQU	42h	; F8
  2805                              <2> 
  2806                              <2> %ifdef MODULE_BOOT_MENU
  2807                              <2> BOOT_MENU_HOTKEY_SCANCODE				EQU	3Ch	; F2
  2808                              <2> %endif
  2809                              <2> 
  2810                              <2> %ifdef MODULE_SERIAL
  2811                              <2> COM_DETECT_HOTKEY_SCANCODE				EQU	40h	; F6
  2812                              <2> %endif
  2813                              <2> 
  2814                              <2> %endif ; HOTKEYBAR_INC
  2815                              <1> %endif
  2816                              <1> 
  2817                              <1> %ifdef MODULE_BOOT_MENU
  2818                              <1> 	%include "BootMenu.inc"			; For Boot Menu
  2819                              <1> %endif
  2820                              <1> 
  2821                              <1> %ifdef MODULE_BOOT_MENU OR MODULE_HOTKEYS
  2822                              <1> 	%define MODULE_DRIVEXLATE
  2823                              <1> %endif
  2824                              <1> 
  2825                              <1> %ifdef MODULE_IRQ
  2826                              <1> 	%include "IntController.inc"
  2827                              <1> %endif
  2828                              <1> 
  2829                              <1> 
  2830                              <1> ; Included modules for ROMVARS.wFlags
  2831                              <1> %ifdef MODULE_8BIT_IDE
  2832                              <1> 	MAIN_FLG_MODULE_8BIT_IDE	EQU	FLG_ROMVARS_MODULE_8BIT_IDE
  2833                              <1> %else
  2834                              <1> 	MAIN_FLG_MODULE_8BIT_IDE	EQU	0
  2835                              <1> %endif
  2836                              <1> 
  2837                              <1> %ifdef MODULE_ADVANCED_ATA
  2838                              <1> 	MAIN_FLG_MODULE_ADVANCED_ATA	EQU	FLG_ROMVARS_MODULE_ADVANCED_ATA
  2839                              <1> %else
  2840                              <1> 	MAIN_FLG_MODULE_ADVANCED_ATA	EQU	0
  2841                              <1> %endif
  2842                              <1> 
  2843                              <1> %ifdef MODULE_BOOT_MENU
  2844                              <1> 	MAIN_FLG_MODULE_BOOT_MENU	EQU	FLG_ROMVARS_MODULE_BOOT_MENU
  2845                              <1> %else
  2846                              <1> 	MAIN_FLG_MODULE_BOOT_MENU	EQU	0
  2847                              <1> %endif
  2848                              <1> 
  2849                              <1> %ifdef MODULE_EBIOS
  2850                              <1> 	MAIN_FLG_MODULE_EBIOS	EQU	FLG_ROMVARS_MODULE_EBIOS
  2851                              <1> %else
  2852                              <1> 	MAIN_FLG_MODULE_EBIOS	EQU	0
  2853                              <1> %endif
  2854                              <1> 
  2855                              <1> %ifdef MODULE_HOTKEYS
  2856                              <1> 	MAIN_FLG_MODULE_HOTKEYS	EQU	FLG_ROMVARS_MODULE_HOTKEYS
  2857                              <1> %else
  2858                              <1> 	MAIN_FLG_MODULE_HOTKEYS	EQU	0
  2859                              <1> %endif
  2860                              <1> 
  2861                              <1> %ifdef MODULE_IRQ
  2862                              <1> 	MAIN_FLG_MODULE_IRQ		EQU	FLG_ROMVARS_MODULE_IRQ
  2863                              <1> %else
  2864                              <1> 	MAIN_FLG_MODULE_IRQ		EQU	0
  2865                              <1> %endif
  2866                              <1> 
  2867                              <1> %ifdef MODULE_SERIAL
  2868                              <1> 	MAIN_FLG_MODULE_SERIAL	EQU	FLG_ROMVARS_MODULE_SERIAL
  2869                              <1> %else
  2870                              <1> 	MAIN_FLG_MODULE_SERIAL	EQU	0
  2871                              <1> %endif
  2872                              <1> 
  2873                              <1> %ifdef MODULE_SERIAL_FLOPPY
  2874                              <1> 	MAIN_FLG_MODULE_SERIAL_FLOPPY	EQU	FLG_ROMVARS_MODULE_SERIAL_FLOPPY
  2875                              <1> %else
  2876                              <1> 	MAIN_FLG_MODULE_SERIAL_FLOPPY	EQU	0
  2877                              <1> %endif
  2878                              <1> 
  2879                              <1> %ifdef MODULE_STRINGS_COMPRESSED
  2880                              <1> 	MAIN_FLG_MODULE_STRINGS_COMPRESSED	EQU	FLG_ROMVARS_MODULE_STRINGS_COMPRESSED
  2881                              <1> %else
  2882                              <1> 	MAIN_FLG_MODULE_STRINGS_COMPRESSED	EQU	0
  2883                              <1> %endif
  2884                              <1> 
  2885                              <1> %ifdef MODULE_FEATURE_SETS
  2886                              <1> 	MAIN_FLG_MODULE_FEATURE_SETS	EQU	FLG_ROMVARS_MODULE_FEATURE_SETS
  2887                              <1> %else
  2888                              <1> 	MAIN_FLG_MODULE_FEATURE_SETS	EQU	0
  2889                              <1> %endif
  2890                              <1> 
  2891                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
  2892                              <1> 	MAIN_FLG_MODULE_8BIT_IDE_ADVANCED	EQU	FLG_ROMVARS_MODULE_8BIT_IDE_ADVANCED
  2893                              <1> %else
  2894                              <1> 	MAIN_FLG_MODULE_8BIT_IDE_ADVANCED	EQU	0
  2895                              <1> %endif
  2896                              <1> 
  2897                              <1> MASK_ROMVARS_INCLUDED_MODULES	EQU	MAIN_FLG_MODULE_8BIT_IDE | MAIN_FLG_MODULE_ADVANCED_ATA | MAIN_FLG_MODULE_BOOT_MENU | MAIN_FLG_MODULE_EBIOS | MAIN_FLG_MODULE_HOTKEYS | MAIN_FLG_MODULE_IRQ | MAIN_FLG_MODULE_SERIAL 
  2898                              <1> 
  2899                                  	%include "Version.inc"
  2900                              <1> ; /*
  2901                              <1> ; Project name	:	XTIDE Universal BIOS
  2902                              <1> ; Description	:	Version information.
  2903                              <1> 
  2904                              <1> ;
  2905                              <1> ; XTIDE Universal BIOS and Associated Tools
  2906                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2907                              <1> ;
  2908                              <1> ; This program is free software; you can redistribute it and/or modify
  2909                              <1> ; it under the terms of the GNU General Public License as published by
  2910                              <1> ; the Free Software Foundation; either version 2 of the License, or
  2911                              <1> ; (at your option) any later version.
  2912                              <1> ;
  2913                              <1> ; This program is distributed in the hope that it will be useful,
  2914                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2915                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2916                              <1> ; GNU General Public License for more details.
  2917                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2918                              <1> ;
  2919                              <1> 
  2920                              <1> ;--------------------------------------------------------------------------------
  2921                              <1> ;
  2922                              <1> ; Assembler Version
  2923                              <1> ;
  2924                              <1> 
  2925                              <1> %ifndef VERSION_INC
  2926                              <1> %define VERSION_INC
  2927                              <1> 
  2928                              <1> 
  2929                              <1> %define TITLE_STRING_START	"-=XTIDE Universal BIOS "
  2930                              <1> %ifdef USE_AT
  2931                              <1> 	%ifdef USE_386
  2932                              <1> 		%define	TITLE_STRING_END	"(386)=-",NULL
  2933                              <1> 	%else
  2934                              <1> 		%define	TITLE_STRING_END	"(AT)=-",NULL
  2935                              <1> 	%endif
  2936                              <1> %elifdef USE_186
  2937                              <1> 	%define	TITLE_STRING_END	"(XT+)=-",NULL
  2938                              <1> %else
  2939                              <1> 	%define	TITLE_STRING_END	"(XT)=-",NULL
  2940                              <1> %endif
  2941                              <1> 
  2942                              <1> %define	TITLE_STRING			TITLE_STRING_START, TITLE_STRING_END
  2943                              <1> %define	ROM_VERSION_STRING		"v2.0.0",BETA,"3+ (",__DATE__,")",NULL
  2944                              <1> %define	FLASH_SIGNATURE			"XTIDE203"	; Do not terminate with NULL
  2945                              <1> 
  2946                              <1> 
  2947                              <1> %endif ; VERSION_INC
  2948                              <1> 
  2949                              <1> %if 0			; equivalent of a NASM comment block
  2950                              <1> ;*/
  2951                              <1> 
  2952                              <1> //--------------------------------------------------------------------------------
  2953                              <1> //
  2954                              <1> // C/C++ Version
  2955                              <1> //
  2956                              <1> 
  2957                              <1> #define BETA " Beta "
  2958                              <1> 
  2959                              <1> #define ROM_VERSION_STRING		"v2.0.0" BETA "3 (" __DATE__ ")"
  2960                              <1> 
  2961                              <1> /*
  2962                              <1> %endif
  2963                              <1> ;*/
  2964                                  	%include "ATA_ID.inc"			; For ATA Drive Information structs
  2965                              <1> ; Project name	:	XTIDE Universal BIOS
  2966                              <1> ; Description	:	ATA Identify Drive information.
  2967                              <1> 
  2968                              <1> ;
  2969                              <1> ; XTIDE Universal BIOS and Associated Tools
  2970                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  2971                              <1> ;
  2972                              <1> ; This program is free software; you can redistribute it and/or modify
  2973                              <1> ; it under the terms of the GNU General Public License as published by
  2974                              <1> ; the Free Software Foundation; either version 2 of the License, or
  2975                              <1> ; (at your option) any later version.
  2976                              <1> ;
  2977                              <1> ; This program is distributed in the hope that it will be useful,
  2978                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  2979                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2980                              <1> ; GNU General Public License for more details.
  2981                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  2982                              <1> ;
  2983                              <1> 
  2984                              <1> %ifndef ATA_ID_INC
  2985                              <1> %define ATA_ID_INC
  2986                              <1> 
  2987                              <1> ; Maximum valid P-CHS parameters
  2988                              <1> MAX_VALID_PCHS_CYLINDERS			EQU		16383
  2989                              <1> MAX_VALID_PCHS_HEADS				EQU		16
  2990                              <1> MAX_VALID_PCHS_SECTORS_PER_TRACK	EQU		63
  2991                              <1> 
  2992                              <1> 
  2993                              <1> ; PIO Minimum Cycle Times (t0)
  2994                              <1> ; Timings for Advanced Modes (3 and above) can be read from ATA info WORDs 67 and 68
  2995                              <1> ; Those usually have the same Cycle Time as below
  2996                              <1> PIO_0_MIN_CYCLE_TIME_NS		EQU		600
  2997                              <1> PIO_1_MIN_CYCLE_TIME_NS		EQU		383
  2998                              <1> PIO_2_MIN_CYCLE_TIME_NS		EQU		240
  2999                              <1> PIO_3_MIN_CYCLE_TIME_NS		EQU		180
  3000                              <1> PIO_4_MIN_CYCLE_TIME_NS		EQU		120
  3001                              <1> PIO_5_MIN_CYCLE_TIME_NS		EQU		100		; CF specification
  3002                              <1> PIO_6_MIN_CYCLE_TIME_NS		EQU		80		; CF specification
  3003                              <1> 
  3004                              <1> ; PIO Minimum Address Valid Times (t1)
  3005                              <1> PIO_0_MIN_ADDRESS_VALID_NS	EQU		70
  3006                              <1> PIO_1_MIN_ADDRESS_VALID_NS	EQU		50
  3007                              <1> PIO_2_MIN_ADDRESS_VALID_NS	EQU		30
  3008                              <1> PIO_3_MIN_ADDRESS_VALID_NS	EQU		30
  3009                              <1> PIO_4_MIN_ADDRESS_VALID_NS	EQU		25
  3010                              <1> PIO_5_MIN_ADDRESS_VALID_NS	EQU		15
  3011                              <1> PIO_6_MIN_ADDRESS_VALID_NS	EQU		10
  3012                              <1> 
  3013                              <1> ; PIO Minimum Active Times (t2)
  3014                              <1> PIO_0_MIN_ACTIVE_TIME_NS	EQU		165
  3015                              <1> PIO_1_MIN_ACTIVE_TIME_NS	EQU		125
  3016                              <1> PIO_2_MIN_ACTIVE_TIME_NS	EQU		100
  3017                              <1> PIO_3_MIN_ACTIVE_TIME_NS	EQU		80
  3018                              <1> PIO_4_MIN_ACTIVE_TIME_NS	EQU		70
  3019                              <1> PIO_5_MIN_ACTIVE_TIME_NS	EQU		65
  3020                              <1> PIO_6_MIN_ACTIVE_TIME_NS	EQU		55
  3021                              <1> 
  3022                              <1> ; PIO Minimum Recovery Times or Inactive Times (t2i) can be calculated
  3023                              <1> ; from Minimum Cycle Time (t0) - Minimum Active Time (t2) - Address Valid Time (t1).
  3024                              <1> ; I'm not sure about this calculation so correct me if I'm wrong!
  3025                              <1> ; Recovery time should be calculated at run time since Cycle Time t0 can be
  3026                              <1> ; read from ATA information (ATA2+) but most drives just report the
  3027                              <1> ; Min Cycle Times listed above.
  3028                              <1> 
  3029                              <1> 
  3030                              <1> 
  3031                              <1> ; ATA-1 Drive Information struct
  3032                              <1> ; F = Fixed value
  3033                              <1> ; V = Variable value
  3034                              <1> ; R = Reserved word
  3035                              <1> ; X = Vendor specific word
  3036                              <1> struc ATA1
  3037 00000000 <res 00000002>      <1> 	.wGenCfg	resw 1	; 0F, General configuration bit-significant information
  3038 00000002 <res 00000002>      <1> 	.wCylCnt	resw 1	; 1F, Number of cylinders
  3039 00000004 <res 00000002>      <1> 				resw 1	; 2R
  3040 00000006 <res 00000002>      <1> 	.wHeadCnt	resw 1	; 3F, Number of heads
  3041 00000008 <res 00000002>      <1> 	.wBpTrck	resw 1	; 4F, Number of unformatted bytes per track
  3042 0000000A <res 00000002>      <1> 	.wBpSect	resw 1	; 5F, Number of unformatted bytes per sector
  3043 0000000C <res 00000002>      <1> 	.wSPT		resw 1	; 6F, Number of sectors per track
  3044 0000000E <res 00000006>      <1> 				resw 3	; 7...9X
  3045 00000014 <res 00000014>      <1> 	.strSerial	resb 20	; 10...19F, Serial number (20 ASCII characters, 0000h=not specified)
  3046 00000028 <res 00000002>      <1> 	.wBuffType	resw 1	; 20F, Buffer type
  3047 0000002A <res 00000002>      <1> 	.wBuffSize	resw 1	; 21F, Buffer size in 512 byte increments (0000h=not specified)
  3048 0000002C <res 00000002>      <1> 	.wEccCnt	resw 1	; 22F, # of ECC bytes avail on read/write long cmds (0000h=not spec'd)
  3049 0000002E <res 00000008>      <1> 	.strFirmW	resb 8	; 23...26F, Firmware revision (8 ASCII characters, 0000h=not specified)
  3050 00000036 <res 00000028>      <1> 	.strModel	resb 40	; 27...46F, Model number (40 ASCII characters, 0000h=not specified)
  3051 0000005E <res 00000001>      <1> 	.bBlckSize	resb 1	; 47[0-7]F, Maximum number of sectors that can be transferred
  3052                              <1> 						;          per interrupt on read and write multiple commands
  3053                              <1> 						;		   (00h=Read/write multiple commands not implemented)
  3054 0000005F <res 00000001>      <1> 				resb 1	; 47[8-15]X
  3055 00000060 <res 00000002>      <1> 	.wDWIO		resw 1	; 48F, Can perform doubleword I/O (boolean)
  3056 00000062 <res 00000002>      <1> 	.wCaps		resw 1	; 49FRX, Capabilities
  3057 00000064 <res 00000002>      <1> 				resw 1	; 50R
  3058 00000066 <res 00000001>      <1> 				resb 1	; 51[0-7]X
  3059 00000067 <res 00000001>      <1> 	.bPioMode	resb 1	; 51[8-15]F, PIO data transfer cycle timing mode (0, 1 or 2)
  3060 00000068 <res 00000001>      <1> 				resb 1	; 52[0-7]X
  3061 00000069 <res 00000001>      <1> 	.bDMATiming	resb 1	; 52[8-15]F, DMA data transfer cycle timing mode
  3062 0000006A <res 00000002>      <1> 	.wFields	resw 1	; 53FVR, Field (next words) validity bits
  3063                              <1> 
  3064                              <1> 	; Words 54-58 are valid only if bit0 is set in .wFields
  3065 0000006C <res 00000002>      <1> 	.wCurCyls	resw 1	; 54V, Number of current cylinders
  3066 0000006E <res 00000002>      <1> 	.wCurHeads	resw 1	; 55V, Number of current heads
  3067 00000070 <res 00000002>      <1> 	.wCurSPT	resw 1	; 56V, Number of current sectors per track
  3068 00000072 <res 00000004>      <1> 	.dwCurSCnt	resd 1	; 57...58V, Current capacity in sectors
  3069                              <1> 
  3070                              <1> 	; Words 59-63 are always valid
  3071 00000076 <res 00000001>      <1> 	.bBlockSel	resb 1	; 59[0-7]V, Current setting for number of sectors that
  3072                              <1> 						;           can be transferred per interrupt on R/W multiple command
  3073 00000077 <res 00000001>      <1> 	.bBlockFlgs	resb 1	; 59[8-15]VR, bit 0 set if Multiple sector setting is valid
  3074 00000078 <res 00000004>      <1> 	.dwLBACnt	resd 1	; 60...61F, Total number of user addressable sectors (LBA mode only)
  3075 0000007C <res 00000001>      <1> 	.bSDMASupp	resb 1	; 62[0-7]F, Single word DMA transfer modes supported
  3076 0000007D <res 00000001>      <1> 	.bSDMAAct	resb 1	; 62[8-15]V, Single word DMA transfer mode active
  3077 0000007E <res 00000001>      <1> 	.bMDMASupp	resb 1	; 63[0-7]F, Multiword DMA transfer modes supported
  3078 0000007F <res 00000001>      <1> 	.bMDMAAct	resb 1	; 63[8-15]V, Multiword DMA transfer mode active
  3079                              <1> endstruc
  3080                              <1> 
  3081                              <1> A1_MODEL_NUMBER_LENGTH	EQU	40		; 40 ASCII characters
  3082                              <1> 
  3083                              <1> ; ATA-1 Word 0, General configuration
  3084                              <1> A1_wGenCfg_NONMAG		EQU	(1<<15)	; Reserved for non-magnetic drives
  3085                              <1> A1_wGenCfg_FGAPREQ		EQU	(1<<14)	; Format speed tolerance gap required
  3086                              <1> A1_wGenCfg_TRCKOFF		EQU	(1<<13)	; Track offset option available
  3087                              <1> A1_wGenCfg_DATAOFF		EQU	(1<<12)	; Data strobe offset option available
  3088                              <1> A1_wGenCfg_ROTTOL		EQU	(1<<11)	; Rotational speed tolerance is > 0,5%
  3089                              <1> A1_wGenCfg_XFERFAST		EQU (1<<10)	; Disk transfer rate > 10 Mbs
  3090                              <1> A1_wGenCfg_XFERMED		EQU	(1<<9)	; Disk transfer rate > 5Mbs but <= 10Mbs
  3091                              <1> A1_wGenCfg_XFERSLOW		EQU (1<<8)	; Disk transfer rate <= 5Mbs
  3092                              <1> A1_wGenCfg_REMOVABLE	EQU	(1<<7)	; Removable cartridge drive
  3093                              <1> A1_wGenCfg_FIXED		EQU	(1<<6)	; Fixed drive
  3094                              <1> A1_wGenCfg_MOTCTRL		EQU	(1<<5)	; Spindle motor control option implemented
  3095                              <1> A1_wGenCfg_HEADSLOW		EQU	(1<<4)	; Head switch time > 15 usec
  3096                              <1> A1_wGenCfg_NOTMFM		EQU	(1<<3)	; Not MFM encoded
  3097                              <1> A1_wGenCfg_SOFTSECT		EQU	(1<<2)	; Soft sectored
  3098                              <1> A1_wGenCfg_HARDSECT		EQU	(1<<1)	; Hard sectored
  3099                              <1> 
  3100                              <1> ; ATA-1 Word 49, Capabilities
  3101                              <1> A1_wCaps_LBA			EQU	(1<<9)	; LBA supported
  3102                              <1> A1_wCaps_DMA			EQU	(1<<8)	; DMA supported
  3103                              <1> 
  3104                              <1> ; ATA-1 Word 53, Fields
  3105                              <1> A1_wFields_54to58		EQU	(1<<0)	; The fields reported in words 54-58 are valid
  3106                              <1> 
  3107                              <1> ; ATA-1 Word 59 high byte, Block mode flags
  3108                              <1> A1_bBlockFlgs_VALID		EQU	(1<<0)	; Multiple sector setting (bBlockSel) is valid
  3109                              <1> 
  3110                              <1> 
  3111                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3112                              <1> 
  3113                              <1> ; ATA-2 Drive Information struct
  3114                              <1> ; F = Fixed value
  3115                              <1> ; V = Variable value
  3116                              <1> ; R = Reserved word
  3117                              <1> ; X = Vendor specific word
  3118                              <1> struc ATA2
  3119 00000000 <res 00000002>      <1> 	.wGenCfg	resw 1	; 0F, General configuration bit-significant information
  3120 00000002 <res 00000002>      <1> 	.wCylCnt	resw 1	; 1F, Number of logical cylinders
  3121 00000004 <res 00000002>      <1> 				resw 1	; 2R
  3122 00000006 <res 00000002>      <1> 	.wHeadCnt	resw 1	; 3F, Number of logical heads
  3123 00000008 <res 00000002>      <1> 				resw 1	; 4X
  3124 0000000A <res 00000002>      <1> 				resw 1	; 5X
  3125 0000000C <res 00000002>      <1> 	.wSPT		resw 1	; 6F, Number of logical sectors per track
  3126 0000000E <res 00000006>      <1> 				resw 3	; 7...9X
  3127 00000014 <res 00000014>      <1> 	.strSerial	resb 20	; 10...19F, Serial number (20 ASCII characters, 0000h=not specified)
  3128 00000028 <res 00000002>      <1> 				resw 1	; 20X
  3129 0000002A <res 00000002>      <1> 				resw 1	; 21X
  3130 0000002C <res 00000002>      <1> 	.wEccCnt	resw 1	; 22F, # of ECC bytes avail on read/write long cmds (0000h=not spec'd)
  3131 0000002E <res 00000008>      <1> 	.strFirmW	resb 8	; 23...26F, Firmware revision (8 ASCII characters, 0000h=not specified)
  3132 00000036 <res 00000028>      <1> 	.strModel	resb 40	; 27...46F, Model number (40 ASCII characters, 0000h=not specified)
  3133 0000005E <res 00000001>      <1> 	.bBlckSize	resb 1	; 47[0-7]F, Maximum number of sectors that can be transferred
  3134                              <1> 						;          per interrupt on read and write multiple commands
  3135                              <1> 						;		   (00h=Read/write multiple commands not implemented)
  3136 0000005F <res 00000001>      <1> 				resb 1	; 47[8-15]X
  3137 00000060 <res 00000002>      <1> 				resw 1	; 48R
  3138 00000062 <res 00000002>      <1> 	.wCaps		resw 1	; 49FRX, Capabilities
  3139 00000064 <res 00000002>      <1> 				resw 1	; 50R
  3140 00000066 <res 00000001>      <1> 				resb 1	; 51[0-7]X
  3141 00000067 <res 00000001>      <1> 	.bPIOTiming	resb 1	; 51[8-15]F, PIO data transfer cycle timing mode
  3142 00000068 <res 00000001>      <1> 				resb 1	; 52[0-7]X
  3143 00000069 <res 00000001>      <1> 	.bDMATiming	resb 1	; 52[8-15]F, DMA data transfer cycle timing mode
  3144 0000006A <res 00000002>      <1> 	.wFields	resw 1	; 53FVR, Field (next words) validity bits
  3145                              <1> 
  3146                              <1> 	; Words 54-58 are valid only if bit0 is set in .wFields
  3147 0000006C <res 00000002>      <1> 	.wCurCyls	resw 1	; 54V, Number of current logical cylinders
  3148 0000006E <res 00000002>      <1> 	.wCurHeads	resw 1	; 55V, Number of current logical heads
  3149 00000070 <res 00000002>      <1> 	.wCurSPT	resw 1	; 56V, Number of current logical sectors per track
  3150 00000072 <res 00000004>      <1> 	.dwCurSCnt	resd 1	; 57...58V, Current capacity in sectors
  3151                              <1> 
  3152                              <1> 	; Words 59-63 are always valid
  3153 00000076 <res 00000001>      <1> 	.bBlockSel	resb 1	; 59[0-7]V, Current setting for number of sectors that
  3154                              <1> 						;           can be transferred per interrupt on R/W multiple command
  3155 00000077 <res 00000001>      <1> 	.bBlockFlgs	resb 1	; 59[8-15]VR, bit 0 set if Multiple sector setting is valid
  3156 00000078 <res 00000004>      <1> 	.dwLBACnt	resd 1	; 60...61F, Total number of user addressable sectors (LBA mode only)
  3157 0000007C <res 00000001>      <1> 	.bSDMASupp	resb 1	; 62[0-7]F, Single word DMA transfer modes supported
  3158 0000007D <res 00000001>      <1> 	.bSDMAAct	resb 1	; 62[8-15]V, Single word DMA transfer mode active
  3159 0000007E <res 00000001>      <1> 	.bMDMASupp	resb 1	; 63[0-7]F, Multiword DMA transfer modes supported
  3160 0000007F <res 00000001>      <1> 	.bMDMAAct	resb 1	; 63[8-15]V, Multiword DMA transfer mode active
  3161                              <1> 
  3162                              <1> 	; Words 64-70 are valid only if bit1 is set in .wFields (ATA2+)
  3163 00000080 <res 00000001>      <1> 	.bPIOSupp	resb 1	; 64[0-7]F, Advanced PIO Transfer Modes Supported
  3164 00000081 <res 00000001>      <1> 				resb 1	; 64[8-15]R
  3165 00000082 <res 00000002>      <1> 	.wMDMAMinCy	resw 1	; 65F, Minimum Multiword DMA Transfer Cycle Time Per Word
  3166 00000084 <res 00000002>      <1> 	.wMDMARecCy	resw 1	; 66F, Manufacturers Recommended Multiword DMA Transfer Cycle Time
  3167 00000086 <res 00000002>      <1> 	.wPIOMinCy	resw 1	; 67F, Minimum PIO Transfer Cycle Time Without Flow Control
  3168 00000088 <res 00000002>      <1> 	.wPIOMinCyF	resw 1	; 68F, Minimum PIO Transfer Cycle Time With IORDY Flow Control
  3169                              <1> endstruc
  3170                              <1> 
  3171                              <1> ; ATA-2 Word 0, General configuration
  3172                              <1> A2_wGenCfg_NONMAG		EQU	(1<<15)	; Reserved for non-magnetic drives
  3173                              <1> A2_wGenCfg_REMOVABLE	EQU	(1<<7)	; Removable media device
  3174                              <1> A2_wGenCfg_FIXED		EQU	(1<<6)	; Not removable controller and/or device
  3175                              <1> 
  3176                              <1> ; ATA-1 Word 49, Capabilities
  3177                              <1> A2_wCaps_TIMER			EQU	(1<<13)	; Standby timer values as specified in this standard are supported
  3178                              <1> A2_wCaps_IORDY			EQU	(1<<11)	; IORDY supported
  3179                              <1> A2_wCaps_CANDISIORDY	EQU	(1<<10)	; IORDY can be disabled
  3180                              <1> A2_wCaps_LBA			EQU	(1<<9)	; LBA supported
  3181                              <1> A2_wCaps_DMA			EQU	(1<<8)	; DMA supported
  3182                              <1> 
  3183                              <1> ; ATA-2 Word 53, Fields
  3184                              <1> A2_wFields_54to58		EQU	(1<<0)	; The fields reported in words 54-58 are valid
  3185                              <1> A2_wFields_64to70		EQU	(1<<1)	; The fields reported in words 64-70 are valid
  3186                              <1> 
  3187                              <1> ; ATA-2 Word 59 high byte, Block mode flags
  3188                              <1> A2_bBlockFlgs_VALID		EQU	(1<<0)	; Multiple sector setting (bBlockSel) is valid
  3189                              <1> 
  3190                              <1> ; ATA-2 Word 64, Advanced PIO transfer modes supported
  3191                              <1> A2_bPIOSupp_PIO3		EQU	(1<<0)
  3192                              <1> A2_bPIOSupp_PIO4		EQU	(1<<1)
  3193                              <1> 
  3194                              <1> 
  3195                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3196                              <1> 
  3197                              <1> ; ATA-6 Drive Information struct
  3198                              <1> ; F = Fixed value
  3199                              <1> ; V = Variable value
  3200                              <1> ; R = Reserved word
  3201                              <1> ; X = Vendor specific word
  3202                              <1> struc ATA6
  3203 00000000 <res 00000002>      <1> 	.wGenCfg	resw 1	; 0F, General configuration bit-significant information
  3204 00000002 <res 00000002>      <1> 				resw 1	; 1X, Obsolete (Number of logical cylinders)
  3205 00000004 <res 00000002>      <1> 				resw 1	; 2V, Specific configuration
  3206 00000006 <res 00000002>      <1> 				resw 1	; 3X, Obsolete (Number of logical heads)
  3207 00000008 <res 00000002>      <1> 				resw 1	; 4X
  3208 0000000A <res 00000002>      <1> 				resw 1	; 5X
  3209 0000000C <res 00000002>      <1> 				resw 1	; 6X, Obsolete (Number of logical sectors per track)
  3210 0000000E <res 00000004>      <1> 				resw 2	; 7...8V, Reserved for assignment by the CompactFlash Association
  3211 00000012 <res 00000002>      <1> 				resw 1	; 9X
  3212 00000014 <res 00000014>      <1> 	.strSerial	resb 20	; 10...19F, Serial number (20 ASCII characters, 0000h=not specified)
  3213 00000028 <res 00000002>      <1> 				resw 1	; 20X
  3214 0000002A <res 00000002>      <1> 				resw 1	; 21X
  3215 0000002C <res 00000002>      <1> 				resw 1	; 22X, Obsolete (# of ECC bytes avail on read/write long cmds (0000h=not spec'd))
  3216 0000002E <res 00000008>      <1> 	.strFirmW	resb 8	; 23...26F, Firmware revision (8 ASCII characters, 0000h=not specified)
  3217 00000036 <res 00000028>      <1> 	.strModel	resb 40	; 27...46F, Model number (40 ASCII characters, 0000h=not specified)
  3218 0000005E <res 00000001>      <1> 	.bBlckSize	resb 1	; 47[0-7]F, Maximum number of sectors that can be transferred
  3219                              <1> 						;           per interrupt on read and write multiple commands
  3220                              <1> 						;		    (00h=Read/write multiple commands not implemented)
  3221 0000005F <res 00000001>      <1> 				resb 1	; 47[8-15]F, 80h
  3222 00000060 <res 00000002>      <1> 				resw 1	; 48R
  3223 00000062 <res 00000002>      <1> 	.wCaps		resw 1	; 49FX, Capabilities
  3224 00000064 <res 00000002>      <1> 	.wCapsHigh	resw 1	; 50FX, Capabilities 2
  3225 00000066 <res 00000002>      <1> 				resw 1	; 51X, Obsolete (PIO data transfer cycle timing mode)
  3226 00000068 <res 00000002>      <1> 				resw 1	; 52X, Obsolete (DMA data transfer cycle timing mode)
  3227 0000006A <res 00000002>      <1> 	.wFields	resw 1	; 53FX, Field (next words) validity bits
  3228                              <1> 
  3229                              <1> 	; Words 54-58 are valid only if bit0 is set in .wFields
  3230 0000006C <res 00000002>      <1> 				resw 1	; 54X, Obsolete (Number of current logical cylinders)
  3231 0000006E <res 00000002>      <1> 				resw 1	; 55X, Obsolete (Number of current logical heads)
  3232 00000070 <res 00000002>      <1> 				resw 1	; 56X, Obsolete (Number of current logical sectors per track)
  3233 00000072 <res 00000004>      <1> 				resd 1	; 57...58X, Obsolete (Current capacity in sectors)
  3234                              <1> 
  3235                              <1> 	; Words 59-63 are always valid
  3236 00000076 <res 00000001>      <1> 	.bBlockSel	resb 1	; 59[0-7]V, Current setting for number of sectors that
  3237                              <1> 						;           can be transferred per interrupt on R/W multiple command
  3238 00000077 <res 00000001>      <1> 	.bBlockFlgs	resb 1	; 59[8-15]VR, bit 0 set if Multiple sector setting is valid
  3239 00000078 <res 00000004>      <1> 	.dwLBACnt	resd 1	; 60...61F, Total number of user addressable sectors (LBA-28)
  3240 0000007C <res 00000001>      <1> 				resb 1	; 62[0-7]X, Obsolete (Single word DMA transfer modes supported)
  3241 0000007D <res 00000001>      <1> 				resb 1	; 62[8-15]X, Obsolete (Single word DMA transfer mode active)
  3242 0000007E <res 00000002>      <1> 	.wMDMA		resw 1	; 63FV, Multiword DMA transfer modes supported and active
  3243                              <1> 
  3244                              <1> 	; Words 64-70 are valid only if bit1 is set in .wFields (ATA2+)
  3245 00000080 <res 00000001>      <1> 	.bPIOSupp	resb 1	; 64[0-7]F, Advanced PIO Transfer Modes Supported
  3246 00000081 <res 00000001>      <1> 				resb 1	; 64[8-15]R
  3247 00000082 <res 00000002>      <1> 	.wMDMAMinCy	resw 1	; 65F, Minimum Multiword DMA Transfer Cycle Time Per Word
  3248 00000084 <res 00000002>      <1> 	.wMDMARecCy	resw 1	; 66F, Manufacturers Recommended Multiword DMA Transfer Cycle Time
  3249 00000086 <res 00000002>      <1> 	.wPIOMinCy	resw 1	; 67F, Minimum PIO Transfer Cycle Time Without Flow Control
  3250 00000088 <res 00000002>      <1> 	.wPIOMinCyF	resw 1	; 68F, Minimum PIO Transfer Cycle Time With IORDY Flow Control
  3251 0000008A <res 00000004>      <1> 				resw 71-69	; 69...70R
  3252                              <1> 
  3253                              <1> 	; Words 71...74 are reserved for IDENTIFY PACKET DEVICE command
  3254 0000008E <res 00000008>      <1> 				resw 75-71	; 71...74R
  3255                              <1> 
  3256 00000096 <res 00000002>      <1> 	.wQueue		resw 1	; 75[0-4]F, Maximum queue depth - 1
  3257 00000098 <res 00000008>      <1> 				resw 80-76	; 76...79R
  3258                              <1> 
  3259 000000A0 <res 00000002>      <1> 	.wMajorVer	resw 1	; 80F, Major Version Number
  3260 000000A2 <res 00000002>      <1> 	.wMinorVer	resw 1	; 81F, Minor Version Number
  3261 000000A4 <res 00000002>      <1> 	.wSetSup82	resw 1	; 82F, Command set supported
  3262 000000A6 <res 00000002>      <1> 	.wSetSup83	resw 1	; 83F, Command sets supported
  3263 000000A8 <res 00000002>      <1> 	.wSetSup84	resw 1	; 84F, Command set / Feature supported extension
  3264 000000AA <res 00000002>      <1> 	.wEnFor82	resw 1	; 85FV, Command set / feature enabled (for word 82)
  3265 000000AC <res 00000002>      <1> 	.wEnFor83	resw 1	; 86FV, Command set / feature enabled (for word 83)
  3266 000000AE <res 00000002>      <1> 	.wEnFor84	resw 1	; 87FV, Command set / feature enabled (for word 84)
  3267                              <1> 
  3268                              <1> 	; Word 88 is valid only if bit2 is set in .wFields (word 53)
  3269 000000B0 <res 00000002>      <1> 	.wUDMA		resw 1	; 88FV, Ultra DMA Mode support
  3270                              <1> 
  3271 000000B2 <res 00000002>      <1> 	.wEraseTime	resw 1	; 89F, Time required for security erase unit completion
  3272 000000B4 <res 00000002>      <1> 	.wEnhErTime	resw 1	; 90F, Time required for Enhanced security erase completion
  3273 000000B6 <res 00000002>      <1> 	.wCurPower	resw 1	; 91V, Current advanced power management value
  3274 000000B8 <res 00000002>      <1> 	.wPWRev		resw 1	; 92V, Master Password Revision Code
  3275 000000BA <res 00000002>      <1> 	.wReset		resw 1	; 93FV, Hardware reset result
  3276 000000BC <res 00000001>      <1> 	.bCurAcous	resb 1	; 94[0-7]V, Current automatic acoustic management value
  3277 000000BD <res 00000001>      <1> 	.bRecAcous	resb 1	; 94[8-15]V, Vendors recommended acoustic management value
  3278 000000BE <res 0000000A>      <1> 				resw 100-95		; 95...99R
  3279 000000C8 <res 00000008>      <1> 	.qwLBACnt	resb 8	; 100...103V, Total number of user addressable sectors (LBA48)
  3280 000000D0 <res 0000002E>      <1> 				resw 127-104	; 104...126R
  3281 000000FE <res 00000002>      <1> 	.wRMSN		resw 1	; 127F, Removable Media Status Notification feature set support
  3282 00000100 <res 00000002>      <1> 	.wSecurity	resw 1	; 128FV, Security Status
  3283 00000102 <res 0000003E>      <1> 				resw 160-129	; 129...157X, Vendor Specific
  3284 00000140 <res 00000002>      <1> 	.wCFAPower	resw 1	; 160FV, CFA Power Mode 1
  3285 00000142 <res 0000001E>      <1> 				resw 176-161	; 161...175R, Reserved for assignment by the CompactFlash Association
  3286 00000160 <res 0000003C>      <1> 	.strMediaSr	resw 206-176	; 176...205V, Current media serial number
  3287 0000019C <res 00000062>      <1> 				resw 255-206	; 206...254R
  3288                              <1> 	.wIntegrityWord:
  3289 000001FE <res 00000001>      <1> 	.bSignature	resb 1	; 255[0-7]X, Signature
  3290 000001FF <res 00000001>      <1> 	.bChecksum	resb 1	; 255[8-15]X, Checksum
  3291                              <1> endstruc
  3292                              <1> 
  3293                              <1> ; ATA-6 Word 0, General configuration
  3294                              <1> A6_wGenCfg_REMOVABLE	EQU	(1<<7)	; Removable media device
  3295                              <1> A6_wGenCfg_INCOMPLETE	EQU	(1<<2)	; Response incomplete
  3296                              <1> 
  3297                              <1> ; ATA-6 Word 49, Capabilities
  3298                              <1> A6_wCaps_TIMER			EQU	(1<<13)	; Standby timer values as specified in this standard are supported
  3299                              <1> A6_wCaps_IORDY			EQU	(1<<11)	; IORDY supported
  3300                              <1> A6_wCaps_CANDISIORDY	EQU	(1<<10)	; IORDY can be disabled
  3301                              <1> A6_wCaps_LBA			EQU	(1<<9)	; LBA supported
  3302                              <1> A6_wCaps_DMA			EQU	(1<<8)	; DMA supported
  3303                              <1> 
  3304                              <1> ; ATA-6 Word 53, Fields
  3305                              <1> A6_wFields_88			EQU	(1<<2)	; The fields reported in word 88 are valid
  3306                              <1> A6_wFields_64to70		EQU	(1<<1)	; The fields reported in words 64-70 are valid
  3307                              <1> 
  3308                              <1> ; ATA-6 Word 59 high byte, Block mode flags
  3309                              <1> A6_bBlockFlgs_VALID		EQU	(1<<0)	; Multiple sector setting (bBlockSel) is valid
  3310                              <1> 
  3311                              <1> ; ATA-6 Word 63, Multiword DMA Mode
  3312                              <1> A6_wMDMA_MODE2_SELECTED	EQU	(1<<10)	; Multiword DMA mode 2 is selected
  3313                              <1> A6_wMDMA_MODE1_SELECTED	EQU	(1<<9)	; Multiword DMA mode 1 is selected
  3314                              <1> A6_wMDMA_MODE0_SELECTED	EQU	(1<<8)	; Multiword DMA mode 0 is selected
  3315                              <1> A6_wMDMA_MODE2_SUPRTD	EQU	(1<<2)	; Multiword DMA mode 2 and below are supported
  3316                              <1> A6_wMDMA_MODE1_SUPRTD	EQU	(1<<1)	; Multiword DMA mode 1 and below are supported
  3317                              <1> A6_wMDMA_MODE0_SUPRTD	EQU	(1<<0)	; Multiword DMA mode 0 is supported
  3318                              <1> 
  3319                              <1> ; ATA-6 Word 80, Major version number
  3320                              <1> A6_wMajorVer_ATA6		EQU	(1<<6)
  3321                              <1> A6_wMajorVer_ATA5		EQU	(1<<5)
  3322                              <1> A6_wMajorVer_ATA4		EQU	(1<<4)
  3323                              <1> A6_wMajorVer_ATA3		EQU	(1<<3)
  3324                              <1> 
  3325                              <1> ; ATA-6 Word 82, Command set supported
  3326                              <1> A6_wSetSup82_NOP		EQU	(1<<14)	; NOP command supported
  3327                              <1> A6_wSetSup82_RDBUFF		EQU	(1<<13)	; READ BUFFER command supported
  3328                              <1> A6_wSetSup82_WRBUFF		EQU	(1<<12)	; WRITE BUFFER command supported
  3329                              <1> A6_wSetSup82_PROT_AREA	EQU	(1<<10)	; Host Protected Area feature set supported
  3330                              <1> A6_wSetSup82_DEV_RESET	EQU	(1<<9)	; DEVICE RESET command supported
  3331                              <1> A6_wSetSup82_SERVICE	EQU	(1<<8)	; SERVICE interrupt supported
  3332                              <1> A6_wSetSup82_RELEASE	EQU	(1<<7)	; Release interrupt supported
  3333                              <1> A6_wSetSup82_LOOKAHEAD	EQU	(1<<6)	; Look-ahead supported
  3334                              <1> A6_wSetSup82_WRCACHE	EQU	(1<<5)	; Write cache supported
  3335                              <1> A6_wSetSup82_POWERMAN	EQU	(1<<3)	; Power Management feature set supported
  3336                              <1> A6_wSetSup82_REM_MEDIA	EQU	(1<<2)	; Removable Media feature set supported
  3337                              <1> A6_wSetSup82_SECURITY	EQU	(1<<1)	; Security Mode feature set supported
  3338                              <1> A6_wSetSup82_SMART		EQU	(1<<0)	; SMART feature set supported
  3339                              <1> 
  3340                              <1> ; ATA-6 Word 83, Command sets supported
  3341                              <1> A6_wSetSup83_FLUSH_EXT	EQU	(1<<13)	; FLUSH CACHE EXT command supported
  3342                              <1> A6_wSetSup83_FLUSH		EQU	(1<<12)	; FLUSH CACHE command supported
  3343                              <1> A6_wSetSup83_CFG		EQU	(1<<11)	; Device Configuration Overlay feature set supported
  3344                              <1> A6_wSetSup83_LBA48		EQU	(1<<10)	; 48-bit LBA feature set supported
  3345                              <1> A6_wSetSup83_ACOUSTIC	EQU	(1<<9)	; Automatic Acoustic Management feature set supported
  3346                              <1> A6_wSetSup83_SET_MAX	EQU	(1<<8)	; SET MAX security extension supported
  3347                              <1> A6_wSetSup83_FEATURES	EQU	(1<<6)	; SET FEATURES subcommand required to spinup after power-up
  3348                              <1> A6_wSetSup83_POWERUP	EQU	(1<<5)	; Power-Up In Standby feature set supported
  3349                              <1> A6_wSetSup83_RMSN		EQU	(1<<4)	; Removable Media Status Notification feature set supported
  3350                              <1> A6_wSetSup83_APM		EQU	(1<<3)	; Advanced Power Management feature set supported
  3351                              <1> A6_wSetSup83_CFA		EQU	(1<<2)	; CFA feature set supported
  3352                              <1> A6_wSetSup83_DMAQUEUED	EQU	(1<<1)	; READ/WRITE DMA QUEUED supported
  3353                              <1> A6_wSetSup83_MICROCODE	EQU	(1<<0)	; DOWNLOAD MICROCODE command supported
  3354                              <1> 
  3355                              <1> ; ATA-6 Word 84, Command set/feature supported extension
  3356                              <1> A6_wSetSup84_GENLOG		EQU	(1<<5)	; General Purpose Logging feature set supported
  3357                              <1> A6_wSetSup84_MEDIAPASS	EQU	(1<<3)	; Media Card Pass Through Command feature set supported
  3358                              <1> A6_wSetSup84_MEDIASER	EQU	(1<<2)	; Media serial number supported
  3359                              <1> A6_wSetSup84_SMARTTEST	EQU	(1<<1)	; SMART self-test supported
  3360                              <1> A6_wSetSup84_SMARTLOG	EQU	(1<<0)	; SMART error logging supported
  3361                              <1> 
  3362                              <1> ; ATA-6 Word 85, Command set/feature enabled (supported by word 82)
  3363                              <1> A6_wEnFor82_NOP			EQU	(1<<14)	; NOP command enabled
  3364                              <1> A6_wEnFor82_RDBUFF		EQU	(1<<13)	; READ BUFFER command enabled
  3365                              <1> A6_wEnFor82_WRBUFF		EQU	(1<<12)	; WRITE BUFFER command enabled
  3366                              <1> A6_wEnFor82_PROT_AREA	EQU	(1<<10)	; Host Protected Area feature set enabled
  3367                              <1> A6_wEnFor82_DEV_RESET	EQU	(1<<9)	; DEVICE RESET command enabled
  3368                              <1> A6_wEnFor82_SERVICE		EQU	(1<<8)	; SERVICE interrupt enabled
  3369                              <1> A6_wEnFor82_RELEASE		EQU	(1<<7)	; Release interrupt enabled
  3370                              <1> A6_wEnFor82_LOOKAHEAD	EQU	(1<<6)	; Look-ahead enabled
  3371                              <1> A6_wEnFor82_WRCACHE		EQU	(1<<5)	; Write cache enabled
  3372                              <1> A6_wEnFor82_POWERMAN	EQU	(1<<3)	; Power Management feature set enabled
  3373                              <1> A6_wEnFor82_REM_MEDIA	EQU	(1<<2)	; Removable Media feature set enabled
  3374                              <1> A6_wEnFor82_SECURITY	EQU	(1<<1)	; Security Mode feature set enabled
  3375                              <1> A6_wEnFor82_SMART		EQU	(1<<0)	; SMART feature set enabled
  3376                              <1> 
  3377                              <1> ; ATA-6 Word 86, Command set/feature enabled (supported by word 83)
  3378                              <1> A6_wEnFor83_FLUSH_EXT	EQU	(1<<13)	; FLUSH CACHE EXT command supported
  3379                              <1> A6_wEnFor83_FLUSH		EQU	(1<<12)	; FLUSH CACHE command supported
  3380                              <1> A6_wEnFor83_CFG			EQU	(1<<11)	; Device Configuration Overlay supported
  3381                              <1> A6_wEnFor83_LBA48		EQU	(1<<10)	; 48-bit LBA feature set supported
  3382                              <1> A6_wEnFor83_ACOUSTIC	EQU	(1<<9)	; Automatic Acoustic Management feature set enabled
  3383                              <1> A6_wEnFor83_SET_MAX		EQU	(1<<8)	; SET MAX security extension enabled by SET MAX SET PASSWORD
  3384                              <1> A6_wEnFor83_FEATURES	EQU	(1<<6)	; SET FEATURES subcommand required to spinup after power-up
  3385                              <1> A6_wEnFor83_POWERUP		EQU	(1<<5)	; Power-Up In Standby feature set enabled
  3386                              <1> A6_wEnFor83_RMSN		EQU	(1<<4)	; Removable Media Status Notification feature set enabled
  3387                              <1> A6_wEnFor83_APM			EQU	(1<<3)	; Advanced Power Management feature set enabled
  3388                              <1> A6_wEnFor83_CFA			EQU	(1<<2)	; CFA feature set enabled
  3389                              <1> A6_wEnFor83_DMAQUEUED	EQU	(1<<1)	; READ/WRITE DMA QUEUED supported
  3390                              <1> A6_wEnFor83_MICROCODE	EQU	(1<<0)	; DOWNLOAD MICROCODE command supported
  3391                              <1> 
  3392                              <1> ; ATA-6 Word 87, Command set/feature default
  3393                              <1> A6_wEnFor84_GENLOG		EQU	(1<<5)	; General Purpose Logging feature set supported
  3394                              <1> A6_wEnFor84_MEDIAPASS	EQU	(1<<3)	; Media Card Pass Through Command feature set enabled
  3395                              <1> A6_wEnFor84_MEDIASER	EQU	(1<<2)	; Media serial number is valid
  3396                              <1> A6_wEnFor84_SMARTTEST	EQU	(1<<1)	; SMART self-test supported
  3397                              <1> A6_wEnFor84_SMARTLOG	EQU	(1<<0)	; SMART error logging supported
  3398                              <1> 
  3399                              <1> ; ATA-6 Word 88, Ultra DMA Mode
  3400                              <1> A6_wUDMA_MODE5_SELECTED	EQU	(1<<13)	; Ultra DMA mode 5 is selected
  3401                              <1> A6_wUDMA_MODE4_SELECTED	EQU	(1<<12)	; Ultra DMA mode 4 is selected
  3402                              <1> A6_wUDMA_MODE3_SELECTED	EQU	(1<<11)	; Ultra DMA mode 3 is selected
  3403                              <1> A6_wUDMA_MODE2_SELECTED	EQU	(1<<10)	; Ultra DMA mode 2 is selected
  3404                              <1> A6_wUDMA_MODE1_SELECTED	EQU	(1<<9)	; Ultra DMA mode 1 is selected
  3405                              <1> A6_wUDMA_MODE0_SELECTED	EQU	(1<<8)	; Ultra DMA mode 0 is selected
  3406                              <1> A6_wUDMA_MODE5_SUPRTD	EQU	(1<<5)	; Ultra DMA mode 5 and below are supported
  3407                              <1> A6_wUDMA_MODE4_SUPRTD	EQU	(1<<4)	; Ultra DMA mode 4 and below are supported
  3408                              <1> A6_wUDMA_MODE3_SUPRTD	EQU	(1<<3)	; Ultra DMA mode 3 and below are supported
  3409                              <1> A6_wUDMA_MODE2_SUPRTD	EQU	(1<<2)	; Ultra DMA mode 2 and below are supported
  3410                              <1> A6_wUDMA_MODE1_SUPRTD	EQU	(1<<1)	; Ultra DMA mode 1 and below are supported
  3411                              <1> A6_wUDMA_MODE0_SUPRTD	EQU	(1<<0)	; Ultra DMA mode 0 is supported
  3412                              <1> 
  3413                              <1> ; ATA-6 Word 93, Hardware reset result
  3414                              <1> A6_wReset_CBLID_BELOW	EQU	(1<<13)	; Device detected CBLID- above ViH
  3415                              <1> A6_wReset_DEV1_PDIAG	EQU	(1<<11)	; Device 1 asserted PDIAG-
  3416                              <1> A6_wReset_DEV0_RESP_D1	EQU	(1<<6)	; Device 0 responds when Device 1 is selected
  3417                              <1> A6_wReset_DEV0_DASP		EQU	(1<<5)	; Device 0 detected the assertion of DASP-
  3418                              <1> A6_wReset_DEV0_PDIAG	EQU	(1<<4)	; Device 0 detected the assertion of PDIAG
  3419                              <1> A6_wReset_DEV0_PASSED	EQU	(1<<3)	; Device 0 passed diagnostics
  3420                              <1> A6_wReset_MASK_DEV1_DETERMINE	EQU ((1<<10)|(1<<9))	; These bits indicate how Device 1 determined the device number
  3421                              <1> A6_wReset_MASK_DEV0_DETERMINE	EQU ((1<<2)|(1<<1))		; These bits indicate how Device 0 determined the device number:
  3422                              <1> A6_wReset_RESERVED		EQU	00b
  3423                              <1> A6_wReset_JUMPER		EQU	01b		; a jumper was used
  3424                              <1> A6_wReset_CSEL			EQU	10b		; the CSEL signal was used
  3425                              <1> A6_wReset_UNKNOWN		EQU	11b		; some other method was used or the method is unknown
  3426                              <1> 
  3427                              <1> ; ATA-6 Word 127, Removable Media Status Notification feature set support
  3428                              <1> A6_wRMSN_SUPPORTED		EQU	(1<<0)	; Removable Media Status Notification feature supported
  3429                              <1> 
  3430                              <1> ; ATA-6 Word 128, Security status
  3431                              <1> A6_wSecurity_MAX		EQU	(1<<8)	; Security level 0 = High, 1 = Maximum
  3432                              <1> A6_wSecurity_ENH_ERASE	EQU	(1<<5)	; Enhanced security erase supported
  3433                              <1> A6_wSecurity_EXPIRED	EQU	(1<<4)	; Security count expired
  3434                              <1> A6_wSecurity_FROZEN		EQU	(1<<3)	; Security frozen
  3435                              <1> A6_wSecurity_LOCKED		EQU	(1<<2)	; Security locked
  3436                              <1> A6_wSecurity_ENABLED	EQU	(1<<1)	; Security enabled
  3437                              <1> A6_wSecurity_SUPPORTED	EQU	(1<<0)	; Security supported
  3438                              <1> 
  3439                              <1> ; ATA-6 Word 160, CFA Power Mode 1
  3440                              <1> A6_wCFAPower_WORDSUPP	EQU	(1<<15)	; Word 160 supported
  3441                              <1> A6_wCFAPower_REQUIRED	EQU	(1<<13)	; CFA power mode 1 is required for one or more commands implemented by the device
  3442                              <1> A6_wCFAPower_DISABLED	EQU	(1<<12)	; CFA power mode 1 disabled
  3443                              <1> A6_wCFAPower_MASK_mA	EQU	0FFFh	; Maximum current in mA
  3444                              <1> 
  3445                              <1> ; ATA-6 WORD 255, Integrity Word (Signature and Checksum)
  3446                              <1> A6_wIntegrity_SIGNATURE	EQU	0A5h
  3447                              <1> 
  3448                              <1> 
  3449                              <1> %endif ; ATA_ID_INC
  3450                                  	%include "IdeRegisters.inc"		; For ATA Registers, flags and commands
  3451                              <1> ; Project name	:	XTIDE Universal BIOS
  3452                              <1> ; Description	:	Equates for IDE registers, flags and commands.
  3453                              <1> 
  3454                              <1> ;
  3455                              <1> ; XTIDE Universal BIOS and Associated Tools
  3456                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3457                              <1> ;
  3458                              <1> ; This program is free software; you can redistribute it and/or modify
  3459                              <1> ; it under the terms of the GNU General Public License as published by
  3460                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3461                              <1> ; (at your option) any later version.
  3462                              <1> ;
  3463                              <1> ; This program is distributed in the hope that it will be useful,
  3464                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3465                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3466                              <1> ; GNU General Public License for more details.
  3467                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3468                              <1> ;
  3469                              <1> 
  3470                              <1> %ifndef IDEREGISTERS_INC
  3471                              <1> %define IDEREGISTERS_INC
  3472                              <1> 
  3473                              <1> ; IDE Register offsets from Command Block base port
  3474                              <1> DATA_REGISTER					EQU		0
  3475                              <1> ERROR_REGISTER_in				EQU		1		; Read only
  3476                              <1> FEATURES_REGISTER_out			EQU		1		; Write only, ATA1+
  3477                              <1> ;WRITE_PRECOMPENSATION_out		EQU		1		; Write only, Obsolete on ATA1+
  3478                              <1> SECTOR_COUNT_REGISTER			EQU		2
  3479                              <1> SECTOR_NUMBER_REGISTER			EQU		3		; LBA Low Register
  3480                              <1> LOW_CYLINDER_REGISTER			EQU		4		; LBA Middle Register
  3481                              <1> HIGH_CYLINDER_REGISTER			EQU		5		; LBA High Register
  3482                              <1> LBA_LOW_REGISTER				EQU		3		; LBA 7...0, LBA48 31...24
  3483                              <1> LBA_MIDDLE_REGISTER				EQU		4		; LBA 15...8, LBA48 39...32
  3484                              <1> LBA_HIGH_REGISTER				EQU		5		; LBA 23...16, LBA48 47...40
  3485                              <1> DRIVE_AND_HEAD_SELECT_REGISTER	EQU		6		; LBA28 27...24
  3486                              <1> STATUS_REGISTER_in				EQU		7		; Read only
  3487                              <1> COMMAND_REGISTER_out			EQU		7		; Write only
  3488                              <1> ;XTIDE_DATA_HIGH_REGISTER		EQU		8		; Non-standard (actually first Control Block reg)
  3489                              <1> 
  3490                              <1> ; IDE Register offsets from Control Block base port
  3491                              <1> ; (usually Command Block base port + 200h)
  3492                              <1> ALTERNATE_STATUS_REGISTER_in	EQU		6		; Read only
  3493                              <1> DEVICE_CONTROL_REGISTER_out		EQU		6		; Write only
  3494                              <1> ;DRIVE_ADDRESS_REGISTER			EQU		7		; Obsolete on ATA2+
  3495                              <1> 
  3496                              <1> ; Bit mask for XTIDE mod with reversed A0 and A3 address lines
  3497                              <1> MASK_A3_AND_A0_ADDRESS_LINES	EQU		((1<<3) | (1<<0))
  3498                              <1> 
  3499                              <1> ; Bit definitions for IDE Error Register
  3500                              <1> FLG_ERROR_BBK			EQU		(1<<7)	; Bad Block Detected (reserved on ATA2+, command dependent on ATA4+)
  3501                              <1> FLG_ERROR_UNC			EQU		(1<<6)	; Uncorrectable Data Error (command dependent on ATA4+)
  3502                              <1> FLG_ERROR_MC			EQU		(1<<5)	; Media Changed (command dependent on ATA4+)
  3503                              <1> FLG_ERROR_IDNF			EQU		(1<<4)	; ID Not Found (command dependent on ATA4+)
  3504                              <1> FLG_ERROR_MCR			EQU		(1<<3)	; Media Change Request (command dependent on ATA4+)
  3505                              <1> FLG_ERROR_ABRT			EQU		(1<<2)	; Command Aborted
  3506                              <1> FLG_ERROR_TK0NF			EQU		(1<<1)	; Track 0 Not Found (command dependent on ATA4+)
  3507                              <1> FLG_ERROR_AMNF			EQU		(1<<0)	; Address Mark Not Found (command dependent on ATA4+)
  3508                              <1> 
  3509                              <1> ; Bit definitions for IDE Drive and Head Select Register
  3510                              <1> FLG_DRVNHEAD_LBA		EQU		(1<<6)	; LBA Addressing enabled (instead of CHS)
  3511                              <1> FLG_DRVNHEAD_DRV		EQU		(1<<4)	; Drive Select (0=Master, 1=Slave)
  3512                              <1> MASK_DRVNHEAD_HEAD		EQU		0Fh		; Head select bits (bits 0...3)
  3513                              <1> MASK_DRVNHEAD_SET		EQU		0A0h	; Bits that must be set to 1 on ATA1 (reserved on ATA2+)
  3514                              <1> 
  3515                              <1> ; Bit definitions for IDE Status Register
  3516                              <1> FLG_STATUS_BSY			EQU		(1<<7)	; Busy (other flags undefined when set)
  3517                              <1> FLG_STATUS_DRDY			EQU		(1<<6)	; Device Ready
  3518                              <1> FLG_STATUS_DF			EQU		(1<<5)	; Device Fault (command dependent on ATA4+)
  3519                              <1> FLG_STATUS_DSC			EQU		(1<<4)	; Device Seek Complete (command dependent on ATA4+)
  3520                              <1> FLG_STATUS_DRQ			EQU		(1<<3)	; Data Request
  3521                              <1> FLG_STATUS_CORR			EQU		(1<<2)	; Corrected Data (obsolete on ATA4+)
  3522                              <1> FLG_STATUS_IDX			EQU		(1<<1)	; Index (vendor specific on ATA2+, obsolete on ATA4+)
  3523                              <1> FLG_STATUS_ERR			EQU		(1<<0)	; Error
  3524                              <1> 
  3525                              <1> ; Bit definitions for IDE Device Control Register
  3526                              <1> ; Bit 0 must be zero, unlisted bits are reserved.
  3527                              <1> ;FLG_DEVCONTROL_HOB		EQU		(1<<7)	; High Order Byte (ATA6+)
  3528                              <1> ;FLG_DEVCONTROL_O8H		EQU		(1<<3)	; Drive has more than 8 heads (pre-ATA only, 1 on ATA1, reserved on ATA2+)
  3529                              <1> FLG_DEVCONTROL_SRST		EQU		(1<<2)	; Software Reset
  3530                              <1> FLG_DEVCONTROL_nIEN		EQU		(1<<1)	; Negated Interrupt Enable (IRQ disabled when set)
  3531                              <1> 
  3532                              <1> ; Commands for IDE Controller
  3533                              <1> COMMAND_RECALIBRATE						EQU		10h
  3534                              <1> COMMAND_READ_SECTORS					EQU		20h
  3535                              <1> COMMAND_READ_SECTORS_EXT				EQU		24h		; LBA48
  3536                              <1> COMMAND_WRITE_SECTORS					EQU		30h
  3537                              <1> COMMAND_WRITE_SECTORS_EXT				EQU		34h		; LBA48
  3538                              <1> COMMAND_VERIFY_SECTORS					EQU		40h
  3539                              <1> COMMAND_VERIFY_SECTORS_EXT				EQU		42h		; LBA48
  3540                              <1> COMMAND_SEEK							EQU		70h
  3541                              <1> COMMAND_INITIALIZE_DEVICE_PARAMETERS	EQU		91h
  3542                              <1> COMMAND_SET_MULTIPLE_MODE				EQU		0C6h	; Block mode
  3543                              <1> COMMAND_READ_MULTIPLE					EQU		0C4h	; Block mode
  3544                              <1> COMMAND_READ_MULTIPLE_EXT				EQU		29h		; LBA48, Block mode
  3545                              <1> COMMAND_WRITE_MULTIPLE					EQU		0C5h	; Block mode
  3546                              <1> COMMAND_WRITE_MULTIPLE_EXT				EQU		39h		; LBA48, Block mode
  3547                              <1> COMMAND_IDENTIFY_DEVICE					EQU		0ECh
  3548                              <1> COMMAND_SET_FEATURES					EQU		0EFh
  3549                              <1> COMMAND_IDLE							EQU		0E3h
  3550                              <1> 
  3551                              <1> 
  3552                              <1> ; Subcommands for COMMAND_SET_FEATURES
  3553                              <1> FEATURE_ENABLE_8BIT_PIO_TRANSFER_MODE	EQU		01h		; CFA feature set only
  3554                              <1> FEATURE_ENABLE_WRITE_CACHE				EQU		02h
  3555                              <1> FEATURE_DISABLE_8BIT_PIO_TRANSFER_MODE	EQU		81h		; CFA feature set only
  3556                              <1> FEATURE_DISABLE_WRITE_CACHE				EQU		82h		; Can also be used to flush cache
  3557                              <1> FEATURE_SET_TRANSFER_MODE				EQU		03h		; Transfer mode goes to the Sector Count Register
  3558                              <1> 	PIO_DEFAULT_MODE					EQU		0h
  3559                              <1> 	PIO_DEFAULT_MODE_DISABLE_IORDY		EQU		1h
  3560                              <1> 	PIO_FLOW_CONTROL_MODE_xxx			EQU		(1<<3)	; Bits 2...0 hold the PIO mode
  3561                              <1> 
  3562                              <1> 
  3563                              <1> %endif ; IDEREGISTERS_INC
  3564                                  	%include "Int13h.inc"			; Equates for INT 13h functions
  3565                              <1> ; Project name	:	XTIDE Universal BIOS
  3566                              <1> ; Description	:	Equates used in INT 13h functions.
  3567                              <1> 
  3568                              <1> ;
  3569                              <1> ; XTIDE Universal BIOS and Associated Tools
  3570                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3571                              <1> ;
  3572                              <1> ; This program is free software; you can redistribute it and/or modify
  3573                              <1> ; it under the terms of the GNU General Public License as published by
  3574                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3575                              <1> ; (at your option) any later version.
  3576                              <1> ;
  3577                              <1> ; This program is distributed in the hope that it will be useful,
  3578                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3579                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3580                              <1> ; GNU General Public License for more details.
  3581                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3582                              <1> ;
  3583                              <1> 
  3584                              <1> %ifndef INT13H_INC
  3585                              <1> %define INT13H_INC
  3586                              <1> 
  3587                              <1> ; Hard Disk function (INT 13h) return status codes in AH
  3588                              <1> RET_HD_SUCCESS			EQU		0h		; Operation successful, no error occurred
  3589                              <1> RET_HD_INVALID			EQU		1h		; Invalid value passed or unsupported func
  3590                              <1> RET_HD_ADDRMARK			EQU		2h		; Missing address mark
  3591                              <1> RET_HD_WRITEPROT		EQU		3h		; Removable media is write protected
  3592                              <1> RET_HD_NOT_FOUND		EQU		4h		; Requested sector not found
  3593                              <1> RET_HD_RESETFAIL		EQU		5h		; Reset failed
  3594                              <1> RET_HD_CHANGED			EQU		6h		; Media changed
  3595                              <1> RET_HD_PARAMACT			EQU		7h		; Drive parameter activity failed
  3596                              <1> RET_HD_OVERRUN			EQU		8h		; DMA overrun
  3597                              <1> RET_HD_BOUNDARY			EQU		9h		; Data boundary error
  3598                              <1> RET_HD_BADSECTOR		EQU		0Ah		; Bad sector detected
  3599                              <1> RET_HD_BADTRACK			EQU		0Bh		; Bad track detected
  3600                              <1> RET_HD_UNCORRECC		EQU		10h		; Uncorrectable ECC error
  3601                              <1> RET_HD_ECC				EQU		11h		; Corrected ECC error
  3602                              <1> RET_HD_CONTROLLER		EQU		20h		; Hard disk controller or drive problem
  3603                              <1> RET_HD_NOMEDIA			EQU		31h		; No media in removable media drive
  3604                              <1> RET_HD_SEEK_FAIL		EQU		40h		; Seek operation failed
  3605                              <1> RET_HD_TIMEOUT			EQU		80h		; Drive failed to respond
  3606                              <1> RET_HD_NOTREADY			EQU		0AAh	; Drive is not ready or is not selected
  3607                              <1> RET_HD_NOTLOCKED		EQU		0B0h	; Volume not locked in drive
  3608                              <1> RET_HD_LOCKED			EQU		0B1h	; Volume locked in drive
  3609                              <1> RET_HD_NOTREMOVABLE		EQU		0B2h	; Volume not removable
  3610                              <1> RET_HD_INUSE			EQU		0B3h	; Volume in use
  3611                              <1> RET_HD_LOCKEXCEEDED		EQU		0B4h	; Lock count exceeded
  3612                              <1> RET_HD_EJECTFAIL		EQU		0B5h	; Valid eject request failed
  3613                              <1> RET_HD_UNDEFINED		EQU		0BBh	; Undefined error occurred
  3614                              <1> RET_HD_WRFAULT			EQU		0CCh	; Write fault on selected drive
  3615                              <1> RET_HD_STATUSERR		EQU		0E0h	; Status error without error
  3616                              <1> RET_HD_SENSEFAIL		EQU		0FFh	; Sense operation failed
  3617                              <1> 
  3618                              <1> 
  3619                              <1> ; Floppy Drive types returned by INT 13h, AH=08h
  3620                              <1> FLOPPY_TYPE_525_OR_35_DD	EQU	0
  3621                              <1> FLOPPY_TYPE_525_DD			EQU	1
  3622                              <1> FLOPPY_TYPE_525_HD			EQU	2
  3623                              <1> FLOPPY_TYPE_35_DD			EQU	3
  3624                              <1> FLOPPY_TYPE_35_HD			EQU	4
  3625                              <1> FLOPPY_TYPE_35_ED			EQU	6
  3626                              <1> 
  3627                              <1> 
  3628                              <1> %define TIMEOUT_AND_STATUS_TO_WAIT(timeout, status)		(((timeout)<<8) | (status))
  3629                              <1> 
  3630                              <1> 
  3631                              <1> %endif ; INT13H_INC
  3632                                  	%include "CustomDPT.inc"		; For Disk Parameter Table
  3633                              <1> ; Project name	:	XTIDE Universal BIOS
  3634                              <1> ; Description	:	Defines for DPT structs containing custom
  3635                              <1> ;					Disk Parameter Table used by this BIOS.
  3636                              <1> 
  3637                              <1> ;
  3638                              <1> ; XTIDE Universal BIOS and Associated Tools
  3639                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3640                              <1> ;
  3641                              <1> ; This program is free software; you can redistribute it and/or modify
  3642                              <1> ; it under the terms of the GNU General Public License as published by
  3643                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3644                              <1> ; (at your option) any later version.
  3645                              <1> ;
  3646                              <1> ; This program is distributed in the hope that it will be useful,
  3647                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3648                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3649                              <1> ; GNU General Public License for more details.
  3650                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3651                              <1> ;
  3652                              <1> 
  3653                              <1> %ifndef CUSTOMDPT_INC
  3654                              <1> %define CUSTOMDPT_INC
  3655                              <1> 
  3656                              <1> ; Base DPT for all device types
  3657                              <1> struc DPT
  3658                              <1> 	; General Disk Parameter Table related
  3659                              <1> 	.wFlags:
  3660 00000000 <res 00000001>      <1> 	.bFlagsLow				resb	1
  3661 00000001 <res 00000001>      <1> 	.bFlagsHigh				resb	1
  3662 00000002 <res 00000001>      <1> 	.bIdevarsOffset			resb	1	; Offset to IDEVARS for this drive
  3663 00000003 <res 00000001>      <1> 	.bInitError				resb	1	; Flags for AH=09h initialization errors
  3664 00000004 <res 00000002>      <1> 	.wBasePort				resb	2	; Segment for JR-IDE/ISA
  3665                              <1> 
  3666                              <1> 	; CHS variables
  3667 00000006 <res 00000002>      <1> 	.wLchsCylinders			resb	2	; (1...1027, yes 1027)
  3668                              <1> 	.wLchsHeadsAndSectors:
  3669 00000008 <res 00000001>      <1> 	.bLchsHeads				resb	1	; (1...255)
  3670 00000009 <res 00000001>      <1> 	.bLchsSectorsPerTrack	resb	1	; (1...63)
  3671 0000000A <res 00000001>      <1> 	.bPchsHeads				resb	1	; (1...16)
  3672                              <1> 
  3673                              <1> 	; LBA and remaining P-CHS variables
  3674                              <1> %ifdef MODULE_EBIOS
  3675 0000000B <res 00000001>      <1> 	.bPchsSectorsPerTrack	resb	1
  3676 0000000C <res 00000002>      <1> 	.wPchsCylinders			resb	2
  3677 0000000E <res 00000006>      <1> 	.twLbaSectors			resb	6	; 48-bit sector count for LBA addressing
  3678                              <1> %endif
  3679                              <1> 							alignb	2	; WORD alignment for DPT_SERIAL or DPT_ATA
  3680                              <1> endstruc
  3681                              <1> 
  3682                              <1> 	; Bit definitions for DPT.bFlagsLow
  3683                              <1> 	MASKL_DPT_CHS_SHIFT_COUNT			EQU	(3<<0)				; Bits 0...1, P-CHS to L-CHS bit shift count (0...3)
  3684                              <1> 	MASKL_DPT_TRANSLATEMODE				EQU	MASK_DRVPARAMS_TRANSLATEMODE	; Bits 2...3, NORMAL, LARGE or Assisted LBA addressing mode
  3685                              <1> 	FLGL_DPT_ASSISTED_LBA				EQU	(1<<(TRANSLATEMODE_FIELD_POSITION+1))
  3686                              <1> 	FLGL_DPT_SLAVE						EQU	FLG_DRVNHEAD_DRV	; Bit 4, Drive is a Slave Drive
  3687                              <1> %ifdef MODULE_IRQ
  3688                              <1> 	FLGL_DPT_ENABLE_IRQ					EQU	(1<<5)				; Bit 5, Enable IRQ
  3689                              <1> %endif
  3690                              <1> %ifdef MODULE_EBIOS
  3691                              <1> 	FLGL_DPT_LBA_AND_EBIOS_SUPPORTED	EQU	FLG_DRVNHEAD_LBA	; Bit 6, Drive supports LBA and so EBIOS functions can be supported
  3692                              <1> 	FLGL_DPT_LBA48						EQU	(1<<7)				; Bit 7, Drive supports 48-bit LBA (Must be bit 7!)
  3693                              <1> %endif
  3694                              <1> 
  3695                              <1> 
  3696                              <1> 	; Bit definitions for DPT.bFlagsHigh
  3697                              <1> 	FLGH_DPT_BLOCK_MODE_SUPPORTED		EQU	(1<<1)	; Bit 1, Use block transfer commands (must be bit 1!)
  3698                              <1> %ifdef MODULE_SERIAL
  3699                              <1> 	FLGH_DPT_SERIAL_DEVICE				EQU	(1<<2)	; Bit 2, Serial Port Device
  3700                              <1> %endif
  3701                              <1> %ifdef MODULE_IRQ
  3702                              <1> 	FLGH_DPT_INTERRUPT_IN_SERVICE		EQU	(1<<3)	; Bit 3, Set when waiting for IRQ
  3703                              <1> %endif
  3704                              <1> %ifdef MODULE_FEATURE_SETS
  3705                              <1> 	FLGH_DPT_POWER_MANAGEMENT_SUPPORTED	EQU (1<<5)	; Bit 5, Drive supports power management
  3706                              <1> %endif
  3707                              <1> %ifdef MODULE_ADVANCED_ATA
  3708                              <1> 	FLGH_DPT_IORDY						EQU	(1<<7)	; Bit 7, Controller and Drive supports IORDY
  3709                              <1> %endif
  3710                              <1> 
  3711                              <1> 	; Serial device only
  3712                              <1> %ifdef MODULE_SERIAL_FLOPPY
  3713                              <1> 	FLGH_DPT_SERIAL_FLOPPY						EQU	(1<<4)
  3714                              <1> 	FLGH_DPT_SERIAL_FLOPPY_TYPE_MASK			EQU	0e0h
  3715                              <1> 	FLGH_DPT_SERIAL_FLOPPY_TYPE_FIELD_POSITION	EQU	5
  3716                              <1> %endif
  3717                              <1> 
  3718                              <1> 
  3719                              <1> 	; Flags for DPT_ADVANCED_ATA.bInitError
  3720                              <1> 	FLG_INITERROR_FAILED_TO_SELECT_DRIVE				EQU (1<<0)
  3721                              <1> 	FLG_INITERROR_FAILED_TO_INITIALIZE_CHS_PARAMETERS	EQU (1<<1)
  3722                              <1> 	FLG_INITERROR_FAILED_TO_SET_WRITE_CACHE				EQU (1<<2)
  3723                              <1> 	FLG_INITERROR_FAILED_TO_RECALIBRATE_DRIVE			EQU (1<<3)
  3724                              <1> 	FLG_INITERROR_FAILED_TO_SET_BLOCK_MODE				EQU (1<<4)
  3725                              <1> 	FLG_INITERROR_FAILED_TO_SET_PIO_MODE				EQU (1<<5)
  3726                              <1> 	FLG_INITERROR_FAILED_TO_INITIALIZE_STANDBY_TIMER	EQU	(1<<6)
  3727                              <1> 	FLG_INITERROR_FAILED_TO_SET_XTCF_MODE				EQU	(1<<7)
  3728                              <1> 	FLG_INITERROR_FAILED_TO_SET_8BIT_MODE				EQU	FLG_INITERROR_FAILED_TO_SET_XTCF_MODE
  3729                              <1> 
  3730                              <1> 
  3731                              <1> 
  3732                              <1> ; DPT for ATA devices
  3733                              <1> struc DPT_ATA
  3734 00000000 <res 00000014>      <1> 	.dpt					resb	DPT_size
  3735 00000014 <res 00000001>      <1> 	.bDevice				resb	1	; Device Type from IDEVARS (overrided when 32-bit controller detected)
  3736 00000015 <res 00000001>      <1> 	.bBlockSize				resb	1	; Current block size in sectors (do not set to zero!)
  3737                              <1> endstruc
  3738                              <1> 
  3739                              <1> 
  3740                              <1> 
  3741                              <1> ; Additional variables needed to initialize and reset Advanced IDE Controllers.
  3742                              <1> ; EBDA must be reserved for DPTs when using these!
  3743                              <1> %ifdef MODULE_ADVANCED_ATA
  3744                              <1> struc DPT_ADVANCED_ATA
  3745                              <1> 	.dpt_ata				resb	DPT_ATA_size
  3746                              <1> 	.wControllerID			resb	2	; Controller specific ID WORD (from Advanced Controller detection)
  3747                              <1> 	.wControllerBasePort	resb	2	; Advanced Controller port (not IDE port)
  3748                              <1> 	.wMinPioCycleTime		resb	2	; Minimum PIO Cycle Time in ns
  3749                              <1> 	.bPioMode				resb	1	; Best supported PIO mode
  3750                              <1> 							alignb	2
  3751                              <1> endstruc
  3752                              <1> %endif
  3753                              <1> 
  3754                              <1> 
  3755                              <1> ; DPT for Serial devices
  3756                              <1> %ifdef MODULE_SERIAL
  3757                              <1> struc DPT_SERIAL
  3758 00000000 <res 00000014>      <1> 	.dpt					resb	DPT_size
  3759                              <1> 	.wSerialPortAndBaud:
  3760 00000014 <res 00000001>      <1> 	.bSerialPort			resb	1	; Serial connection I/O port address, divided by 4
  3761 00000015 <res 00000001>      <1> 	.bSerialBaud			resb 	1	; Serial connection baud rate divisor
  3762                              <1> endstruc
  3763                              <1> 
  3764                              <1> ; On performance critical situations we compare DPT_ATA.bDevice without checking FLGH_DPT_SERIAL_DEVICE
  3765                              <1> ; first! DPT_ATA.bDevice uses small values so there will be no problems.
  3766                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  3767                              <1> 	%if DPT_SERIAL.bSerialPort <> DPT_ATA.bDevice
  3768                              <1> 		%error "DPT_ATA.bDevice and DPT_SERIAL.bSerialPort must be in same offsets!"
  3769                              <1> 	%endif
  3770                              <1> %endif
  3771                              <1> %endif ; MODULE_SERIAL
  3772                              <1> 
  3773                              <1> 
  3774                              <1> ; This is the common size for all DPTs. All DPTs must be equal size.
  3775                              <1> %ifdef MODULE_ADVANCED_ATA
  3776                              <1> 	LARGEST_DPT_SIZE			EQU		DPT_ADVANCED_ATA_size
  3777                              <1> %else
  3778                              <1> 	LARGEST_DPT_SIZE			EQU		DPT_ATA_size
  3779                              <1> %endif
  3780                              <1> 
  3781                              <1> 
  3782                              <1> 	; Number of Sectors per Track is fixed to 63 for LBA assist calculation.
  3783                              <1> 	; 1024 cylinders, 256 heads, 63 sectors = 8.4 GB limit (but DOS does not support more than 255 heads)
  3784                              <1> 	MAX_LCHS_CYLINDERS			EQU		1024
  3785                              <1> 	LBA_ASSIST_SPT				EQU		63
  3786                              <1> 
  3787                              <1> 
  3788                              <1> %endif ; CUSTOMDPT_INC
  3789                                  	%include "RomVars.inc"			; For ROMVARS and IDEVARS structs
  3790                              <1> ; Project name	:	XTIDE Universal BIOS
  3791                              <1> ; Description	:	Defines for ROMVARS struct containing variables stored
  3792                              <1> ;			in BIOS ROM.
  3793                              <1> 
  3794                              <1> ;
  3795                              <1> ; XTIDE Universal BIOS and Associated Tools
  3796                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  3797                              <1> ;
  3798                              <1> ; This program is free software; you can redistribute it and/or modify
  3799                              <1> ; it under the terms of the GNU General Public License as published by
  3800                              <1> ; the Free Software Foundation; either version 2 of the License, or
  3801                              <1> ; (at your option) any later version.
  3802                              <1> ;
  3803                              <1> ; This program is distributed in the hope that it will be useful,
  3804                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  3805                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  3806                              <1> ; GNU General Public License for more details.
  3807                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  3808                              <1> ;
  3809                              <1> 
  3810                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
  3811                              <1> 
  3812                              <1> 
  3813                              <1> %ifndef ROMVARS_INC
  3814                              <1> %define ROMVARS_INC
  3815                              <1> 
  3816                              <1> ; ROM Variables. Written to the ROM image before flashing.
  3817                              <1> struc ROMVARS
  3818 00000000 <res 00000002>      <1> 	.wRomSign			resb	2	; ROM Signature (AA55h)
  3819 00000002 <res 00000001>      <1> 	.bRomSize			resb	1	; ROM size in 512 byte blocks
  3820 00000003 <res 00000003>      <1> 	.rgbJump			resb	3	; First instruction to ROM init (jmp)
  3821                              <1> 
  3822 00000006 <res 00000008>      <1> 	.rgbSign			resb	8	; Signature for XTIDE Configurator Program
  3823 0000000E <res 0000001F>      <1> 	.szTitle			resb	31	; BIOS title string
  3824 0000002D <res 00000019>      <1> 	.szVersion			resb	25	; BIOS version string
  3825                              <1> 
  3826 00000046 <res 00000002>      <1> 	.wFlags				resb	2	; Word for ROM flags
  3827 00000048 <res 00000002>      <1> 	.wDisplayMode			resb	2	; Display mode for boot menu
  3828 0000004A <res 00000002>      <1> 	.wBootTimeout			resb	2	; Boot Menu selection timeout in system timer ticks
  3829 0000004C <res 00000001>      <1> 	.bIdeCnt			resb	1	; Number of available IDE controllers
  3830 0000004D <res 00000001>      <1> 	.bBootDrv			resb	1	; Default drive to boot from
  3831 0000004E <res 00000001>      <1> 	.bMinFddCnt			resb	1	; Minimum number of Floppy Drives
  3832 0000004F <res 00000001>      <1> 	.bStealSize			resb	1	; Number of 1kB blocks stolen from 640kB base RAM
  3833 00000050 <res 00000001>      <1> 	.bIdleTimeout			resb	1	; Standby timer value
  3834                              <1> 
  3835                              <1> 	.ideVarsBegin:
  3836 00000051 <res 00000012>      <1> 	.ideVars0			resb	IDEVARS_size
  3837 00000063 <res 00000012>      <1> 	.ideVars1			resb	IDEVARS_size
  3838 00000075 <res 00000012>      <1> 	.ideVars2			resb	IDEVARS_size
  3839 00000087 <res 00000012>      <1> 	.ideVars3			resb	IDEVARS_size
  3840                              <1> 
  3841                              <1> %ifdef MODULE_SERIAL
  3842 00000099 <res 00000012>      <1> 	.ideVarsSerialAuto		resb	IDEVARS_size
  3843                              <1> %endif
  3844                              <1> 
  3845                              <1> 	.ideVarsEnd:
  3846                              <1> endstruc
  3847                              <1> 
  3848                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  3849                              <1> 	%if ROMVARS.ideVarsEnd & 0xff00 <> 0
  3850                              <1> 		%error ".ideVars structures must fit within the first 256 bytes of the ROM image"
  3851                              <1> 	%endif
  3852                              <1> 	%if (ROMVARS.ideVarsEnd - ROMVARS.ideVarsBegin) = 0
  3853                              <1> 		%error "there must be at least one .ideVars structure, it would be bizarre if this were not true, but it is assumed in the ah0h reset code."
  3854                              <1> 	%endif
  3855                              <1> %endif
  3856                              <1> 
  3857                              <1> NUMBER_OF_IDEVARS					EQU	((ROMVARS.ideVarsEnd - ROMVARS.ideVarsBegin) / IDEVARS_size)
  3858                              <1> 
  3859                              <1> ; Bit defines for ROMVARS.wFlags
  3860                              <1> FLG_ROMVARS_FULLMODE					EQU	(1<<0)	; Full operating mode (steals base RAM, supports EBIOS etc.)
  3861                              <1> FLG_ROMVARS_SERIAL_SCANDETECT 				EQU	(1<<3)	; Scan COM ports at the end of drive detection.  Can also be invoked
  3862                              <1> 									; by holding down the ALT key at the end of drive detection.
  3863                              <1> 									; (Conveniently, this is 8, a fact we exploit when testing the bit)
  3864                              <1> 
  3865                              <1> ; Here in case the configuration needs to know functionality is present
  3866                              <1> FLG_ROMVARS_MODULE_FEATURE_SETS				EQU	(1<<5)
  3867                              <1> FLG_ROMVARS_MODULE_8BIT_IDE				EQU	(1<<6)
  3868                              <1> FLG_ROMVARS_MODULE_8BIT_IDE_ADVANCED			EQU	(1<<7)
  3869                              <1> FLG_ROMVARS_MODULE_ADVANCED_ATA				EQU	(1<<8)
  3870                              <1> FLG_ROMVARS_MODULE_BOOT_MENU				EQU	(1<<9)
  3871                              <1> FLG_ROMVARS_MODULE_EBIOS				EQU	(1<<10)
  3872                              <1> FLG_ROMVARS_MODULE_HOTKEYS				EQU	(1<<11)
  3873                              <1> FLG_ROMVARS_MODULE_IRQ					EQU	(1<<12)
  3874                              <1> FLG_ROMVARS_MODULE_SERIAL				EQU	(1<<13)
  3875                              <1> FLG_ROMVARS_MODULE_SERIAL_FLOPPY			EQU	(1<<14)
  3876                              <1> FLG_ROMVARS_MODULE_STRINGS_COMPRESSED			EQU	(1<<15)
  3877                              <1> 
  3878                              <1> 
  3879                              <1> ; Boot Menu Display Modes (see Assembly Library Display.inc for standard modes)
  3880                              <1> DEFAULT_TEXT_MODE					EQU	4
  3881                              <1> 
  3882                              <1> 
  3883                              <1> ; Controller specific variables
  3884                              <1> struc IDEVARS
  3885                              <1> ;;; Word 0
  3886                              <1> 	.wSerialPortAndBaud:						; Serial connection port (low, divided by 4) and baud rate divisor (high)
  3887                              <1> 	.wBasePort:							; IDE Base Port for Command Block (usual) Registers
  3888 00000000 <res 00000001>      <1> 	.bSerialPort					resb	1
  3889 00000001 <res 00000001>      <1> 	.bSerialBaud					resb	1
  3890                              <1> 
  3891                              <1> ;;; Word 1
  3892                              <1> 	.wControlBlockPort:
  3893                              <1> 	.bXTCFcontrolRegister:						; XT-CFv3 port used to initiate a DMA transfer
  3894 00000002 <res 00000001>      <1> 	.bSerialUnused					resb	1	; IDE Base Port for Control Block Registers
  3895                              <1> 
  3896                              <1> 	.wSerialCOMPortCharAndDevice:					; In DetectPrint, we grab the COM Port char and Device at the same time
  3897 00000003 <res 00000001>      <1> 	.bSerialCOMPortChar				resb	1	; Serial connection COM port number/letter
  3898                              <1> 
  3899                              <1> ;;; Word 2
  3900 00000004 <res 00000001>      <1> 	.bDevice					resb	1	; Device type
  3901 00000005 <res 00000001>      <1> 	.bIRQ						resb	1	; Interrupt Request Number
  3902                              <1> 
  3903                              <1> ;;; And more...
  3904 00000006 <res 00000006>      <1> 	.drvParamsMaster				resb	DRVPARAMS_size
  3905 0000000C <res 00000006>      <1> 	.drvParamsSlave					resb	DRVPARAMS_size
  3906                              <1> endstruc
  3907                              <1> 
  3908                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  3909                              <1> 	%if IDEVARS.bSerialCOMPortChar+1 != IDEVARS.bDevice
  3910                              <1> 		%error "IDEVARS.bSerialCOMPortChar needs to come immediately before IDEVARS.bDevice so that both bytes can be fetched at the same time inside DetectPrint.asm"
  3911                              <1> 	%endif
  3912                              <1> %endif
  3913                              <1> 
  3914                              <1> STANDARD_CONTROL_BLOCK_OFFSET				EQU		200h
  3915                              <1> XTIDE_CONTROL_BLOCK_OFFSET				EQU		8h	; for XTIDE, A3 is used to control selected register (CS0 vs CS1)
  3916                              <1> XTCF_CONTROL_BLOCK_OFFSET				EQU		10h	; and for XT-CF (all varients), it's A4
  3917                              <1> 
  3918                              <1> ; Default values for Port and PortCtrl, shared with the configurator
  3919                              <1> ;
  3920                              <1> DEVICE_XTIDE_DEFAULT_PORT				EQU		300h	; Also the default port for XT-CF
  3921                              <1> DEVICE_XTIDE_DEFAULT_PORTCTRL				EQU		(DEVICE_XTIDE_DEFAULT_PORT + XTIDE_CONTROL_BLOCK_OFFSET)
  3922                              <1> DEVICE_XTCF_DEFAULT_PORTCTRL				EQU		(DEVICE_XTIDE_DEFAULT_PORT + XTCF_CONTROL_BLOCK_OFFSET)
  3923                              <1> 
  3924                              <1> DEVICE_ATA_PRIMARY_PORT					EQU		1F0h
  3925                              <1> DEVICE_ATA_PRIMARY_PORTCTRL				EQU		(DEVICE_ATA_PRIMARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
  3926                              <1> 
  3927                              <1> DEVICE_ATA_SECONDARY_PORT				EQU		170h
  3928                              <1> DEVICE_ATA_SECONDARY_PORTCTRL				EQU		(DEVICE_ATA_SECONDARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
  3929                              <1> 
  3930                              <1> DEVICE_ATA_TERTIARY_PORT				EQU		1E8h
  3931                              <1> DEVICE_ATA_TERTIARY_PORTCTRL				EQU		(DEVICE_ATA_TERTIARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
  3932                              <1> 
  3933                              <1> DEVICE_ATA_QUATERNARY_PORT				EQU		168h
  3934                              <1> DEVICE_ATA_QUATERNARY_PORTCTRL				EQU		(DEVICE_ATA_QUATERNARY_PORT + STANDARD_CONTROL_BLOCK_OFFSET)
  3935                              <1> 
  3936                              <1> 
  3937                              <1> ; Device types for IDEVARS.bDevice
  3938                              <1> ; IDE Devices are grouped so device numbers cannot be changed without modifying code elsewhere!
  3939                              <1> ;
  3940                              <1> COUNT_OF_STANDARD_IDE_DEVICES				EQU	2	; 16- and 32-bit controllers
  3941                              <1> COUNT_OF_8BIT_IDE_DEVICES				EQU	7
  3942                              <1> COUNT_OF_ALL_IDE_DEVICES				EQU	(COUNT_OF_8BIT_IDE_DEVICES + COUNT_OF_STANDARD_IDE_DEVICES)
  3943                              <1> ; Standard port mapped I/O
  3944                              <1> DEVICE_16BIT_ATA					EQU	(0<<1)
  3945                              <1> DEVICE_32BIT_ATA					EQU	(1<<1)
  3946                              <1> DEVICE_8BIT_ATA						EQU	((COUNT_OF_STANDARD_IDE_DEVICES+0)<<1)	; 16- or 32-bit controller in 8-bit mode
  3947                              <1> DEVICE_8BIT_XTIDE_REV1					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+1)<<1)
  3948                              <1> ; Address lines A0 and A3 are swapped
  3949                              <1> DEVICE_8BIT_XTIDE_REV2					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+2)<<1)	; Or rev 1 with swapped A0 and A3
  3950                              <1> ; IDE Register offsets are SHL 1
  3951                              <1> ; Note: ordering swapped to support XT-CFv3 and all other XT-CF derivatives
  3952                              <1> DEVICE_8BIT_XTCF_PIO8					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+3)<<1)	; XT-CF using 8-bit PIO mode
  3953                              <1> DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD			EQU	((COUNT_OF_STANDARD_IDE_DEVICES+4)<<1)	; XT-CF using 8-bit PIO mode, but with 16-bit instructions
  3954                              <1> DEVICE_8BIT_XTCF_DMA					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+5)<<1)	; XT-CFv3 using DMA
  3955                              <1> ; Memory Mapped I/O
  3956                              <1> DEVICE_8BIT_JRIDE_ISA					EQU	((COUNT_OF_STANDARD_IDE_DEVICES+6)<<1)	; JR-IDE/ISA (Memory Mapped I/O)
  3957                              <1> ; Virtual devices
  3958                              <1> DEVICE_SERIAL_PORT					EQU	(COUNT_OF_ALL_IDE_DEVICES<<1)
  3959                              <1> 
  3960                              <1> 
  3961                              <1> 
  3962                              <1> ; Master/Slave drive specific parameters
  3963                              <1> struc DRVPARAMS
  3964 00000000 <res 00000002>      <1> 	.wFlags						resb	2	; Drive flags
  3965                              <1> 	.dwMaximumLBA:							; User specified maximum number of sectors
  3966 00000002 <res 00000002>      <1> 	.wCylinders					resb	2	; User specified cylinders (1...16383)
  3967                              <1> 	.wHeadsAndSectors:
  3968 00000004 <res 00000001>      <1> 	.bHeads						resb	1	; User specified Heads (1...16)
  3969 00000005 <res 00000001>      <1> 	.bSect						resb	1	; User specified Sectors per track (1...63)
  3970                              <1> endstruc
  3971                              <1> 
  3972                              <1> ; Bit defines for DRVPARAMS.wFlags
  3973                              <1> 	MASK_DRVPARAMS_WRITECACHE			EQU	(3<<0)	; Bits 0...1, Drive internal write cache settings (must start at bit 0)
  3974                              <1> 	DEFAULT_WRITE_CACHE				EQU	0	; Must be 0
  3975                              <1> 	DISABLE_WRITE_CACHE				EQU	1
  3976                              <1> 	ENABLE_WRITE_CACHE				EQU	2
  3977                              <1> 	MASK_DRVPARAMS_TRANSLATEMODE			EQU	(3<<TRANSLATEMODE_FIELD_POSITION)	; Bits 2...3, Position shared with DPT
  3978                              <1> 	TRANSLATEMODE_FIELD_POSITION			EQU	2
  3979                              <1> 	TRANSLATEMODE_NORMAL				EQU	0
  3980                              <1> 	TRANSLATEMODE_LARGE				EQU	1
  3981                              <1> 	TRANSLATEMODE_ASSISTED_LBA			EQU	2	; 28-bit or 48-bit LBA
  3982                              <1> 	TRANSLATEMODE_AUTO				EQU	3	; Only available in ROMVARS, not in DPTs
  3983                              <1> 	FLG_DRVPARAMS_BLOCKMODE				EQU	(1<<4)	; Enable Block mode transfers
  3984                              <1> 	FLG_DRVPARAMS_USERCHS				EQU	(1<<5)	; User specified P-CHS values
  3985                              <1> 	MAX_USER_CYLINDERS				EQU	16383
  3986                              <1> 	MAX_USER_HEADS					EQU	16
  3987                              <1> 	MAX_USER_SECTORS_PER_TRACK			EQU	63
  3988                              <1> 	FLG_DRVPARAMS_USERLBA				EQU	(1<<6)	; User specified LBA value
  3989                              <1> 	MIN_USER_LBA_COUNT				EQU	((MAX_USER_CYLINDERS*MAX_USER_HEADS*MAX_USER_SECTORS_PER_TRACK)+1)
  3990                              <1> 	MAX_USER_LBA_COUNT				EQU	((2^28)-1)
  3991                              <1> 
  3992                              <1> 
  3993                              <1> %endif ; ROMVARS_INC
  3994                                  	%include "RamVars.inc"			; For RAMVARS struct
  3995                              <1> ; Project name	:	XTIDE Universal BIOS
  3996                              <1> ; Description	:	RAMVARS struct containing BIOS variables stored in RAM.
  3997                              <1> 
  3998                              <1> ;
  3999                              <1> ; XTIDE Universal BIOS and Associated Tools
  4000                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  4001                              <1> ;
  4002                              <1> ; This program is free software; you can redistribute it and/or modify
  4003                              <1> ; it under the terms of the GNU General Public License as published by
  4004                              <1> ; the Free Software Foundation; either version 2 of the License, or
  4005                              <1> ; (at your option) any later version.
  4006                              <1> ;
  4007                              <1> ; This program is distributed in the hope that it will be useful,
  4008                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4009                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4010                              <1> ; GNU General Public License for more details.
  4011                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  4012                              <1> ;
  4013                              <1> 
  4014                              <1> %ifndef RAMVARS_INC
  4015                              <1> %define RAMVARS_INC
  4016                              <1> 
  4017                              <1> ; Segment when RAMVARS is stored to top of interrupt vectors.
  4018                              <1> %ifndef USE_AT
  4019                              <1> 	LITE_MODE_RAMVARS_SEGMENT	EQU		30h
  4020                              <1> %endif
  4021                              <1> 
  4022                              <1> 
  4023                              <1> %ifdef MODULE_SERIAL_FLOPPY OR MODULE_DRIVEXLATE
  4024                              <1> 	%define NEED_XLATEVARS
  4025                              <1> %endif
  4026                              <1> 
  4027                              <1> 
  4028                              <1> ; RAM Variables.
  4029                              <1> ; Variables should be kept to minimum since they might be located
  4030                              <1> ; at the top of interrupt vectors.
  4031                              <1> struc RAMVARS
  4032                              <1> %ifdef RELOCATE_INT13H_STACK
  4033                              <1> 						resb	252
  4034                              <1> 	.dwStackChangeDSDI:
  4035                              <1> 	.wStackChangeDI		resb	2	; Used during stack
  4036                              <1> 	.wStackChangeDS		resb	2	; switching only
  4037                              <1> 	.rgbTopOfStack:					; 256 bytes of stack
  4038                              <1> 	.fpInt13hEntryStack	resb	4
  4039                              <1> %endif
  4040                              <1> 	.wDrvDetectSignature:			; Signature when BIOS is in drive detection mode
  4041 00000000 <res 00000004>      <1> 	.fpOldI13h			resb	4	; Far pointer to old INT 13h handler
  4042 00000004 <res 00000002>      <1> 	.wSignature			resb	2	; Sign for finding stolen 1...64 kiB
  4043 00000006 <res 00000001>      <1> 	.bTimeoutTicksLeft	resb	1
  4044 00000007 <res 00000001>      <1> 	.bLastTimeoutUpdate	resb	1
  4045                              <1> 
  4046                              <1> 	.wFirstDrvAndCount:
  4047 00000008 <res 00000001>      <1> 	.bFirstDrv			resb	1	; Number of first drive for this BIOS
  4048                              <1> 	.wDrvCntAndFlopCnt:				; Both the hard disk and floppy counts in one word
  4049                              <1> 									; (yes, misaligned, but it is only used this way during initialization)
  4050 00000009 <res 00000001>      <1> 	.bDrvCnt			resb	1	; Number of drives handled by this BIOS
  4051                              <1> 
  4052                              <1> 	; Variables for drive number translation
  4053                              <1> %ifdef NEED_XLATEVARS
  4054 0000000A <res 00000004>      <1> 	.xlateVars			resb	XLATEVARS_size
  4055                              <1> %endif
  4056                              <1> endstruc
  4057                              <1> 
  4058                              <1> ; Note!!! .wDrvDetectSignature and .wSignature are intentionally in different locations.
  4059                              <1> RAMVARS_RAM_SIGNATURE			EQU	"Xu"	; RAMVARS signature for .wSignature
  4060                              <1> RAMVARS_DRV_DETECT_SIGNATURE	EQU	5A5Ah	; Signature when BIOS is in drive detection mode
  4061                              <1> 
  4062                              <1> 
  4063                              <1> %ifdef NEED_XLATEVARS
  4064                              <1> ; Variables for translating drive numbers.
  4065                              <1> 	struc XLATEVARS
  4066                              <1> 	%ifdef MODULE_SERIAL_FLOPPY
  4067                              <1> 		.bFlopCreateCnt:
  4068 00000000 <res 00000001>      <1> 		.bFlopCntAndFirst	resb	1	; Normally, packed starting floppy drive number (high order 7 bits)
  4069                              <1> 										; and number of drives (low order bit, max 2 drives supported).
  4070                              <1> 										; During initialization, until the end of DetectDrives_FromAllIDEControllers,
  4071                              <1> 										; this byte contains the raw number of floppy drives seen
  4072                              <1> 										; (using .bFlopCreateCnt)
  4073                              <1> 	%else
  4074                              <1> 							resb	1	; alignment
  4075                              <1> 	%endif
  4076                              <1> 
  4077                              <1> 	%ifdef MODULE_DRIVEXLATE
  4078 00000001 <res 00000001>      <1> 		.bXlatedDrv			resb	1	; Drive number after translation
  4079                              <1> 		.wFDandHDswap:
  4080 00000002 <res 00000001>      <1> 		.bFDSwap			resb	1	; Floppy Drive to swap to 00h and vice versa
  4081 00000003 <res 00000001>      <1> 		.bHDSwap			resb	1	; Hard Drive to swap to 80h and vice versa
  4082                              <1> 	%else
  4083                              <1> 							resb	1	; alignment
  4084                              <1> 	%endif
  4085                              <1> 	endstruc
  4086                              <1> %endif
  4087                              <1> 
  4088                              <1> %ifdef MODULE_SERIAL_FLOPPY
  4089                              <1>   %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4090                              <1> 	%if RAMVARS.xlateVars != RAMVARS.bDrvCnt+1 || XLATEVARS.bFlopCreateCnt != 0
  4091                              <1> 		%error "bFlopCreateCnt needs to be the first thing in XLATEVARS, and .xlateVars needs to come immediately after .bDrvCnt.  In at least one place, we read .wDrvCntAndFlopCnt to get both counts in one fetch"
  4092                              <1> 	%endif
  4093                              <1>   %endif
  4094                              <1> %endif
  4095                              <1> 
  4096                              <1> 
  4097                              <1> 
  4098                              <1> ;
  4099                              <1> ; IDEPACK NOTE: The first six bytes of this structure are directly put on the
  4100                              <1> ; wire for MODULE_SERIAL, please do not change the order or insert other members.
  4101                              <1> ;
  4102                              <1> struc IDEPACK	; PIOVARS and MEMPIOVARS overwrite the first 7 bytes
  4103 00000000 <res 00000001>      <1> 	.bFeatures				resb	1
  4104 00000001 <res 00000001>      <1> 	.bDrvAndHead			resb	1	; LBA28 27...24
  4105                              <1> 
  4106                              <1> 	.wSectorCountAndLbaLow:
  4107 00000002 <res 00000001>      <1> 	.bSectorCount			resb	1
  4108                              <1> 	.bSectorNumber:
  4109 00000003 <res 00000001>      <1> 	.bLbaLow				resb	1	; LBA 7...0
  4110                              <1> 
  4111                              <1> 	.wCylinder:
  4112                              <1> 	.wLbaMiddleAndHigh:
  4113 00000004 <res 00000001>      <1> 	.bLbaMiddle				resb	1	; LBA 15...8
  4114 00000005 <res 00000001>      <1> 	.bLbaHigh				resb	1	; LBA 23...16
  4115                              <1> 
  4116 00000006 <res 00000001>      <1> 	.bCommand				resb	1
  4117 00000007 <res 00000001>      <1> 	.bDeviceControl			resb	1	; Offset 7 shared with PIOVARS and MEMPIOVARS
  4118 00000008 <res 00000001>      <1> 							resb	1	; Used by PIOVARS and MEMPIOVARS
  4119                              <1> 
  4120                              <1> %ifdef MODULE_EBIOS
  4121                              <1> 	; Parameters for 48-bit LBA
  4122 00000009 <res 00000001>      <1> 	.bLbaLowExt				resb	1	; LBA48 31...24
  4123                              <1> 	.wLbaMiddleAndHighExt:
  4124 0000000A <res 00000001>      <1> 	.bLbaMiddleExt			resb	1	; LBA48 39...32
  4125 0000000B <res 00000001>      <1> 	.bLbaHighExt			resb	1	; LBA48 47...40
  4126                              <1> %endif
  4127                              <1> 
  4128 0000000C <res 0000001A>      <1> 	.intpack				resb	INTPACK_size
  4129                              <1> endstruc
  4130                              <1> 
  4131                              <1> SIZE_OF_IDEPACK_WITHOUT_INTPACK		EQU	(IDEPACK_size - INTPACK_size)
  4132                              <1> 
  4133                              <1> 
  4134                              <1> %endif ; RAMVARS_INC
  4135                                  	%include "BootVars.inc"			; For BOOTVARS struct
  4136                              <1> ; Project name	:	XTIDE Universal BIOS
  4137                              <1> ; Description	:	Defines for BOOTVARS struct used by boot menu
  4138                              <1> ;					and drive initialization.
  4139                              <1> 
  4140                              <1> ;
  4141                              <1> ; XTIDE Universal BIOS and Associated Tools
  4142                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  4143                              <1> ;
  4144                              <1> ; This program is free software; you can redistribute it and/or modify
  4145                              <1> ; it under the terms of the GNU General Public License as published by
  4146                              <1> ; the Free Software Foundation; either version 2 of the License, or
  4147                              <1> ; (at your option) any later version.
  4148                              <1> ;
  4149                              <1> ; This program is distributed in the hope that it will be useful,
  4150                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4151                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4152                              <1> ; GNU General Public License for more details.
  4153                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  4154                              <1> ;
  4155                              <1> 
  4156                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
  4157                              <1> 
  4158                              <1> %ifndef BOOTVARS_INC
  4159                              <1> %define BOOTVARS_INC
  4160                              <1> 
  4161                              <1> ; Default drives
  4162                              <1> DEFAULT_FLOPPY_DRIVE_LETTER				EQU	'A'
  4163                              <1> DEFAULT_HARD_DRIVE_LETTER				EQU	'C'
  4164                              <1> 
  4165                              <1> ; Number of times to retry booting before accepting error
  4166                              <1> BOOT_READ_RETRY_TIMES		EQU		3
  4167                              <1> 
  4168                              <1> 
  4169                              <1> 
  4170                              <1> ; Pre-boot variables. These do not exist after successful boot to OS.
  4171                              <1> ; Segment is always 0000h, same as BDA segment
  4172                              <1> struc BOOTVARS
  4173 00000000 <res 00007C00>      <1> 						resb	7C00h
  4174                              <1> 	.rgbAtaInfo:						; 7C00h, ATA Information for drive detection
  4175 00007C00 <res 00000200>      <1> 	.rgbBootSect		resb 	512		; 7C00h, Boot sector
  4176 00007E00 <res 00000100>      <1> 						resb	256		; Boot Menu stack
  4177                              <1> 	.rgbMnuStack:
  4178 00007F00 <res 00000004>      <1> 	.dwPostStack		resb	4		; POST stack pointer when entering INT 19h
  4179                              <1> 
  4180                              <1> %ifdef MODULE_8BIT_IDE
  4181 00007F04 <res 00000002>      <1> 	.wNextXTCFportToScan	resb	2	; Needed for XT-CF port autodetection
  4182                              <1> %endif
  4183                              <1> %ifdef MODULE_HOTKEYS
  4184 00007F06 <res 00000006>      <1> 	.hotkeyVars				resb	HOTKEYVARS_size
  4185                              <1> %endif
  4186                              <1> 	.rgDrvDetectInfo:					; Array containing DRVDETECTINFO structs
  4187                              <1> endstruc
  4188                              <1> 
  4189                              <1> 
  4190                              <1> %ifdef MODULE_HOTKEYS
  4191                              <1> 
  4192                              <1> struc HOTKEYVARS
  4193 00000000 <res 00000002>      <1> 	.wTimeWhenDisplayed	resb	2		; System time (ticks) when Hotkey bar was first displayed
  4194                              <1> 	.wFddAndHddLetters:
  4195 00000002 <res 00000001>      <1> 	.bFddLetter			resb	1		; Floppy Drive letter hotkey (upper case)
  4196 00000003 <res 00000001>      <1> 	.bHddLetter			resb	1		; Hard Drive letter hotkey (upper case). Must be after .bFddLetter!
  4197 00000004 <res 00000001>      <1> 	.bFlags				resb	1		; Must be just after .bHddLetter!  (dependency in Hotkeybar.asm)
  4198 00000005 <res 00000001>      <1> 	.bScancode			resb	1		; Function hotkey scancode, must be just after .bFlags!
  4199                              <1> endstruc
  4200                              <1> 
  4201                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4202                              <1> %if HOTKEYVARS.bFddLetter+1 != HOTKEYVARS.bHddLetter || HOTKEYVARS.bHddLetter+1 != HOTKEYVARS.bFlags || HOTKEYVARS.bFlags+1 != HOTKEYVARS.bScancode
  4203                              <1> %error "HOTKEYVARS: bytes need to come in the order .bFddLetter, then .bHddLetter, then .bFlags, then .bScancode"
  4204                              <1> %endif
  4205                              <1> %endif
  4206                              <1> 
  4207                              <1> ; Bit defines for HOTKEYVARS.bFlags
  4208                              <1> FLG_HOTKEY_HD_FIRST			EQU		(1<<0)	; First try to boot from HDD, then FDD
  4209                              <1> 
  4210                              <1> %endif ; MODULE_HOTKEYS
  4211                              <1> 
  4212                              <1> struc DRVDETECTINFO
  4213                              <1> 	.StartOfDrvDetectInfo:
  4214 00000000 <res 0000001E>      <1> 	.szDrvName				resb	MAX_HARD_DISK_NAME_LENGTH
  4215 0000001E <res 00000002>      <1> 							resb	2	; Zero word (ensures string terminates)
  4216 00000020 <res 00000002>      <1> 	.wInitErrorFlags		resb	2	; Errors during initialization
  4217                              <1> 
  4218                              <1> 	; DRVDETECTINFO's size must be an even multiple of DPT's size
  4219 00000022 <res 0000000A>      <1> 	.EndOfDriveDetectInfo:	resb	LARGEST_DPT_SIZE - (.EndOfDriveDetectInfo % LARGEST_DPT_SIZE)
  4220                              <1> endstruc
  4221                              <1> 
  4222                              <1> ; Boot Menu Information Table. These are generated for all XTIDE Universal
  4223                              <1> ; BIOS drives. Available only until boot is successful.
  4224                              <1> MAX_HARD_DISK_NAME_LENGTH			EQU		30		; Bytes reserved for drive name
  4225                              <1> DPT_DRVDETECTINFO_SIZE_MULTIPLIER	EQU		DRVDETECTINFO_size / LARGEST_DPT_SIZE
  4226                              <1> 
  4227                              <1> 
  4228                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4229                              <1> 
  4230                              <1> %if MAX_HARD_DISK_NAME_LENGTH % 2 <> 0
  4231                              <1> 	%error "MAX_HARD_DISK_NAME_LENGTH needs to be a multiple of 2, memory is moved with word operations."
  4232                              <1> %endif
  4233                              <1> 
  4234                              <1> %if DRVDETECTINFO_size % LARGEST_DPT_SIZE <> 0
  4235                              <1> 	%error "DRVDETECTINFO's size must be an even multiple of DPT's size.  Add or remove padding at the bottom of DRVDETECTINFO to bring the two sizes into alignment.  As DRVDETECTINFO is only used at boot time, with pl
  4236                              <1> %endif
  4237                              <1> 
  4238                              <1> %if DRVDETECTINFO.szDrvName <> 0
  4239                              <1> 	%error "DRVDETECTINFO.szDrvName is assumed to be the first member of struc DRVDETECTINFO, in BootMenuPrint_RefreshItem"
  4240                              <1> %endif
  4241                              <1> 
  4242                              <1> %endif
  4243                              <1> 
  4244                              <1> 
  4245                              <1> ;--------------------------------------------------------------------
  4246                              <1> ; Stores POST stack pointer to BOOTVARS.
  4247                              <1> ;
  4248                              <1> ; STORE_POST_STACK_POINTER
  4249                              <1> ;	Parameters:
  4250                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  4251                              <1> ;	Returns:
  4252                              <1> ;		Nothing
  4253                              <1> ;	Corrupts registers:
  4254                              <1> ;		Nothing
  4255                              <1> ;--------------------------------------------------------------------
  4256                              <1> %macro STORE_POST_STACK_POINTER 0
  4257                              <1> 	mov		[es:BOOTVARS.dwPostStack], sp
  4258                              <1> 	mov		[es:BOOTVARS.dwPostStack+2], ss
  4259                              <1> %endmacro
  4260                              <1> 
  4261                              <1> 
  4262                              <1> ;--------------------------------------------------------------------
  4263                              <1> ; Initializes stack for boot menu usage.
  4264                              <1> ; POST stack is not large enough when DPTs are stored to 30:0h.
  4265                              <1> ;
  4266                              <1> ; Note regarding LOAD_BDA_SEGMENT_TO: If you force the use of SP
  4267                              <1> ; then you also have to unconditionally enable the CLI/STI pair.
  4268                              <1> ; The reason for this is that only some buggy 808x CPU:s need the
  4269                              <1> ; CLI/STI instruction pair when changing stacks. Other CPU:s disable
  4270                              <1> ; interrupts automatically when SS is modified for the duration of
  4271                              <1> ; the immediately following instruction to give time to change SP.
  4272                              <1> ;
  4273                              <1> ; SWITCH_TO_BOOT_MENU_STACK
  4274                              <1> ;	Parameters:
  4275                              <1> ;		Nothing
  4276                              <1> ;	Returns:
  4277                              <1> ;		SS:SP:	Pointer to top of Boot Menu stack
  4278                              <1> ;	Corrupts registers:
  4279                              <1> ;		Nothing
  4280                              <1> ;--------------------------------------------------------------------
  4281                              <1> %macro SWITCH_TO_BOOT_MENU_STACK 0
  4282                              <1> %ifndef USE_186
  4283                              <1> 	cli									; Disable interrupts
  4284                              <1> %endif
  4285                              <1> 	LOAD_BDA_SEGMENT_TO	ss, sp
  4286                              <1> 	mov		sp, BOOTVARS.rgbMnuStack	; Load offset to stack
  4287                              <1> %ifndef USE_186
  4288                              <1> 	sti									; Enable interrupts
  4289                              <1> %endif
  4290                              <1> %endmacro
  4291                              <1> 
  4292                              <1> 
  4293                              <1> ;--------------------------------------------------------------------
  4294                              <1> ; Restores SS and SP to initial boot loader values.
  4295                              <1> ;
  4296                              <1> ; Note! Must return with AX=0 and CF preserved.
  4297                              <1> ; See Int19hMenu_JumpToBootSector_or_RomBoot.
  4298                              <1> ;
  4299                              <1> ; SWITCH_BACK_TO_POST_STACK
  4300                              <1> ;	Parameters:
  4301                              <1> ;		AX:		BDA and Interrupt Vector segment (zero)
  4302                              <1> ;	Returns:
  4303                              <1> ;		SS:SP:	Ptr to POST stack
  4304                              <1> ;	Corrupts registers:
  4305                              <1> ;		Nothing (not even FLAGS)
  4306                              <1> ;--------------------------------------------------------------------
  4307                              <1> %macro SWITCH_BACK_TO_POST_STACK 0
  4308                              <1> %ifndef USE_386
  4309                              <1> 	cli
  4310                              <1> 	mov		ss, ax
  4311                              <1> 	mov		sp, [ss:BOOTVARS.dwPostStack]
  4312                              <1> 	mov		ss, [ss:BOOTVARS.dwPostStack+2]
  4313                              <1> 	sti
  4314                              <1> %else
  4315                              <1> 	mov		ss, ax
  4316                              <1> 	lss		sp, [ss:BOOTVARS.dwPostStack]
  4317                              <1> %endif
  4318                              <1> %endmacro
  4319                              <1> 
  4320                              <1> 
  4321                              <1> %endif ; BOOTVARS_INC
  4322                                  	%include "IdeIO.inc"			; Macros for IDE port I/O
  4323                              <1> ; Project name	:	XTIDE Universal BIOS
  4324                              <1> ; Description	:	Macros for normal I/O mapped ATA controllers.
  4325                              <1> 
  4326                              <1> ;
  4327                              <1> ; XTIDE Universal BIOS and Associated Tools
  4328                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  4329                              <1> ;
  4330                              <1> ; This program is free software; you can redistribute it and/or modify
  4331                              <1> ; it under the terms of the GNU General Public License as published by
  4332                              <1> ; the Free Software Foundation; either version 2 of the License, or
  4333                              <1> ; (at your option) any later version.
  4334                              <1> ;
  4335                              <1> ; This program is distributed in the hope that it will be useful,
  4336                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4337                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4338                              <1> ; GNU General Public License for more details.
  4339                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  4340                              <1> ;
  4341                              <1> 
  4342                              <1> %ifndef IDE_IO_INC
  4343                              <1> %define IDE_IO_INC
  4344                              <1> 
  4345                              <1> ;--------------------------------------------------------------------
  4346                              <1> ; OUTPUT_AL_TO_IDE_REGISTER
  4347                              <1> ; OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER
  4348                              <1> ;	Parameters:
  4349                              <1> ;		AL:		Byte to output
  4350                              <1> ;		%1:		IDE Register				(OUTPUT_AL_TO_IDE_REGISTER)
  4351                              <1> ;				IDE Control Block Register	(OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER)
  4352                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
  4353                              <1> ;	Returns:
  4354                              <1> ;		Nothing
  4355                              <1> ;	Corrupts registers:
  4356                              <1> ;		BX, DX
  4357                              <1> ;--------------------------------------------------------------------
  4358                              <1> %macro OUTPUT_AL_TO_IDE_REGISTER 1
  4359                              <1> %ifndef MODULE_8BIT_IDE	; Standard IDE controllers only
  4360                              <1> 
  4361                              <1> 	%ifnidni %1, dx
  4362                              <1> 		mov		dx, %1
  4363                              <1> 	%endif
  4364                              <1> 	add		dx, [di+DPT.wBasePort]
  4365                              <1> 	out		dx, al
  4366                              <1> 
  4367                              <1> %else	; Register translations required
  4368                              <1> 
  4369                              <1> 	%ifnidni %1, dl
  4370                              <1> 		mov		dl, %1
  4371                              <1> 	%endif
  4372                              <1> 	call	IdeIO_OutputALtoIdeRegisterInDL
  4373                              <1> 
  4374                              <1> %endif
  4375                              <1> %endmacro
  4376                              <1> 
  4377                              <1> 
  4378                              <1> %macro OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER 1
  4379                              <1> %ifndef MODULE_8BIT_IDE	; Standard IDE controllers only
  4380                              <1> 
  4381                              <1> 	%ifnidni %1, dx
  4382                              <1> 		mov		dx, %1
  4383                              <1> 	%endif
  4384                              <1> 	eMOVZX	bx, BYTE [di+DPT.bIdevarsOffset]
  4385                              <1> 	add		dx, [cs:bx+IDEVARS.wControlBlockPort]
  4386                              <1> 	out		dx, al
  4387                              <1> 
  4388                              <1> %else	; Register translations required
  4389                              <1> 
  4390                              <1> 	%ifnidni %1, dl
  4391                              <1> 		mov		dl, %1
  4392                              <1> 	%endif
  4393                              <1> 	call	IdeIO_OutputALtoIdeControlBlockRegisterInDL
  4394                              <1> 
  4395                              <1> %endif
  4396                              <1> %endmacro
  4397                              <1> 
  4398                              <1> 
  4399                              <1> ;--------------------------------------------------------------------
  4400                              <1> ; INPUT_TO_AL_FROM_IDE_REGISTER
  4401                              <1> ;	Parameters:
  4402                              <1> ;		%1:		IDE Register
  4403                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
  4404                              <1> ;	Returns:
  4405                              <1> ;		AL:		Inputted byte
  4406                              <1> ;	Corrupts registers:
  4407                              <1> ;		BX, DX
  4408                              <1> ;--------------------------------------------------------------------
  4409                              <1> %macro INPUT_TO_AL_FROM_IDE_REGISTER 1
  4410                              <1> %ifndef MODULE_8BIT_IDE	; Standard IDE controllers only
  4411                              <1> 
  4412                              <1> 	%ifnidni %1, dx
  4413                              <1> 		mov		dx, %1
  4414                              <1> 	%endif
  4415                              <1> 	add		dx, [di+DPT.wBasePort]
  4416                              <1> 	in		al, dx
  4417                              <1> 
  4418                              <1> %else	; Register translations required
  4419                              <1> 
  4420                              <1> 	%ifnidni %1, dl
  4421                              <1> 		mov		dl, %1
  4422                              <1> 	%endif
  4423                              <1> 		call	IdeIO_InputToALfromIdeRegisterInDL
  4424                              <1> 
  4425                              <1> %endif
  4426                              <1> %endmacro
  4427                              <1> 
  4428                              <1> 
  4429                              <1> %endif ; IDE_IO_INC
  4430                                  	%include "DeviceIDE.inc"		; For IDE device equates
  4431                              <1> ; Project name	:	XTIDE Universal BIOS
  4432                              <1> ; Description	:	Device specific equates for IDE drives.
  4433                              <1> 
  4434                              <1> ;
  4435                              <1> ; XTIDE Universal BIOS and Associated Tools
  4436                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  4437                              <1> ;
  4438                              <1> ; This program is free software; you can redistribute it and/or modify
  4439                              <1> ; it under the terms of the GNU General Public License as published by
  4440                              <1> ; the Free Software Foundation; either version 2 of the License, or
  4441                              <1> ; (at your option) any later version.
  4442                              <1> ;
  4443                              <1> ; This program is distributed in the hope that it will be useful,
  4444                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4445                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4446                              <1> ; GNU General Public License for more details.
  4447                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  4448                              <1> ;
  4449                              <1> 
  4450                              <1> %ifndef DEVICEIDE_INC
  4451                              <1> %define DEVICEIDE_INC
  4452                              <1> 
  4453                              <1> ; Reset delays
  4454                              <1> HSR0_RESET_WAIT_US		EQU		6		; Delay must be at least 5 us
  4455                              <1> HSR1_RESET_WAIT_US		EQU		2100	; Delay must be at least 2 ms
  4456                              <1> 
  4457                              <1> ; Polling timeout delays (system timer ticks, 1 tick = 54.9 ms)
  4458                              <1> TIMEOUT_DRQ				EQU		255			;   14 s (some CF cards occasionally have long write delays)
  4459                              <1> TIMEOUT_SELECT_DRIVE_DURING_DRIVE_DETECTION	EQU	(500/55)	;  500 ms
  4460                              <1> TIMEOUT_MOTOR_STARTUP	EQU		(10000/55)	;   10 s
  4461                              <1> TIMEOUT_MAXIMUM			EQU		255			; We would actually want 31 seconds here but I don't think there are so slow drives
  4462                              <1> 
  4463                              <1> %ifdef MODULE_FEATURE_SETS
  4464                              <1> 	TIMEOUT_BSY			EQU		TIMEOUT_MOTOR_STARTUP
  4465                              <1> 	TIMEOUT_DRDY		EQU		TIMEOUT_MOTOR_STARTUP
  4466                              <1> %else
  4467                              <1> 	TIMEOUT_BSY			EQU		(2600/55)	; 2600 ms
  4468                              <1> 	TIMEOUT_DRDY		EQU		(2600/55)	; 2600 ms
  4469                              <1> %endif
  4470                              <1> 
  4471                              <1> %endif ; DEVICEIDE_INC
  4472                                  
  4473                                  
  4474                                  
  4475                                  ; Section containing code
  4476                                  SECTION .text
  4477                                  
  4478                                  ; ROM variables (must start at offset 0)
  4479                                  CNT_ROM_BLOCKS		EQU		BIOS_SIZE / 512		; number of 512B blocks, 16 = 8kB BIOS
  4480                                  istruc ROMVARS
  4481 00000000 55AA                    	at	ROMVARS.wRomSign,	dw	0AA55h			; PC ROM signature
  4482 00000002 10                      	at	ROMVARS.bRomSize,	db	CNT_ROM_BLOCKS	; ROM size in 512B blocks
  4483 00000003 E92C04                  	at	ROMVARS.rgbJump,	jmp	Initialize_FromMainBiosRomSearch
  4484 00000006 5854494445323033        	at	ROMVARS.rgbSign,	db	FLASH_SIGNATURE
  4485 0000000E 2D3D58544944452055-     	at	ROMVARS.szTitle,	db	TITLE_STRING
  4486 00000017 6E6976657273616C20-
  4487 00000020 42494F532028585429-
  4488 00000029 3D2D00             
  4489 0000002C 0076322E302E30E133-     	at	ROMVARS.szVersion,	db	ROM_VERSION_STRING
  4490 00000035 2B2028323031332D30-
  4491 0000003E 342D30332900       
  4492                                  
  4493                                  ;---------------------------;
  4494                                  ; AT Build default settings ;
  4495                                  ;---------------------------;
  4496                                  %ifdef USE_AT
  4497                                  	at	ROMVARS.wFlags,			dw	FLG_ROMVARS_FULLMODE | MASK_ROMVARS_INCLUDED_MODULES
  4498                                  	at	ROMVARS.wDisplayMode,	dw	DEFAULT_TEXT_MODE
  4499                                  %ifdef MODULE_BOOT_MENU
  4500                                  	at	ROMVARS.wBootTimeout,	dw	BOOT_MENU_DEFAULT_TIMEOUT
  4501                                  %endif
  4502                                  	at	ROMVARS.bIdeCnt,		db	2						; Number of supported controllers
  4503                                  	at	ROMVARS.bBootDrv,		db	80h						; Boot Menu default drive
  4504                                  	at	ROMVARS.bMinFddCnt, 	db	0						; Do not force minimum number of floppy drives
  4505                                  	at	ROMVARS.bStealSize,		db	1						; Steal 1kB from base memory
  4506                                  	at	ROMVARS.bIdleTimeout,	db	0						; Standby timer disabled by default
  4507                                  
  4508                                  	at	ROMVARS.ideVars0+IDEVARS.wBasePort,			dw	DEVICE_ATA_PRIMARY_PORT 		; Controller Command Block base port
  4509                                  	at	ROMVARS.ideVars0+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_PRIMARY_PORTCTRL 	; Controller Control Block base port
  4510                                  	at	ROMVARS.ideVars0+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
  4511                                  	at	ROMVARS.ideVars0+IDEVARS.bIRQ,				db	14
  4512                                  	at	ROMVARS.ideVars0+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4513                                  	at	ROMVARS.ideVars0+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4514                                  
  4515                                  	at	ROMVARS.ideVars1+IDEVARS.wBasePort,			dw	DEVICE_ATA_SECONDARY_PORT
  4516                                  	at	ROMVARS.ideVars1+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_SECONDARY_PORTCTRL
  4517                                  	at	ROMVARS.ideVars1+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
  4518                                  	at	ROMVARS.ideVars1+IDEVARS.bIRQ,				db	15
  4519                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4520                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4521                                  
  4522                                  	at	ROMVARS.ideVars2+IDEVARS.wBasePort,			dw	DEVICE_ATA_TERTIARY_PORT
  4523                                  	at	ROMVARS.ideVars2+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_TERTIARY_PORTCTRL
  4524                                  	at	ROMVARS.ideVars2+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
  4525                                  	at	ROMVARS.ideVars2+IDEVARS.bIRQ,				db	0
  4526                                  	at	ROMVARS.ideVars2+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4527                                  	at	ROMVARS.ideVars2+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4528                                  
  4529                                  	at	ROMVARS.ideVars3+IDEVARS.wBasePort,			dw	DEVICE_ATA_QUATERNARY_PORT
  4530                                  	at	ROMVARS.ideVars3+IDEVARS.wControlBlockPort,	dw	DEVICE_ATA_QUATERNARY_PORTCTRL
  4531                                  	at	ROMVARS.ideVars3+IDEVARS.bDevice,			db	DEVICE_16BIT_ATA
  4532                                  	at	ROMVARS.ideVars3+IDEVARS.bIRQ,				db	0
  4533                                  	at	ROMVARS.ideVars3+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4534                                  	at	ROMVARS.ideVars3+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	dw	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4535                                  
  4536                                  %ifdef MODULE_SERIAL
  4537                                  	at	ROMVARS.ideVarsSerialAuto+IDEVARS.bDevice,		db	DEVICE_SERIAL_PORT
  4538                                  %endif
  4539                                  %else
  4540                                  ;-----------------------------------;
  4541                                  ; XT and XT+ Build default settings ;
  4542                                  ;-----------------------------------;
  4543 00000044 00<rept>E0EC            	at	ROMVARS.wFlags,			dw	MASK_ROMVARS_INCLUDED_MODULES
  4544 00000048 0400                    	at	ROMVARS.wDisplayMode,	dw	DEFAULT_TEXT_MODE
  4545                                  %ifdef MODULE_BOOT_MENU
  4546                                  	at	ROMVARS.wBootTimeout,	dw	BOOT_MENU_DEFAULT_TIMEOUT
  4547                                  %endif
  4548                                  %ifdef MODULE_8BIT_IDE_ADVANCED
  4549 0000004A 00<rept>02              	at	ROMVARS.bIdeCnt,		db	2						; Number of supported controllers
  4550                                  %else
  4551                                  	at  ROMVARS.bIdeCnt,		db	1
  4552                                  %endif
  4553 0000004D 80                      	at	ROMVARS.bBootDrv,		db	80h						; Boot Menu default drive
  4554 0000004E 00                      	at	ROMVARS.bMinFddCnt, 	db	0						; Do not force minimum number of floppy drives
  4555 0000004F 01                      	at	ROMVARS.bStealSize,		db	1						; Steal 1kB from base memory in full mode
  4556 00000050 00                      	at	ROMVARS.bIdleTimeout,	db	0						; Standby timer disabled by default
  4557                                  
  4558 00000051 0003                    	at	ROMVARS.ideVars0+IDEVARS.wBasePort,			dw	DEVICE_XTIDE_DEFAULT_PORT			; Controller Command Block base port
  4559 00000053 0803                    	at	ROMVARS.ideVars0+IDEVARS.wControlBlockPort,	dw	DEVICE_XTIDE_DEFAULT_PORTCTRL		; Controller Control Block base port
  4560 00000055 06                      	at	ROMVARS.ideVars0+IDEVARS.bDevice,			db	DEVICE_8BIT_XTIDE_REV1
  4561 00000056 001D                    	at	ROMVARS.ideVars0+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4562 00000058 00<rept>1D              	at	ROMVARS.ideVars0+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4563                                  
  4564                                  %ifdef MODULE_8BIT_IDE_ADVANCED
  4565 0000005E 00<rept>00              	at	ROMVARS.ideVars1+IDEVARS.bXTCFcontrolRegister,	db	XTCF_8BIT_PIO_MODE
  4566 00000066 000A                    	at	ROMVARS.ideVars1+IDEVARS.bDevice,				db	DEVICE_8BIT_XTCF_PIO8
  4567 00000068 001D                    	at	ROMVARS.ideVars1+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4568 0000006A 00<rept>1D              	at	ROMVARS.ideVars1+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4569                                  %else
  4570                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4571                                  	at	ROMVARS.ideVars1+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4572                                  %endif
  4573                                  
  4574 00000070 00<rept>1D              	at	ROMVARS.ideVars2+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4575 0000007C 00<rept>1D              	at	ROMVARS.ideVars2+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4576                                  
  4577 00000082 00<rept>1D              	at	ROMVARS.ideVars3+IDEVARS.drvParamsMaster+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4578 0000008E 00<rept>1D              	at	ROMVARS.ideVars3+IDEVARS.drvParamsSlave+DRVPARAMS.wFlags,	db	DISABLE_WRITE_CACHE | FLG_DRVPARAMS_BLOCKMODE | (TRANSLATEMODE_AUTO<<TRANSLATEMODE_FIELD_POSITION)
  4579                                  
  4580                                  %ifdef MODULE_SERIAL
  4581 00000094 00<rept>12              	at	ROMVARS.ideVarsSerialAuto+IDEVARS.bDevice,		db	DEVICE_SERIAL_PORT
  4582                                  %endif
  4583                                  %endif
  4584 0000009E 00<rept>                iend
  4585                                  
  4586                                  	; Strings are first to avoid them moving unnecessarily when code is turned on and off with %ifdef's
  4587                                  	; since some groups of strings need to be on the same 256-byte page.
  4588                                  	;
  4589                                  %ifdef MODULE_STRINGS_COMPRESSED
  4590                                  	%define STRINGSCOMPRESSED_STRINGS
  4591                                  	%include "StringsCompressed.asm"
  4592                              <1> ;;;======================================================================
  4593                              <1> ;;;
  4594                              <1> ;;; This file is generated by StringsCompress.pl from source in Strings.asm
  4595                              <1> ;;; DO NOT EDIT DIRECTLY - See the makefile for how to rebuild this file.
  4596                              <1> ;;; This file only needs to be rebuilt if Strings.asm is changed.
  4597                              <1> ;;;
  4598                              <1> ;;;======================================================================
  4599                              <1> 
  4600                              <1> %ifdef STRINGSCOMPRESSED_STRINGS
  4601                              <1> 
  4602                              <1> ; Project name	:	XTIDE Universal BIOS
  4603                              <1> ; Description	:	Strings and equates for BIOS messages.
  4604                              <1> 
  4605                              <1> ;
  4606                              <1> ; XTIDE Universal BIOS and Associated Tools
  4607                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  4608                              <1> ;
  4609                              <1> ; This program is free software; you can redistribute it and/or modify
  4610                              <1> ; it under the terms of the GNU General Public License as published by
  4611                              <1> ; the Free Software Foundation; either version 2 of the License, or
  4612                              <1> ; (at your option) any later version.
  4613                              <1> ;
  4614                              <1> ; This program is distributed in the hope that it will be useful,
  4615                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  4616                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  4617                              <1> ; GNU General Public License for more details.
  4618                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  4619                              <1> ;
  4620                              <1> 
  4621                              <1> %ifdef MODULE_STRINGS_COMPRESSED_PRECOMPRESS
  4622                              <1> %include "Display.inc"
  4623                              <1> %endif
  4624                              <1> 
  4625                              <1> ; Section containing code
  4626                              <1> SECTION .text
  4627                              <1> 
  4628                              <1> ; The following strings are used by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
  4629                              <1> ; To support an optimization in that code, these strings must start on the same 256 byte page,
  4630                              <1> ; which is checked at assembly time below.
  4631                              <1> ;
  4632                              <1> g_szDetectStart:
  4633                              <1> g_szDetectMaster:		; db	"Master",NULL
  4634                              <1>                  		; db	 4dh,  61h,  73h,  74h,  65h,  72h,  00h    ; uncompressed
  4635 000000AB 5367797A6BB8        <1>                  		  db	 53h,  67h,  79h,  7ah,  6bh, 0b8h          ; compressed
  4636                              <1> 
  4637                              <1> g_szDetectSlave:		; db	"Slave ",NULL
  4638                              <1>                 		; db	 53h,  6ch,  61h,  76h,  65h,  20h,  00h    ; uncompressed
  4639 000000B1 5972677C6B00        <1>                 		  db	 59h,  72h,  67h,  7ch,  6bh,  00h          ; compressed
  4640                              <1> 
  4641                              <1> g_szDetectOuter:		; db	"%s at %s: ",NULL
  4642                              <1>                 		; db	 25h,  73h,  20h,  61h,  74h,  20h,  25h,  73h,  3ah,  20h,  00h    ; uncompressed
  4643 000000B7 3D2067FA3D4000      <1>                 		  db	 3dh,  20h,  67h, 0fah,  3dh,  40h,  00h                            ; compressed
  4644                              <1> 
  4645                              <1> %ifdef MODULE_SERIAL
  4646                              <1> g_szDetectCOM:			; db	"COM%c%s",NULL
  4647                              <1>               			; db	 43h,  4fh,  4dh,  25h,  63h,  25h,  73h,  00h    ; uncompressed
  4648 000000BE 4955533C1D          <1>               			  db	 49h,  55h,  53h,  3ch,  1dh                      ; compressed
  4649                              <1> 
  4650                              <1> g_szDetectCOMAuto:		; db	" Detect",NULL
  4651                              <1>                   		; db	 20h,  44h,  65h,  74h,  65h,  63h,  74h,  00h    ; uncompressed
  4652 000000C3 204A6B7A6B69BA      <1>                   		  db	 20h,  4ah,  6bh,  7ah,  6bh,  69h, 0bah          ; compressed
  4653                              <1> 
  4654                              <1> g_szDetectCOMSmall:		; db	"/%u%u00",NULL					; IDE Master at COM1/9600:
  4655                              <1>                    		; db	 2fh,  25h,  75h,  25h,  75h,  30h,  30h,  00h    ; uncompressed
  4656 000000CA 2A35353313          <1>                    		  db	 2ah,  35h,  35h,  33h,  13h                      ; compressed
  4657                              <1> 
  4658                              <1> g_szDetectCOMLarge:		; db	"/%u.%uK",NULL					; IDE Master at COM1/19.2K:
  4659                              <1>                    		; db	 2fh,  25h,  75h,  2eh,  25h,  75h,  4bh,  00h    ; uncompressed
  4660 000000CF 2A35293591          <1>                    		  db	 2ah,  35h,  29h,  35h,  91h                      ; compressed
  4661                              <1> 
  4662                              <1> %endif
  4663                              <1> g_szDetectEnd:
  4664                              <1> g_szDetectPort:			; db	"%x",NULL						; IDE Master at 1F0h:
  4665                              <1>                			; db	 25h,  78h,  00h    ; uncompressed
  4666 000000D4 17                  <1>                			  db	 17h                ; compressed
  4667                              <1> 
  4668                              <1> 
  4669                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4670                              <1> %if ((g_szDetectEnd-$$) & 0xff00) <> ((g_szDetectStart-$$) & 0xff00)
  4671                              <1> %error "g_szDetect* strings must start on the same 256 byte page, required by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP.  Please move this block up or down within Strings.asm"
  4672                              <1> %endif
  4673                              <1> %endif
  4674                              <1> 
  4675                              <1> 
  4676                              <1> ; POST drive detection strings
  4677                              <1> g_szDashForZero:	; db	"- ",NULL	; Required by Display Library
  4678                              <1>                 	; db	 2dh,  20h,  00h    ; uncompressed
  4679 000000D5 2800                <1>                 	  db	 28h,  00h          ; compressed
  4680                              <1> 
  4681                              <1> g_szRomAt:			; db	LF,CR
  4682                              <1>           			; db	 0ah,  0dh    ; uncompressed
  4683 000000D7 39                  <1>           			  db	 39h          ; compressed
  4684                              <1> 
  4685                              <1> 	; db	"%s @ %x",LF,CR						; -=XTIDE ... =- @ Segment
  4686                              <1> 	; db	 25h,  73h,  20h,  40h,  20h,  25h,  78h,  0ah,  0dh    ; uncompressed
  4687 000000D8 3D20C63739          <1> 	  db	 3dh,  20h, 0c6h,  37h,  39h                            ; compressed
  4688                              <1> 
  4689                              <1> 	; db	"%s",LF,CR							; version string
  4690                              <1> 	; db	 25h,  73h,  0ah,  0dh    ; uncompressed
  4691 000000DD 3D39                <1> 	  db	 3dh,  39h                ; compressed
  4692                              <1> 
  4693                              <1> 	; db	"Released under GNU GPL v2",LF,CR
  4694                              <1> 	; db	 52h,  65h,  6ch,  65h,  61h,  73h,  65h,  64h,  20h,  75h,  6eh,  64h,  65h,  72h,  20h,  47h,  4eh,  55h,  20h,  47h,  50h,  4ch,  20h,  76h,  32h,  0ah,  0dh    ; uncompressed
  4695 000000DF 586B726B67796BEA7B- <1> 	  db	 58h,  6bh,  72h,  6bh,  67h,  79h,  6bh, 0eah,  7bh,  74h,  6ah,  6bh, 0f8h,  4dh,  54h, 0dbh,  4dh,  56h, 0d2h,  7ch,  2ch,  39h                                  ; compressed
  4696 000000E8 746A6BF84D54DB4D56- <1>
  4697 000000F1 D27C2C39            <1>
  4698                              <1> 
  4699                              <1> 	; db	LF,CR,NULL
  4700                              <1> 	; db	 0ah,  0dh,  00h    ; uncompressed
  4701 000000F5 19                  <1> 	  db	 19h                ; compressed
  4702                              <1> 
  4703                              <1> %ifdef MODULE_BOOT_MENU
  4704                              <1> g_szBootMenuTitle:	; db	"%s%c",LF,CR						; -=XTIDE ... =- and null (eaten)
  4705                              <1>                   	; db	 25h,  73h,  25h,  63h,  0ah,  0dh    ; uncompressed
  4706                              <1>                   	  db	 3dh,  3ch,  39h                      ; compressed
  4707                              <1> 
  4708                              <1> 	; db	"%s",NULL							; version string
  4709                              <1> 	; db	 25h,  73h,  00h    ; uncompressed
  4710                              <1> 	  db	 1dh                ; compressed
  4711                              <1> 
  4712                              <1> %endif
  4713                              <1> g_szDriveName:		; db	"%z",LF,CR,NULL
  4714                              <1>               		; db	 25h,  7ah,  0ah,  0dh,  00h    ; uncompressed
  4715 000000F6 3E19                <1>               		  db	 3eh,  19h                      ; compressed
  4716                              <1> 
  4717                              <1> 
  4718                              <1> 
  4719                              <1> ; Boot loader strings
  4720                              <1> g_szTryToBoot:			; db	"Booting %c",ANGLE_QUOTE_RIGHT,"%c",LF,CR,NULL
  4721                              <1>               			; db	 42h,  6fh,  6fh,  74h,  69h,  6eh,  67h,  20h,  25h,  63h, 0afh,  25h,  63h,  0ah,  0dh,  00h    ; uncompressed
  4722 000000F8 4875757A6F74ED3C24- <1>               			  db	 48h,  75h,  75h,  7ah,  6fh,  74h, 0edh,  3ch,  24h,  3ch,  19h                                  ; compressed
  4723 00000101 3C19                <1>
  4724                              <1> 
  4725                              <1> g_szBootSectorNotFound:	; db	"Boot sector " 			; String fall through...
  4726                              <1>                        	; db	 42h,  6fh,  6fh,  74h,  20h,  73h,  65h,  63h,  74h,  6fh,  72h,  20h    ; uncompressed
  4727 00000103 487575FA796B697A75- <1>                        	  db	 48h,  75h,  75h, 0fah,  79h,  6bh,  69h,  7ah,  75h, 0f8h                ; compressed
  4728 0000010C F8                  <1>
  4729                              <1> 
  4730                              <1> g_szNotFound:			; db	"not found",LF,CR,NULL
  4731                              <1>              			; db	 6eh,  6fh,  74h,  20h,  66h,  6fh,  75h,  6eh,  64h,  0ah,  0dh,  00h    ; uncompressed
  4732 0000010D 7475FA6C757B746A19  <1>              			  db	 74h,  75h, 0fah,  6ch,  75h,  7bh,  74h,  6ah,  19h                      ; compressed
  4733                              <1> 
  4734                              <1> g_szReadError:			; db	"Error %x!",LF,CR,NULL
  4735                              <1>               			; db	 45h,  72h,  72h,  6fh,  72h,  20h,  25h,  78h,  21h,  0ah,  0dh,  00h    ; uncompressed
  4736 00000116 4B787875F8372519    <1>               			  db	 4bh,  78h,  78h,  75h, 0f8h,  37h,  25h,  19h                            ; compressed
  4737                              <1> 
  4738                              <1> 
  4739                              <1> 
  4740                              <1> %ifdef MODULE_HOTKEYS
  4741                              <1> ; Hotkey Bar strings
  4742                              <1> g_szFDD:				; db	"FDD [%c]",NULL			; "FDD [A]"
  4743                              <1>         				; db	 46h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
  4744 0000011E 4C4ACA613CA3        <1>         				  db	 4ch,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
  4745                              <1> 
  4746                              <1> g_szHDD:				; db	"HDD [%c]",NULL			; "HDD [C]"
  4747                              <1>         				; db	 48h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
  4748 00000124 4E4ACA613CA3        <1>         				  db	 4eh,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
  4749                              <1> 
  4750                              <1> %ifdef MODULE_BOOT_MENU
  4751                              <1> g_szBootMenu:			; db	"BootMnu%c",NULL		; "BootMnu", location of %c doesn't matter
  4752                              <1>              			; db	 42h,  6fh,  6fh,  74h,  4dh,  6eh,  75h,  25h,  63h,  00h    ; uncompressed
  4753                              <1>              			  db	 48h,  75h,  75h,  7ah,  53h,  74h,  7bh,  1ch                ; compressed
  4754                              <1> 
  4755                              <1> %endif ; MODULE_BOOT_MENU
  4756                              <1> g_szHotkey:				; db	"%A%c%c%A%s%A ",NULL	; "CHDD [A] ", "F2BootMnu " or "F8RomBoot "
  4757                              <1>            				; db	 25h,  41h,  25h,  63h,  25h,  63h,  25h,  41h,  25h,  73h,  25h,  41h,  20h,  00h    ; uncompressed
  4758 0000012A 3B3C3C3B3D3B00      <1>            				  db	 3bh,  3ch,  3ch,  3bh,  3dh,  3bh,  00h                                              ; compressed
  4759                              <1> 
  4760                              <1> %ifdef MODULE_SERIAL
  4761                              <1> g_szHotComDetect:		; db	"ComDtct%c",NULL		; "ComDtct", location of %c doesn't matter
  4762                              <1>                  		; db	 43h,  6fh,  6dh,  44h,  74h,  63h,  74h,  25h,  63h,  00h    ; uncompressed
  4763 00000131 4975734A7A697A1C    <1>                  		  db	 49h,  75h,  73h,  4ah,  7ah,  69h,  7ah,  1ch                ; compressed
  4764                              <1> 
  4765                              <1> %endif ; MODULE_SERIAL
  4766                              <1> %endif ; MODULE_HOTKEYS
  4767                              <1> 
  4768                              <1> %ifdef MODULE_BOOT_MENU
  4769                              <1> g_szRomBootDash:		; db	" -  "					; String fall through to g_szRomBoot
  4770                              <1>                 		; db	 20h,  2dh,  20h,  20h    ; uncompressed
  4771                              <1>                 		  db	 20h,  28h,  20h,  20h    ; compressed
  4772                              <1> 
  4773                              <1> %endif
  4774                              <1> %ifdef MODULE_HOTKEYS OR MODULE_BOOT_MENU
  4775                              <1> g_szRomBoot:			; db	"Rom%cBoot",NULL		; "RomBoot" or "Rom Boot"
  4776                              <1>             			; db	 52h,  6fh,  6dh,  25h,  63h,  42h,  6fh,  6fh,  74h,  00h    ; uncompressed
  4777 00000139 5875733C487575BA    <1>             			  db	 58h,  75h,  73h,  3ch,  48h,  75h,  75h, 0bah                ; compressed
  4778                              <1> 
  4779                              <1> %endif
  4780                              <1> 
  4781                              <1> 
  4782                              <1> %ifdef MODULE_BOOT_MENU
  4783                              <1> ; Boot Menu Floppy Disk strings
  4784                              <1> ;
  4785                              <1> ; The following strings are used by BootMenuPrint_RefreshInformation
  4786                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
  4787                              <1> ; which is checked at assembly time below.
  4788                              <1> ;
  4789                              <1> g_szFddStart:
  4790                              <1> g_szFddUnknown:		; db	"Unknown",NULL
  4791                              <1>                		; db	 55h,  6eh,  6bh,  6eh,  6fh,  77h,  6eh,  00h    ; uncompressed
  4792                              <1>                		  db	 5bh,  74h,  71h,  74h,  75h,  7dh, 0b4h          ; compressed
  4793                              <1> 
  4794                              <1> g_szFddSizeOr:		; db	"5",ONE_QUARTER,QUOTATION_MARK," or 3",ONE_HALF,QUOTATION_MARK," DD",NULL
  4795                              <1>               		; db	 35h, 0ach,  22h,  20h,  6fh,  72h,  20h,  33h, 0abh,  22h,  20h,  44h,  44h,  00h    ; uncompressed
  4796                              <1>               		  db	 2eh,  21h,  26h,  20h,  75h, 0f8h,  2dh,  22h,  26h,  20h,  4ah,  8ah                ; compressed
  4797                              <1> 
  4798                              <1> g_szFddSize:		; db	"%s",QUOTATION_MARK,", %u kiB",NULL	; 3", 1440 kiB
  4799                              <1>             		; db	 25h,  73h,  22h,  2ch,  20h,  25h,  75h,  20h,  6bh,  69h,  42h,  00h    ; uncompressed
  4800                              <1>             		  db	 3dh,  26h,  27h,  20h,  35h,  20h,  71h,  6fh,  88h                      ; compressed
  4801                              <1> 
  4802                              <1> g_szFddThreeHalf:	; db	"3",ONE_HALF,NULL
  4803                              <1>                  	; db	 33h, 0abh,  00h    ; uncompressed
  4804                              <1>                  	  db	 2dh,  02h          ; compressed
  4805                              <1> 
  4806                              <1> g_szFddEnd:
  4807                              <1> g_szFddFiveQuarter:	; db	"5",ONE_QUARTER,NULL
  4808                              <1>                    	; db	 35h, 0ach,  00h    ; uncompressed
  4809                              <1>                    	  db	 2eh,  01h          ; compressed
  4810                              <1> 
  4811                              <1> 
  4812                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4813                              <1> %if ((g_szFddStart-$$) & 0xff00) <> ((g_szFddEnd-$$) & 0xff00)
  4814                              <1> %error "g_szFdd* strings must start on the same 256 byte page, required by the BootMenuPrint_RefreshInformation routines for floppy drives.  Please move this block up or down within Strings.asm"
  4815                              <1> %endif
  4816                              <1> %endif
  4817                              <1> 
  4818                              <1> 
  4819                              <1> g_szAddressingModes:
  4820                              <1> g_szNORMAL:		; db	"NORMAL",NULL
  4821                              <1>            		; db	 4eh,  4fh,  52h,  4dh,  41h,  4ch,  00h    ; uncompressed
  4822                              <1>            		  db	 54h,  55h,  58h,  53h,  47h,  92h          ; compressed
  4823                              <1> 
  4824                              <1> g_szLARGE:		; db	"LARGE ",NULL
  4825                              <1>           		; db	 4ch,  41h,  52h,  47h,  45h,  20h,  00h    ; uncompressed
  4826                              <1>           		  db	 52h,  47h,  58h,  4dh,  4bh,  00h          ; compressed
  4827                              <1> 
  4828                              <1> g_szLBA:		; db	"LBA   ",NULL
  4829                              <1>         		; db	 4ch,  42h,  41h,  20h,  20h,  20h,  00h    ; uncompressed
  4830                              <1>         		  db	 52h,  48h, 0c7h,  20h,  00h                ; compressed
  4831                              <1> 
  4832                              <1> g_szAddressingModes_Displacement equ (g_szLARGE - g_szAddressingModes)
  4833                              <1> ;
  4834                              <1> ; Ensure that addressing modes are correctly spaced in memory
  4835                              <1> ;
  4836                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4837                              <1> %if g_szNORMAL <> g_szAddressingModes
  4838                              <1> %error "g_szAddressingModes Displacement Incorrect 1"
  4839                              <1> %endif
  4840                              <1> %if g_szLARGE <> g_szNORMAL + g_szAddressingModes_Displacement
  4841                              <1> %error "g_szAddressingModes Displacement Incorrect 2"
  4842                              <1> %endif
  4843                              <1> %if g_szLBA <> g_szLARGE + g_szAddressingModes_Displacement
  4844                              <1> %error "g_szAddressingModes Displacement Incorrect 3"
  4845                              <1> %endif
  4846                              <1> %endif
  4847                              <1> 
  4848                              <1> 
  4849                              <1> g_szDeviceTypeValues:
  4850                              <1> g_szDeviceTypeValues_16bit:		; db	" 16",NULL
  4851                              <1>                            		; db	 20h,  31h,  36h,  00h    ; uncompressed
  4852                              <1>                            		  db	 20h,  2bh,  0fh          ; compressed
  4853                              <1> 
  4854                              <1> g_szDeviceTypeValues_32bit:		; db	" 32",NULL
  4855                              <1>                            		; db	 20h,  33h,  32h,  00h    ; uncompressed
  4856                              <1>                            		  db	 20h,  2dh,  0ch          ; compressed
  4857                              <1> 
  4858                              <1> g_szDeviceTypeValues_8bit:		; db	"  8",NULL
  4859                              <1>                           		; db	 20h,  20h,  38h,  00h    ; uncompressed
  4860                              <1>                           		  db	 20h,  20h,  10h          ; compressed
  4861                              <1> 
  4862                              <1> g_szDeviceTypeValues_XTIDEr1:	; db	"D8 ",NULL	; Dual 8-bit
  4863                              <1>                              	; db	 44h,  38h,  20h,  00h    ; uncompressed
  4864                              <1>                              	  db	 4ah,  30h,  00h          ; compressed
  4865                              <1> 
  4866                              <1> g_szDeviceTypeValues_XTIDEr2:	; db	"X8 ",NULL	; A0<->A3 swapped 8-bit
  4867                              <1>                              	; db	 58h,  38h,  20h,  00h    ; uncompressed
  4868                              <1>                              	  db	 5eh,  30h,  00h          ; compressed
  4869                              <1> 
  4870                              <1> g_szDeviceTypeValues_XTCFpio8:	; db	"T8 ",NULL	; True 8-bit
  4871                              <1>                               	; db	 54h,  38h,  20h,  00h    ; uncompressed
  4872                              <1>                               	  db	 5ah,  30h,  00h          ; compressed
  4873                              <1> 
  4874                              <1> g_szDeviceTypeValues_XTCFdma:	; db	"8MA",NULL	; DMA 8-bit
  4875                              <1>                              	; db	 38h,  4dh,  41h,  00h    ; uncompressed
  4876                              <1>                              	  db	 30h,  53h,  87h          ; compressed
  4877                              <1> 
  4878                              <1> g_szDeviceTypeValues_XTCFmem:	; db	"M8 ",NULL	; Memory Mapped 8-bit
  4879                              <1>                              	; db	 4dh,  38h,  20h,  00h    ; uncompressed
  4880                              <1>                              	  db	 53h,  30h,  00h          ; compressed
  4881                              <1> 
  4882                              <1> g_szDeviceTypeValues_JrIde:		; db	"M8 ",NULL
  4883                              <1>                            		; db	 4dh,  38h,  20h,  00h    ; uncompressed
  4884                              <1>                            		  db	 53h,  30h,  00h          ; compressed
  4885                              <1> 
  4886                              <1> g_szDeviceTypeValues_Serial:	; db	"SER",NULL
  4887                              <1>                             	; db	 53h,  45h,  52h,  00h    ; uncompressed
  4888                              <1>                             	  db	 59h,  4bh,  98h          ; compressed
  4889                              <1> 
  4890                              <1> 
  4891                              <1> g_szDeviceTypeValues_Displacement equ (g_szDeviceTypeValues_32bit - g_szDeviceTypeValues)
  4892                              <1> ;
  4893                              <1> ; Ensure that device type strings are correctly spaced in memory
  4894                              <1> ;
  4895                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4896                              <1> %if g_szDeviceTypeValues_16bit <> g_szDeviceTypeValues
  4897                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 1"
  4898                              <1> %endif
  4899                              <1> %if g_szDeviceTypeValues_32bit <> g_szDeviceTypeValues_16bit + g_szDeviceTypeValues_Displacement
  4900                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
  4901                              <1> %endif
  4902                              <1> %if g_szDeviceTypeValues_8bit <> g_szDeviceTypeValues_32bit + g_szDeviceTypeValues_Displacement
  4903                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
  4904                              <1> %endif
  4905                              <1> %if g_szDeviceTypeValues_XTIDEr1 <> g_szDeviceTypeValues_8bit + g_szDeviceTypeValues_Displacement
  4906                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 3"
  4907                              <1> %endif
  4908                              <1> %if g_szDeviceTypeValues_XTIDEr2 <> g_szDeviceTypeValues_XTIDEr1 + g_szDeviceTypeValues_Displacement
  4909                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 4"
  4910                              <1> %endif
  4911                              <1> %if g_szDeviceTypeValues_XTCFpio8 <> g_szDeviceTypeValues_XTIDEr2 + g_szDeviceTypeValues_Displacement
  4912                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 5"
  4913                              <1> %endif
  4914                              <1> %if g_szDeviceTypeValues_XTCFdma <> g_szDeviceTypeValues_XTCFpio8 + g_szDeviceTypeValues_Displacement
  4915                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 6"
  4916                              <1> %endif
  4917                              <1> %if g_szDeviceTypeValues_XTCFmem <> g_szDeviceTypeValues_XTCFdma + g_szDeviceTypeValues_Displacement
  4918                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 7"
  4919                              <1> %endif
  4920                              <1> %if g_szDeviceTypeValues_JrIde <> g_szDeviceTypeValues_XTCFmem + g_szDeviceTypeValues_Displacement
  4921                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 8"
  4922                              <1> %endif
  4923                              <1> %if g_szDeviceTypeValues_Serial <> g_szDeviceTypeValues_JrIde + g_szDeviceTypeValues_Displacement
  4924                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 9"
  4925                              <1> %endif
  4926                              <1> %endif
  4927                              <1> 
  4928                              <1> 
  4929                              <1> g_szSelectionTimeout:	; db	DOUBLE_BOTTOM_LEFT_CORNER,DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL,"%ASelection in %2-u s",NULL
  4930                              <1>                      	; db	0c8h, 0b5h,  25h,  41h,  53h,  65h,  6ch,  65h,  63h,  74h,  69h,  6fh,  6eh,  20h,  69h,  6eh,  20h,  25h,  32h,  2dh,  75h,  20h,  73h,  00h    ; uncompressed
  4931                              <1>                      	  db	 31h,  32h,  3bh,  59h,  6bh,  72h,  6bh,  69h,  7ah,  6fh,  75h, 0f4h,  6fh, 0f4h,  3ah,  20h, 0b9h                                              ; compressed
  4932                              <1> 
  4933                              <1> 
  4934                              <1> 
  4935                              <1> ; Boot Menu information strings
  4936                              <1> g_szCapacity:			; db	"Capacity : %s",NULL
  4937                              <1>              			; db	 43h,  61h,  70h,  61h,  63h,  69h,  74h,  79h,  20h,  3ah,  20h,  25h,  73h,  00h    ; uncompressed
  4938                              <1>              			  db	 49h,  67h,  76h,  67h,  69h,  6fh,  7ah, 0ffh, 0c0h,  1dh                            ; compressed
  4939                              <1> 
  4940                              <1> g_szCapacityNum:		; db	"%5-u.%u %ciB",NULL
  4941                              <1>                 		; db	 25h,  35h,  2dh,  75h,  2eh,  25h,  75h,  20h,  25h,  63h,  69h,  42h,  00h    ; uncompressed
  4942                              <1>                 		  db	 36h,  29h,  35h,  20h,  3ch,  6fh,  88h                                        ; compressed
  4943                              <1> 
  4944                              <1> g_szInformation:		; db	"%s",LF,CR
  4945                              <1>                 		; db	 25h,  73h,  0ah,  0dh    ; uncompressed
  4946                              <1>                 		  db	 3dh,  39h                ; compressed
  4947                              <1> 
  4948                              <1> 	; db	"Addr. ",SINGLE_VERTICAL,"Block",SINGLE_VERTICAL,"Bus",SINGLE_VERTICAL,"IRQ",SINGLE_VERTICAL,"Reset",LF,CR
  4949                              <1> 	; db	 41h,  64h,  64h,  72h,  2eh,  20h, 0b3h,  42h,  6ch,  6fh,  63h,  6bh, 0b3h,  42h,  75h,  73h, 0b3h,  49h,  52h,  51h, 0b3h,  52h,  65h,  73h,  65h,  74h,  0ah,  0dh    ; uncompressed
  4950                              <1> 	  db	 47h,  6ah,  6ah,  78h,  29h,  20h,  23h,  48h,  72h,  75h,  69h,  71h,  23h,  48h,  7bh,  79h,  23h,  4fh,  58h,  57h,  23h,  58h,  6bh,  79h,  6bh,  7ah,  39h          ; compressed
  4951                              <1> 
  4952                              <1> 	; db	"%s",SINGLE_VERTICAL,"%5-u",SINGLE_VERTICAL,"%s",SINGLE_VERTICAL," %2-I",SINGLE_VERTICAL,"%5-x",NULL
  4953                              <1> 	; db	 25h,  73h, 0b3h,  25h,  35h,  2dh,  75h, 0b3h,  25h,  73h, 0b3h,  20h,  25h,  32h,  2dh,  49h, 0b3h,  25h,  35h,  2dh,  78h,  00h    ; uncompressed
  4954                              <1> 	  db	 3dh,  23h,  36h,  23h,  3dh,  23h,  20h,  34h,  23h,  18h                                                                            ; compressed
  4955                              <1> 
  4956                              <1> 
  4957                              <1> 
  4958                              <1> ; Boot Menu menuitem strings
  4959                              <1> ;
  4960                              <1> ; The following strings are used by BootMenuPrint_* routines.
  4961                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
  4962                              <1> ; which is checked at assembly time below.
  4963                              <1> ;
  4964                              <1> g_szDriveNumSpace:		; db	" "							; leading space, used if drive number is less than 0fh
  4965                              <1>                   		; db	 20h    ; uncompressed
  4966                              <1>                   		  db	 20h    ; compressed
  4967                              <1> 
  4968                              <1> ; must come immediately before g_szDriveNum!
  4969                              <1> g_szBootMenuPrintStart:
  4970                              <1> g_szDriveNum:			; db	"%x %s",NULL
  4971                              <1>              			; db	 25h,  78h,  20h,  25h,  73h,  00h    ; uncompressed
  4972                              <1>              			  db	 37h,  20h,  1dh                      ; compressed
  4973                              <1> 
  4974                              <1> g_szDriveNumBNSpace:	; db	" "							; leading space, used if drive number is less than 0fh
  4975                              <1>                     	; db	 20h    ; uncompressed
  4976                              <1>                     	  db	 20h    ; compressed
  4977                              <1> 
  4978                              <1> ; must come immediately before g_szDriveNumBOOTNFO!
  4979                              <1> g_szDriveNumBOOTNFO:	; db	"%x %z",NULL
  4980                              <1>                     	; db	 25h,  78h,  20h,  25h,  7ah,  00h    ; uncompressed
  4981                              <1>                     	  db	 37h,  20h,  1eh                      ; compressed
  4982                              <1> 
  4983                              <1> g_szFloppyDrv:			; db	"Floppy Drive %c",NULL
  4984                              <1>               			; db	 46h,  6ch,  6fh,  70h,  70h,  79h,  20h,  44h,  72h,  69h,  76h,  65h,  20h,  25h,  63h,  00h    ; uncompressed
  4985                              <1>               			  db	 4ch,  72h,  75h,  76h,  76h, 0ffh,  4ah,  78h,  6fh,  7ch, 0ebh,  1ch                            ; compressed
  4986                              <1> 
  4987                              <1> g_szBootMenuPrintEnd:
  4988                              <1> g_szForeignHD:			; db	"Foreign Hard Disk",NULL
  4989                              <1>               			; db	 46h,  6fh,  72h,  65h,  69h,  67h,  6eh,  20h,  48h,  61h,  72h,  64h,  20h,  44h,  69h,  73h,  6bh,  00h    ; uncompressed
  4990                              <1>               			  db	 4ch,  75h,  78h,  6bh,  6fh,  6dh, 0f4h,  4eh,  67h,  78h, 0eah,  4ah,  6fh,  79h, 0b1h                      ; compressed
  4991                              <1> 
  4992                              <1> 
  4993                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  4994                              <1> %if ((g_szBootMenuPrintStart-$$) & 0xff00) <> ((g_szBootMenuPrintEnd-$$) & 0xff00)
  4995                              <1> %error "g_szBootMenuPrint* strings must start on the same 256 byte page, required by the BootMenuPrint_* routines.  Please move this block up or down within Strings.asm"
  4996                              <1> %endif
  4997                              <1> %if g_szDriveNumSpace+1 != g_szDriveNum || g_szDriveNumBNSpace+1 != g_szDriveNumBOOTNFO
  4998                              <1> %error "g_szDriveNumSpace or g_szDriveNumBNSpace are out of position"
  4999                              <1> %endif
  5000                              <1> %endif
  5001                              <1> 
  5002                              <1> %endif ; MODULE_BOOT_MENU
  5003                              <1> 
  5004                              <1> 
  5005                              <1> ;------------------------------------------------------------------------------------------
  5006                              <1> ;
  5007                              <1> ; Tables for StringsCompress.pl
  5008                              <1> ;
  5009                              <1> ; Items can be added and removed from this table as needed, with the following rules:
  5010                              <1> ;  * Formats follow the special characters.  But other than that, order makes no difference.
  5011                              <1> ;  * Some of the formats require "even" and "odd" numbering.  Even tells the code that
  5012                              <1> ;    it is a "number-" format, otherwise it doesn't interpret a number first.  The easiest
  5013                              <1> ;    way to maintain this is to move one of the "n/a" items to/from the front of the format
  5014                              <1> ;    list to maintain the even/odd.
  5015                              <1> ;  * Values do not need to remain consistent across versions.  This table is only used
  5016                              <1> ;    internally to this file.
  5017                              <1> ;  * There can only be 32 of these (0-31).
  5018                              <1> ;  * Keeping the list short is good - this translates to a table in the compressed version.
  5019                              <1> ;    An error will be reported if a character or format is no longer being used by any
  5020                              <1> ;    strings above.
  5021                              <1> ;  * Please keep items sequential for ease of further editing.
  5022                              <1> ;
  5023                              <1> ;$translate{ord(' ')} = 0;    [StringsCompress Processed]
  5024                              <1> ;$translate{172}      = 1;     # ONE_QUARTER    [StringsCompress Processed]
  5025                              <1> ;$translate{171}      = 2;     # ONE_HALF    [StringsCompress Processed]
  5026                              <1> ;$translate{179}      = 3;     # SINGLE_VERTICAL    [StringsCompress Processed]
  5027                              <1> ;$translate{175}      = 4;     # ANGLE_QUOTE_RIGHT    [StringsCompress Processed]
  5028                              <1> ;$translate{ord('!')} = 5;    [StringsCompress Processed]
  5029                              <1> ;$translate{ord('"')} = 6;    [StringsCompress Processed]
  5030                              <1> ;$translate{ord(',')} = 7;    [StringsCompress Processed]
  5031                              <1> ;$translate{ord('-')} = 8;    [StringsCompress Processed]
  5032                              <1> ;$translate{ord('.')} = 9;    [StringsCompress Processed]
  5033                              <1> ;$translate{ord('/')} = 10;    [StringsCompress Processed]
  5034                              <1> ;$translate{ord('1')} = 11;    [StringsCompress Processed]
  5035                              <1> ;$translate{ord('2')} = 12;    [StringsCompress Processed]
  5036                              <1> ;$translate{ord('3')} = 13;    [StringsCompress Processed]
  5037                              <1> ;$translate{ord('5')} = 14;    [StringsCompress Processed]
  5038                              <1> ;$translate{ord('6')} = 15;    [StringsCompress Processed]
  5039                              <1> ;$translate{ord('8')} = 16;    [StringsCompress Processed]
  5040                              <1> ;$translate{200}      = 17;    # DOUBLE_BOTTOM_LEFT_CORNER    [StringsCompress Processed]
  5041                              <1> ;$translate{181}      = 18;    # DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL    [StringsCompress Processed]
  5042                              <1> ;$translate{ord('0')} = 19;    [StringsCompress Processed]
  5043                              <1> ;
  5044                              <1> ; Formats begin immediately after the last Translated character (they are in the same table)
  5045                              <1> ;
  5046                              <1> ;$format_begin = 20;    [StringsCompress Processed]
  5047                              <1> ;
  5048                              <1> ;$format{"2-I"} = 20;        # must be even    [StringsCompress Processed]
  5049                              <1> ;$format{"u"}   = 21;        # must be odd    [StringsCompress Processed]
  5050                              <1> ;$format{"5-u"} = 22;        # must be even    [StringsCompress Processed]
  5051                              <1> ;$format{"x"}   = 23;        # must be odd    [StringsCompress Processed]
  5052                              <1> ;$format{"5-x"} = 24;        # must be even    [StringsCompress Processed]
  5053                              <1> ;$format{"nl"}  = 25;        # n/a    [StringsCompress Processed]
  5054                              <1> ;$format{"2-u"} = 26;        # must be even    [StringsCompress Processed]
  5055                              <1> ;$format{"A"}   = 27;        # n/a    [StringsCompress Processed]
  5056                              <1> ;$format{"c"}   = 28;        # n/a    [StringsCompress Processed]
  5057                              <1> ;$format{"s"}   = 29;        # n/a, normal string from DS    [StringsCompress Processed]
  5058                              <1> ;$format{"z"}   = 30;        # n/a, boot string from BDA    [StringsCompress Processed]
  5059                              <1> ;
  5060                              <1> ; NOTE: The last $format cannot exceed 31 (stored in a 5-bit quantity).
  5061                              <1> ;
  5062                              <1> ; Starting point for the "normal" range, typically around 0x40 to cover upper and lower case
  5063                              <1> ; letters.  If lower case 'z' is not used, 0x3a can be a good choice as it adds ':' to the
  5064                              <1> ; front end.
  5065                              <1> ;
  5066                              <1> ;$normal_base = 0x3a;    [StringsCompress Processed]
  5067                              <1> ;
  5068                              <1> ; End of StringsCompress.pl information
  5069                              <1> ;
  5070                              <1> ;;; end of input stream
  5071                              <1> 
  5072                              <1> %endif ; STRINGSCOMPRESSED_STRINGS
  5073                              <1> 
  5074                              <1> %ifdef STRINGSCOMPRESSED_TABLES
  5075                              <1> 
  5076                              <1> StringsCompressed_NormalBase     equ   58
  5077                              <1> 
  5078                              <1> StringsCompressed_FormatsBegin   equ   20
  5079                              <1> 
  5080                              <1> StringsCompressed_TranslatesAndFormats:
  5081                              <1>         db     32  ; 0
  5082                              <1>         db     172  ; 1
  5083                              <1>         db     171  ; 2
  5084                              <1>         db     179  ; 3
  5085                              <1>         db     175  ; 4
  5086                              <1>         db     33  ; 5
  5087                              <1>         db     34  ; 6
  5088                              <1>         db     44  ; 7
  5089                              <1>         db     45  ; 8
  5090                              <1>         db     46  ; 9
  5091                              <1>         db     47  ; 10
  5092                              <1>         db     49  ; 11
  5093                              <1>         db     50  ; 12
  5094                              <1>         db     51  ; 13
  5095                              <1>         db     53  ; 14
  5096                              <1>         db     54  ; 15
  5097                              <1>         db     56  ; 16
  5098                              <1>         db     200  ; 17
  5099                              <1>         db     181  ; 18
  5100                              <1>         db     48  ; 19
  5101                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I)    ; 20
  5102                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u)    ; 21
  5103                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u)    ; 22
  5104                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x)    ; 23
  5105                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x)    ; 24
  5106                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl)    ; 25
  5107                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u)    ; 26
  5108                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A)    ; 27
  5109                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c)    ; 28
  5110                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s)    ; 29
  5111                              <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z)    ; 30
  5112                              <1> 
  5113                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  5114                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_I || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I > 255
  5115                              <1> %error "DisplayFormatCompressed_Format_2_I is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5116                              <1> %endif
  5117                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u > 255
  5118                              <1> %error "DisplayFormatCompressed_Format_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5119                              <1> %endif
  5120                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u > 255
  5121                              <1> %error "DisplayFormatCompressed_Format_5_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5122                              <1> %endif
  5123                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x > 255
  5124                              <1> %error "DisplayFormatCompressed_Format_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5125                              <1> %endif
  5126                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x > 255
  5127                              <1> %error "DisplayFormatCompressed_Format_5_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5128                              <1> %endif
  5129                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_nl || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl > 255
  5130                              <1> %error "DisplayFormatCompressed_Format_nl is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5131                              <1> %endif
  5132                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u > 255
  5133                              <1> %error "DisplayFormatCompressed_Format_2_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5134                              <1> %endif
  5135                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_A || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A > 255
  5136                              <1> %error "DisplayFormatCompressed_Format_A is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5137                              <1> %endif
  5138                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_c || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c > 255
  5139                              <1> %error "DisplayFormatCompressed_Format_c is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5140                              <1> %endif
  5141                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_s || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s > 255
  5142                              <1> %error "DisplayFormatCompressed_Format_s is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5143                              <1> %endif
  5144                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_z || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z > 255
  5145                              <1> %error "DisplayFormatCompressed_Format_z is out of range of DisplayFormatCompressed_BaseFormatOffset"
  5146                              <1> %endif
  5147                              <1> %endif
  5148                              <1> 
  5149                              <1> ;; translated usage stats
  5150                              <1> ;; 33:1
  5151                              <1> ;; 32:34
  5152                              <1> ;; 181:1
  5153                              <1> ;; 53:2
  5154                              <1> ;; 48:2
  5155                              <1> ;; 200:1
  5156                              <1> ;; 46:3
  5157                              <1> ;; 179:8
  5158                              <1> ;; 44:1
  5159                              <1> ;; 50:2
  5160                              <1> ;; 51:3
  5161                              <1> ;; 47:2
  5162                              <1> ;; 172:2
  5163                              <1> ;; 34:3
  5164                              <1> ;; 49:1
  5165                              <1> ;; 56:7
  5166                              <1> ;; 45:2
  5167                              <1> ;; 175:1
  5168                              <1> ;; 171:2
  5169                              <1> ;; 54:1
  5170                              <1> ;; total translated: 20
  5171                              <1> 
  5172                              <1> ;; format usage stats
  5173                              <1> ;; A:4
  5174                              <1> ;; 2-u:1
  5175                              <1> ;; 5-u:2
  5176                              <1> ;; x:5
  5177                              <1> ;; s:14
  5178                              <1> ;; 5-x:1
  5179                              <1> ;; nl:12
  5180                              <1> ;; 2-I:1
  5181                              <1> ;; u:6
  5182                              <1> ;; c:13
  5183                              <1> ;; z:2
  5184                              <1> ;; total format: 11
  5185                              <1> 
  5186                              <1> ;; alphabet usage stats
  5187                              <1> ;; 58,::2
  5188                              <1> ;; 59,;:
  5189                              <1> ;; 60,<:
  5190                              <1> ;; 61,=:
  5191                              <1> ;; 62,>:
  5192                              <1> ;; 63,?:
  5193                              <1> ;; 64,@:1
  5194                              <1> ;; 65,A:5
  5195                              <1> ;; 66,B:9
  5196                              <1> ;; 67,C:3
  5197                              <1> ;; 68,D:11
  5198                              <1> ;; 69,E:3
  5199                              <1> ;; 70,F:3
  5200                              <1> ;; 71,G:3
  5201                              <1> ;; 72,H:2
  5202                              <1> ;; 73,I:1
  5203                              <1> ;; 74,J:
  5204                              <1> ;; 75,K:1
  5205                              <1> ;; 76,L:4
  5206                              <1> ;; 77,M:7
  5207                              <1> ;; 78,N:2
  5208                              <1> ;; 79,O:2
  5209                              <1> ;; 80,P:1
  5210                              <1> ;; 81,Q:1
  5211                              <1> ;; 82,R:7
  5212                              <1> ;; 83,S:3
  5213                              <1> ;; 84,T:1
  5214                              <1> ;; 85,U:2
  5215                              <1> ;; 86,V:
  5216                              <1> ;; 87,W:
  5217                              <1> ;; 88,X:1
  5218                              <1> ;; 89,Y:
  5219                              <1> ;; 90,Z:
  5220                              <1> ;; 91,[:2
  5221                              <1> ;; 92,\:
  5222                              <1> ;; 93,]:2
  5223                              <1> ;; 94,^:
  5224                              <1> ;; 95,_:
  5225                              <1> ;; 96,`:
  5226                              <1> ;; 97,a:7
  5227                              <1> ;; 98,b:
  5228                              <1> ;; 99,c:6
  5229                              <1> ;; 100,d:6
  5230                              <1> ;; 101,e:15
  5231                              <1> ;; 102,f:1
  5232                              <1> ;; 103,g:2
  5233                              <1> ;; 104,h:
  5234                              <1> ;; 105,i:9
  5235                              <1> ;; 106,j:
  5236                              <1> ;; 107,k:4
  5237                              <1> ;; 108,l:5
  5238                              <1> ;; 109,m:2
  5239                              <1> ;; 110,n:11
  5240                              <1> ;; 111,o:20
  5241                              <1> ;; 112,p:3
  5242                              <1> ;; 113,q:
  5243                              <1> ;; 114,r:11
  5244                              <1> ;; 115,s:7
  5245                              <1> ;; 116,t:15
  5246                              <1> ;; 117,u:4
  5247                              <1> ;; 118,v:3
  5248                              <1> ;; 119,w:1
  5249                              <1> ;; 120,x:
  5250                              <1> ;; 121,y:2
  5251                              <1> ;; alphabet used count: 45
  5252                              <1> %endif ; STRINGSCOMPRESSED_TABLES
  5253                              <1> 
  5254                                  %else
  5255                                  	%include "Strings.asm"			; For BIOS message strings
  5256                                  %endif
  5257                                  
  5258                                  	; Libraries, data, Initialization and drive detection
  5259                                  
  5260                                  	%include "AssemblyLibrary.asm"
  5261                              <1> ; Project name	:	Assembly Library
  5262                              <1> ; Description	:	Assembly Library main file. This is the only file that
  5263                              <1> ;					needs to be included.
  5264                              <1> 
  5265                              <1> ;
  5266                              <1> ; XTIDE Universal BIOS and Associated Tools
  5267                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5268                              <1> ;
  5269                              <1> ; This program is free software; you can redistribute it and/or modify
  5270                              <1> ; it under the terms of the GNU General Public License as published by
  5271                              <1> ; the Free Software Foundation; either version 2 of the License, or
  5272                              <1> ; (at your option) any later version.
  5273                              <1> ;
  5274                              <1> ; This program is distributed in the hope that it will be useful,
  5275                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5276                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5277                              <1> ; GNU General Public License for more details.
  5278                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5279                              <1> ;
  5280                              <1> 
  5281                              <1> ; Section containing code
  5282                              <1> SECTION .text
  5283                              <1> 
  5284                              <1> %ifdef INCLUDE_DISPLAY_LIBRARY
  5285                              <1>   %ifndef DISPLAY_JUMP_ALIGN
  5286                              <1> 	%define DISPLAY_JUMP_ALIGN 1
  5287                              <1>   %endif
  5288                              <1> 	%include "CgaSnow.asm"
  5289                              <2> ; Project name	:	Assembly Library
  5290                              <2> ; Description	:	Functions for preventing CGA snow.
  5291                              <2> 
  5292                              <2> ;
  5293                              <2> ; XTIDE Universal BIOS and Associated Tools
  5294                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5295                              <2> ;
  5296                              <2> ; This program is free software; you can redistribute it and/or modify
  5297                              <2> ; it under the terms of the GNU General Public License as published by
  5298                              <2> ; the Free Software Foundation; either version 2 of the License, or
  5299                              <2> ; (at your option) any later version.
  5300                              <2> ;
  5301                              <2> ; This program is distributed in the hope that it will be useful,
  5302                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5303                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5304                              <2> ; GNU General Public License for more details.
  5305                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5306                              <2> ;
  5307                              <2> 
  5308                              <2> ; Section containing code
  5309                              <2> SECTION .text
  5310                              <2> 
  5311                              <2> ;--------------------------------------------------------------------
  5312                              <2> ; CgaSnow_IsCgaPresent
  5313                              <2> ;	Parameters:
  5314                              <2> ;		DS:		BDA segment (zero)
  5315                              <2> ;	Returns:
  5316                              <2> ;		CF:		Set if CGA detected
  5317                              <2> ;				Cleared if CGA not detected
  5318                              <2> ;	Corrupts registers:
  5319                              <2> ;		AX
  5320                              <2> ;--------------------------------------------------------------------
  5321                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5322                              <2> CgaSnow_IsCgaPresent:
  5323 00000141 813E6304D403        <2> 	cmp		WORD [BDA.wVidPort], CGA_STATUS_REGISTER - OFFSET_TO_CGA_STATUS_REGISTER
  5324 00000147 7509                <2> 	jne		SHORT .CgaNotFound
  5325                              <2> 
  5326                              <2> 	; All standard CGA modes use 25 rows but only EGA and later store it to BDA.
  5327 00000149 803E840419          <2> 	cmp		BYTE [BDA.bVidRows], 25
  5328 0000014E 7D02                <2> 	jge		SHORT .CgaNotFound
  5329 00000150 F9                  <2> 	stc
  5330 00000151 C3                  <2> 	ret
  5331                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5332                              <2> .CgaNotFound:
  5333 00000152 F8                  <2> 	clc
  5334 00000153 C3                  <2> 	ret
  5335                              <2> 
  5336                              <2> 
  5337                              <2> ; CGA snow prevention must be kept optional to avoid unnecessary
  5338                              <2> ; overhead when building programs meant for non-CGA systems.
  5339                              <2> %ifdef ELIMINATE_CGA_SNOW
  5340                              <2> 
  5341                              <2> ;--------------------------------------------------------------------
  5342                              <2> ; CgaSnow_Stosb
  5343                              <2> ; CgaSnow_Stosw
  5344                              <2> ;	Parameters:
  5345                              <2> ;		AL:		Character to output
  5346                              <2> ;		AH:		Attribute to output (CgaSnow_StoswWithoutCgaSnow only)
  5347                              <2> ;		DS:		BDA segment (zero)
  5348                              <2> ;		ES:DI:	Ptr to video memory where to output
  5349                              <2> ;	Returns:
  5350                              <2> ;		DI:		Incremented for next character
  5351                              <2> ;	Corrupts registers:
  5352                              <2> ;		AX, DX
  5353                              <2> ;--------------------------------------------------------------------
  5354                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5355                              <2> CgaSnow_Stosb:
  5356 00000154 E82B00              <2> 	call	LoadCgaStatusRegisterAddressToDXifCgaPresent
  5357 00000157 740F                <2> 	jz		SHORT .StosbWithoutWaitSinceUnknownPort
  5358                              <2> 
  5359 00000159 88C4                <2> 	mov		ah, al
  5360 0000015B FA                  <2> 	cli				; Interrupt request would mess up timing
  5361                              <2> 	WAIT_UNTIL_SAFE_CGA_WRITE
  5362                              <3> %%WaitUntilNotInRetrace:
  5363 0000015C EC                  <3>  in al, dx
  5364 0000015D D0E8                <3>  shr al, 1
  5365                              <3> 
  5366 0000015F 72FB                <3>  jc SHORT %%WaitUntilNotInRetrace
  5367                              <3> %%WaitUntilNextRetraceStarts:
  5368 00000161 EC                  <3>  in al, dx
  5369 00000162 D0E8                <3>  shr al, 1
  5370 00000164 73FB                <3>  jnc SHORT %%WaitUntilNextRetraceStarts
  5371 00000166 88E0                <2> 	mov		al, ah
  5372                              <2> .StosbWithoutWaitSinceUnknownPort:
  5373 00000168 AA                  <2> 	stosb
  5374 00000169 FB                  <2> 	sti
  5375 0000016A C3                  <2> 	ret
  5376                              <2> 
  5377                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5378                              <2> CgaSnow_Stosw:
  5379 0000016B 53                  <2> 	push	bx
  5380 0000016C E81300              <2> 	call	LoadCgaStatusRegisterAddressToDXifCgaPresent
  5381 0000016F 740D                <2> 	jz		SHORT .StoswWithoutWaitSinceUnknownPort
  5382                              <2> 
  5383 00000171 93                  <2> 	xchg	bx, ax
  5384 00000172 FA                  <2> 	cli				; Interrupt request would mess up timing
  5385                              <2> 	WAIT_UNTIL_SAFE_CGA_WRITE
  5386                              <3> %%WaitUntilNotInRetrace:
  5387 00000173 EC                  <3>  in al, dx
  5388 00000174 D0E8                <3>  shr al, 1
  5389                              <3> 
  5390 00000176 72FB                <3>  jc SHORT %%WaitUntilNotInRetrace
  5391                              <3> %%WaitUntilNextRetraceStarts:
  5392 00000178 EC                  <3>  in al, dx
  5393 00000179 D0E8                <3>  shr al, 1
  5394 0000017B 73FB                <3>  jnc SHORT %%WaitUntilNextRetraceStarts
  5395 0000017D 93                  <2> 	xchg	ax, bx
  5396                              <2> .StoswWithoutWaitSinceUnknownPort:
  5397 0000017E AB                  <2> 	stosw
  5398 0000017F FB                  <2> 	sti
  5399 00000180 5B                  <2> 	pop		bx
  5400 00000181 C3                  <2> 	ret
  5401                              <2> 
  5402                              <2> 
  5403                              <2> ;--------------------------------------------------------------------
  5404                              <2> ; CgaSnow_RepMovsb
  5405                              <2> ;	Parameters:
  5406                              <2> ;		CX:		Number of characters to copy
  5407                              <2> ;		DS:		BDA segment (zero)
  5408                              <2> ;		ES:SI:	Ptr to video memory where to read from
  5409                              <2> ;		ES:DI:	Ptr to video memory where to write to
  5410                              <2> ;	Returns:
  5411                              <2> ;		SI, DI:	Updated for next character
  5412                              <2> ;	Corrupts registers:
  5413                              <2> ;		AX, CX, DX
  5414                              <2> ;--------------------------------------------------------------------
  5415                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5416                              <2> 	%ifdef MODULE_STRINGS_COMPRESSED
  5417                              <2> 		%define EXCLUDE
  5418                              <2> 	%endif
  5419                              <2> 	%ifdef MODULE_BOOT_MENU
  5420                              <2> 		%undef EXCLUDE
  5421                              <2> 	%endif
  5422                              <2> %endif
  5423                              <2> 
  5424                              <2> %ifndef EXCLUDE
  5425                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5426                              <2> CgaSnow_RepMovsb:
  5427                              <2> 	call	LoadCgaStatusRegisterAddressToDXifCgaPresent
  5428                              <2> 	jz		SHORT .RepMovsbWithoutWaitSinceUnknownPort
  5429                              <2> 
  5430                              <2> .MovsbNextByte:
  5431                              <2> 	cli				; Interrupt request would mess up timing
  5432                              <2> 	WAIT_UNTIL_SAFE_CGA_WRITE
  5433                              <2> 	es movsb
  5434                              <2> 	sti
  5435                              <2> 	loop	.MovsbNextByte
  5436                              <2> 	ret
  5437                              <2> .RepMovsbWithoutWaitSinceUnknownPort:
  5438                              <2> 	eSEG_STR rep, es, movsb
  5439                              <2> 	ret
  5440                              <2> %endif
  5441                              <2> %undef EXCLUDE
  5442                              <2> 
  5443                              <2> 
  5444                              <2> ;--------------------------------------------------------------------
  5445                              <2> ; LoadCgaStatusRegisterAddressToDXifCgaPresent
  5446                              <2> ;	Parameters:
  5447                              <2> ;		DS:		BDA segment (zero)
  5448                              <2> ;	Returns:
  5449                              <2> ;		DX:		CGA Status Register Address
  5450                              <2> ;		ZF:		Set if CGA not present
  5451                              <2> ;				Cleared if CGA present
  5452                              <2> ;	Corrupts registers:
  5453                              <2> ;		Nothing
  5454                              <2> ;--------------------------------------------------------------------
  5455                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5456                              <2> LoadCgaStatusRegisterAddressToDXifCgaPresent:
  5457 00000182 F6065F0402          <2> 	test	BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], FLG_CONTEXT_CGA
  5458 00000187 7403                <2> 	jz		SHORT .NoCgaDetected
  5459 00000189 BADA03              <2> 	mov		dx, CGA_STATUS_REGISTER
  5460                              <2> ALIGN DISPLAY_JUMP_ALIGN, ret
  5461                              <2> .NoCgaDetected:
  5462 0000018C C3                  <2> 	ret
  5463                              <2> 
  5464                              <2> 
  5465                              <2> %endif ; ELIMINATE_CGA_SNOW
  5466                              <1> 	%include "Display.asm"
  5467                              <2> ; Project name	:	Assembly Library
  5468                              <2> ; Description	:	Display Library functions for CALL_DISPLAY_LIBRARY macro
  5469                              <2> ;					that users should use to make library call.
  5470                              <2> 
  5471                              <2> ;
  5472                              <2> ; XTIDE Universal BIOS and Associated Tools
  5473                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5474                              <2> ;
  5475                              <2> ; This program is free software; you can redistribute it and/or modify
  5476                              <2> ; it under the terms of the GNU General Public License as published by
  5477                              <2> ; the Free Software Foundation; either version 2 of the License, or
  5478                              <2> ; (at your option) any later version.
  5479                              <2> ;
  5480                              <2> ; This program is distributed in the hope that it will be useful,
  5481                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5482                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5483                              <2> ; GNU General Public License for more details.
  5484                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5485                              <2> ;
  5486                              <2> 
  5487                              <2> ; Section containing code
  5488                              <2> SECTION .text
  5489                              <2> 
  5490                              <2> ;--------------------------------------------------------------------
  5491                              <2> ; DisplayFunctionFromDI
  5492                              <2> ;	Parameters:
  5493                              <2> ;		DI:		Function to call (DISPLAY_LIB.functionName)
  5494                              <2> ;		Others:	Depends on function to call (DX cannot be parameter)
  5495                              <2> ;	Returns:
  5496                              <2> ;		Depends on function to call
  5497                              <2> ;	Corrupts registers:
  5498                              <2> ;		AX (unless used as a return register), DI
  5499                              <2> ;--------------------------------------------------------------------
  5500                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5501                              <2> Display_FunctionFromDI:
  5502 0000018D 06                  <2> 	push	es
  5503 0000018E 1E                  <2> 	push	ds
  5504 0000018F 52                  <2> 	push	dx
  5505                              <2> 
  5506 00000190 FC                  <2> 	cld
  5507                              <2> 	LOAD_BDA_SEGMENT_TO	ds, dx
  5508                              <3> %ifndef USE_186
  5509 00000191 31D2                <3>  xor %2, %2
  5510 00000193 8EDA                <3>  mov %1, %2
  5511                              <3> %elifidn %3, !
  5512                              <3>  xor %2, %2
  5513                              <3>  mov %1, %2
  5514                              <3> %else
  5515                              <3>  push BYTE 0
  5516                              <3>  pop %1
  5517                              <3> %endif
  5518 00000195 89FA                <2> 	mov		dx, di
  5519 00000197 C43E5404            <2> 	les		di, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
  5520 0000019B FFD2                <2> 	call	dx
  5521 0000019D 893E5404            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], di
  5522                              <2> 
  5523 000001A1 5A                  <2> 	pop		dx
  5524 000001A2 1F                  <2> 	pop		ds
  5525 000001A3 07                  <2> 	pop		es
  5526 000001A4 C3                  <2> 	ret
  5527                              <2> 
  5528                              <2> ;--------------------------------------------------------------------
  5529                              <2> ; Display_FormatNullTerminatedStringFromCSSI
  5530                              <2> ;	Parameters:
  5531                              <2> ;		Same as DisplayPrint_FormattedNullTerminatedStringFromCSSI
  5532                              <2> ;	Returns:
  5533                              <2> ;		Stack variables will be cleaned
  5534                              <2> ;	Corrupts registers:
  5535                              <2> ;		AX
  5536                              <2> ;--------------------------------------------------------------------
  5537                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5538                              <2> Display_FormatNullTerminatedStringFromCSSI:
  5539 000001A5 58                  <2> 	pop		ax					; Discard return address to inside Display_FunctionFromDI
  5540 000001A6 E80501              <2> 	call	DisplayPrint_FormattedNullTerminatedStringFromCSSI
  5541 000001A9 893E5404            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], di
  5542                              <2> 
  5543 000001AD 5A                  <2> 	pop		dx
  5544 000001AE 1F                  <2> 	pop		ds
  5545 000001AF 07                  <2> 	pop		es
  5546                              <2> 
  5547 000001B0 58                  <2> 	pop		ax					; Pop return address
  5548 000001B1 89EC                <2> 	mov		sp, bp				; Clean stack variables
  5549 000001B3 FFE0                <2> 	jmp		ax
  5550                              <2> 
  5551                              <2> 
  5552                              <2> 	%define InitializeDisplayContext						DisplayContext_Initialize
  5553                              <2> 
  5554                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5555                              <2> 	%define SetCharacterPointerFromBXAX						DisplayContext_SetCharacterPointerFromBXAX
  5556                              <2> %endif
  5557                              <2> 	%define SetCharOutputFunctionFromAXwithAttribFlagInBL	DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL
  5558                              <2> 	%define SetCharacterOutputParameterFromAX				DisplayContext_SetCharacterOutputParameterFromAX
  5559                              <2> 	%define SetCharacterAttributeFromAL						DisplayContext_SetCharacterAttributeFromAL
  5560                              <2> 	%define SetCursorShapeFromAX							DisplayCursor_SetShapeFromAX
  5561                              <2> 	%define SetCursorCoordinatesFromAX						DisplayCursor_SetCoordinatesFromAX
  5562                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  5563                              <2> 	%define SetNewPageFromAL								DisplayPage_SetFromAL
  5564                              <2> %endif
  5565                              <2> 	%define SynchronizeDisplayContextToHardware				DisplayContext_SynchronizeToHardware
  5566                              <2> 
  5567                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5568                              <2> 	%define GetCharacterPointerToBXAX						DisplayContext_GetCharacterPointerToBXAX
  5569                              <2> %endif
  5570                              <2> 	%define GetSoftwareCoordinatesToAX						DisplayCursor_GetSoftwareCoordinatesToAX
  5571                              <2> 	%define GetColumnsToALandRowsToAH						DisplayPage_GetColumnsToALandRowsToAH
  5572                              <2> 
  5573                              <2> 	%define FormatNullTerminatedStringFromCSSI				Display_FormatNullTerminatedStringFromCSSI
  5574                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5575                              <2> 	%define PrintSignedWordFromAXWithBaseInBX				DisplayPrint_SignedWordFromAXWithBaseInBX
  5576                              <2> %endif
  5577                              <2> 	%define PrintWordFromAXwithBaseInBX						DisplayPrint_WordFromAXWithBaseInBX
  5578                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  5579                              <2> 	%define PrintQWordFromSSBPwithBaseInBX					DisplayPrint_QWordFromSSBPwithBaseInBX
  5580                              <2> %endif
  5581                              <2> 	%define PrintCharBufferFromBXSIwithLengthInCX			DisplayPrint_CharacterBufferFromBXSIwithLengthInCX
  5582                              <2> 	%define PrintNullTerminatedStringFromBXSI				DisplayPrint_NullTerminatedStringFromBXSI
  5583                              <2> 	%define PrintNullTerminatedStringFromCSSI				DisplayPrint_NullTerminatedStringFromCSSI
  5584                              <2> 	%define PrintRepeatedCharacterFromALwithCountInCX		DisplayPrint_RepeatCharacterFromALwithCountInCX
  5585                              <2> 	%define PrintCharacterFromAL							DisplayPrint_CharacterFromAL
  5586                              <2> 	%define PrintNewlineCharacters							DisplayPrint_Newline
  5587                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5588                              <2> 	%define ClearAreaWithHeightInAHandWidthInAL				DisplayPrint_ClearAreaWithHeightInAHandWidthInAL
  5589                              <2> %endif
  5590                              <2> 	%define ClearScreenWithCharInALandAttrInAH				DisplayPrint_ClearScreenWithCharInALandAttributeInAH
  5591                              <2> 
  5592                              <1> 	%include "DisplayCharOut.asm"
  5593                              <2> ; Project name	:	Assembly Library
  5594                              <2> ; Description	:	Functions for outputting characters to video memory.
  5595                              <2> ;					These functions are meant to be called by Display_CharacterFromAL
  5596                              <2> ;					and Display_RepeatCharacterFromAL using function pointer
  5597                              <2> ;					stored in DISPLAY_CONTEXT.
  5598                              <2> 
  5599                              <2> ;
  5600                              <2> ; XTIDE Universal BIOS and Associated Tools
  5601                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5602                              <2> ;
  5603                              <2> ; This program is free software; you can redistribute it and/or modify
  5604                              <2> ; it under the terms of the GNU General Public License as published by
  5605                              <2> ; the Free Software Foundation; either version 2 of the License, or
  5606                              <2> ; (at your option) any later version.
  5607                              <2> ;
  5608                              <2> ; This program is distributed in the hope that it will be useful,
  5609                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5610                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5611                              <2> ; GNU General Public License for more details.
  5612                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5613                              <2> ;
  5614                              <2> 
  5615                              <2> ; Section containing code
  5616                              <2> SECTION .text
  5617                              <2> 
  5618                              <2> ;--------------------------------------------------------------------
  5619                              <2> ; DisplayCharOut_TeletypeOutputWithAttribute
  5620                              <2> ; DisplayCharOut_TeletypeOutput
  5621                              <2> ;	Parameters:
  5622                              <2> ;		AL:		Character to output
  5623                              <2> ;		AH:		Attribute to output
  5624                              <2> ;		DS:		BDA segment (zero)
  5625                              <2> ;		ES:DI:	Ptr to video memory where to output
  5626                              <2> ;	Returns:
  5627                              <2> ;		DI:		Incremented for next character
  5628                              <2> ;	Corrupts registers:
  5629                              <2> ;		AX, DX
  5630                              <2> ;--------------------------------------------------------------------
  5631                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5632                              <2> DisplayCharOut_TeletypeOutputWithAttribute:
  5633 000001B5 3C20                <2> 	cmp		al, ' '							; Printable character?
  5634 000001B7 7208                <2> 	jb		SHORT DisplayCharOut_BiosTeletypeOutput
  5635                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosw
  5636                              <3> %ifdef ELIMINATE_CGA_SNOW
  5637                              <3>  %ifidn %1, stosb
  5638                              <3>  call CgaSnow_Stosb
  5639                              <3>  %elifidn %1, stosw
  5640 000001B9 E8AFFF              <3>  call CgaSnow_Stosw
  5641                              <3>  %elifidn %1, rep movsb
  5642                              <3>  call CgaSnow_RepMovsb
  5643                              <3>  %else
  5644                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  5645                              <3>  %endif
  5646                              <3> %else
  5647                              <3>  %ifidn %1, rep movsb
  5648                              <3>  eSEG_STR rep, es, movsb
  5649                              <3>  %else
  5650                              <3>  %1
  5651                              <3>  %endif
  5652                              <3> %endif
  5653 000001BC C3                  <2> 	ret
  5654                              <2> 
  5655                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5656                              <2> DisplayCharOut_TeletypeOutput:
  5657 000001BD 3C20                <2> 	cmp		al, ' '							; Printable character?
  5658 000001BF 731B                <2> 	jae		SHORT DisplayCharOut_Character
  5659                              <2> 	; Fall to DisplayCharOut_BiosTeletypeOutput
  5660                              <2> 
  5661                              <2> ;--------------------------------------------------------------------
  5662                              <2> ; DisplayCharOut_BiosTeletypeOutput
  5663                              <2> ;	Parameters:
  5664                              <2> ;		AL:		Control character
  5665                              <2> ;		DS:		BDA segment (zero)
  5666                              <2> ;		ES:DI:	Ptr to video memory where to output
  5667                              <2> ;	Returns:
  5668                              <2> ;		DI:		Incremented for next character
  5669                              <2> ;	Corrupts registers:
  5670                              <2> ;		AX, DX
  5671                              <2> ;--------------------------------------------------------------------
  5672                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5673                              <2> DisplayCharOut_BiosTeletypeOutput:
  5674 000001C1 50                  <2> 	push	ax
  5675 000001C2 E8C000              <2> 	call	DisplayCursor_SynchronizeCoordinatesToHardware
  5676 000001C5 58                  <2> 	pop		ax
  5677                              <2> 
  5678                              <2> 	; Output character with BIOS
  5679 000001C6 53                  <2> 	push	bx
  5680 000001C7 B40E                <2> 	mov		ah, TELETYPE_OUTPUT
  5681 000001C9 8A3E6204            <2> 	mov		bh, [VIDEO_BDA.bActivePage]
  5682 000001CD CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  5683 000001CF 5B                  <2> 	pop		bx
  5684                              <2> 
  5685 000001D0 E88E00              <2> 	call	DisplayCursor_GetHardwareCoordinatesToAX
  5686 000001D3 EB67                <2> 	jmp		DisplayCursor_SetCoordinatesFromAX
  5687                              <2> 
  5688                              <2> 
  5689                              <2> ;--------------------------------------------------------------------
  5690                              <2> ; DisplayCharOut_Attribute
  5691                              <2> ; DisplayCharOut_Character
  5692                              <2> ; DisplayCharOut_CharacterWithAttribute
  5693                              <2> ;	Parameters:
  5694                              <2> ;		AL:		Character to output
  5695                              <2> ;		AH:		Attribute to output
  5696                              <2> ;		DS:		BDA segment (zero)
  5697                              <2> ;		ES:DI:	Ptr to video memory where to output
  5698                              <2> ;	Returns:
  5699                              <2> ;		DI:		Incremented for next character
  5700                              <2> ;	Corrupts registers:
  5701                              <2> ;		AX, DX
  5702                              <2> ;--------------------------------------------------------------------
  5703                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5704                              <2> DisplayCharOut_Attribute:
  5705 000001D5 86C4                <2> 	xchg	al, ah				; Swap character and attribute
  5706 000001D7 47                  <2> 	inc		di					; Skip character
  5707                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosb
  5708                              <3> %ifdef ELIMINATE_CGA_SNOW
  5709                              <3>  %ifidn %1, stosb
  5710 000001D8 E879FF              <3>  call CgaSnow_Stosb
  5711                              <3>  %elifidn %1, stosw
  5712                              <3>  call CgaSnow_Stosw
  5713                              <3>  %elifidn %1, rep movsb
  5714                              <3>  call CgaSnow_RepMovsb
  5715                              <3>  %else
  5716                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  5717                              <3>  %endif
  5718                              <3> %else
  5719                              <3>  %ifidn %1, rep movsb
  5720                              <3>  eSEG_STR rep, es, movsb
  5721                              <3>  %else
  5722                              <3>  %1
  5723                              <3>  %endif
  5724                              <3> %endif
  5725 000001DB C3                  <2> 	ret
  5726                              <2> 
  5727                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5728                              <2> DisplayCharOut_Character:
  5729                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosb
  5730                              <3> %ifdef ELIMINATE_CGA_SNOW
  5731                              <3>  %ifidn %1, stosb
  5732 000001DC E875FF              <3>  call CgaSnow_Stosb
  5733                              <3>  %elifidn %1, stosw
  5734                              <3>  call CgaSnow_Stosw
  5735                              <3>  %elifidn %1, rep movsb
  5736                              <3>  call CgaSnow_RepMovsb
  5737                              <3>  %else
  5738                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  5739                              <3>  %endif
  5740                              <3> %else
  5741                              <3>  %ifidn %1, rep movsb
  5742                              <3>  eSEG_STR rep, es, movsb
  5743                              <3>  %else
  5744                              <3>  %1
  5745                              <3>  %endif
  5746                              <3> %endif
  5747 000001DF 47                  <2> 	inc		di					; Skip attribute
  5748 000001E0 C3                  <2> 	ret
  5749                              <2> 
  5750                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5751                              <2> DisplayCharOut_CharacterWithAttribute:
  5752                              <2> 	WAIT_RETRACE_IF_NECESSARY_THEN stosw
  5753                              <3> %ifdef ELIMINATE_CGA_SNOW
  5754                              <3>  %ifidn %1, stosb
  5755                              <3>  call CgaSnow_Stosb
  5756                              <3>  %elifidn %1, stosw
  5757 000001E1 E887FF              <3>  call CgaSnow_Stosw
  5758                              <3>  %elifidn %1, rep movsb
  5759                              <3>  call CgaSnow_RepMovsb
  5760                              <3>  %else
  5761                              <3>  %error "Invalid instruction passed to WAIT_RETRACE_IF_NECESSARY_THEN"
  5762                              <3>  %endif
  5763                              <3> %else
  5764                              <3>  %ifidn %1, rep movsb
  5765                              <3>  eSEG_STR rep, es, movsb
  5766                              <3>  %else
  5767                              <3>  %1
  5768                              <3>  %endif
  5769                              <3> %endif
  5770 000001E4 C3                  <2> 	ret
  5771                              <2> 
  5772                              <2> 
  5773                              <2> ;--------------------------------------------------------------------
  5774                              <2> ; DisplayCharOut_WriteCharacterToBuffer
  5775                              <2> ;	Parameters:
  5776                              <2> ;		AL:		Character to output
  5777                              <2> ;		DS:		BDA segment (zero)
  5778                              <2> ;		ES:DI:	Ptr to destination string buffer
  5779                              <2> ;		DISPLAY_CONTEXT.wCharOutParam:	Characters left in buffer
  5780                              <2> ;	Returns:
  5781                              <2> ;		ES:DI:	Updated for next character
  5782                              <2> ;	Corrupts registers:
  5783                              <2> ;		AX, DX
  5784                              <2> ;--------------------------------------------------------------------
  5785                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5786                              <2> DisplayCharOut_WriteCharacterToBuffer:
  5787 000001E5 833E5A0400          <2> 	cmp		WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam], BYTE 0
  5788 000001EA 7405                <2> 	je		SHORT .BufferFull
  5789 000001EC AA                  <2> 	stosb
  5790 000001ED FF0E5A04            <2> 	dec		WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam]
  5791                              <2> .BufferFull:
  5792 000001F1 C3                  <2> 	ret
  5793                              <1> 	%include "DisplayContext.asm"
  5794                              <2> ; Project name	:	Assembly Library
  5795                              <2> ; Description	:	Functions for managing display context.
  5796                              <2> 
  5797                              <2> ;
  5798                              <2> ; XTIDE Universal BIOS and Associated Tools
  5799                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  5800                              <2> ;
  5801                              <2> ; This program is free software; you can redistribute it and/or modify
  5802                              <2> ; it under the terms of the GNU General Public License as published by
  5803                              <2> ; the Free Software Foundation; either version 2 of the License, or
  5804                              <2> ; (at your option) any later version.
  5805                              <2> ;
  5806                              <2> ; This program is distributed in the hope that it will be useful,
  5807                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  5808                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  5809                              <2> ; GNU General Public License for more details.
  5810                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  5811                              <2> ;
  5812                              <2> 
  5813                              <2> ; Section containing code
  5814                              <2> SECTION .text
  5815                              <2> 
  5816                              <2> ;--------------------------------------------------------------------
  5817                              <2> ; DisplayContext_Initialize
  5818                              <2> ;	Parameters:
  5819                              <2> ;		DS:		BDA segment (zero)
  5820                              <2> ;	Returns:
  5821                              <2> ;		Nothing
  5822                              <2> ;	Corrupts registers:
  5823                              <2> ;		AX, DX, DI
  5824                              <2> ;--------------------------------------------------------------------
  5825                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5826                              <2> DisplayContext_Initialize:
  5827 000001F2 C7065804[B501]      <2> 	mov		WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fnCharOut], DEFAULT_CHARACTER_OUTPUT
  5828 000001F8 C6065E0407          <2> 	mov		BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], SCREEN_BACKGROUND_ATTRIBUTE
  5829 000001FD E82E00              <2> 	call	DisplayCursor_GetDefaultCursorShapeToAX
  5830 00000200 A35C04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCursorShape], ax
  5831                              <2> 	; Fall to .DetectAndSetDisplaySegment
  5832                              <2> 
  5833                              <2> ;--------------------------------------------------------------------
  5834                              <2> ; .DetectAndSetDisplaySegment
  5835                              <2> ;	Parameters:
  5836                              <2> ;		DS:		BDA segment (zero)
  5837                              <2> ;	Returns:
  5838                              <2> ;		Nothing
  5839                              <2> ;	Corrupts registers:
  5840                              <2> ;		AX, DX
  5841                              <2> ;--------------------------------------------------------------------
  5842                              <2> .DetectAndSetDisplaySegment:
  5843 00000203 B800B8              <2> 	mov		ax, COLOR_TEXT_SEGMENT
  5844 00000206 803E490407          <2> 	cmp		BYTE [VIDEO_BDA.bMode], MDA_TEXT_MODE
  5845                              <2> 	eCMOVE	ah, MONO_TEXT_SEGMENT >> 8
  5846                              <3>  eCMOVZ %1, %2
  5847 0000020B 7502                <4>  jnz SHORT %%Return
  5848 0000020D B4B0                <4>  mov %1, %2
  5849                              <4> %%Return:
  5850 0000020F A35604              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition+2], ax
  5851                              <2> 	; Fall to .InitializeFlags
  5852                              <2> 
  5853                              <2> ;--------------------------------------------------------------------
  5854                              <2> ; .InitializeFlags
  5855                              <2> ;	Parameters:
  5856                              <2> ;		DS:		BDA segment (zero)
  5857                              <2> ;	Returns:
  5858                              <2> ;		Nothing
  5859                              <2> ;	Corrupts registers:
  5860                              <2> ;		AX, DX
  5861                              <2> ;--------------------------------------------------------------------
  5862                              <2> .InitializeFlags:
  5863 00000212 B201                <2> 	mov		dl, FLG_CONTEXT_ATTRIBUTES
  5864 00000214 E82AFF              <2> 	call	CgaSnow_IsCgaPresent
  5865 00000217 7303                <2> 	jnc		SHORT .DoNotSetCgaFlag
  5866 00000219 80CA02              <2> 	or		dl, FLG_CONTEXT_CGA
  5867                              <2> .DoNotSetCgaFlag:
  5868 0000021C 88165F04            <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], dl
  5869                              <2> 	; Fall to .InitializeCursor
  5870                              <2> 
  5871                              <2> ;--------------------------------------------------------------------
  5872                              <2> ; .InitializeCursor
  5873                              <2> ;	Parameters:
  5874                              <2> ;		DS:		BDA segment (zero)
  5875                              <2> ;	Returns:
  5876                              <2> ;		Nothing
  5877                              <2> ;	Corrupts registers:
  5878                              <2> ;		AX, DX
  5879                              <2> ;--------------------------------------------------------------------
  5880                              <2> .InitializeCursor:
  5881 00000220 E83E00              <2> 	call	DisplayCursor_GetHardwareCoordinatesToAX	; Coordinates before init
  5882 00000223 E81600              <2> 	call	DisplayCursor_SetCoordinatesFromAX			; Cursor to Display Context
  5883                              <2> 	; Fall to DisplayContext_SynchronizeToHardware
  5884                              <2> 
  5885                              <2> ;--------------------------------------------------------------------
  5886                              <2> ; DisplayContext_SynchronizeToHardware
  5887                              <2> ;	Parameters:
  5888                              <2> ;		DS:		BDA segment (zero)
  5889                              <2> ;	Returns:
  5890                              <2> ;		Nothing
  5891                              <2> ;	Corrupts registers:
  5892                              <2> ;		AX, DX
  5893                              <2> ;--------------------------------------------------------------------
  5894                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5895                              <2> DisplayContext_SynchronizeToHardware:
  5896 00000226 E87100              <2> 	call	DisplayPage_SynchronizeToHardware
  5897 00000229 E84300              <2> 	call	DisplayCursor_SynchronizeShapeToHardware
  5898 0000022C EB57                <2> 	jmp		DisplayCursor_SynchronizeCoordinatesToHardware
  5899                              <2> 
  5900                              <2> 
  5901                              <2> ;--------------------------------------------------------------------
  5902                              <2> ; DisplayContext_Push
  5903                              <2> ; DisplayContext_Pop
  5904                              <2> ;	Parameters:
  5905                              <2> ;		Nothing
  5906                              <2> ;	Returns:
  5907                              <2> ;		Nothing
  5908                              <2> ;	Corrupts registers:
  5909                              <2> ;		AX, DI
  5910                              <2> ;--------------------------------------------------------------------
  5911                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5912                              <2> 	%ifndef MODULE_BOOT_MENU
  5913                              <2> 		%define EXCLUDE
  5914                              <2> 	%endif
  5915                              <2> %endif
  5916                              <2> 
  5917                              <2> %ifndef EXCLUDE
  5918                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5919                              <2> DisplayContext_Push:
  5920                              <2> 	mov		di, ds					; Backup DS
  5921                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax
  5922                              <2> 	pop		ax						; Pop return address
  5923                              <2> 
  5924                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  5925                              <2> 	%assign i 0
  5926                              <2> 	%rep DISPLAY_CONTEXT_size / 2
  5927                              <2> 		push	WORD [VIDEO_BDA.displayContext + i]
  5928                              <2> 	%assign i i+2
  5929                              <2> 	%endrep
  5930                              <2> %endif
  5931                              <2> 
  5932                              <2> 	mov		ds, di					; Restore DS
  5933                              <2> 	jmp		ax
  5934                              <2> 
  5935                              <2> 
  5936                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5937                              <2> DisplayContext_Pop:
  5938                              <2> 	mov		di, ds					; Backup DS
  5939                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax
  5940                              <2> 	pop		ax						; Pop return address
  5941                              <2> 
  5942                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  5943                              <2> 	%assign i DISPLAY_CONTEXT_size-2
  5944                              <2> 	%rep DISPLAY_CONTEXT_size / 2
  5945                              <2> 		pop		WORD [VIDEO_BDA.displayContext + i]
  5946                              <2> 	%assign i i-2
  5947                              <2> 	%endrep
  5948                              <2> %endif
  5949                              <2> 
  5950                              <2> 	push	ax						; Push return address
  5951                              <2> 	push	dx
  5952                              <2> 	call	DisplayContext_SynchronizeToHardware
  5953                              <2> 	pop		dx
  5954                              <2> 	mov		ds, di					; Restore DS
  5955                              <2> 	ret
  5956                              <2> %endif ; EXCLUDE
  5957                              <2> %undef EXCLUDE
  5958                              <2> 
  5959                              <2> 
  5960                              <2> ;--------------------------------------------------------------------
  5961                              <2> ; DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
  5962                              <2> ;	Parameters:
  5963                              <2> ;		CX:		Off screen buffer length in characters
  5964                              <2> ;		ES:BX:	Ptr to off screen buffer
  5965                              <2> ;	Returns:
  5966                              <2> ;		Nothing
  5967                              <2> ;	Corrupts registers:
  5968                              <2> ;		AX, DI
  5969                              <2> ;--------------------------------------------------------------------
  5970                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5971                              <2> ALIGN DISPLAY_JUMP_ALIGN
  5972                              <2> DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX:
  5973                              <2> 	push	ds
  5974                              <2> 
  5975                              <2> 	LOAD_BDA_SEGMENT_TO	ds, di
  5976                              <2> 	xchg	ax, bx
  5977                              <2> 	mov		bx, es
  5978                              <2> 	call	DisplayContext_SetCharacterPointerFromBXAX	; ES:DI now has the pointer
  5979                              <2> 
  5980                              <2> 	mov		bl, ATTRIBUTES_NOT_USED
  5981                              <2> 	mov		ax, BUFFER_OUTPUT_WITH_CHAR_ONLY
  5982                              <2> 	call	DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL
  5983                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam], cx
  5984                              <2> 
  5985                              <2> 	mov		bx, di
  5986                              <2> 	pop		ds
  5987                              <2> 	ret
  5988                              <2> %endif ; EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  5989                              <2> 
  5990                              <2> 
  5991                              <2> ;--------------------------------------------------------------------
  5992                              <2> ; DisplayContext_SetCharacterPointerFromBXAX
  5993                              <2> ;	Parameters:
  5994                              <2> ;		BX:AX:	Ptr to destination for next character to output
  5995                              <2> ;		DS:		BDA segment (zero)
  5996                              <2> ;	Returns:
  5997                              <2> ;		ES:DI:	Pointer that was in BX:AX
  5998                              <2> ;	Corrupts registers:
  5999                              <2> ;		AX
  6000                              <2> ;--------------------------------------------------------------------
  6001                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6002                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6003                              <2> DisplayContext_SetCharacterPointerFromBXAX:
  6004                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], ax
  6005                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition+2], bx
  6006                              <2> 	xchg	di, ax
  6007                              <2> 	mov		es, bx
  6008                              <2> 	ret
  6009                              <2> %endif
  6010                              <2> 
  6011                              <2> 
  6012                              <2> ;--------------------------------------------------------------------
  6013                              <2> ; DisplayContext_GetCharacterPointerToBXAX
  6014                              <2> ;	Parameters:
  6015                              <2> ;		DS:		BDA segment (zero)
  6016                              <2> ;	Returns:
  6017                              <2> ;		BX:AX:	Ptr to destination for next character to output
  6018                              <2> ;	Corrupts registers:
  6019                              <2> ;		Nothing
  6020                              <2> ;--------------------------------------------------------------------
  6021                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6022                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6023                              <2> DisplayContext_GetCharacterPointerToBXAX:
  6024                              <2> 	mov		ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
  6025                              <2> 	mov		bx, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition+2]
  6026                              <2> 	ret
  6027                              <2> %endif
  6028                              <2> 
  6029                              <2> 
  6030                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6031                              <2> 	%ifndef MODULE_BOOT_MENU
  6032                              <2> 		%define EXCLUDE
  6033                              <2> 	%endif
  6034                              <2> %endif
  6035                              <2> ;--------------------------------------------------------------------
  6036                              <2> ; DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL
  6037                              <2> ;	Parameters:
  6038                              <2> ;		AX:		Offset to character output function
  6039                              <2> ;		BL:		Attribute Flag
  6040                              <2> ;		DS:		BDA segment (zero)
  6041                              <2> ;	Returns:
  6042                              <2> ;		Nothing
  6043                              <2> ;	Corrupts registers:
  6044                              <2> ;		BL
  6045                              <2> ;--------------------------------------------------------------------
  6046                              <2> %ifndef EXCLUDE	; 1 of 3
  6047                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6048                              <2> DisplayContext_SetCharOutputFunctionFromAXwithAttribFlagInBL:
  6049                              <2> 	and		bl, FLG_CONTEXT_ATTRIBUTES
  6050                              <2> 	and		BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], ~FLG_CONTEXT_ATTRIBUTES
  6051                              <2> 	or		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], bl
  6052                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fnCharOut], ax
  6053                              <2> 	ret
  6054                              <2> %endif
  6055                              <2> 
  6056                              <2> 
  6057                              <2> ;--------------------------------------------------------------------
  6058                              <2> ; DisplayContext_SetCharacterAttributeFromAL
  6059                              <2> ;	Parameters:
  6060                              <2> ;		AL:		Character attribute
  6061                              <2> ;		DS:		BDA segment (zero)
  6062                              <2> ;	Returns:
  6063                              <2> ;		Nothing
  6064                              <2> ;	Corrupts registers:
  6065                              <2> ;		Nothing
  6066                              <2> ;--------------------------------------------------------------------
  6067                              <2> %ifndef EXCLUDE	; 2 of 3
  6068                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6069                              <2> DisplayContext_SetCharacterAttributeFromAL:
  6070                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], al
  6071                              <2> 	ret
  6072                              <2> %endif
  6073                              <2> 
  6074                              <2> 
  6075                              <2> ;--------------------------------------------------------------------
  6076                              <2> ; DisplayContext_SetCharacterOutputParameterFromAX
  6077                              <2> ;	Parameters:
  6078                              <2> ;		AX:		Parameter for Character Output function
  6079                              <2> ;		DS:		BDA segment (zero)
  6080                              <2> ;	Returns:
  6081                              <2> ;		Nothing
  6082                              <2> ;	Corrupts registers:
  6083                              <2> ;		Nothing
  6084                              <2> ;--------------------------------------------------------------------
  6085                              <2> %ifndef EXCLUDE	; 3 of 3
  6086                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6087                              <2> DisplayContext_SetCharacterOutputParameterFromAX:
  6088                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam], ax
  6089                              <2> 	ret
  6090                              <2> %endif
  6091                              <2> 
  6092                              <2> %undef EXCLUDE
  6093                              <2> 
  6094                              <2> 
  6095                              <2> ;--------------------------------------------------------------------
  6096                              <2> ; DisplayContext_GetCharacterOutputParameterToDX
  6097                              <2> ;	Parameters:
  6098                              <2> ;		DS:		BDA segment (zero)
  6099                              <2> ;	Returns:
  6100                              <2> ;		DX:		User parameter for Character Output function
  6101                              <2> ;	Corrupts registers:
  6102                              <2> ;		Nothing
  6103                              <2> ;--------------------------------------------------------------------
  6104                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  6105                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6106                              <2> DisplayContext_GetCharacterOutputParameterToDX:
  6107                              <2> 	mov		dx, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCharOutParam]
  6108                              <2> 	ret
  6109                              <2> %endif
  6110                              <2> 
  6111                              <2> 
  6112                              <2> ;--------------------------------------------------------------------
  6113                              <2> ; DisplayContext_GetCharacterOffsetToAXfromByteOffsetInAX
  6114                              <2> ;	Parameters:
  6115                              <2> ;		AX:		Offset in bytes from some character to another
  6116                              <2> ;		DS:		BDA segment (zero)
  6117                              <2> ;	Returns:
  6118                              <2> ;		AX:		Offset in characters from some character to another
  6119                              <2> ;	Corrupts registers:
  6120                              <2> ;		Nothing
  6121                              <2> ;--------------------------------------------------------------------
  6122                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  6123                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6124                              <2> DisplayContext_GetCharacterOffsetToAXfromByteOffsetInAX:
  6125                              <2> 	test	BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], FLG_CONTEXT_ATTRIBUTES
  6126                              <2> 	jz		SHORT ReturnOffsetInAX
  6127                              <2> 	sar		ax, 1		; BYTE count to WORD count
  6128                              <2> 	ret
  6129                              <2> %endif
  6130                              <2> 
  6131                              <2> 
  6132                              <2> ;--------------------------------------------------------------------
  6133                              <2> ; DisplayContext_GetByteOffsetToAXfromCharacterOffsetInAX
  6134                              <2> ;	Parameters:
  6135                              <2> ;		AX:		Offset in characters from some character to another
  6136                              <2> ;		DS:		BDA segment (zero)
  6137                              <2> ;	Returns:
  6138                              <2> ;		AX:		Offset in bytes from some character to another
  6139                              <2> ;	Corrupts registers:
  6140                              <2> ;		Nothing
  6141                              <2> ;--------------------------------------------------------------------
  6142                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  6143                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6144                              <2> DisplayContext_GetByteOffsetToAXfromCharacterOffsetInAX:
  6145                              <2> 	test	BYTE [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bFlags], FLG_CONTEXT_ATTRIBUTES
  6146                              <2> 	jz		SHORT ReturnOffsetInAX
  6147                              <2> 	sal		ax, 1		; WORD count to BYTE count
  6148                              <2> ALIGN DISPLAY_JUMP_ALIGN, ret
  6149                              <2> ReturnOffsetInAX:
  6150                              <2> 	ret
  6151                              <2> %endif
  6152                              <1> 	%include "DisplayCursor.asm"
  6153                              <2> ; Project name	:	Assembly Library
  6154                              <2> ; Description	:	Functions for managing display cursor.
  6155                              <2> 
  6156                              <2> ;
  6157                              <2> ; XTIDE Universal BIOS and Associated Tools
  6158                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  6159                              <2> ;
  6160                              <2> ; This program is free software; you can redistribute it and/or modify
  6161                              <2> ; it under the terms of the GNU General Public License as published by
  6162                              <2> ; the Free Software Foundation; either version 2 of the License, or
  6163                              <2> ; (at your option) any later version.
  6164                              <2> ;
  6165                              <2> ; This program is distributed in the hope that it will be useful,
  6166                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6167                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6168                              <2> ; GNU General Public License for more details.
  6169                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  6170                              <2> ;
  6171                              <2> 
  6172                              <2> ; Section containing code
  6173                              <2> SECTION .text
  6174                              <2> 
  6175                              <2> ;--------------------------------------------------------------------
  6176                              <2> ; DisplayCursor_GetDefaultCursorShapeToAX
  6177                              <2> ;	Parameters:
  6178                              <2> ;		DS:		BDA segment (zero)
  6179                              <2> ;	Returns:
  6180                              <2> ;		AX:		Default text mode cursor shape
  6181                              <2> ;	Corrupts registers:
  6182                              <2> ;		Nothing
  6183                              <2> ;--------------------------------------------------------------------
  6184                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6185                              <2> DisplayCursor_GetDefaultCursorShapeToAX:
  6186 0000022E B80706              <2> 	mov		ax, CURSOR_NORMAL_COLOR				; CGA, EGA, VGA cursor
  6187 00000231 803E490407          <2> 	cmp		BYTE [VIDEO_BDA.bMode], MDA_TEXT_MODE
  6188                              <2> 	eCMOVE	ax, CURSOR_NORMAL_MDA				; MDA cursor
  6189                              <3>  eCMOVZ %1, %2
  6190 00000236 7503                <4>  jnz SHORT %%Return
  6191 00000238 B80C0B              <4>  mov %1, %2
  6192                              <4> %%Return:
  6193 0000023B C3                  <2> 	ret
  6194                              <2> 
  6195                              <2> 
  6196                              <2> ;--------------------------------------------------------------------
  6197                              <2> ; DisplayCursor_SetShapeFromAX
  6198                              <2> ;	Parameters:
  6199                              <2> ;		AX:		Cursor shape (AH=Start scan line, AL=End scan line)
  6200                              <2> ;		DS:		BDA segment (zero)
  6201                              <2> ;	Returns:
  6202                              <2> ;		Nothing
  6203                              <2> ;	Corrupts registers:
  6204                              <2> ;		Nothing
  6205                              <2> ;--------------------------------------------------------------------
  6206                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6207                              <2> 	%ifndef MODULE_BOOT_MENU
  6208                              <2> 		%define EXCLUDE
  6209                              <2> 	%endif
  6210                              <2> %endif
  6211                              <2> 
  6212                              <2> %ifndef EXCLUDE
  6213                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6214                              <2> DisplayCursor_SetShapeFromAX:
  6215                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCursorShape], ax
  6216                              <2> 	ret
  6217                              <2> %endif
  6218                              <2> %undef EXCLUDE
  6219                              <2> 
  6220                              <2> 
  6221                              <2> ;--------------------------------------------------------------------
  6222                              <2> ; DisplayCursor_SetCoordinatesFromAX
  6223                              <2> ;	Parameters:
  6224                              <2> ;		AL:		Cursor column (X-coordinate)
  6225                              <2> ;		AH:		Cursor row (Y-coordinate)
  6226                              <2> ;		DS:		BDA segment (zero)
  6227                              <2> ;	Returns:
  6228                              <2> ;		DI:		Offset to cursor location in video RAM
  6229                              <2> ;	Corrupts registers:
  6230                              <2> ;		AX, DX
  6231                              <2> ;--------------------------------------------------------------------
  6232                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6233                              <2> DisplayCursor_SetCoordinatesFromAX:
  6234 0000023C 92                  <2> 	xchg	dx, ax
  6235 0000023D A14A04              <2> 	mov		ax, [VIDEO_BDA.wColumns]		; Column count, 40 or 80
  6236 00000240 F6E6                <2> 	mul		dh								; AX = Column count * row index
  6237 00000242 30F6                <2> 	xor		dh, dh
  6238 00000244 01D0                <2> 	add		ax, dx							; Add column offset
  6239                              <2> 	eSHL_IM	ax, 1							; Convert to WORD offset
  6240                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  6241                              <3> %ifdef USE_386
  6242                              <3>  %if %2 = 1
  6243                              <3>  add %1, %1
  6244                              <3>  %else
  6245                              <3>  eSHIFT_IM %1, %2, shl
  6246                              <3>  %endif
  6247                              <3> %else
  6248                              <3>  eSHIFT_IM %1, %2, shl
  6249                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  6250                              <4> %ifndef USE_186
  6251                              <4>  %ifidni %1, cl
  6252                              <4>  times %2 %3 %1, 1
  6253                              <4>  %elifidni %1, ch
  6254                              <4>  times %2 %3 %1, 1
  6255                              <4>  %elifidni %1, cx
  6256                              <4>  times %2 %3 %1, 1
  6257                              <4>  %else
  6258                              <4>  %if %2 > 3
  6259                              <4>  push cx
  6260                              <4>  mov cl, %2
  6261                              <4>  %3 %1, cl
  6262                              <4>  pop cx
  6263                              <4>  %else
  6264 00000246 D1E0                <4>  times %2 %3 %1, 1
  6265                              <4>  %endif
  6266                              <4>  %endif
  6267                              <4> 
  6268                              <4> %else
  6269                              <4>  %3 %1, %2
  6270                              <4> %endif
  6271                              <4> %endif
  6272                              <3> %endif
  6273                              <3> %endif
  6274 00000248 03064E04            <2> 	add		ax, [VIDEO_BDA.wPageOffset]		; AX = Video RAM offset
  6275 0000024C A35404              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], ax
  6276 0000024F 97                  <2> 	xchg	di, ax
  6277 00000250 C3                  <2> 	ret
  6278                              <2> 
  6279                              <2> 
  6280                              <2> ;--------------------------------------------------------------------
  6281                              <2> ; DisplayCursor_GetSoftwareCoordinatesToAX
  6282                              <2> ;	Parameters:
  6283                              <2> ;		AX:		Offset to cursor location in selected page
  6284                              <2> ;		DS:		BDA segment (zero)
  6285                              <2> ;	Returns:
  6286                              <2> ;		AL:		Cursor column (X-coordinate)
  6287                              <2> ;		AH:		Cursor row (Y-coordinate)
  6288                              <2> ;	Corrupts registers:
  6289                              <2> ;		Nothing
  6290                              <2> ;--------------------------------------------------------------------
  6291                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6292                              <2> DisplayCursor_GetSoftwareCoordinatesToAX:
  6293 00000251 A15404              <2> 	mov		ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
  6294 00000254 2B064E04            <2> 	sub		ax, [VIDEO_BDA.wPageOffset]
  6295 00000258 D1E8                <2> 	shr		ax, 1							; WORD offset to character offset
  6296 0000025A F6364A04            <2> 	div		BYTE [VIDEO_BDA.wColumns]		; AL = full rows, AH = column index for last row
  6297 0000025E 86C4                <2> 	xchg	al, ah
  6298 00000260 C3                  <2> 	ret
  6299                              <2> 
  6300                              <2> 
  6301                              <2> ;--------------------------------------------------------------------
  6302                              <2> ; DisplayCursor_GetHardwareCoordinatesToAX
  6303                              <2> ;	Parameters:
  6304                              <2> ;		DS:		BDA segment (zero)
  6305                              <2> ;	Returns:
  6306                              <2> ;		AL:		Hardware cursor column (X-coordinate)
  6307                              <2> ;		AH:		Hardware cursor row (Y-coordinate)
  6308                              <2> ;	Corrupts registers:
  6309                              <2> ;		DX
  6310                              <2> ;--------------------------------------------------------------------
  6311                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6312                              <2> DisplayCursor_GetHardwareCoordinatesToAX:
  6313 00000261 51                  <2> 	push	cx
  6314 00000262 53                  <2> 	push	bx
  6315                              <2> 
  6316 00000263 B403                <2> 	mov		ah, GET_CURSOR_POSITION_AND_SIZE
  6317 00000265 8A3E6204            <2> 	mov		bh, [VIDEO_BDA.bActivePage]
  6318 00000269 CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  6319 0000026B 92                  <2> 	xchg	ax, dx
  6320                              <2> 
  6321 0000026C 5B                  <2> 	pop		bx
  6322 0000026D 59                  <2> 	pop		cx
  6323 0000026E C3                  <2> 	ret
  6324                              <2> 
  6325                              <2> 
  6326                              <2> ;--------------------------------------------------------------------
  6327                              <2> ; DisplayCursor_SynchronizeShapeToHardware
  6328                              <2> ;	Parameters:
  6329                              <2> ;		DS:		BDA segment (zero)
  6330                              <2> ;	Returns:
  6331                              <2> ;		Nothing
  6332                              <2> ;	Corrupts registers:
  6333                              <2> ;		AX, DX
  6334                              <2> ;--------------------------------------------------------------------
  6335                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6336                              <2> DisplayCursor_SynchronizeShapeToHardware:
  6337 0000026F 8B165C04            <2> 	mov		dx, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.wCursorShape]
  6338                              <2> 	; Fall to .SetHardwareCursorShapeFromDX
  6339                              <2> 
  6340                              <2> ;--------------------------------------------------------------------
  6341                              <2> ; .SetHardwareCursorShapeFromDX
  6342                              <2> ;	Parameters:
  6343                              <2> ;		DX:		Cursor shape
  6344                              <2> ;		DS:		BDA segment (zero)
  6345                              <2> ;	Returns:
  6346                              <2> ;		Nothing
  6347                              <2> ;	Corrupts registers:
  6348                              <2> ;		AX
  6349                              <2> ;--------------------------------------------------------------------
  6350                              <2> .SetHardwareCursorShapeFromDX:
  6351 00000273 3B166004            <2> 	cmp		dx, [VIDEO_BDA.wCursorShape]
  6352 00000277 740B                <2> 	je		SHORT .Return					; Return if no changes
  6353 00000279 51                  <2> 	push	cx
  6354 0000027A 89D1                <2> 	mov		cx, dx							; BIOS wants cursor shape in CX
  6355 0000027C A04904              <2> 	mov		al, [VIDEO_BDA.bMode]			; Load video mode to prevent lock ups on some BIOSes
  6356 0000027F B401                <2> 	mov		ah, SET_TEXT_MODE_CURSOR_SHAPE
  6357 00000281 CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  6358 00000283 59                  <2> 	pop		cx
  6359                              <2> .Return:
  6360 00000284 C3                  <2> 	ret
  6361                              <2> 
  6362                              <2> 
  6363                              <2> ;--------------------------------------------------------------------
  6364                              <2> ; DisplayCursor_SynchronizeCoordinatesToHardware
  6365                              <2> ;	Parameters:
  6366                              <2> ;		DS:		BDA segment (zero)
  6367                              <2> ;	Returns:
  6368                              <2> ;		Nothing
  6369                              <2> ;	Corrupts registers:
  6370                              <2> ;		AX, DX
  6371                              <2> ;--------------------------------------------------------------------
  6372                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6373                              <2> DisplayCursor_SynchronizeCoordinatesToHardware:
  6374 00000285 E8C9FF              <2> 	call	DisplayCursor_GetSoftwareCoordinatesToAX
  6375                              <2> 	; Fall to .SetHardwareCursorCoordinatesFromAX
  6376                              <2> 
  6377                              <2> ;--------------------------------------------------------------------
  6378                              <2> ; .SetHardwareCursorCoordinatesFromAX
  6379                              <2> ;	Parameters:
  6380                              <2> ;		AL:		Cursor column (X-coordinate)
  6381                              <2> ;		AH:		Cursor row (Y-coordinate)
  6382                              <2> ;		DS:		BDA segment (zero)
  6383                              <2> ;	Returns:
  6384                              <2> ;		Nothing
  6385                              <2> ;	Corrupts registers:
  6386                              <2> ;		AX, DX
  6387                              <2> ;--------------------------------------------------------------------
  6388                              <2> .SetHardwareCursorCoordinatesFromAX:
  6389 00000288 53                  <2> 	push	bx
  6390 00000289 92                  <2> 	xchg	dx, ax							; BIOS wants coordinates in DX
  6391 0000028A B402                <2> 	mov		ah, SET_CURSOR_POSITION
  6392 0000028C 8A3E6204            <2> 	mov		bh, [VIDEO_BDA.bActivePage]
  6393 00000290 CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  6394 00000292 5B                  <2> 	pop		bx
  6395 00000293 C3                  <2> 	ret
  6396                              <1> 	%include "DisplayPage.asm"
  6397                              <2> ; Project name	:	Assembly Library
  6398                              <2> ; Description	:	Functions for managing display page.
  6399                              <2> 
  6400                              <2> ;
  6401                              <2> ; XTIDE Universal BIOS and Associated Tools
  6402                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  6403                              <2> ;
  6404                              <2> ; This program is free software; you can redistribute it and/or modify
  6405                              <2> ; it under the terms of the GNU General Public License as published by
  6406                              <2> ; the Free Software Foundation; either version 2 of the License, or
  6407                              <2> ; (at your option) any later version.
  6408                              <2> ;
  6409                              <2> ; This program is distributed in the hope that it will be useful,
  6410                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6411                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6412                              <2> ; GNU General Public License for more details.
  6413                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  6414                              <2> ;
  6415                              <2> 
  6416                              <2> ; Section containing code
  6417                              <2> SECTION .text
  6418                              <2> 
  6419                              <2> ;--------------------------------------------------------------------
  6420                              <2> ; DisplayPage_SetFromAL
  6421                              <2> ;	Parameters:
  6422                              <2> ;		AL:		New display page
  6423                              <2> ;		DS:		BDA segment (zero)
  6424                              <2> ;	Returns:
  6425                              <2> ;		Nothing
  6426                              <2> ;	Corrupts registers:
  6427                              <2> ;		AX, DX
  6428                              <2> ;--------------------------------------------------------------------
  6429                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  6430                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6431                              <2> DisplayPage_SetFromAL:
  6432                              <2> 	xor		ah, ah
  6433                              <2> 	mul		WORD [VIDEO_BDA.wBytesPerPage]		; AX = Offset to page
  6434                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], ax
  6435                              <2> 	ret
  6436                              <2> %endif
  6437                              <2> 
  6438                              <2> 
  6439                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6440                              <2> 	%define EXCLUDE
  6441                              <2> 	%ifdef MODULE_HOTKEYS
  6442                              <2> 		%undef EXCLUDE
  6443                              <2> 	%endif
  6444                              <2> 	%ifdef MODULE_BOOT_MENU
  6445                              <2> 		%undef EXCLUDE
  6446                              <2> 	%endif
  6447                              <2> %endif
  6448                              <2> 
  6449                              <2> %ifndef EXCLUDE
  6450                              <2> ;--------------------------------------------------------------------
  6451                              <2> ; DisplayPage_GetColumnsToALandRowsToAH
  6452                              <2> ;	Parameters:
  6453                              <2> ;		DS:		BDA segment (zero)
  6454                              <2> ;	Returns:
  6455                              <2> ;		AL:		Number of columns in selected text mode
  6456                              <2> ;		AH:		Number of rows in selected text mode
  6457                              <2> ;	Corrupts registers:
  6458                              <2> ;		Nothing
  6459                              <2> ;--------------------------------------------------------------------
  6460                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6461                              <2> DisplayPage_GetColumnsToALandRowsToAH:
  6462 00000294 A04A04              <2> 	mov		al, [VIDEO_BDA.wColumns]		; 40 or 80
  6463 00000297 B419                <2> 	mov		ah, 25							; Always 25 rows on standard text modes
  6464 00000299 C3                  <2> 	ret
  6465                              <2> %endif
  6466                              <2> %undef EXCLUDE
  6467                              <2> 
  6468                              <2> ;--------------------------------------------------------------------
  6469                              <2> ; DisplayPage_SynchronizeToHardware
  6470                              <2> ;	Parameters:
  6471                              <2> ;		DS:		BDA segment (zero)
  6472                              <2> ;	Returns:
  6473                              <2> ;		Nothing
  6474                              <2> ;	Corrupts registers:
  6475                              <2> ;		AX, DX
  6476                              <2> ;--------------------------------------------------------------------
  6477                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6478                              <2> DisplayPage_SynchronizeToHardware:
  6479 0000029A 31D2                <2> 	xor		dx, dx
  6480 0000029C A15404              <2> 	mov		ax, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition]
  6481 0000029F F7364C04            <2> 	div		WORD [VIDEO_BDA.wBytesPerPage]	; AX = Page
  6482                              <2> 
  6483 000002A3 3A066204            <2> 	cmp		al, [VIDEO_BDA.bActivePage]
  6484 000002A7 7404                <2> 	je		SHORT .Return					; Same page, no need to synchronize
  6485 000002A9 B405                <2> 	mov		ah, SELECT_ACTIVE_DISPLAY_PAGE
  6486 000002AB CD10                <2> 	int		BIOS_VIDEO_INTERRUPT_10h
  6487                              <2> .Return:
  6488 000002AD C3                  <2> 	ret
  6489                              <1> 	%include "DisplayPrint.asm"					; must come before DisplayFormat/DisplayFormatCompressed
  6490                              <2> ; Project name	:	Assembly Library
  6491                              <2> ; Description	:	Functions for display output.
  6492                              <2> 
  6493                              <2> ;
  6494                              <2> ; XTIDE Universal BIOS and Associated Tools
  6495                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  6496                              <2> ;
  6497                              <2> ; This program is free software; you can redistribute it and/or modify
  6498                              <2> ; it under the terms of the GNU General Public License as published by
  6499                              <2> ; the Free Software Foundation; either version 2 of the License, or
  6500                              <2> ; (at your option) any later version.
  6501                              <2> ;
  6502                              <2> ; This program is distributed in the hope that it will be useful,
  6503                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6504                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6505                              <2> ; GNU General Public License for more details.
  6506                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  6507                              <2> ;
  6508                              <2> 
  6509                              <2> ; Section containing code
  6510                              <2> SECTION .text
  6511                              <2> 
  6512                              <2> 
  6513                              <2> ;--------------------------------------------------------------------
  6514                              <2> ; Supports following formatting types:
  6515                              <2> ;	%a		Specifies attribute for next character
  6516                              <2> ;	%A		Specifies attribute for remaining string (or until next %A)
  6517                              <2> ;	%d		Prints signed 16-bit decimal integer
  6518                              <2> ;	%u		Prints unsigned 16-bit decimal integer
  6519                              <2> ;	%x		Prints 16-bit hexadecimal integer
  6520                              <2> ;	%s		Prints string (from CS segment)
  6521                              <2> ;	%S		Prints string (far pointer)
  6522                              <2> ;	%c		Prints character
  6523                              <2> ;	%t		Prints character number of times (character needs to be pushed first, then repeat times)
  6524                              <2> ;	%%		Prints '%' character (no parameter pushed)
  6525                              <2> ;
  6526                              <2> ;	Any placeholder can be set to minimum length by specifying
  6527                              <2> ;	minimum number of characters. For example %8d would append spaces
  6528                              <2> ;	after integer so that at least 8 characters would be printed.
  6529                              <2> ;
  6530                              <2> ;	When placing '-' after number, then spaces will be used for prepending.
  6531                              <2> ;	For example %8-d would prepend integer with spaces so that at least
  6532                              <2> ;	8 characters would be printed.
  6533                              <2> ;
  6534                              <2> ; DisplayPrint_FormattedNullTerminatedStringFromCSSI
  6535                              <2> ;	Parameters:
  6536                              <2> ;		BP:		SP before pushing parameters
  6537                              <2> ;		DS:		BDA segment (zero)
  6538                              <2> ;		CS:SI:	Pointer to string to format
  6539                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6540                              <2> ;		Stack:	Parameters for formatting placeholders.
  6541                              <2> ;				Parameter for first placeholder must be pushed first.
  6542                              <2> ;				Low word must pushed first for placeholders requiring
  6543                              <2> ;				32-bit parameters (two words).
  6544                              <2> ;	Returns:
  6545                              <2> ;		DI:		Updated offset to video RAM
  6546                              <2> ;	Corrupts registers:
  6547                              <2> ;		AX, DX
  6548                              <2> ;--------------------------------------------------------------------
  6549                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6550                              <2> DisplayPrint_FormattedNullTerminatedStringFromCSSI:
  6551 000002AE 55                  <2> 	push	bp
  6552 000002AF 56                  <2> 	push	si
  6553 000002B0 51                  <2> 	push	cx
  6554 000002B1 53                  <2> 	push	bx
  6555 000002B2 FF365E04            <2> 	push	WORD [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute]
  6556                              <2> 
  6557 000002B6 4D                  <2> 	dec		bp					; Point BP to...
  6558 000002B7 4D                  <2> 	dec		bp					; ...first stack parameter
  6559 000002B8 E88300              <2> 	call	DisplayFormat_ParseCharacters
  6560                              <2> 
  6561                              <2> 	; Pop original character attribute
  6562 000002BB 58                  <2> 	pop		ax
  6563 000002BC A25E04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], al
  6564                              <2> 
  6565 000002BF 5B                  <2> 	pop		bx
  6566 000002C0 59                  <2> 	pop		cx
  6567 000002C1 5E                  <2> 	pop		si
  6568 000002C2 5D                  <2> 	pop		bp
  6569                              <2> 
  6570 000002C3 C3                  <2> 	ret
  6571                              <2> 
  6572                              <2> 
  6573                              <2> ;--------------------------------------------------------------------
  6574                              <2> ; DisplayPrint_SignedWordFromAXWithBaseInBX
  6575                              <2> ;	Parameters:
  6576                              <2> ;		AX:		Word to display
  6577                              <2> ;		BX:		Integer base (binary=2, octal=8, decimal=10, hexadecimal=16)
  6578                              <2> ;		DS:		BDA segment (zero)
  6579                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6580                              <2> ;	Returns:
  6581                              <2> ;		DI:		Updated offset to video RAM
  6582                              <2> ;	Corrupts registers:
  6583                              <2> ;		AX, DX
  6584                              <2> ;--------------------------------------------------------------------
  6585                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6586                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6587                              <2> DisplayPrint_SignedWordFromAXWithBaseInBX:
  6588                              <2> 	test	ax, ax
  6589                              <2> 	jns		SHORT DisplayPrint_WordFromAXWithBaseInBX
  6590                              <2> 
  6591                              <2> 	push	ax
  6592                              <2> 	mov		al, '-'
  6593                              <2> 	call	DisplayPrint_CharacterFromAL
  6594                              <2> 	pop		ax
  6595                              <2> 	neg		ax
  6596                              <2> 	; Fall to DisplayPrint_WordFromAXWithBaseInBX
  6597                              <2> %endif
  6598                              <2> 
  6599                              <2> 
  6600                              <2> ;--------------------------------------------------------------------
  6601                              <2> ; DisplayPrint_WordFromAXWithBaseInBX
  6602                              <2> ;	Parameters:
  6603                              <2> ;		AX:		Word to display
  6604                              <2> ;		BX:		Integer base (binary=2, octal=8, decimal=10, hexadecimal=16)
  6605                              <2> ;		DS:		BDA segment (zero)
  6606                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6607                              <2> ;	Returns:
  6608                              <2> ;		DI:		Updated offset to video RAM
  6609                              <2> ;	Corrupts registers:
  6610                              <2> ;		AX, DX
  6611                              <2> ;--------------------------------------------------------------------
  6612                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  6613                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6614                              <2> DisplayPrint_WordFromAXWithBaseInBX:
  6615                              <2> 	push	cx
  6616                              <2> 	push	bx
  6617                              <2> 
  6618                              <2> 	xor		cx, cx
  6619                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6620                              <2> .DivideLoop:
  6621                              <2> 	xor		dx, dx				; DX:AX now holds the integer
  6622                              <2> 	div		bx					; Divide DX:AX by base
  6623                              <2> 	push	dx					; Push remainder
  6624                              <2> 	inc		cx					; Increment character count
  6625                              <2> 	test	ax, ax				; All divided?
  6626                              <2> 	jnz		SHORT .DivideLoop	;  If not, loop
  6627                              <2> 
  6628                              <2> PrintAllPushedDigits:
  6629                              <2> 	mov		bx, g_rgcDigitToCharacter
  6630                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6631                              <2> .PrintNextDigit:
  6632                              <2> 	pop		ax					; Pop digit
  6633                              <2> 	cs xlatb
  6634                              <2> 	call	DisplayPrint_CharacterFromAL
  6635                              <2> 	loop	.PrintNextDigit
  6636                              <2> 
  6637                              <2> 	pop		bx
  6638                              <2> 	pop		cx
  6639                              <2> 	ret
  6640                              <2> 
  6641                              <2> g_rgcDigitToCharacter:	db	"0123456789ABCDEF"
  6642                              <2> 
  6643                              <2> %endif ; MODULE_STRINGS_COMPRESSED
  6644                              <2> 
  6645                              <2> ;--------------------------------------------------------------------
  6646                              <2> ; DisplayPrint_QWordFromSSBPwithBaseInBX
  6647                              <2> ;	Parameters:
  6648                              <2> ;		SS:BP:	QWord to display
  6649                              <2> ;		BX:		Integer base (binary=2, octal=8, decimal=10, hexadecimal=16)
  6650                              <2> ;		DS:		BDA segment (zero)
  6651                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6652                              <2> ;	Returns:
  6653                              <2> ;		DI:		Updated offset to video RAM
  6654                              <2> ;	Corrupts registers:
  6655                              <2> ;		AX, DX, [SS:BP]
  6656                              <2> ;--------------------------------------------------------------------
  6657                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  6658                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6659                              <2> DisplayPrint_QWordFromSSBPwithBaseInBX:
  6660                              <2> 	push	cx
  6661                              <2> 	push	bx
  6662                              <2> 
  6663                              <2> 	mov		cx, bx				; CX = Integer base
  6664                              <2> 	xor		bx, bx				; BX = Character count
  6665                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6666                              <2> .DivideLoop:
  6667                              <2> 	call	Math_DivQWatSSBPbyCX; Divide by base
  6668                              <2> 	push	dx					; Push remainder
  6669                              <2> 	inc		bx					; Increment character count
  6670                              <2> 	cmp		WORD [bp], BYTE 0	; All divided?
  6671                              <2> 	jne		SHORT .DivideLoop	;  If not, loop
  6672                              <2> 	mov		cx, bx				; Character count to CX
  6673                              <2> 	jmp		SHORT PrintAllPushedDigits
  6674                              <2> %endif
  6675                              <2> 
  6676                              <2> 
  6677                              <2> ;--------------------------------------------------------------------
  6678                              <2> ; DisplayPrint_CharacterBufferFromBXSIwithLengthInCX
  6679                              <2> ;	Parameters:
  6680                              <2> ;		CX:		Buffer length (characters)
  6681                              <2> ;		BX:SI:	Ptr to NULL terminated string
  6682                              <2> ;		DS:		BDA segment (zero)
  6683                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6684                              <2> ;	Returns:
  6685                              <2> ;		DI:		Updated offset to video RAM
  6686                              <2> ;	Corrupts registers:
  6687                              <2> ;		AX, DX
  6688                              <2> ;--------------------------------------------------------------------
  6689                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6690                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6691                              <2> DisplayPrint_CharacterBufferFromBXSIwithLengthInCX:
  6692                              <2> 	jcxz	.NothingToPrintSinceZeroLength
  6693                              <2> 	push	si
  6694                              <2> 	push	cx
  6695                              <2> 
  6696                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6697                              <2> .PrintNextCharacter:
  6698                              <2> 	mov		ds, bx
  6699                              <2> 	lodsb
  6700                              <2> 	LOAD_BDA_SEGMENT_TO	ds, dx
  6701                              <2> 	call	DisplayPrint_CharacterFromAL
  6702                              <2> 	loop	.PrintNextCharacter
  6703                              <2> 
  6704                              <2> 	pop		cx
  6705                              <2> 	pop		si
  6706                              <2> .NothingToPrintSinceZeroLength:
  6707                              <2> 	ret
  6708                              <2> %endif
  6709                              <2> 
  6710                              <2> 
  6711                              <2> ;--------------------------------------------------------------------
  6712                              <2> ; DisplayPrint_ClearScreenWithCharInALandAttributeInAH
  6713                              <2> ;	Parameters:
  6714                              <2> ;		AL:		Character to clear with
  6715                              <2> ;		AH:		Attribute to clear with
  6716                              <2> ;		DS:		BDA segment (zero)
  6717                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6718                              <2> ;	Returns:
  6719                              <2> ;		Nothing
  6720                              <2> ;	Corrupts registers:
  6721                              <2> ;		AX, DX
  6722                              <2> ;--------------------------------------------------------------------
  6723                              <2> %ifdef INCLUDE_MENU_LIBRARY
  6724                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6725                              <2> DisplayPrint_ClearScreenWithCharInALandAttributeInAH:
  6726                              <2> 	push	di
  6727                              <2> 	push	cx
  6728                              <2> 
  6729                              <2> 	xchg	cx, ax
  6730                              <2> 	xor		ax, ax
  6731                              <2> 	call	DisplayCursor_SetCoordinatesFromAX		; Updates DI
  6732                              <2> 	call	DisplayPage_GetColumnsToALandRowsToAH
  6733                              <2> 	mul		ah		; AX = AL*AH = Characters on screen
  6734                              <2> 	xchg	cx, ax	; AX = Char+Attr, CX = WORDs to store
  6735                              <2> 	rep stosw
  6736                              <2> 
  6737                              <2> 	pop		cx
  6738                              <2> 	pop		di
  6739                              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fpCursorPosition], di
  6740                              <2> 	ret
  6741                              <2> %endif
  6742                              <2> 
  6743                              <2> 
  6744                              <2> ;--------------------------------------------------------------------
  6745                              <2> ; DisplayPrint_ClearAreaWithHeightInAHandWidthInAL
  6746                              <2> ;	Parameters:
  6747                              <2> ;		AH:		Area height
  6748                              <2> ;		AL:		Area width
  6749                              <2> ;		DS:		BDA segment (zero)
  6750                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6751                              <2> ;	Returns:
  6752                              <2> ;		DI:		Updated offset to video RAM
  6753                              <2> ;	Corrupts registers:
  6754                              <2> ;		AX, DX
  6755                              <2> ;--------------------------------------------------------------------
  6756                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6757                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6758                              <2> DisplayPrint_ClearAreaWithHeightInAHandWidthInAL:
  6759                              <2> 	push	si
  6760                              <2> 	push	cx
  6761                              <2> 	push	bx
  6762                              <2> 
  6763                              <2> 	xchg	bx, ax							; Area size to BX
  6764                              <2> 	call	DisplayCursor_GetSoftwareCoordinatesToAX
  6765                              <2> 	xchg	si, ax							; Software (Y,X) coordinates now in SI
  6766                              <2> 	xor		cx, cx
  6767                              <2> 
  6768                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6769                              <2> .ClearRowLoop:
  6770                              <2> 	mov		cl, bl							; Area width now in CX
  6771                              <2> 	mov		al, SCREEN_BACKGROUND_CHARACTER
  6772                              <2> 	call	DisplayPrint_RepeatCharacterFromALwithCountInCX
  6773                              <2> 
  6774                              <2> 	xchg	ax, si							; Coordinates to AX
  6775                              <2> 	inc		ah								; Increment row
  6776                              <2> 	mov		si, ax
  6777                              <2> 	call	DisplayCursor_SetCoordinatesFromAX
  6778                              <2> 	dec		bh								; Decrement rows left
  6779                              <2> 	jnz		SHORT .ClearRowLoop
  6780                              <2> 
  6781                              <2> 	pop		bx
  6782                              <2> 	pop		cx
  6783                              <2> 	pop		si
  6784                              <2> 	ret
  6785                              <2> %endif
  6786                              <2> 
  6787                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  6788                              <2> 	%define EXCLUDE
  6789                              <2> 	%ifdef MODULE_HOTKEYS
  6790                              <2> 		%undef EXCLUDE
  6791                              <2> 	%endif
  6792                              <2> 	%ifdef MODULE_BOOT_MENU
  6793                              <2> 		%undef EXCLUDE
  6794                              <2> 	%endif
  6795                              <2> %endif
  6796                              <2> 
  6797                              <2> %ifndef EXCLUDE
  6798                              <2> ;--------------------------------------------------------------------
  6799                              <2> ; DisplayPrint_RepeatCharacterFromALwithCountInCX
  6800                              <2> ;	Parameters:
  6801                              <2> ;		AL:		Character to display
  6802                              <2> ;		CX:		Repeat count
  6803                              <2> ;		DS:		BDA segment (zero)
  6804                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6805                              <2> ;	Returns:
  6806                              <2> ;		DI:		Updated offset to video RAM
  6807                              <2> ;	Corrupts registers:
  6808                              <2> ;		DX
  6809                              <2> ;--------------------------------------------------------------------
  6810                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6811                              <2> DisplayPrint_RepeatCharacterFromALwithCountInCX:
  6812 000002C4 E309                <2> 	jcxz	.NothingToRepeat
  6813 000002C6 51                  <2> 	push	cx
  6814                              <2> 
  6815                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6816                              <2> .RepeatCharacter:
  6817 000002C7 50                  <2> 	push	ax
  6818 000002C8 E80E00              <2> 	call	DisplayPrint_CharacterFromAL
  6819 000002CB 58                  <2> 	pop		ax
  6820 000002CC E2F9                <2> 	loop	.RepeatCharacter
  6821                              <2> 
  6822 000002CE 59                  <2> 	pop		cx
  6823                              <2> .NothingToRepeat:
  6824 000002CF C3                  <2> 	ret
  6825                              <2> %endif
  6826                              <2> %undef EXCLUDE
  6827                              <2> 
  6828                              <2> ;--------------------------------------------------------------------
  6829                              <2> ; DisplayPrint_NullTerminatedStringFromCSSI
  6830                              <2> ;	Parameters:
  6831                              <2> ;		CS:SI:	Ptr to NULL terminated string
  6832                              <2> ;		DS:		BDA segment (zero)
  6833                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6834                              <2> ;	Returns:
  6835                              <2> ;		DI:		Updated offset to video RAM
  6836                              <2> ;	Corrupts registers:
  6837                              <2> ;		AX, DX
  6838                              <2> ;--------------------------------------------------------------------
  6839                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  6840                              <2> ;;;
  6841                              <2> ;;; Take care when using this routine with compressed strings (which is why it is disabled).
  6842                              <2> ;;; All strings in CSSI should go through the DisplayFormatCompressed code to be decoded.
  6843                              <2> ;;;
  6844                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6845                              <2> DisplayPrint_NullTerminatedStringFromCSSI:
  6846                              <2> 	push	bx
  6847                              <2> 	mov		bx, cs
  6848                              <2> 	call	DisplayPrint_NullTerminatedStringFromBXSI
  6849                              <2> 	pop		bx
  6850                              <2> 	ret
  6851                              <2> %endif
  6852                              <2> 
  6853                              <2> 
  6854                              <2> ;;;
  6855                              <2> ;;; Note that the following routines need to be at the bottom of this file
  6856                              <2> ;;; to accomodate short jumps from the next file (DisplayFormat/DisplayFormatCompressed)
  6857                              <2> ;;;
  6858                              <2> 
  6859                              <2> ;--------------------------------------------------------------------
  6860                              <2> ; DisplayPrint_Newline
  6861                              <2> ;	Parameters:
  6862                              <2> ;		DS:		BDA segment (zero)
  6863                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6864                              <2> ;	Returns:
  6865                              <2> ;		DI:		Updated offset to video RAM
  6866                              <2> ;	Corrupts registers:
  6867                              <2> ;		AX, DX
  6868                              <2> ;--------------------------------------------------------------------
  6869                              <2> %ifdef MODULE_STRINGS_COMPRESSED
  6870                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6871                              <2> DisplayPrint_Newline_FormatAdjustBP:
  6872 000002D0 45                  <2> 	inc		bp					; we didn't need a parameter after all, readjust BP
  6873 000002D1 45                  <2> 	inc		bp
  6874                              <2> 	; fall through to DisplayPrint_Newline
  6875                              <2> %endif
  6876                              <2> 
  6877                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6878                              <2> DisplayPrint_Newline:
  6879 000002D2 B00A                <2> 	mov		al, LF
  6880 000002D4 E80200              <2> 	call	DisplayPrint_CharacterFromAL
  6881 000002D7 B00D                <2> 	mov		al, CR
  6882                              <2> 	; Fall to DisplayPrint_CharacterFromAL
  6883                              <2> 
  6884                              <2> ;--------------------------------------------------------------------
  6885                              <2> ; DisplayPrint_CharacterFromAL
  6886                              <2> ;	Parameters:
  6887                              <2> ;		AL:		Character to display
  6888                              <2> ;               Zero value is ignored (no character is printed)
  6889                              <2> ;		DS:		BDA segment (zero)
  6890                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6891                              <2> ;	Returns:
  6892                              <2> ;		DI:		Updated offset to video RAM
  6893                              <2> ;	Corrupts registers:
  6894                              <2> ;		AX, DX
  6895                              <2> ;--------------------------------------------------------------------
  6896                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6897                              <2> DisplayPrint_CharacterFromAL:
  6898 000002D9 84C0                <2> 	test	al, al
  6899 000002DB 741C                <2> 	jz		DisplayPrint_Ret
  6900                              <2> 
  6901 000002DD 8A265E04            <2> 	mov		ah, [VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute]
  6902 000002E1 FF265804            <2> 	jmp		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.fnCharOut]
  6903                              <2> 
  6904                              <2> 
  6905                              <2> ;--------------------------------------------------------------------
  6906                              <2> ; DisplayPrint_NullTerminatedStringFromBXSI
  6907                              <2> ;	Parameters:
  6908                              <2> ;		DS:		BDA segment (zero)
  6909                              <2> ;		BX:SI:	Ptr to NULL terminated string
  6910                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  6911                              <2> ;	Returns:
  6912                              <2> ;		DI:		Updated offset to video RAM
  6913                              <2> ;	Corrupts registers:
  6914                              <2> ;		AX, DX
  6915                              <2> ;--------------------------------------------------------------------
  6916                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6917                              <2> DisplayPrint_NullTerminatedStringFromBXSI:
  6918 000002E5 56                  <2> 	push	si
  6919 000002E6 51                  <2> 	push	cx
  6920                              <2> 
  6921 000002E7 31C9                <2> 	xor		cx, cx
  6922                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6923                              <2> .PrintNextCharacter:
  6924 000002E9 8EDB                <2> 	mov		ds, bx				; String segment to DS
  6925 000002EB AC                  <2> 	lodsb
  6926 000002EC 8ED9                <2> 	mov		ds, cx				; BDA segment to DS
  6927 000002EE 84C0                <2> 	test	al, al				; NULL?
  6928 000002F0 7405                <2> 	jz		SHORT .EndOfString
  6929 000002F2 E8E4FF              <2> 	call	DisplayPrint_CharacterFromAL
  6930 000002F5 EBF2                <2> 	jmp		SHORT .PrintNextCharacter
  6931                              <2> 
  6932                              <2> ALIGN DISPLAY_JUMP_ALIGN
  6933                              <2> .EndOfString:
  6934 000002F7 59                  <2> 	pop		cx
  6935 000002F8 5E                  <2> 	pop		si
  6936                              <2> 
  6937                              <2> DisplayPrint_Ret:				; random ret to jump to
  6938 000002F9 C3                  <2> 	ret
  6939                              <2> 
  6940                              <1> %ifdef MODULE_STRINGS_COMPRESSED
  6941                              <1> 	%include "DisplayFormatCompressed.asm"
  6942                              <2> ; Project name	:	Assembly Library
  6943                              <2> ; Description	:	Functions for displaying formatted strings.
  6944                              <2> ;					** Compressed Strings edition **
  6945                              <2> ;					This is a plug replacement for DisplayFormat.asm,
  6946                              <2> ;					working instead with precompiled and slightly compressed strings.
  6947                              <2> 
  6948                              <2> ;
  6949                              <2> ; XTIDE Universal BIOS and Associated Tools
  6950                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  6951                              <2> ;
  6952                              <2> ; This program is free software; you can redistribute it and/or modify
  6953                              <2> ; it under the terms of the GNU General Public License as published by
  6954                              <2> ; the Free Software Foundation; either version 2 of the License, or
  6955                              <2> ; (at your option) any later version.
  6956                              <2> ;
  6957                              <2> ; This program is distributed in the hope that it will be useful,
  6958                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  6959                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  6960                              <2> ; GNU General Public License for more details.
  6961                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  6962                              <2> ;
  6963                              <2> 
  6964                              <2> ;=============================================================================================
  6965                              <2> ;
  6966                              <2> ; Strings are compressed in a simple manner:
  6967                              <2> ;	1. The two most common characters, space and null, are removed
  6968                              <2> ;	2. Format specifiers are reduced to a single byte, including length information
  6969                              <2> ;
  6970                              <2> ; Format of bytes in the string are:
  6971                              <2> ;     01 xxxxxx     Character in x plus StringsCompressed_NormalBase
  6972                              <2> ;     10 xxxxxx     Character in x plus StringsCompressed_NormalBase, followed by a null (last character)
  6973                              <2> ;     11 xxxxxx     Character in x plus StringsCompressed_NormalBase, followed by a space
  6974                              <2> ;     00 1 yyyyy    Character/Format in lookup table StringsCopmressed_TranslatesAndFormats
  6975                              <2> ;     00 0 yyyyy    Character/Format in lookup table StringsCompressed_TranslatesAndFormats, followed by a null
  6976                              <2> ;
  6977                              <2> ; StringsCompressed_NormalBase is defined by the compressor, but is usually around 0x40,
  6978                              <2> ; which gives a range of 0x40 to 0x7f, or roughly the upper and lower case letters.
  6979                              <2> ;
  6980                              <2> ; StringsCompressed_TranslatesAndFormats is a lookup table with the first few bytes being translation
  6981                              <2> ; characters, and the last few bytes being format jump offsets from DisplayFormatCompressed_BaseFormatOffset.
  6982                              <2> ; The dividing line is defined by StringsCompressed_FormatsBegin
  6983                              <2> ;
  6984                              <2> ; The assignments of the first two bits above is not by accident.  The translates/format branch is 00
  6985                              <2> ; which is easy to test for.  The '01' for "normal" (no null or space) and '001' for translates/format "normal"
  6986                              <2> ; match, allowing the translates/format codes to be shifted left by 1 and then tested with the same instructions.
  6987                              <2> ;
  6988                              <2> ; It is always possible to say that a null character follows the current character - thus there is
  6989                              <2> ; no way (nor need) to specify a zero character.
  6990                              <2> ;
  6991                              <2> ; Note that this code is optimized for size, not speed.  Since this code is used only during initialization
  6992                              <2> ; and only for the user interface, small performance hits should not be noticed.  It will seem odd to do so
  6993                              <2> ; much "preload", just in case a branch is taken, but that is cheaper (in size) than adding additional branches.
  6994                              <2> ;
  6995                              <2> 
  6996                              <2> ; Section containing code
  6997                              <2> SECTION .text
  6998                              <2> 
  6999                              <2> ;--------------------------------------------------------------------
  7000                              <2> ; Format Handlers
  7001                              <2> ;
  7002                              <2> ; Names of format handlers are DisplayFormatCompressed_Format_* where * is
  7003                              <2> ; replaced with the format code after the '%' in the original string,
  7004                              <2> ; with '-' replaced with '_'.
  7005                              <2> ;
  7006                              <2> ;	Parameters:
  7007                              <2> ;		DS:		BDA segment (zero)
  7008                              <2> ;		AX:     Parameter to Format
  7009                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  7010                              <2> ;	Returns:
  7011                              <2> ;		DI:		Updated offset to video RAM
  7012                              <2> ;	Corrupts registers:
  7013                              <2> ;		AX, BX, CX, DX, SI
  7014                              <2> ;--------------------------------------------------------------------
  7015                              <2> 
  7016                              <2> ;
  7017                              <2> ; The following routines do not need any pre or post processing and can be jumped to directly.
  7018                              <2> ; Note that they need to be within 256 bytes of DisplayFormatCompressed_BaseFormatOffset
  7019                              <2> ;
  7020                              <2> %define DisplayFormatCompressed_Format_c DisplayPrint_CharacterFromAL
  7021                              <2> %define DisplayFormatCompressed_Format_nl DisplayPrint_Newline_FormatAdjustBP
  7022                              <2> %define DisplayFormatCompressed_Format_s DisplayFormat_ParseCharacters_FromAX
  7023                              <2> 
  7024                              <2> DisplayFormatCompressed_Format_A:
  7025 000002FA A25E04              <2> 	mov		[VIDEO_BDA.displayContext+DISPLAY_CONTEXT.bAttribute], al
  7026                              <2> DisplayFormatCompressed_ret:			; jump target for other routines who need a "ret"
  7027 000002FD C3                  <2> 	ret
  7028                              <2> 
  7029                              <2> DisplayFormatCompressed_Format_z:
  7030 000002FE 31DB                <2> 	xor		bx, bx
  7031 00000300 96                  <2> 	xchg	si, ax
  7032 00000301 EBE2                <2> 	jmp		short DisplayPrint_NullTerminatedStringFromBXSI
  7033                              <2> 
  7034                              <2> DisplayFormatCompressed_Format_x:
  7035                              <2> DisplayFormatCompressed_Format_5_x:
  7036 00000303 BE1000              <2> 	mov		si,16						; hex output, change base to 16
  7037 00000306 BB6804              <2> 	mov		bx,(04<<8) + 'h'	        ; 4 bytes, with postfix character 'h' to emit
  7038                              <2> 										; (note that the count includes the 'h')
  7039 00000309 EB09                <2> 	jmp		DisplayFormatCompressed_Format_u
  7040                              <2> 
  7041                              <2> DisplayFormatCompressed_Format_2_I:
  7042 0000030B BE[D500]            <2> 	mov		si,g_szDashForZero			; preload dash string in case we jump
  7043 0000030E 85C0                <2> 	test	ax,ax						; if parameter equals zero, emit dash string instead
  7044 00000310 742C                <2> 	jz		DisplayFormat_ParseCharacters
  7045                              <2> 	; fall through
  7046                              <2> 
  7047                              <2> DisplayFormatCompressed_Format_2_u:
  7048 00000312 B702                <2> 	mov		bh,2						; only two characters (instead of the default 5)
  7049                              <2> 	; fall through
  7050                              <2> 
  7051                              <2> DisplayFormatCompressed_Format_u:
  7052                              <2> DisplayFormatCompressed_Format_5_u:
  7053 00000314 53                  <2> 	push	bx							; push postfix character - either a zero (default) or a 'h'
  7054 00000315 88FB                <2> 	mov		bl,bh						; preserve character count for .PrintLoop
  7055                              <2> 
  7056                              <2> .DivLoop:
  7057 00000317 31D2                <2> 	xor		dx, dx						; Zero DX for division
  7058 00000319 F7F6                <2> 	div		si							; DX:AX / 10 => AX=quot, DX=rem
  7059 0000031B 52                  <2>  	push	dx							; Push digit
  7060                              <2> 
  7061 0000031C FECF                <2> 	dec		bh
  7062 0000031E 75F7                <2> 	jnz		.DivLoop
  7063                              <2> 
  7064                              <2> .PrintLoop:
  7065 00000320 58                  <2> 	pop		ax							; Pop digit, postfix character on last iteration
  7066                              <2> 
  7067 00000321 FECB                <2> 	dec		bl							; on second to last iteration, emit digit whether it is zero or not
  7068 00000323 740D                <2> 	jz		.PrintDigit
  7069                              <2> 
  7070 00000325 78B2                <2> 	js		short DisplayPrint_CharacterFromAL	; on last iteration, emit postfix character
  7071                              <2> 												; if it is zero, DisplayPrint_CharacterFromAL will not emit
  7072                              <2> 
  7073 00000327 08C7                <2> 	or		bh, al						; skip leading zeros, bh keeps track if we have emitted anything non-zero
  7074 00000329 7507                <2> 	jnz		.PrintDigit					; note that bh starts at zero, from the loop above
  7075                              <2> 
  7076 0000032B F6C502              <2> 	test	ch,2						; are we padding with leading spaces?
  7077 0000032E 75F0                <2> 	jnz		.PrintLoop					; test the even/odd of the format byte in the string
  7078                              <2> 
  7079 00000330 B089                <2> 	mov		al, 89h						; emit space
  7080                              <2> 
  7081                              <2> .PrintDigit:
  7082 00000332 3C0A                <2> 	cmp		al, 10						; Convert binary digit in AL to ASCII hex digit ('0'-'9' or 'A'-'F')
  7083 00000334 1C69                <2> 	sbb		al, 69h
  7084 00000336 2F                  <2> 	das
  7085                              <2> 
  7086 00000337 E89FFF              <2> 	call	DisplayPrint_CharacterFromAL
  7087                              <2> 
  7088 0000033A EBE4                <2> 	jmp		.PrintLoop
  7089                              <2> 
  7090                              <2> 
  7091                              <2> ;--------------------------------------------------------------------
  7092                              <2> ; DisplayFormat_ParseCharacters
  7093                              <2> ;	Parameters:
  7094                              <2> ;		DS:		BDA segment (zero)
  7095                              <2> ;		SS:BP:	Pointer to first format parameter (-=2 updates to next parameter)
  7096                              <2> ;		CS:SI:	Pointer to string to format
  7097                              <2> ;		ES:DI:	Ptr to cursor location in video RAM
  7098                              <2> ;	Returns:
  7099                              <2> ;		CS:SI:	Ptr to end of format string (ptr to one past NULL)
  7100                              <2> ;		DI:		Updated offset to video RAM
  7101                              <2> ;	Corrupts registers:
  7102                              <2> ;		AX, BX, CX, DX, BP
  7103                              <2> ;--------------------------------------------------------------------
  7104                              <2> 
  7105                              <2> DisplayFormatCompressed_BaseFormatOffset:
  7106                              <2> 
  7107                              <2> DisplayFormat_ParseCharacters_FromAX:
  7108 0000033C 89C6                <2> 	mov		si,ax
  7109                              <2> 	; fall through to DisplayFormat_ParseCharacters
  7110                              <2> 
  7111                              <2> ALIGN DISPLAY_JUMP_ALIGN
  7112                              <2> DisplayFormat_ParseCharacters:
  7113                              <2> ;
  7114                              <2> ; This routine is used to output all strings from the ROM.  The strings in ROMVARS are not compressed,
  7115                              <2> ; and must be handled differently.
  7116                              <2> ;
  7117 0000033E 83FE7F              <2> 	cmp		si,byte 07fh		; well within the boundaries of ROMVARS_size
  7118 00000341 8CCB                <2> 	mov		bx,cs				; preload bx with cs in case we take the following jump
  7119 00000343 72A0                <2> 	jb		short DisplayPrint_NullTerminatedStringFromBXSI
  7120                              <2> 
  7121                              <2> .decode:
  7122 00000345 2EAC                <2> 	cs lodsb					; load next byte of the string
  7123                              <2> 
  7124 00000347 88C5                <2> 	mov		ch,al				; save a copy for later processing of high order bits
  7125                              <2> 
  7126 00000349 A8C0                <2> 	test	al,0c0h				; check for translation/format character
  7127 0000034B 7414                <2> 	jz		DisplayFormatCompressed_TranslatesAndFormats
  7128                              <2> 
  7129 0000034D 243F                <2> 	and		al,03fh								; "Normal" character, mask off high order bits
  7130 0000034F 043A                <2> 	add		al,StringsCompressed_NormalBase		; and add character offset (usually around 0x40)
  7131                              <2> 
  7132                              <2> .output:
  7133 00000351 E885FF              <2> 	call 	DisplayPrint_CharacterFromAL
  7134                              <2> 
  7135                              <2> .process_after_output:
  7136                              <2> 	eSHL_IM	ch,1								; check high order bits for end of string or space
  7137                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  7138                              <3> %ifdef USE_386
  7139                              <3>  %if %2 = 1
  7140                              <3>  add %1, %1
  7141                              <3>  %else
  7142                              <3>  eSHIFT_IM %1, %2, shl
  7143                              <3>  %endif
  7144                              <3> %else
  7145                              <3>  eSHIFT_IM %1, %2, shl
  7146                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  7147                              <4> %ifndef USE_186
  7148                              <4>  %ifidni %1, cl
  7149                              <4>  times %2 %3 %1, 1
  7150                              <4>  %elifidni %1, ch
  7151 00000354 D0E5                <4>  times %2 %3 %1, 1
  7152                              <4>  %elifidni %1, cx
  7153                              <4>  times %2 %3 %1, 1
  7154                              <4>  %else
  7155                              <4>  %if %2 > 3
  7156                              <4>  push cx
  7157                              <4>  mov cl, %2
  7158                              <4>  %3 %1, cl
  7159                              <4>  pop cx
  7160                              <4>  %else
  7161                              <4>  times %2 %3 %1, 1
  7162                              <4>  %endif
  7163                              <4>  %endif
  7164                              <4> 
  7165                              <4> %else
  7166                              <4>  %3 %1, %2
  7167                              <4> %endif
  7168                              <4> %endif
  7169                              <3> %endif
  7170                              <3> %endif
  7171 00000356 79A5                <2> 	jns		short DisplayFormatCompressed_ret
  7172 00000358 73EB                <2> 	jnc		.decode
  7173 0000035A B020                <2> 	mov		al,' '
  7174 0000035C E87AFF              <2> 	call	DisplayPrint_CharacterFromAL
  7175 0000035F EBE4                <2> 	jmp		.decode
  7176                              <2> 
  7177                              <2> 
  7178                              <2> ALIGN DISPLAY_JUMP_ALIGN
  7179                              <2> DisplayFormatCompressed_TranslatesAndFormats:
  7180                              <2> ;
  7181                              <2> ; This routine is here (above DisplayFormat_ParseCharacters) to reduce the amount of code between
  7182                              <2> ; DisplayFormatCompressed_BaseFormatOffset and jump targets (must fit in 256 bytes)
  7183                              <2> ;
  7184                              <2> 	eSHL_IM	ch,1				; setup ch for later testing of null in .process_after_output
  7185                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  7186                              <3> %ifdef USE_386
  7187                              <3>  %if %2 = 1
  7188                              <3>  add %1, %1
  7189                              <3>  %else
  7190                              <3>  eSHIFT_IM %1, %2, shl
  7191                              <3>  %endif
  7192                              <3> %else
  7193                              <3>  eSHIFT_IM %1, %2, shl
  7194                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  7195                              <4> %ifndef USE_186
  7196                              <4>  %ifidni %1, cl
  7197                              <4>  times %2 %3 %1, 1
  7198                              <4>  %elifidni %1, ch
  7199 00000361 D0E5                <4>  times %2 %3 %1, 1
  7200                              <4>  %elifidni %1, cx
  7201                              <4>  times %2 %3 %1, 1
  7202                              <4>  %else
  7203                              <4>  %if %2 > 3
  7204                              <4>  push cx
  7205                              <4>  mov cl, %2
  7206                              <4>  %3 %1, cl
  7207                              <4>  pop cx
  7208                              <4>  %else
  7209                              <4>  times %2 %3 %1, 1
  7210                              <4>  %endif
  7211                              <4>  %endif
  7212                              <4> 
  7213                              <4> %else
  7214                              <4>  %3 %1, %2
  7215                              <4> %endif
  7216                              <4> %endif
  7217                              <3> %endif
  7218                              <3> %endif
  7219 00000363 83E01F              <2> 	and		ax,0001fh			; also clears AH for addition with BX and DX below
  7220                              <2> 
  7221 00000366 BB[1304]            <2> 	mov		bx,StringsCompressed_TranslatesAndFormats	; calculate offset of translation/formats offset byte
  7222 00000369 01C3                <2> 	add		bx,ax
  7223                              <2> 
  7224 0000036B 3C14                <2> 	cmp		al,StringsCompressed_FormatsBegin			; determine if this is a translation or a format
  7225                              <2> 
  7226 0000036D 2E8A07              <2> 	mov		al,[cs:bx]									; fetch translation/formats byte
  7227                              <2> 
  7228 00000370 72DF                <2> 	jb		DisplayFormat_ParseCharacters.output		; check if this a translation or a format
  7229                              <2> 														; if it is translation, output and postprocess for eos
  7230                              <2> 														; note that the flags for this conditional jump were
  7231                              <2> 														; set with the cmp al,StringsCompressed_FormatsBegin
  7232                              <2> 
  7233 00000372 BA[3C03]            <2> 	mov		dx,DisplayFormatCompressed_BaseFormatOffset   ; calculate address to jump to for format handler
  7234 00000375 29C2                <2> 	sub		dx,ax
  7235                              <2> 
  7236 00000377 8B4600              <2> 	mov		ax,[bp]				; preload ax with parameter
  7237 0000037A 4D                  <2> 	dec		bp					; if no parameter is needed (format 'nl' for example),
  7238 0000037B 4D                  <2> 	dec		bp					; the format handler can reincrement bp
  7239                              <2> 
  7240 0000037C BB0005              <2> 	mov		bx,0500h			; preload bh with 5 decimal places for numeric output
  7241                              <2> 								; bl is zero, indicating not to output a 'h' (default base 10)
  7242                              <2> 
  7243 0000037F 56                  <2> 	push	si					; preserve si and cx, in the case of outputing a string
  7244 00000380 51                  <2> 	push	cx
  7245                              <2> 
  7246 00000381 BE0A00              <2> 	mov		si,10				; preload si with 10 for numeric output (default base 10)
  7247                              <2> 
  7248 00000384 FFD2                <2> 	call	dx					; call the format routine
  7249                              <2> 
  7250 00000386 59                  <2> 	pop		cx					; restore cx and si
  7251 00000387 5E                  <2> 	pop		si
  7252                              <2> 
  7253 00000388 EBCA                <2> 	jmp		DisplayFormat_ParseCharacters.process_after_output	; continue postprocessing, check for end of string
  7254                              <2> 
  7255                              <1> %else
  7256                              <1> 	%include "DisplayFormat.asm"
  7257                              <1> %endif
  7258                              <1> %endif
  7259                              <1> 
  7260                              <1> %ifdef INCLUDE_FILE_LIBRARY
  7261                              <1> 	%include "Directory.asm"
  7262                              <1> 	%include "DosCritical.asm"
  7263                              <1> 	%include "Drive.asm"
  7264                              <1> 	%include "FileIO.asm"
  7265                              <1> %endif
  7266                              <1> 
  7267                              <1> %ifdef INCLUDE_KEYBOARD_LIBRARY
  7268                              <1>   %ifndef KEYBOARD_JUMP_ALIGN
  7269                              <1> 	%define KEYBOARD_JUMP_ALIGN 1
  7270                              <1>   %endif
  7271                              <1> 	%include "Keyboard.asm"
  7272                              <2> ; Project name	:	Assembly Library
  7273                              <2> ; Description	:	Functions for managing keyboard.
  7274                              <2> 
  7275                              <2> ;
  7276                              <2> ; XTIDE Universal BIOS and Associated Tools
  7277                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  7278                              <2> ;
  7279                              <2> ; This program is free software; you can redistribute it and/or modify
  7280                              <2> ; it under the terms of the GNU General Public License as published by
  7281                              <2> ; the Free Software Foundation; either version 2 of the License, or
  7282                              <2> ; (at your option) any later version.
  7283                              <2> ;
  7284                              <2> ; This program is distributed in the hope that it will be useful,
  7285                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7286                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7287                              <2> ; GNU General Public License for more details.
  7288                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  7289                              <2> ;
  7290                              <2> 
  7291                              <2> 
  7292                              <2> BUFFER_SIZE_FOR_WORD_INPUT		EQU		6	; 5 chars + NULL
  7293                              <2> 
  7294                              <2> ; Section containing code
  7295                              <2> SECTION .text
  7296                              <2> 
  7297                              <2> ;--------------------------------------------------------------------
  7298                              <2> ; Reads user inputted word.
  7299                              <2> ; Function returns when ENTER or ESC will be pressed.
  7300                              <2> ;
  7301                              <2> ; Keyboard_ReadUserInputtedWordWhilePrinting
  7302                              <2> ;	Parameters
  7303                              <2> ;		BX:		Numeric base (10 or 16)
  7304                              <2> ;	Returns:
  7305                              <2> ;		AX:		User inputted word
  7306                              <2> ;		ZF:		Set if user cancellation
  7307                              <2> ;	Corrupts registers:
  7308                              <2> ;		DX
  7309                              <2> ;--------------------------------------------------------------------
  7310                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7311                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7312                              <2> Keyboard_ReadUserInputtedWordWhilePrinting:
  7313                              <2> 	push	ds
  7314                              <2> 	push	si
  7315                              <2> 	push	cx
  7316                              <2> 
  7317                              <2> 	mov		cx, BUFFER_SIZE_FOR_WORD_INPUT
  7318                              <2> 	call	Memory_ReserveCXbytesFromStackToDSSI
  7319                              <2> 
  7320                              <2> 	call	Char_GetFilterFunctionToDXforNumericBaseInBX
  7321                              <2> 	call	Registers_ExchangeDSSIwithESDI
  7322                              <2> 	call	Keyboard_ReadUserInputtedStringToESDIWhilePrinting
  7323                              <2> 	call	Registers_ExchangeDSSIwithESDI	; Does not modify FLAGS
  7324                              <2> 	jz		SHORT .CancelledByUser
  7325                              <2> 
  7326                              <2> 	call	String_ConvertWordToAXfromStringInDSSIwithBaseInBX
  7327                              <2> .CancelledByUser:
  7328                              <2> 	add		sp, BYTE BUFFER_SIZE_FOR_WORD_INPUT
  7329                              <2> 	test	cx, cx							; Set ZF if string length is zero
  7330                              <2> 	pop		cx
  7331                              <2> 	pop		si
  7332                              <2> 	pop		ds
  7333                              <2> 	ret
  7334                              <2> %endif
  7335                              <2> 
  7336                              <2> 
  7337                              <2> ;--------------------------------------------------------------------
  7338                              <2> ; Reads user inputted string to buffer. Character filter is
  7339                              <2> ; supported to ignore unwanted characters.
  7340                              <2> ; Function returns when ENTER or ESC will be pressed.
  7341                              <2> ;
  7342                              <2> ; Keyboard_ReadUserInputtedStringToESDIWhilePrinting
  7343                              <2> ;	Parameters:
  7344                              <2> ;		CX:		Buffer size (with NULL)
  7345                              <2> ;		ES:DI:	Ptr to destination buffer
  7346                              <2> ;		CS:DX:	Ptr to character filter function:
  7347                              <2> ;					Parameters:
  7348                              <2> ;						AL:		Character inputted by user
  7349                              <2> ;					Returns:
  7350                              <2> ;						CF:		Set if character is accepted
  7351                              <2> ;								Cleared if character is rejected
  7352                              <2> ;					Corrupts registers:
  7353                              <2> ;						Nothing
  7354                              <2> ;	Returns:
  7355                              <2> ;		CX:		String length in characters (without NULL)
  7356                              <2> ;		ZF:		Set if user cancellation
  7357                              <2> ;	Corrupts registers:
  7358                              <2> ;		AX
  7359                              <2> ;--------------------------------------------------------------------
  7360                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7361                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7362                              <2> Keyboard_ReadUserInputtedStringToESDIWhilePrinting:
  7363                              <2> 	push	di
  7364                              <2> 	push	si
  7365                              <2> 	push	bx
  7366                              <2> 	call	.PrepareDisplayContextForKeyboardInput
  7367                              <2> 	jcxz	.ReturnAfterUpdatingZF
  7368                              <2> 
  7369                              <2> 	xor		bx, bx								; Zero character counter
  7370                              <2> 	dec		cx									; Decrement buffer size for NULL
  7371                              <2> 	cld
  7372                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7373                              <2> .GetCharacterFromUser:
  7374                              <2> 	call	Keyboard_GetKeystrokeToAXandWaitIfNecessary	; Get ASCII to AL
  7375                              <2> 	call	.ProcessControlCharacter
  7376                              <2> 	jz		SHORT .TerminateStringWithNULL
  7377                              <2> 	jc		SHORT .PlayBellForRejectedCharacter
  7378                              <2> 	call	dx									; Filter character
  7379                              <2> 	jnc		SHORT .PlayBellForRejectedCharacter
  7380                              <2> 	inc		bx									; Increment number of characters stored
  7381                              <2> 	stosb										; Store from AL to ES:DI
  7382                              <2> 	call	Keyboard_PrintInputtedCharacter
  7383                              <2> 	loop	.GetCharacterFromUser
  7384                              <2> .PlayBellForRejectedCharacter:
  7385                              <2> 	cmp		al, BS								; No bell for backspace
  7386                              <2> 	je		SHORT .GetCharacterFromUser
  7387                              <2> 	call	Keyboard_PlayBellForUnwantedKeystroke
  7388                              <2> 	jmp		SHORT .GetCharacterFromUser
  7389                              <2> 
  7390                              <2> .TerminateStringWithNULL:
  7391                              <2> 	stosb										; Terminate string with NULL
  7392                              <2> 	mov		cx, bx								; String length now in CX
  7393                              <2> 
  7394                              <2> .ReturnAfterUpdatingZF:
  7395                              <2> 	CALL_DISPLAY_LIBRARY PopDisplayContext
  7396                              <2> 	test	cx, cx								; Clear or set ZF
  7397                              <2> 	pop		bx
  7398                              <2> 	pop		si
  7399                              <2> 	pop		di
  7400                              <2> 	ret
  7401                              <2> 
  7402                              <2> ;--------------------------------------------------------------------
  7403                              <2> ; .PrepareDisplayContextForKeyboardInput
  7404                              <2> ;	Parameters:
  7405                              <2> ;		Nothing
  7406                              <2> ;	Returns:
  7407                              <2> ;		Nothing (Display context pushed to stack)
  7408                              <2> ;	Corrupts registers:
  7409                              <2> ;		AX, BX, SI
  7410                              <2> ;--------------------------------------------------------------------
  7411                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7412                              <2> .PrepareDisplayContextForKeyboardInput:
  7413                              <2> 	pop		bx					; Pop return address to BX
  7414                              <2> 	mov		si, di
  7415                              <2> 
  7416                              <2> 	CALL_DISPLAY_LIBRARY PushDisplayContext
  7417                              <2> 	call	DisplayCursor_GetDefaultCursorShapeToAX
  7418                              <2> 	CALL_DISPLAY_LIBRARY SetCursorShapeFromAX
  7419                              <2> 	CALL_DISPLAY_LIBRARY SynchronizeDisplayContextToHardware
  7420                              <2> 
  7421                              <2> 	mov		di, si
  7422                              <2> 	jmp		bx
  7423                              <2> 
  7424                              <2> 
  7425                              <2> ;--------------------------------------------------------------------
  7426                              <2> ; .ProcessControlCharacter
  7427                              <2> ;	Parameters:
  7428                              <2> ;		AL:		Character inputted by user
  7429                              <2> ;		CX:		Number of bytes left in buffer
  7430                              <2> ;		BX:		Total number of characters inputted
  7431                              <2> ;		ES:DI:	Ptr where to store next character
  7432                              <2> ;	Returns:
  7433                              <2> ;		AL:		Character inputted by user or NULL if end of input
  7434                              <2> ;		BX:		Cleared if user cancellation
  7435                              <2> ;		ZF:		Set if user has ended or cancelled key input
  7436                              <2> ;		CF:		Set if character is rejected
  7437                              <2> ;	Corrupts registers:
  7438                              <2> ;		AH
  7439                              <2> ;--------------------------------------------------------------------
  7440                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7441                              <2> .ProcessControlCharacter:
  7442                              <2> 	cmp		al, CR								; ENTER to terminate string?
  7443                              <2> 	je		SHORT .EndCharacterInput
  7444                              <2> 	cmp		al, ESC								; Cancel input?
  7445                              <2> 	je		SHORT .CancelCharacterInput
  7446                              <2> 	cmp		al, BS								; Backspace?
  7447                              <2> 	je		SHORT .Backspace
  7448                              <2> 	jcxz	.RejectCharacter
  7449                              <2> 	clc											; Clear CF (ZF is already cleared)
  7450                              <2> 	ret
  7451                              <2> 
  7452                              <2> .Backspace:
  7453                              <2> 	test	bx, bx								; At the beginning?
  7454                              <2> 	jz		SHORT .RejectCharacter
  7455                              <2> 	inc		cx									; Increment bytes left
  7456                              <2> 	dec		bx									; Decrement characters inputted
  7457                              <2> 	dec		di
  7458                              <2> 	call	Keyboard_PrintBackspace
  7459                              <2> 	mov		al, BS								; Restore character
  7460                              <2> .RejectCharacter:
  7461                              <2> 	test	al, al								; Clear ZF...
  7462                              <2> 	stc											; ...and set CF
  7463                              <2> 	ret
  7464                              <2> 
  7465                              <2> .CancelCharacterInput:
  7466                              <2> 	xor		bx, bx
  7467                              <2> .EndCharacterInput:
  7468                              <2> 	xor		al, al								; Set ZF and clear CF
  7469                              <2> 	ret
  7470                              <2> %endif ; EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7471                              <2> 
  7472                              <2> 
  7473                              <2> ;--------------------------------------------------------------------
  7474                              <2> ; Keyboard_PrintBackspace
  7475                              <2> ;	Parameters:
  7476                              <2> ;		Nothing
  7477                              <2> ;	Returns:
  7478                              <2> ;		Nothing
  7479                              <2> ;	Corrupts registers:
  7480                              <2> ;		AX
  7481                              <2> ;--------------------------------------------------------------------
  7482                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7483                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7484                              <2> Keyboard_PrintBackspace:
  7485                              <2> 	mov		al, BS
  7486                              <2> 	call	Keyboard_PrintInputtedCharacter
  7487                              <2> 	mov		al, ' '
  7488                              <2> 	call	Keyboard_PrintInputtedCharacter
  7489                              <2> 	mov		al, BS
  7490                              <2> 	jmp		SHORT Keyboard_PrintInputtedCharacter
  7491                              <2> %endif
  7492                              <2> 
  7493                              <2> 
  7494                              <2> ;--------------------------------------------------------------------
  7495                              <2> ; Keyboard_PlayBellForUnwantedKeystroke
  7496                              <2> ;	Parameters:
  7497                              <2> ;		Nothing
  7498                              <2> ;	Returns:
  7499                              <2> ;		Nothing
  7500                              <2> ;	Corrupts registers:
  7501                              <2> ;		AX
  7502                              <2> ;--------------------------------------------------------------------
  7503                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7504                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7505                              <2> Keyboard_PlayBellForUnwantedKeystroke:
  7506                              <2> 	mov		al, BELL
  7507                              <2> 	; Fall to Keyboard_PrintInputtedCharacter
  7508                              <2> %endif
  7509                              <2> 
  7510                              <2> ;--------------------------------------------------------------------
  7511                              <2> ; Keyboard_PrintInputtedCharacter
  7512                              <2> ;	Parameters:
  7513                              <2> ;		AL:		Character inputted by user
  7514                              <2> ;	Returns:
  7515                              <2> ;		Nothing
  7516                              <2> ;	Corrupts registers:
  7517                              <2> ;		AX
  7518                              <2> ;--------------------------------------------------------------------
  7519                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7520                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7521                              <2> Keyboard_PrintInputtedCharacter:
  7522                              <2> 	push	di
  7523                              <2> 	CALL_DISPLAY_LIBRARY PrintCharacterFromAL
  7524                              <2> 	CALL_DISPLAY_LIBRARY SynchronizeDisplayContextToHardware	; Hardware cursor
  7525                              <2> 	pop		di
  7526                              <2> 	ret
  7527                              <2> %endif
  7528                              <2> 
  7529                              <2> 
  7530                              <2> ;--------------------------------------------------------------------
  7531                              <2> ; Keyboard_RemoveAllKeystrokesFromBuffer
  7532                              <2> ;	Parameters:
  7533                              <2> ;		Nothing
  7534                              <2> ;	Returns:
  7535                              <2> ;		Nothing
  7536                              <2> ;	Corrupts registers:
  7537                              <2> ;		AX
  7538                              <2> ;--------------------------------------------------------------------
  7539                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS	; Only used when debugging
  7540                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7541                              <2> Keyboard_RemoveAllKeystrokesFromBuffer:
  7542                              <2> 	call	Keyboard_GetKeystrokeToAX
  7543                              <2> 	jnz		SHORT Keyboard_RemoveAllKeystrokesFromBuffer
  7544                              <2> 	ret
  7545                              <2> %endif
  7546                              <2> 
  7547                              <2> 
  7548                              <2> ;--------------------------------------------------------------------
  7549                              <2> ; Keyboard_GetKeystrokeToAX
  7550                              <2> ; Keyboard_GetKeystrokeToAXandLeaveItToBuffer
  7551                              <2> ; Keyboard_GetKeystrokeToAXandWaitIfNecessary
  7552                              <2> ;	Parameters:
  7553                              <2> ;		Nothing
  7554                              <2> ;	Returns:
  7555                              <2> ;		AL:		ASCII character (if keystroke available)
  7556                              <2> ;		AH:		BIOS scan code (if keystroke available)
  7557                              <2> ;		ZF:		Set if no keystroke available
  7558                              <2> ;				Cleared if keystroke available
  7559                              <2> ;	Corrupts registers:
  7560                              <2> ;		Nothing
  7561                              <2> ;--------------------------------------------------------------------
  7562                              <2> 
  7563                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7564                              <2> 	%define EXCLUDE
  7565                              <2> 	%ifdef MODULE_HOTKEYS
  7566                              <2> 		%undef EXCLUDE
  7567                              <2> 	%endif
  7568                              <2> 	%ifdef MODULE_BOOT_MENU
  7569                              <2> 		%undef EXCLUDE
  7570                              <2> 	%endif
  7571                              <2> %endif
  7572                              <2> 
  7573                              <2> %ifndef EXCLUDE
  7574                              <2> 
  7575                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7576                              <2> Keyboard_GetKeystrokeToAXandLeaveItToBuffer:
  7577 0000038A B401                <2> 	mov		ah, CHECK_FOR_KEYSTROKE
  7578 0000038C CD16                <2> 	int		BIOS_KEYBOARD_INTERRUPT_16h
  7579 0000038E C3                  <2> 	ret
  7580                              <2> 
  7581                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7582                              <2> Keyboard_GetKeystrokeToAX:
  7583 0000038F E8F8FF              <2> 	call	Keyboard_GetKeystrokeToAXandLeaveItToBuffer
  7584 00000392 7406                <2> 	jz		SHORT Keyboard_GetKeystrokeToAXReturn
  7585                              <2> 	; Fall to Keyboard_GetKeystrokeToAXandWaitIfNecessary
  7586                              <2> ALIGN KEYBOARD_JUMP_ALIGN
  7587                              <2> Keyboard_GetKeystrokeToAXandWaitIfNecessary:
  7588 00000394 30E4                <2> 	xor		ah, ah						; GET_KEYSTROKE
  7589 00000396 CD16                <2> 	int		BIOS_KEYBOARD_INTERRUPT_16h
  7590 00000398 85C0                <2> 	test	ax, ax						; Clear ZF
  7591                              <2> Keyboard_GetKeystrokeToAXReturn:
  7592 0000039A C3                  <2> 	ret
  7593                              <2> 
  7594                              <2> %endif
  7595                              <2> %undef EXCLUDE
  7596                              <1> %endif
  7597                              <1> 
  7598                              <1> %ifdef INCLUDE_MENU_LIBRARY
  7599                              <1>   %ifndef MENU_JUMP_ALIGN
  7600                              <1> 	%define MENU_JUMP_ALIGN 1
  7601                              <1>   %endif
  7602                              <1> 	%include "CharOutLineSplitter.asm"
  7603                              <1> 	%include "Menu.asm"
  7604                              <1> 	%include "MenuAttributes.asm"
  7605                              <1> 	%include "MenuBorders.asm"
  7606                              <1> 	%include "MenuCharOut.asm"
  7607                              <1> 	%include "MenuEvent.asm"
  7608                              <1> 	%include "MenuInit.asm"
  7609                              <1> 	%include "MenuLocation.asm"
  7610                              <1> 	%include "MenuLoop.asm"
  7611                              <1> 	%include "MenuScrollbars.asm"
  7612                              <1> 	%include "MenuText.asm"
  7613                              <1> 	%include "MenuTime.asm"
  7614                              <1> 
  7615                              <1> 	%ifdef INCLUDE_MENU_DIALOGS
  7616                              <1> 		%include "Dialog.asm"
  7617                              <1> 		%include "DialogDrive.asm"
  7618                              <1> 		%include "DialogFile.asm"
  7619                              <1> 		%include "DialogMessage.asm"
  7620                              <1> 		%include "DialogProgress.asm"
  7621                              <1> 		%include "DialogSelection.asm"
  7622                              <1> 		%include "DialogString.asm"
  7623                              <1> 		%include "DialogWord.asm"
  7624                              <1> 		%include "ItemLineSplitter.asm"
  7625                              <1> 		%include "StringsForDialogs.asm"
  7626                              <1> 	%endif
  7627                              <1> %endif
  7628                              <1> 
  7629                              <1> %ifdef INCLUDE_STRING_LIBRARY
  7630                              <1>   %ifndef STRING_JUMP_ALIGN
  7631                              <1> 	%define STRING_JUMP_ALIGN 1
  7632                              <1>   %endif
  7633                              <1> 	%include "Char.asm"
  7634                              <2> ; Project name	:	Assembly Library
  7635                              <2> ; Description	:	Functions for handling characters.
  7636                              <2> 
  7637                              <2> ;
  7638                              <2> ; XTIDE Universal BIOS and Associated Tools
  7639                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  7640                              <2> ;
  7641                              <2> ; This program is free software; you can redistribute it and/or modify
  7642                              <2> ; it under the terms of the GNU General Public License as published by
  7643                              <2> ; the Free Software Foundation; either version 2 of the License, or
  7644                              <2> ; (at your option) any later version.
  7645                              <2> ;
  7646                              <2> ; This program is distributed in the hope that it will be useful,
  7647                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7648                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7649                              <2> ; GNU General Public License for more details.
  7650                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  7651                              <2> ;
  7652                              <2> 
  7653                              <2> ; Section containing code
  7654                              <2> SECTION .text
  7655                              <2> 
  7656                              <2> ;--------------------------------------------------------------------
  7657                              <2> ; This macro can only be used within this source file!!!
  7658                              <2> ; IS_BETWEEN_IMMEDIATES
  7659                              <2> ;	Parameters:
  7660                              <2> ;		%1:		Value to check
  7661                              <2> ;		%2:		First accepted value in range
  7662                              <2> ;		%3:		Last accepted value in range
  7663                              <2> ;	Returns:
  7664                              <2> ;		CF:		Set if character in range
  7665                              <2> ;				(Jumps to Char_CharIsNotValid if before range)
  7666                              <2> ;	Corrupts registers:
  7667                              <2> ;		Nothing
  7668                              <2> ;--------------------------------------------------------------------
  7669                              <2> %macro IS_BETWEEN_IMMEDIATES 3
  7670                              <2> 	cmp		%1, %2
  7671                              <2> 	jb		SHORT Char_CharIsNotValid
  7672                              <2> 	cmp		%1, (%3)+1				; Set CF if %1 is lesser
  7673                              <2> %endmacro
  7674                              <2> 
  7675                              <2> 
  7676                              <2> ;--------------------------------------------------------------------
  7677                              <2> ; Char_IsLowerCaseLetterInAL
  7678                              <2> ;	Parameters:
  7679                              <2> ;		AL:		Character to check
  7680                              <2> ;	Returns:
  7681                              <2> ;		CF:		Set if character is lower case letter ('a'...'z')
  7682                              <2> ;				Cleared if character is not lower case letter
  7683                              <2> ;	Corrupts registers:
  7684                              <2> ;		Nothing
  7685                              <2> ;--------------------------------------------------------------------
  7686                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7687                              <2> 	%ifndef MODULE_HOTKEYS
  7688                              <2> 		%define EXCLUDE
  7689                              <2> 	%endif
  7690                              <2> %endif
  7691                              <2> 
  7692                              <2> %ifndef EXCLUDE
  7693                              <2> ALIGN STRING_JUMP_ALIGN
  7694                              <2> Char_IsLowerCaseLetterInAL:
  7695                              <2> 	IS_BETWEEN_IMMEDIATES al, 'a', 'z'
  7696 0000039B 3C61                <3>  cmp %1, %2
  7697 0000039D 7203                <3>  jb SHORT Char_CharIsNotValid
  7698 0000039F 3C7B                <3>  cmp %1, (%3)+1
  7699 000003A1 C3                  <2> 	ret
  7700                              <2> %endif
  7701                              <2> %undef EXCLUDE
  7702                              <2> 
  7703                              <2> 
  7704                              <2> ;--------------------------------------------------------------------
  7705                              <2> ; Char_IsUpperCaseLetterInAL
  7706                              <2> ;	Parameters:
  7707                              <2> ;		AL:		Character to check
  7708                              <2> ;	Returns:
  7709                              <2> ;		CF:		Set if character is upper case letter ('A'...'Z')
  7710                              <2> ;				Cleared if character is not upper case letter
  7711                              <2> ;	Corrupts registers:
  7712                              <2> ;		Nothing
  7713                              <2> ;--------------------------------------------------------------------
  7714                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7715                              <2> ALIGN STRING_JUMP_ALIGN
  7716                              <2> Char_IsUpperCaseLetterInAL:
  7717                              <2> 	IS_BETWEEN_IMMEDIATES al, 'A', 'Z'
  7718                              <2> 	ret
  7719                              <2> %endif
  7720                              <2> 
  7721                              <2> 
  7722                              <2> ;--------------------------------------------------------------------
  7723                              <2> ; Char_IsHexadecimalDigitInAL
  7724                              <2> ;	Parameters:
  7725                              <2> ;		AL:		Character to check
  7726                              <2> ;	Returns:
  7727                              <2> ;		AL:		Character converted to lower case
  7728                              <2> ;		CF:		Set if character is decimal digit ('0'...'F')
  7729                              <2> ;				Cleared if character is not decimal digit
  7730                              <2> ;	Corrupts registers:
  7731                              <2> ;		Nothing
  7732                              <2> ;--------------------------------------------------------------------
  7733                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7734                              <2> ALIGN STRING_JUMP_ALIGN
  7735                              <2> Char_IsHexadecimalDigitInAL:
  7736                              <2> 	call	Char_IsDecimalDigitInAL
  7737                              <2> 	jc		SHORT Char_CharIsValid
  7738                              <2> 	call	Char_ALtoLowerCaseLetter
  7739                              <2> 	IS_BETWEEN_IMMEDIATES al, 'a', 'f'
  7740                              <2> 	ret
  7741                              <2> %endif
  7742                              <2> 
  7743                              <2> 
  7744                              <2> ;--------------------------------------------------------------------
  7745                              <2> ; Char_IsDecimalDigitInAL
  7746                              <2> ;	Parameters:
  7747                              <2> ;		AL:		Character to check
  7748                              <2> ;	Returns:
  7749                              <2> ;		CF:		Set if character is decimal digit ('0'...'9')
  7750                              <2> ;				Cleared if character is not decimal digit
  7751                              <2> ;	Corrupts registers:
  7752                              <2> ;		Nothing
  7753                              <2> ;--------------------------------------------------------------------
  7754                              <2> %ifndef MODULE_STRINGS_COMPRESSED
  7755                              <2> ALIGN STRING_JUMP_ALIGN
  7756                              <2> Char_IsDecimalDigitInAL:
  7757                              <2> 	IS_BETWEEN_IMMEDIATES al, '0', '9'
  7758                              <2> 	ret
  7759                              <2> %endif
  7760                              <2> 
  7761                              <2> 
  7762                              <2> ;--------------------------------------------------------------------
  7763                              <2> ; Char_ConvertIntegerToALfromDigitInALwithBaseInBX
  7764                              <2> ;	Parameters:
  7765                              <2> ;		AL:		Character to convert
  7766                              <2> ;		BX:		Numeric base (10 or 16)
  7767                              <2> ;	Returns:
  7768                              <2> ;		AL:		Character converted to integer
  7769                              <2> ;		CF:		Set if character was valid
  7770                              <2> ;				Cleared if character was invalid
  7771                              <2> ;	Corrupts registers:
  7772                              <2> ;		Nothing
  7773                              <2> ;--------------------------------------------------------------------
  7774                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7775                              <2> ALIGN STRING_JUMP_ALIGN
  7776                              <2> Char_ConvertIntegerToALfromDigitInALwithBaseInBX:
  7777                              <2> 	push	dx
  7778                              <2> 	call	Char_GetFilterFunctionToDXforNumericBaseInBX
  7779                              <2> 	call	dx						; Converts to lower case
  7780                              <2> 	pop		dx
  7781                              <2> 	jnc		SHORT Char_CharIsNotValid
  7782                              <2> 
  7783                              <2> 	cmp		al, '9'					; Decimal digit
  7784                              <2> 	jbe		SHORT .ConvertToDecimalDigit
  7785                              <2> 	sub		al, 'a'-'0'-10			; Convert to hexadecimal integer
  7786                              <2> ALIGN STRING_JUMP_ALIGN
  7787                              <2> .ConvertToDecimalDigit:
  7788                              <2> 	sub		al, '0'					; Convert to decimal integer
  7789                              <2> 	; Fall to Char_CharIsValid
  7790                              <2> %endif
  7791                              <2> 
  7792                              <2> 
  7793                              <2> ;--------------------------------------------------------------------
  7794                              <2> ; Char_CharIsValid
  7795                              <2> ; Char_CharIsNotValid
  7796                              <2> ;	Parameters:
  7797                              <2> ;		Nothing
  7798                              <2> ;	Returns:
  7799                              <2> ;		CF:		Set for Char_CharIsValid
  7800                              <2> ;				Cleared for Char_CharIsNotValid
  7801                              <2> ;	Corrupts registers:
  7802                              <2> ;		Nothing
  7803                              <2> ;--------------------------------------------------------------------
  7804                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7805                              <2> ALIGN STRING_JUMP_ALIGN
  7806                              <2> Char_CharIsValid:
  7807                              <2> 	stc
  7808                              <2> 	ret
  7809                              <2> %endif
  7810                              <2> 
  7811                              <2> 
  7812                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7813                              <2> 	%ifndef MODULE_HOTKEYS
  7814                              <2> 		%define EXCLUDE
  7815                              <2> 	%endif
  7816                              <2> 	%ifndef MODULE_STRINGS_COMPRESSED
  7817                              <2> 		%undef EXCLUDE
  7818                              <2> 	%endif
  7819                              <2> %endif
  7820                              <2> 
  7821                              <2> %ifndef EXCLUDE
  7822                              <2> ALIGN STRING_JUMP_ALIGN
  7823                              <2> Char_CharIsNotValid:
  7824 000003A2 F8                  <2> 	clc
  7825 000003A3 C3                  <2> 	ret
  7826                              <2> %endif
  7827                              <2> %undef EXCLUDE
  7828                              <2> 
  7829                              <2> 
  7830                              <2> ;--------------------------------------------------------------------
  7831                              <2> ; Char_ALtoLowerCaseLetter
  7832                              <2> ;	Parameters:
  7833                              <2> ;		AL:		Character to convert
  7834                              <2> ;	Returns:
  7835                              <2> ;		AL:		Character with possible conversion
  7836                              <2> ;	Corrupts registers:
  7837                              <2> ;		Nothing
  7838                              <2> ;--------------------------------------------------------------------
  7839                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7840                              <2> ALIGN STRING_JUMP_ALIGN
  7841                              <2> Char_ALtoLowerCaseLetter:
  7842                              <2> 	call	Char_IsUpperCaseLetterInAL	; Is upper case character?
  7843                              <2> 	jmp		SHORT Char_ALtoUpperCaseLetter.CheckCF
  7844                              <2> %endif
  7845                              <2> 
  7846                              <2> 
  7847                              <2> ;--------------------------------------------------------------------
  7848                              <2> ; Char_ALtoUpperCaseLetter
  7849                              <2> ;	Parameters:
  7850                              <2> ;		AL:		Character to convert
  7851                              <2> ;	Returns:
  7852                              <2> ;		AL:		Character with possible conversion
  7853                              <2> ;	Corrupts registers:
  7854                              <2> ;		Nothing
  7855                              <2> ;--------------------------------------------------------------------
  7856                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7857                              <2> ALIGN STRING_JUMP_ALIGN
  7858                              <2> Char_ALtoUpperCaseLetter:
  7859                              <2> 	call	Char_IsLowerCaseLetterInAL	; Is lower case character?
  7860                              <2> .CheckCF:
  7861                              <2> 	jnc		SHORT Char_ChangeCaseInAL.Return
  7862                              <2> 	; Fall to Char_ChangeCaseInAL
  7863                              <2> %endif
  7864                              <2> 
  7865                              <2> 
  7866                              <2> ;--------------------------------------------------------------------
  7867                              <2> ; Char_ChangeCaseInAL
  7868                              <2> ;	Parameters:
  7869                              <2> ;		AL:		Character to convert (must be A-Z or a-z)
  7870                              <2> ;	Returns:
  7871                              <2> ;		AL:		Character converted
  7872                              <2> ;	Corrupts registers:
  7873                              <2> ;		Nothing
  7874                              <2> ;--------------------------------------------------------------------
  7875                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7876                              <2> Char_ChangeCaseInAL:
  7877                              <2> 	xor		al, 32
  7878                              <2> .Return:
  7879                              <2> 	ret
  7880                              <2> %endif
  7881                              <2> 
  7882                              <2> 
  7883                              <2> ;--------------------------------------------------------------------
  7884                              <2> ; Char_GetFilterFunctionToDXforNumericBaseInBX
  7885                              <2> ;	Parameters
  7886                              <2> ;		BX:		Numeric base (10 or 16)
  7887                              <2> ;	Returns:
  7888                              <2> ;		CS:DX:	Ptr to character filter function
  7889                              <2> ;	Corrupts registers:
  7890                              <2> ;		Nothing
  7891                              <2> ;--------------------------------------------------------------------
  7892                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7893                              <2> ALIGN STRING_JUMP_ALIGN
  7894                              <2> Char_GetFilterFunctionToDXforNumericBaseInBX:
  7895                              <2> 	mov		dx, Char_IsDecimalDigitInAL
  7896                              <2> 	cmp		bl, 10
  7897                              <2> 	je		SHORT .Return
  7898                              <2> 	mov		dx, Char_IsHexadecimalDigitInAL
  7899                              <2> .Return:
  7900                              <2> 	ret
  7901                              <2> %endif
  7902                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7903                              <1> 		%include "String.asm"
  7904                              <1> 		%include "StringProcess.asm"
  7905                              <1> 	%endif
  7906                              <1> %endif
  7907                              <1> 
  7908                              <1> %ifdef INCLUDE_SERIAL_LIBRARY
  7909                              <1> 	%include "Serial.inc"
  7910                              <1> %endif
  7911                              <1> %ifdef INCLUDE_SERIALSERVER_LIBRARY
  7912                              <1> 	%include "SerialServer.asm"
  7913                              <1> 	%include "SerialServerScan.asm"
  7914                              <1> 	%define INCLUDE_TIME_LIBRARY
  7915                              <1> %endif
  7916                              <1> 
  7917                              <1> %ifdef INCLUDE_TIME_LIBRARY
  7918                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7919                              <1> 		%include "Delay.asm"
  7920                              <1> 		%ifndef EXCLUDE_FROM_XTIDECFG
  7921                              <1> 			%include "SystemTimer.asm"
  7922                              <1> 		%endif
  7923                              <1> 	%endif
  7924                              <1> 	%include "TimerTicks.asm"
  7925                              <2> ; Project name	:	Assembly Library
  7926                              <2> ; Description	:	Functions for system timer related operations.
  7927                              <2> 
  7928                              <2> ;
  7929                              <2> ; XTIDE Universal BIOS and Associated Tools
  7930                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  7931                              <2> ;
  7932                              <2> ; This program is free software; you can redistribute it and/or modify
  7933                              <2> ; it under the terms of the GNU General Public License as published by
  7934                              <2> ; the Free Software Foundation; either version 2 of the License, or
  7935                              <2> ; (at your option) any later version.
  7936                              <2> ;
  7937                              <2> ; This program is distributed in the hope that it will be useful,
  7938                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  7939                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  7940                              <2> ; GNU General Public License for more details.
  7941                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  7942                              <2> ;
  7943                              <2> 
  7944                              <2> ; With a PIT input clock of 1193181.6666... Hz and a maximum
  7945                              <2> ; 16 bit divisor of 65536 (if PIT programmed with 0) we get:
  7946                              <2> ;
  7947                              <2> ; Clock / Divisor = ~18.2065 ticks per second
  7948                              <2> ; Clock * SecondsPerMinute / Divisor = ~1092 ticks per minute
  7949                              <2> ; Clock * SecondsPerHour / Divisor = ~65543 ticks per hour
  7950                              <2> ;
  7951                              <2> ; Since 65543 can't fit in a 16 bit register we use the
  7952                              <2> ; maximum possible instead and disregard the last ~8 ticks.
  7953                              <2> 
  7954                              <2> TICKS_PER_HOUR			EQU		65535
  7955                              <2> TICKS_PER_MINUTE		EQU		1092
  7956                              <2> TICKS_PER_SECOND		EQU		18
  7957                              <2> 
  7958                              <2> 
  7959                              <2> ; Section containing code
  7960                              <2> SECTION .text
  7961                              <2> 
  7962                              <2> ;--------------------------------------------------------------------
  7963                              <2> ; TimerTicks_GetHoursToAXandRemainderTicksToDXfromTicksInDXAX
  7964                              <2> ; TimerTicks_GetMinutesToAXandRemainderTicksToDXfromTicksInDX
  7965                              <2> ; TimerTicks_GetSecondsToAXandRemainderTicksToDXfromTicksInDX
  7966                              <2> ;	Parameters
  7967                              <2> ;		DX(:AX):	Timer ticks to convert
  7968                              <2> ;	Returns:
  7969                              <2> ;		AX:			Hours, minutes or seconds
  7970                              <2> ;		DX:			Remainder ticks
  7971                              <2> ;	Corrupts registers:
  7972                              <2> ;		CX
  7973                              <2> ;--------------------------------------------------------------------
  7974                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7975                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  7976                              <2> ALIGN JUMP_ALIGN
  7977                              <2> TimerTicks_GetHoursToAXandRemainderTicksToDXfromTicksInDXAX:
  7978                              <2> 	mov		cx, TICKS_PER_HOUR
  7979                              <2> 	div		cx		; Divide DX:AX by CX, Hours to AX, remainder ticks to DX
  7980                              <2> 	ret
  7981                              <2> %endif ; EXCLUDE_FROM_XTIDECFG
  7982                              <2> 
  7983                              <2> ALIGN JUMP_ALIGN
  7984                              <2> TimerTicks_GetMinutesToAXandRemainderTicksToDXfromTicksInDX:
  7985                              <2> 	xor		ax, ax
  7986                              <2> 	xchg	ax, dx	; Ticks now in DX:AX
  7987                              <2> 	mov		cx, TICKS_PER_MINUTE
  7988                              <2> 	div		cx		; Divide DX:AX by CX, Minutes to AX, remainder ticks to DX
  7989                              <2> 	ret
  7990                              <2> %endif ; EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  7991                              <2> 
  7992                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  7993                              <2> ALIGN JUMP_ALIGN
  7994                              <2> TimerTicks_GetSecondsToAXandRemainderTicksToDXfromTicksInDX:
  7995                              <2> 	; This procedure can handle at most 4607 ticks in DX (almost 256 seconds)
  7996                              <2> 	; More than 4607 ticks will generate a divide overflow exception!
  7997                              <2> 	xchg	ax, dx	; Ticks now in AX
  7998                              <2> 	mov		cl, TICKS_PER_SECOND
  7999                              <2> 	div		cl		; Divide AX by CL, Seconds to AL, remainder ticks to AH
  8000                              <2> 	xor		dx, dx
  8001                              <2> 	xchg	dl, ah	; Seconds in AX, remainder in DX
  8002                              <2> 	ret
  8003                              <2> %endif
  8004                              <2> 
  8005                              <2> 
  8006                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8007                              <2> 	%ifndef MODULE_BOOT_MENU
  8008                              <2> 		%define EXCLUDE
  8009                              <2> 	%endif
  8010                              <2> %endif
  8011                              <2> ;--------------------------------------------------------------------
  8012                              <2> ; TimerTicks_GetSecondsToAXfromTicksInDX
  8013                              <2> ;	Parameters
  8014                              <2> ;		DX:			Timer ticks to convert
  8015                              <2> ;	Returns:
  8016                              <2> ;		AX:			Seconds
  8017                              <2> ;	Corrupts registers:
  8018                              <2> ;		DX
  8019                              <2> ;--------------------------------------------------------------------
  8020                              <2> %ifndef EXCLUDE	; 1 of 3
  8021                              <2> ALIGN JUMP_ALIGN
  8022                              <2> TimerTicks_GetSecondsToAXfromTicksInDX:
  8023                              <2> 	mov		ax, 3600	; Approximately 65536 / (Clock / Divisor)
  8024                              <2> 	mul		dx
  8025                              <2> 	xchg	dx, ax
  8026                              <2> 	ret
  8027                              <2> %endif
  8028                              <2> 
  8029                              <2> 
  8030                              <2> ;--------------------------------------------------------------------
  8031                              <2> ; First tick might take 0...54.9 ms and remaining ticks
  8032                              <2> ; will occur at 54.9 ms intervals. Use delay of two (or more) ticks to
  8033                              <2> ; ensure at least 54.9 ms timeout.
  8034                              <2> ;
  8035                              <2> ; TimerTicks_InitializeTimeoutFromAX
  8036                              <2> ;	Parameters:
  8037                              <2> ;		AX:			Timeout ticks (54.9 ms) before timeout
  8038                              <2> ;		DS:BX:		Ptr to timeout variable WORD
  8039                              <2> ;	Returns:
  8040                              <2> ;		[DS:BX]:	Initialized for TimerTicks_SetCarryIfTimeoutFromDSBX
  8041                              <2> ;	Corrupts registers:
  8042                              <2> ;		AX
  8043                              <2> ;--------------------------------------------------------------------
  8044                              <2> %ifndef EXCLUDE	; 2 of 3
  8045                              <2> ALIGN JUMP_ALIGN
  8046                              <2> TimerTicks_InitializeTimeoutFromAX:
  8047                              <2> 	mov		[bx], ax					; Store timeout ticks
  8048                              <2> 	call	TimerTicks_ReadFromBdaToAX
  8049                              <2> 	add		[bx], ax					; [bx] now contains end time for timeout
  8050                              <2> 	ret
  8051                              <2> %endif
  8052                              <2> 
  8053                              <2> 
  8054                              <2> ;--------------------------------------------------------------------
  8055                              <2> ; TimerTicks_GetTimeoutTicksLeftToAXfromDSBX
  8056                              <2> ;	Parameters:
  8057                              <2> ;		DS:BX:		Ptr to timeout variable WORD
  8058                              <2> ;	Returns:
  8059                              <2> ;		AX:			Number of ticks left before timeout
  8060                              <2> ;		CF:			Set if timeout
  8061                              <2> ;					Cleared if time left
  8062                              <2> ;	Corrupts registers:
  8063                              <2> ;		Nothing
  8064                              <2> ;--------------------------------------------------------------------
  8065                              <2> %ifndef EXCLUDE	; 3 of 3
  8066                              <2> ALIGN JUMP_ALIGN
  8067                              <2> TimerTicks_GetTimeoutTicksLeftToAXfromDSBX:
  8068                              <2> 	push	dx
  8069                              <2> 	mov		dx, [bx]
  8070                              <2> 	call	TimerTicks_ReadFromBdaToAX
  8071                              <2> 	xchg	ax, dx
  8072                              <2> 	sub		ax, dx		; AX = End time - current time
  8073                              <2> 	pop		dx
  8074                              <2> 	ret
  8075                              <2> %endif
  8076                              <2> 
  8077                              <2> %undef EXCLUDE
  8078                              <2> 
  8079                              <2> 
  8080                              <2> ;--------------------------------------------------------------------
  8081                              <2> ; TimerTicks_GetElapsedToAXandResetDSBX
  8082                              <2> ;	Parameters
  8083                              <2> ;		DS:BX:		Ptr to WORD containing previous reset time
  8084                              <2> ;	Returns:
  8085                              <2> ;		AX:			54.9 ms ticks elapsed since last reset
  8086                              <2> ;		[DS:BX]:	Reset to latest time
  8087                              <2> ;	Corrupts registers:
  8088                              <2> ;		Nothing
  8089                              <2> ;--------------------------------------------------------------------
  8090                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8091                              <2> ALIGN JUMP_ALIGN
  8092                              <2> TimerTicks_GetElapsedToAXandResetDSBX:
  8093                              <2> 	call	TimerTicks_ReadFromBdaToAX
  8094                              <2> 	push	ax
  8095                              <2> 	sub		ax, [bx]
  8096                              <2> 	pop		WORD [bx]			; Latest time to [DS:BX]
  8097                              <2> 	ret
  8098                              <2> %endif
  8099                              <2> 
  8100                              <2> 
  8101                              <2> ;--------------------------------------------------------------------
  8102                              <2> ; TimerTicks_GetElapsedToAXfromDSBX
  8103                              <2> ;	Parameters
  8104                              <2> ;		DS:BX:		Ptr to WORD containing previous update time
  8105                              <2> ;	Returns:
  8106                              <2> ;		AX:			54.9 ms ticks elapsed since initializing [DS:BX]
  8107                              <2> ;	Corrupts registers:
  8108                              <2> ;		Nothing
  8109                              <2> ;--------------------------------------------------------------------
  8110                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8111                              <2> ALIGN JUMP_ALIGN
  8112                              <2> TimerTicks_GetElapsedToAXfromDSBX:
  8113                              <2> 	call	TimerTicks_ReadFromBdaToAX
  8114                              <2> 	sub		ax, [bx]
  8115                              <2> 	ret
  8116                              <2> %endif
  8117                              <2> 
  8118                              <2> 
  8119                              <2> ;--------------------------------------------------------------------
  8120                              <2> ; TimerTicks_ReadFromBdaToAX
  8121                              <2> ;	Parameters
  8122                              <2> ;		Nothing
  8123                              <2> ;	Returns:
  8124                              <2> ;		AX:		System time in 54.9 ms ticks
  8125                              <2> ;	Corrupts registers:
  8126                              <2> ;		Nothing
  8127                              <2> ;--------------------------------------------------------------------
  8128                              <2> %ifdef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8129                              <2> 	%ifndef MODULE_BOOT_MENU OR MODULE_HOTKEYS
  8130                              <2> 		%define EXCLUDE
  8131                              <2> 	%endif
  8132                              <2> %endif
  8133                              <2> 
  8134                              <2> %ifndef EXCLUDE
  8135                              <2> ALIGN JUMP_ALIGN
  8136                              <2> TimerTicks_ReadFromBdaToAX:
  8137 000003A4 1E                  <2> 	push	ds
  8138                              <2> 
  8139                              <2> 	LOAD_BDA_SEGMENT_TO	ds, ax
  8140                              <3> %ifndef USE_186
  8141 000003A5 31C0                <3>  xor %2, %2
  8142 000003A7 8ED8                <3>  mov %1, %2
  8143                              <3> %elifidn %3, !
  8144                              <3>  xor %2, %2
  8145                              <3>  mov %1, %2
  8146                              <3> %else
  8147                              <3>  push BYTE 0
  8148                              <3>  pop %1
  8149                              <3> %endif
  8150 000003A9 A16C04              <2> 	mov		ax, [BDA.dwTimerTicks]	; Read low WORD only
  8151                              <2> 
  8152 000003AC 1F                  <2> 	pop		ds
  8153 000003AD C3                  <2> 	ret
  8154                              <2> %endif
  8155                              <2> %undef EXCLUDE
  8156                              <1> %endif
  8157                              <1> 
  8158                              <1> %ifdef INCLUDE_UTIL_LIBRARY
  8159                              <1>   %ifndef UTIL_SIZE_JUMP_ALIGN
  8160                              <1> 	%define UTIL_SIZE_JUMP_ALIGN 1
  8161                              <1>   %endif
  8162                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8163                              <1> 		%include "Bit.asm"
  8164                              <1> 	%endif
  8165                              <1> 	%include "Math.asm"
  8166                              <2> ; Project name	:	Assembly Library
  8167                              <2> ; Description	:	Functions for register operations.
  8168                              <2> 
  8169                              <2> ;
  8170                              <2> ; XTIDE Universal BIOS and Associated Tools
  8171                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  8172                              <2> ;
  8173                              <2> ; This program is free software; you can redistribute it and/or modify
  8174                              <2> ; it under the terms of the GNU General Public License as published by
  8175                              <2> ; the Free Software Foundation; either version 2 of the License, or
  8176                              <2> ; (at your option) any later version.
  8177                              <2> ;
  8178                              <2> ; This program is distributed in the hope that it will be useful,
  8179                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8180                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8181                              <2> ; GNU General Public License for more details.
  8182                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  8183                              <2> ;
  8184                              <2> 
  8185                              <2> 
  8186                              <2> ; Section containing code
  8187                              <2> SECTION .text
  8188                              <2> 
  8189                              <2> ;--------------------------------------------------------------------
  8190                              <2> ; Math_DivQWatSSBPbyCX
  8191                              <2> ;	Parameters:
  8192                              <2> ;		[SS:BP]:	64-bit unsigned divident
  8193                              <2> ;		CX:			16-bit unsigned divisor
  8194                              <2> ;	Returns:
  8195                              <2> ;		[SS:BP]:	64-bit unsigned quotient
  8196                              <2> ;		DX:			16-bit unsigned remainder
  8197                              <2> ;	Corrupts registers:
  8198                              <2> ;		AX
  8199                              <2> ;--------------------------------------------------------------------
  8200                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  8201                              <2> ALIGN JUMP_ALIGN
  8202                              <2> Math_DivQWatSSBPbyCX:
  8203                              <2> 	xor		dx, dx
  8204                              <2> 	mov		ax, [bp+6]		; Load highest divident WORD to DX:AX
  8205                              <2> 	div		cx
  8206                              <2> 	mov		[bp+6], ax		; Store quotient
  8207                              <2> 
  8208                              <2> 	mov		ax, [bp+4]
  8209                              <2> 	div		cx
  8210                              <2> 	mov		[bp+4], ax
  8211                              <2> 
  8212                              <2> 	mov		ax, [bp+2]
  8213                              <2> 	div		cx
  8214                              <2> 	mov		[bp+2], ax
  8215                              <2> 
  8216                              <2> 	mov		ax, [bp]
  8217                              <2> 	div		cx
  8218                              <2> 	mov		[bp], ax
  8219                              <2> 	ret
  8220                              <2> %endif
  8221                              <2> 
  8222                              <2> 
  8223                              <2> ;--------------------------------------------------------------------
  8224                              <2> ; Math_DivDXAXbyCX
  8225                              <2> ;	Parameters:
  8226                              <2> ;		DX:AX:	32-bit unsigned divident
  8227                              <2> ;		CX:		16-bit unsigned divisor
  8228                              <2> ;	Returns:
  8229                              <2> ;		DX:AX:	32-bit unsigned quotient
  8230                              <2> ;		BX:		16-bit unsigned remainder
  8231                              <2> ;	Corrupts registers:
  8232                              <2> ;		Nothing
  8233                              <2> ;--------------------------------------------------------------------
  8234                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  8235                              <2> ALIGN JUMP_ALIGN
  8236                              <2> Math_DivDXAXbyCX:
  8237 000003AE 31DB                <2> 	xor		bx, bx
  8238 000003B0 93                  <2> 	xchg	bx, ax
  8239 000003B1 92                  <2> 	xchg	dx, ax
  8240 000003B2 F7F1                <2> 	div		cx
  8241 000003B4 93                  <2> 	xchg	ax, bx
  8242 000003B5 F7F1                <2> 	div		cx
  8243 000003B7 87D3                <2> 	xchg	dx, bx
  8244 000003B9 C3                  <2> 	ret
  8245                              <2> %endif
  8246                              <1> 	%include "Registers.asm"
  8247                              <2> ; Project name	:	Assembly Library
  8248                              <2> ; Description	:	Functions for register operations.
  8249                              <2> 
  8250                              <2> ;
  8251                              <2> ; XTIDE Universal BIOS and Associated Tools
  8252                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  8253                              <2> ;
  8254                              <2> ; This program is free software; you can redistribute it and/or modify
  8255                              <2> ; it under the terms of the GNU General Public License as published by
  8256                              <2> ; the Free Software Foundation; either version 2 of the License, or
  8257                              <2> ; (at your option) any later version.
  8258                              <2> ;
  8259                              <2> ; This program is distributed in the hope that it will be useful,
  8260                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8261                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8262                              <2> ; GNU General Public License for more details.
  8263                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  8264                              <2> ;
  8265                              <2> 
  8266                              <2> ; Section containing code
  8267                              <2> SECTION .text
  8268                              <2> 
  8269                              <2> ;--------------------------------------------------------------------
  8270                              <2> ; Registers_ExchangeDSSIwithESDI
  8271                              <2> ;	Parameters
  8272                              <2> ;		Nothing
  8273                              <2> ;	Returns:
  8274                              <2> ;		DS:SI and ES:DI are exchanged.
  8275                              <2> ;	Corrupts registers:
  8276                              <2> ;		Nothing
  8277                              <2> ;--------------------------------------------------------------------
  8278                              <2> ALIGN JUMP_ALIGN
  8279                              <2> Registers_ExchangeDSSIwithESDI:
  8280 000003BA 1E                  <2> 	push	ds
  8281 000003BB 06                  <2> 	push	es
  8282 000003BC 1F                  <2> 	pop		ds
  8283 000003BD 07                  <2> 	pop		es
  8284 000003BE 87F7                <2> 	xchg	si, di
  8285 000003C0 C3                  <2> 	ret
  8286                              <2> 
  8287                              <2> 
  8288                              <2> ;--------------------------------------------------------------------
  8289                              <2> ; Registers_CopySSBPtoESDI
  8290                              <2> ; Registers_CopySSBPtoDSSI
  8291                              <2> ; Registers_CopyDSSItoESDI
  8292                              <2> ; Registers_CopyESDItoDSSI
  8293                              <2> ;	Parameters
  8294                              <2> ;		Nothing
  8295                              <2> ;	Returns:
  8296                              <2> ;		Copies farm pointer to different segment/pointer register pair
  8297                              <2> ;	Corrupts registers:
  8298                              <2> ;		Nothing
  8299                              <2> ;--------------------------------------------------------------------
  8300                              <2> %ifdef INCLUDE_MENU_LIBRARY
  8301                              <2> ALIGN JUMP_ALIGN
  8302                              <2> Registers_CopySSBPtoESDI:
  8303                              <2> 	COPY_SSBP_TO_ESDI
  8304                              <2> 	ret
  8305                              <2> %endif
  8306                              <2> 
  8307                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8308                              <2> ALIGN JUMP_ALIGN
  8309                              <2> Registers_CopySSBPtoDSSI:
  8310                              <2> 	COPY_SSBP_TO_DSSI
  8311                              <2> 	ret
  8312                              <2> 
  8313                              <2> ALIGN JUMP_ALIGN
  8314                              <2> Registers_CopyDSSItoESDI:
  8315                              <2> 	COPY_DSSI_TO_ESDI
  8316                              <2> 	ret
  8317                              <2> 
  8318                              <2> ALIGN JUMP_ALIGN
  8319                              <2> Registers_CopyESDItoDSSI:
  8320                              <2> 	COPY_ESDI_to_DSSI
  8321                              <2> 	ret
  8322                              <2> %endif
  8323                              <2> 
  8324                              <2> 
  8325                              <2> ;--------------------------------------------------------------------
  8326                              <2> ; Registers_NormalizeESSI
  8327                              <2> ; Registers_NormalizeESDI
  8328                              <2> ;	Parameters
  8329                              <2> ;		DS:SI or ES:DI:	Ptr to normalize
  8330                              <2> ;	Returns:
  8331                              <2> ;		DS:SI or ES:DI:	Normalized pointer
  8332                              <2> ;	Corrupts registers:
  8333                              <2> ;		AX, CX
  8334                              <2> ;
  8335                              <2> ; Inline of NORMALIZE_FAR_POINTER so that we can share the last 2/3 of the
  8336                              <2> ; routine with Registers_NormalizeFinish.
  8337                              <2> ;
  8338                              <2> ;--------------------------------------------------------------------
  8339                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS OR EXCLUDE_FROM_XTIDECFG
  8340                              <2> ALIGN JUMP_ALIGN
  8341                              <2> Registers_NormalizeESSI:
  8342                              <2> 	mov			cx, si
  8343                              <2> 	and			si, byte 0fh
  8344                              <2> 	jmp			Registers_NormalizeFinish
  8345                              <2> 
  8346                              <2> ALIGN JUMP_ALIGN
  8347                              <2> Registers_NormalizeESDI:
  8348                              <2> 	mov			cx, di
  8349                              <2> 	and			di, byte 0fh
  8350                              <2> ;;; fall-through
  8351                              <2> 
  8352                              <2> ALIGN JUMP_ALIGN
  8353                              <2> Registers_NormalizeFinish:
  8354                              <2> 	eSHR_IM		cx, 4
  8355                              <2> 	mov			ax, es
  8356                              <2> 	add			ax, cx
  8357                              <2> 	mov			es, ax
  8358                              <2> 	ret
  8359                              <2> %endif
  8360                              <2> 
  8361                              <2> 
  8362                              <2> ;--------------------------------------------------------------------
  8363                              <2> ; Registers_SetZFifNullPointerInDSSI (commented to save bytes)
  8364                              <2> ;	Parameters
  8365                              <2> ;		DS:SI:	Far pointer
  8366                              <2> ;	Returns:
  8367                              <2> ;		ZF:		Set if NULL pointer in DS:SI
  8368                              <2> ;	Corrupts registers:
  8369                              <2> ;		Nothing
  8370                              <2> ;--------------------------------------------------------------------
  8371                              <2> ;ALIGN JUMP_ALIGN
  8372                              <2> ;Registers_SetZFifNullPointerInDSSI:
  8373                              <2> ;	push	ax
  8374                              <2> ;	mov		ax, ds
  8375                              <2> ;	or		ax, si
  8376                              <2> ;	pop		ax
  8377                              <2> ;	ret
  8378                              <1> 	%include "Reboot.asm"
  8379                              <2> ; Project name	:	Assembly Library
  8380                              <2> ; Description	:	Functions for rebooting computer.
  8381                              <2> 
  8382                              <2> ;
  8383                              <2> ; XTIDE Universal BIOS and Associated Tools
  8384                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  8385                              <2> ;
  8386                              <2> ; This program is free software; you can redistribute it and/or modify
  8387                              <2> ; it under the terms of the GNU General Public License as published by
  8388                              <2> ; the Free Software Foundation; either version 2 of the License, or
  8389                              <2> ; (at your option) any later version.
  8390                              <2> ;
  8391                              <2> ; This program is distributed in the hope that it will be useful,
  8392                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8393                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8394                              <2> ; GNU General Public License for more details.
  8395                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  8396                              <2> ;
  8397                              <2> 
  8398                              <2> ; Section containing code
  8399                              <2> SECTION .text
  8400                              <2> 
  8401                              <2> ;--------------------------------------------------------------------
  8402                              <2> ; Reboot_ComputerWithBootFlagInAX
  8403                              <2> ;	Parameters:
  8404                              <2> ; 		AX:		Boot Flag
  8405                              <2> ;	Returns:
  8406                              <2> ;		Nothing, function never returns
  8407                              <2> ;--------------------------------------------------------------------
  8408                              <2> Reboot_ComputerWithBootFlagInAX:
  8409                              <2> 	LOAD_BDA_SEGMENT_TO	ds, bx
  8410                              <3> %ifndef USE_186
  8411 000003C1 31DB                <3>  xor %2, %2
  8412 000003C3 8EDB                <3>  mov %1, %2
  8413                              <3> %elifidn %3, !
  8414                              <3>  xor %2, %2
  8415                              <3>  mov %1, %2
  8416                              <3> %else
  8417                              <3>  push BYTE 0
  8418                              <3>  pop %1
  8419                              <3> %endif
  8420 000003C5 A37204              <2> 	mov		[BDA.wBoot], ax			; Store boot flag
  8421                              <2> 	; Fall to Reboot_AT
  8422                              <2> 
  8423                              <2> 
  8424                              <2> ;--------------------------------------------------------------------
  8425                              <2> ; Reboot_AT
  8426                              <2> ;	Parameters:
  8427                              <2> ; 		Nothing
  8428                              <2> ;	Returns:
  8429                              <2> ;		Nothing, function never returns
  8430                              <2> ;--------------------------------------------------------------------
  8431                              <2> Reboot_AT:
  8432 000003C8 B0FE                <2> 	mov		al, 0FEh				; System reset (AT+ keyboard controller)
  8433 000003CA E664                <2> 	out		64h, al					; Reset computer (AT+)
  8434                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8435                              <2> 	%ifdef INCLUDE_TIME_LIBRARY
  8436                              <2> 		mov		ax, 10
  8437                              <2> 		call	Delay_MicrosecondsFromAX
  8438                              <2> 	%else
  8439                              <2> 		JMP_DELAY
  8440                              <2> 	%endif
  8441                              <2> %else
  8442                              <2> 	JMP_DELAY
  8443 000003CC EB00                <3>  jmp SHORT %%NextInstruction
  8444                              <3> %%NextInstruction:
  8445                              <2> %endif
  8446                              <2> 	; Fall to Reboot_XT
  8447                              <2> 
  8448                              <2> 
  8449                              <2> ;--------------------------------------------------------------------
  8450                              <2> ; Reboot_XT
  8451                              <2> ;	Parameters:
  8452                              <2> ; 		Nothing
  8453                              <2> ;	Returns:
  8454                              <2> ;		Nothing, function never returns
  8455                              <2> ;--------------------------------------------------------------------
  8456                              <2> Reboot_XT:
  8457 000003CE 31C0                <2> 	xor		ax, ax
  8458 000003D0 50                  <2> 	push	ax
  8459 000003D1 9D                  <2> 	popf							; Clear FLAGS (disables interrupt)
  8460 000003D2 8ED8                <2> 	mov		ds, ax
  8461 000003D4 8EC0                <2> 	mov		es, ax
  8462 000003D6 8ED0                <2> 	mov		ss, ax
  8463 000003D8 EA0000FFFF          <2> 	jmp		0FFFFh:0				; XT reset
  8464                              <1> 	%include "Memory.asm"
  8465                              <2> ; Project name	:	Assembly Library
  8466                              <2> ; Description	:	Functions for memory access.
  8467                              <2> 
  8468                              <2> ;
  8469                              <2> ; XTIDE Universal BIOS and Associated Tools
  8470                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  8471                              <2> ;
  8472                              <2> ; This program is free software; you can redistribute it and/or modify
  8473                              <2> ; it under the terms of the GNU General Public License as published by
  8474                              <2> ; the Free Software Foundation; either version 2 of the License, or
  8475                              <2> ; (at your option) any later version.
  8476                              <2> ;
  8477                              <2> ; This program is distributed in the hope that it will be useful,
  8478                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8479                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8480                              <2> ; GNU General Public License for more details.
  8481                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  8482                              <2> ;
  8483                              <2> 
  8484                              <2> ; Section containing code
  8485                              <2> SECTION .text
  8486                              <2> 
  8487                              <2> ;--------------------------------------------------------------------
  8488                              <2> ; OPTIMIZE_STRING_OPERATION
  8489                              <2> ;	Parameters
  8490                              <2> ;		%1:		Repeat instruction
  8491                              <2> ;		%2:		String instruction without size (for example MOVS and not MOVSB or MOVSW)
  8492                              <2> ;		CX:		Number of BYTEs to operate
  8493                              <2> ;		DS:SI:	Ptr to source data
  8494                              <2> ;		ES:DI:	Ptr to destination
  8495                              <2> ;	Returns:
  8496                              <2> ;		SI, DI:	Updated by number of bytes operated
  8497                              <2> ;	Corrupts registers:
  8498                              <2> ;		Nothing
  8499                              <2> ;--------------------------------------------------------------------
  8500                              <2> %macro OPTIMIZE_STRING_OPERATION 2
  8501                              <2> 	push	cx
  8502                              <2> 
  8503                              <2> 	shr		cx, 1			; Operate with WORDs for performance
  8504                              <2> 	jz	%%HandleRemainingByte
  8505                              <2> 	%1		%2w
  8506                              <2> %%HandleRemainingByte:
  8507                              <2> 	jnc		SHORT %%OperationCompleted
  8508                              <2> 	%2b
  8509                              <2> 
  8510                              <2> ALIGN JUMP_ALIGN
  8511                              <2> %%OperationCompleted:
  8512                              <2> 	pop		cx
  8513                              <2> %endmacro
  8514                              <2> 
  8515                              <2> 
  8516                              <2> ;--------------------------------------------------------------------
  8517                              <2> ; Memory_CopyCXbytesFromDSSItoESDI
  8518                              <2> ;	Parameters
  8519                              <2> ;		CX:		Number of bytes to copy
  8520                              <2> ;		DS:SI:	Ptr to source data
  8521                              <2> ;		ES:DI:	Ptr to destination buffer
  8522                              <2> ;	Returns:
  8523                              <2> ;		SI, DI:	Updated by number of bytes copied
  8524                              <2> ;	Corrupts registers:
  8525                              <2> ;		Nothing
  8526                              <2> ;--------------------------------------------------------------------
  8527                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8528                              <2> ALIGN JUMP_ALIGN
  8529                              <2> Memory_CopyCXbytesFromDSSItoESDI:
  8530                              <2> 	OPTIMIZE_STRING_OPERATION rep, movs
  8531                              <2> 	ret
  8532                              <2> %endif
  8533                              <2> 
  8534                              <2> 
  8535                              <2> ;--------------------------------------------------------------------
  8536                              <2> ; Memory_ZeroSSBPwithSizeInCX
  8537                              <2> ;	Parameters
  8538                              <2> ;		CX:		Number of bytes to zero
  8539                              <2> ;		SS:BP:	Ptr to buffer to zero
  8540                              <2> ;	Returns:
  8541                              <2> ;		Nothing
  8542                              <2> ;	Corrupts registers:
  8543                              <2> ;		Nothing
  8544                              <2> ;--------------------------------------------------------------------
  8545                              <2> %ifdef INCLUDE_MENU_LIBRARY
  8546                              <2> ALIGN JUMP_ALIGN
  8547                              <2> Memory_ZeroSSBPwithSizeInCX:
  8548                              <2> 	push	es
  8549                              <2> 	push	di
  8550                              <2> 	push	ax
  8551                              <2> 	call	Registers_CopySSBPtoESDI
  8552                              <2> 	call	Memory_ZeroESDIwithSizeInCX
  8553                              <2> 	pop		ax
  8554                              <2> 	pop		di
  8555                              <2> 	pop		es
  8556                              <2> 	ret
  8557                              <2> %endif
  8558                              <2> 
  8559                              <2> 
  8560                              <2> ;--------------------------------------------------------------------
  8561                              <2> ; Memory_ZeroESDIwithSizeInCX
  8562                              <2> ;	Parameters
  8563                              <2> ;		CX:		Number of bytes to zero
  8564                              <2> ;		ES:DI:	Ptr to destination buffer
  8565                              <2> ;	Returns:
  8566                              <2> ;		DI:		Updated by number of BYTEs stored
  8567                              <2> ;	Corrupts registers:
  8568                              <2> ;		AX
  8569                              <2> ;--------------------------------------------------------------------
  8570                              <2> ALIGN JUMP_ALIGN
  8571                              <2> Memory_ZeroESDIwithSizeInCX:
  8572 000003DD 31C0                <2> 	xor		ax, ax
  8573                              <2> 	; Fall to Memory_StoreCXbytesFromAccumToESDI
  8574                              <2> 
  8575                              <2> ;--------------------------------------------------------------------
  8576                              <2> ; Memory_StoreCXbytesFromAccumToESDI
  8577                              <2> ;	Parameters
  8578                              <2> ;		AX:		Word to use to fill buffer
  8579                              <2> ;		CX:		Number of BYTEs to store
  8580                              <2> ;		ES:DI:	Ptr to destination buffer
  8581                              <2> ;	Returns:
  8582                              <2> ;		DI:		Updated by number of BYTEs stored
  8583                              <2> ;	Corrupts registers:
  8584                              <2> ;		Nothing
  8585                              <2> ;--------------------------------------------------------------------
  8586                              <2> ALIGN JUMP_ALIGN
  8587                              <2> Memory_StoreCXbytesFromAccumToESDI:
  8588                              <2> 	OPTIMIZE_STRING_OPERATION rep, stos
  8589 000003DF 51                  <3>  push cx
  8590                              <3> 
  8591 000003E0 D1E9                <3>  shr cx, 1
  8592 000003E2 7402                <3>  jz %%HandleRemainingByte
  8593 000003E4 F3AB                <3>  %1 %2w
  8594                              <3> %%HandleRemainingByte:
  8595 000003E6 7301                <3>  jnc SHORT %%OperationCompleted
  8596 000003E8 AA                  <3>  %2b
  8597                              <3> 
  8598                              <3> ALIGN JUMP_ALIGN
  8599                              <3> %%OperationCompleted:
  8600 000003E9 59                  <3>  pop cx
  8601 000003EA C3                  <2> 	ret
  8602                              <2> 
  8603                              <2> 
  8604                              <2> ;--------------------------------------------------------------------
  8605                              <2> ; Memory_ReserveCXbytesFromStackToDSSI
  8606                              <2> ;	Parameters
  8607                              <2> ;		CX:		Number of bytes to reserve
  8608                              <2> ;	Returns:
  8609                              <2> ;		DS:SI:	Ptr to reserved buffer
  8610                              <2> ;	Corrupts registers:
  8611                              <2> ;		AX
  8612                              <2> ;--------------------------------------------------------------------
  8613                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8614                              <2> ALIGN JUMP_ALIGN
  8615                              <2> Memory_ReserveCXbytesFromStackToDSSI:
  8616                              <2> 	pop		ax
  8617                              <2> 	push	ss
  8618                              <2> 	pop		ds
  8619                              <2> 	sub		sp, cx
  8620                              <2> 	mov		si, sp
  8621                              <2> 	jmp		ax
  8622                              <2> %endif
  8623                              <2> 
  8624                              <2> 
  8625                              <2> ;--------------------------------------------------------------------
  8626                              <2> ; Memory_SumCXbytesFromESSItoAL
  8627                              <2> ;	Parameters
  8628                              <2> ;		CX:		Number of bytes to sum (0=65536)
  8629                              <2> ;		ES:SI:	Ptr to buffer containing the bytes to sum
  8630                              <2> ;	Returns:
  8631                              <2> ;		AL:		Sum of bytes
  8632                              <2> ;		ZF:		Set if result is zero
  8633                              <2> ;				Cleared if result is non-zero
  8634                              <2> ;	Corrupts registers:
  8635                              <2> ;		CX
  8636                              <2> ;--------------------------------------------------------------------
  8637                              <2> %ifndef EXCLUDE_FROM_XTIDECFG
  8638                              <2> ALIGN JUMP_ALIGN
  8639                              <2> Memory_SumCXbytesFromESSItoAL:
  8640 000003EB 56                  <2> 	push	si
  8641 000003EC 4E                  <2> 	dec		si
  8642 000003ED 30C0                <2> 	xor		al, al
  8643                              <2> ALIGN JUMP_ALIGN
  8644                              <2> .AddNextByteToAL:
  8645 000003EF 46                  <2> 	inc		si
  8646 000003F0 260204              <2> 	add		al, [es:si]
  8647 000003F3 E2FA                <2> 	loop	.AddNextByteToAL
  8648 000003F5 5E                  <2> 	pop		si
  8649 000003F6 C3                  <2> 	ret
  8650                              <2> %endif
  8651                              <1> 	%include "Size.asm"
  8652                              <2> ; Project name	:	Assembly Library
  8653                              <2> ; Description	:	Functions for size calculations.
  8654                              <2> 
  8655                              <2> ;
  8656                              <2> ; XTIDE Universal BIOS and Associated Tools
  8657                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  8658                              <2> ;
  8659                              <2> ; This program is free software; you can redistribute it and/or modify
  8660                              <2> ; it under the terms of the GNU General Public License as published by
  8661                              <2> ; the Free Software Foundation; either version 2 of the License, or
  8662                              <2> ; (at your option) any later version.
  8663                              <2> ;
  8664                              <2> ; This program is distributed in the hope that it will be useful,
  8665                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8666                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8667                              <2> ; GNU General Public License for more details.
  8668                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  8669                              <2> ;
  8670                              <2> 
  8671                              <2> %ifdef INCLUDE_MENU_LIBRARY
  8672                              <2> struc BYTE_MULTIPLES
  8673                              <2> 	.B			resb	1
  8674                              <2> 	.kiB		resb	1
  8675                              <2> 	.MiB		resb	1
  8676                              <2> 	.GiB		resb	1
  8677                              <2> 	.TiB		resb	1
  8678                              <2> endstruc
  8679                              <2> 
  8680                              <2> ; Section containing code
  8681                              <2> SECTION .text
  8682                              <2> 
  8683                              <2> ;--------------------------------------------------------------------
  8684                              <2> ; Size_GetSizeToAXAndCharToDLfromBXDXAXwithMagnitudeInCX
  8685                              <2> ;	Parameters:
  8686                              <2> ;		BX:DX:AX:	Size in magnitude
  8687                              <2> ;		CX:			Magnitude in BYTE_MULTIPLES
  8688                              <2> ;	Returns:
  8689                              <2> ;		AX:			Size in magnitude
  8690                              <2> ;		CX:			Tenths
  8691                              <2> ;		DL:			Magnitude character:
  8692                              <2> ;						'k' = *1024   B = kiB
  8693                              <2> ;						'M' = *1024 kiB = MiB
  8694                              <2> ;						'G' = *1024 MiB = GiB
  8695                              <2> ;						'T' = *1024 GiB = TiB
  8696                              <2> ;						'P' = *1024 TiB = PiB
  8697                              <2> ;	Corrupts registers:
  8698                              <2> ;		BX, DH
  8699                              <2> ;--------------------------------------------------------------------
  8700                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8701                              <2> Size_GetSizeToAXAndCharToDLfromBXDXAXwithMagnitudeInCX:
  8702                              <2> %ifndef USE_186		; If 8086/8088
  8703                              <2> 	push	di
  8704                              <2> %endif
  8705                              <2> 	push	si
  8706                              <2> 
  8707                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8708                              <2> .MagnitudeConversionLoop:
  8709                              <2> 	ePUSH_T	di, .MagnitudeConversionLoop; DI corrupted only on 8086/8088 build
  8710                              <2> 	test	bx, bx						; Bits 32...47 in use?
  8711                              <2> 	jnz		SHORT Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
  8712                              <2> 	test	dx, dx						; Bits 16...31 in use?
  8713                              <2> 	jnz		SHORT Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
  8714                              <2> 	cmp		ax, 10000					; 5 digits needed?
  8715                              <2> 	jae		SHORT Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
  8716                              <2> 	add		sp, BYTE 2					; Clean return address from stack
  8717                              <2> 	xchg	si, cx						; CX = Remainder (0...1023), SI = Magnitude
  8718                              <2> 
  8719                              <2> 	; Convert remainder to tenths
  8720                              <2> 	xchg	bx, ax						; Store AX
  8721                              <2> 	mov		ax, 5
  8722                              <2> 	mul		cx							; DX:AX = remainder * (10 / 2)
  8723                              <2> %ifdef USE_186
  8724                              <2> 	shr		ax, 9						; Divide AX by (1024 / 2)
  8725                              <2> %else
  8726                              <2> 	shr		ax, 1
  8727                              <2> 	mov		al, ah
  8728                              <2> 	cbw
  8729                              <2> %endif
  8730                              <2> 	xchg	cx, ax						; CX = tenths
  8731                              <2> 	xchg	ax, bx
  8732                              <2> 
  8733                              <2> 	; Convert magnitude to character
  8734                              <2> 	mov		dl, [cs:si+.rgbMagnitudeToChar]
  8735                              <2> 
  8736                              <2> 	pop		si
  8737                              <2> %ifndef USE_186
  8738                              <2> 	pop		di
  8739                              <2> %endif
  8740                              <2> 	ret
  8741                              <2> .rgbMagnitudeToChar:	db	" kMGTP"
  8742                              <2> %endif
  8743                              <2> 
  8744                              <2> ;--------------------------------------------------------------------
  8745                              <2> ; Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
  8746                              <2> ;	Parameters:
  8747                              <2> ;		BX:DX:AX:	Size
  8748                              <2> ;		CX:			Magnitude in BYTE_MULTIPLES
  8749                              <2> ;	Returns:
  8750                              <2> ;		BX:DX:AX:	Size in magnitude
  8751                              <2> ;		SI:			Remainder (0...1023)
  8752                              <2> ;		CX:			Magnitude in BYTE_MULTIPLES
  8753                              <2> ;	Corrupts registers:
  8754                              <2> ;		Nothing
  8755                              <2> ;--------------------------------------------------------------------
  8756                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8757                              <2> Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX:
  8758 000003F7 51                  <2> 	push	cx
  8759 000003F8 31F6                <2> 	xor		si, si					; Zero remainder
  8760 000003FA B10A                <2> 	mov		cl, 10					; Divide by 1024
  8761                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8762                              <2> .ShiftLoop:
  8763 000003FC E80D00              <2> 	call	Size_DivideBXDXAXbyTwo
  8764 000003FF D1DE                <2> 	rcr		si, 1					; Update remainder
  8765 00000401 E2F9                <2> 	loop	.ShiftLoop
  8766                              <2> 	eSHR_IM	si, 6					; Remainder to SI beginning
  8767                              <3>  eSHIFT_IM %1, %2, shr
  8768                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  8769                              <4> %ifndef USE_186
  8770                              <4>  %ifidni %1, cl
  8771                              <4>  times %2 %3 %1, 1
  8772                              <4>  %elifidni %1, ch
  8773                              <4>  times %2 %3 %1, 1
  8774                              <4>  %elifidni %1, cx
  8775                              <4>  times %2 %3 %1, 1
  8776                              <4>  %else
  8777                              <4>  %if %2 > 3
  8778 00000403 51                  <4>  push cx
  8779 00000404 B106                <4>  mov cl, %2
  8780 00000406 D3EE                <4>  %3 %1, cl
  8781 00000408 59                  <4>  pop cx
  8782                              <4>  %else
  8783                              <4>  times %2 %3 %1, 1
  8784                              <4>  %endif
  8785                              <4>  %endif
  8786                              <4> 
  8787                              <4> %else
  8788                              <4>  %3 %1, %2
  8789                              <4> %endif
  8790                              <4> %endif
  8791 00000409 59                  <2> 	pop		cx
  8792 0000040A 41                  <2> 	inc		cx						; Increment magnitude
  8793 0000040B C3                  <2> 	ret
  8794                              <2> 
  8795                              <2> ;--------------------------------------------------------------------
  8796                              <2> ; Size_ConvertSectorCountInBXDXAXtoKiB
  8797                              <2> ; Size_DivideBXDXAXbyTwo
  8798                              <2> ;	Parameters:
  8799                              <2> ;		BX:DX:AX:	Total sector count
  8800                              <2> ;	Returns:
  8801                              <2> ;		BX:DX:AX:	Total size in kiB
  8802                              <2> ;		CF:			Remainder from division
  8803                              <2> ;	Corrupts registers:
  8804                              <2> ;		Nothing
  8805                              <2> ;--------------------------------------------------------------------
  8806                              <2> ALIGN UTIL_SIZE_JUMP_ALIGN
  8807                              <2> Size_ConvertSectorCountInBXDXAXtoKiB:	; unused entrypoint ok
  8808                              <2> Size_DivideBXDXAXbyTwo:
  8809 0000040C D1EB                <2> 	shr		bx, 1					; Divide sector count by 2...
  8810 0000040E D1DA                <2> 	rcr		dx, 1					; ...to get disk size in...
  8811 00000410 D1D8                <2> 	rcr		ax, 1					; ...kiB
  8812 00000412 C3                  <2> 	ret
  8813                              <1> 	%ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS
  8814                              <1> 		%include "Sort.asm"
  8815                              <1> 	%endif
  8816                              <1> %endif
  8817                              <1> 
  8818                                  
  8819                                  	; String compression tables need to come after the AssemblyLibrary (since they depend on addresses
  8820                                  	; established in the assembly library), and are unnecessary if strings are not compressed.
  8821                                  	;
  8822                                  %ifdef MODULE_STRINGS_COMPRESSED
  8823                                  	%undef  STRINGSCOMPRESSED_STRINGS
  8824                                  	%define STRINGSCOMPRESSED_TABLES
  8825                                  	%include "StringsCompressed.asm"
  8826                              <1> ;;;======================================================================
  8827                              <1> ;;;
  8828                              <1> ;;; This file is generated by StringsCompress.pl from source in Strings.asm
  8829                              <1> ;;; DO NOT EDIT DIRECTLY - See the makefile for how to rebuild this file.
  8830                              <1> ;;; This file only needs to be rebuilt if Strings.asm is changed.
  8831                              <1> ;;;
  8832                              <1> ;;;======================================================================
  8833                              <1> 
  8834                              <1> %ifdef STRINGSCOMPRESSED_STRINGS
  8835                              <1> 
  8836                              <1> ; Project name	:	XTIDE Universal BIOS
  8837                              <1> ; Description	:	Strings and equates for BIOS messages.
  8838                              <1> 
  8839                              <1> ;
  8840                              <1> ; XTIDE Universal BIOS and Associated Tools
  8841                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  8842                              <1> ;
  8843                              <1> ; This program is free software; you can redistribute it and/or modify
  8844                              <1> ; it under the terms of the GNU General Public License as published by
  8845                              <1> ; the Free Software Foundation; either version 2 of the License, or
  8846                              <1> ; (at your option) any later version.
  8847                              <1> ;
  8848                              <1> ; This program is distributed in the hope that it will be useful,
  8849                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  8850                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  8851                              <1> ; GNU General Public License for more details.
  8852                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  8853                              <1> ;
  8854                              <1> 
  8855                              <1> %ifdef MODULE_STRINGS_COMPRESSED_PRECOMPRESS
  8856                              <1> %include "Display.inc"
  8857                              <1> %endif
  8858                              <1> 
  8859                              <1> ; Section containing code
  8860                              <1> SECTION .text
  8861                              <1> 
  8862                              <1> ; The following strings are used by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
  8863                              <1> ; To support an optimization in that code, these strings must start on the same 256 byte page,
  8864                              <1> ; which is checked at assembly time below.
  8865                              <1> ;
  8866                              <1> g_szDetectStart:
  8867                              <1> g_szDetectMaster:		; db	"Master",NULL
  8868                              <1>                  		; db	 4dh,  61h,  73h,  74h,  65h,  72h,  00h    ; uncompressed
  8869                              <1>                  		  db	 53h,  67h,  79h,  7ah,  6bh, 0b8h          ; compressed
  8870                              <1> 
  8871                              <1> g_szDetectSlave:		; db	"Slave ",NULL
  8872                              <1>                 		; db	 53h,  6ch,  61h,  76h,  65h,  20h,  00h    ; uncompressed
  8873                              <1>                 		  db	 59h,  72h,  67h,  7ch,  6bh,  00h          ; compressed
  8874                              <1> 
  8875                              <1> g_szDetectOuter:		; db	"%s at %s: ",NULL
  8876                              <1>                 		; db	 25h,  73h,  20h,  61h,  74h,  20h,  25h,  73h,  3ah,  20h,  00h    ; uncompressed
  8877                              <1>                 		  db	 3dh,  20h,  67h, 0fah,  3dh,  40h,  00h                            ; compressed
  8878                              <1> 
  8879                              <1> %ifdef MODULE_SERIAL
  8880                              <1> g_szDetectCOM:			; db	"COM%c%s",NULL
  8881                              <1>               			; db	 43h,  4fh,  4dh,  25h,  63h,  25h,  73h,  00h    ; uncompressed
  8882                              <1>               			  db	 49h,  55h,  53h,  3ch,  1dh                      ; compressed
  8883                              <1> 
  8884                              <1> g_szDetectCOMAuto:		; db	" Detect",NULL
  8885                              <1>                   		; db	 20h,  44h,  65h,  74h,  65h,  63h,  74h,  00h    ; uncompressed
  8886                              <1>                   		  db	 20h,  4ah,  6bh,  7ah,  6bh,  69h, 0bah          ; compressed
  8887                              <1> 
  8888                              <1> g_szDetectCOMSmall:		; db	"/%u%u00",NULL					; IDE Master at COM1/9600:
  8889                              <1>                    		; db	 2fh,  25h,  75h,  25h,  75h,  30h,  30h,  00h    ; uncompressed
  8890                              <1>                    		  db	 2ah,  35h,  35h,  33h,  13h                      ; compressed
  8891                              <1> 
  8892                              <1> g_szDetectCOMLarge:		; db	"/%u.%uK",NULL					; IDE Master at COM1/19.2K:
  8893                              <1>                    		; db	 2fh,  25h,  75h,  2eh,  25h,  75h,  4bh,  00h    ; uncompressed
  8894                              <1>                    		  db	 2ah,  35h,  29h,  35h,  91h                      ; compressed
  8895                              <1> 
  8896                              <1> %endif
  8897                              <1> g_szDetectEnd:
  8898                              <1> g_szDetectPort:			; db	"%x",NULL						; IDE Master at 1F0h:
  8899                              <1>                			; db	 25h,  78h,  00h    ; uncompressed
  8900                              <1>                			  db	 17h                ; compressed
  8901                              <1> 
  8902                              <1> 
  8903                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  8904                              <1> %if ((g_szDetectEnd-$$) & 0xff00) <> ((g_szDetectStart-$$) & 0xff00)
  8905                              <1> %error "g_szDetect* strings must start on the same 256 byte page, required by DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP.  Please move this block up or down within Strings.asm"
  8906                              <1> %endif
  8907                              <1> %endif
  8908                              <1> 
  8909                              <1> 
  8910                              <1> ; POST drive detection strings
  8911                              <1> g_szDashForZero:	; db	"- ",NULL	; Required by Display Library
  8912                              <1>                 	; db	 2dh,  20h,  00h    ; uncompressed
  8913                              <1>                 	  db	 28h,  00h          ; compressed
  8914                              <1> 
  8915                              <1> g_szRomAt:			; db	LF,CR
  8916                              <1>           			; db	 0ah,  0dh    ; uncompressed
  8917                              <1>           			  db	 39h          ; compressed
  8918                              <1> 
  8919                              <1> 	; db	"%s @ %x",LF,CR						; -=XTIDE ... =- @ Segment
  8920                              <1> 	; db	 25h,  73h,  20h,  40h,  20h,  25h,  78h,  0ah,  0dh    ; uncompressed
  8921                              <1> 	  db	 3dh,  20h, 0c6h,  37h,  39h                            ; compressed
  8922                              <1> 
  8923                              <1> 	; db	"%s",LF,CR							; version string
  8924                              <1> 	; db	 25h,  73h,  0ah,  0dh    ; uncompressed
  8925                              <1> 	  db	 3dh,  39h                ; compressed
  8926                              <1> 
  8927                              <1> 	; db	"Released under GNU GPL v2",LF,CR
  8928                              <1> 	; db	 52h,  65h,  6ch,  65h,  61h,  73h,  65h,  64h,  20h,  75h,  6eh,  64h,  65h,  72h,  20h,  47h,  4eh,  55h,  20h,  47h,  50h,  4ch,  20h,  76h,  32h,  0ah,  0dh    ; uncompressed
  8929                              <1> 	  db	 58h,  6bh,  72h,  6bh,  67h,  79h,  6bh, 0eah,  7bh,  74h,  6ah,  6bh, 0f8h,  4dh,  54h, 0dbh,  4dh,  56h, 0d2h,  7ch,  2ch,  39h                                  ; compressed
  8930                              <1> 
  8931                              <1> 	; db	LF,CR,NULL
  8932                              <1> 	; db	 0ah,  0dh,  00h    ; uncompressed
  8933                              <1> 	  db	 19h                ; compressed
  8934                              <1> 
  8935                              <1> %ifdef MODULE_BOOT_MENU
  8936                              <1> g_szBootMenuTitle:	; db	"%s%c",LF,CR						; -=XTIDE ... =- and null (eaten)
  8937                              <1>                   	; db	 25h,  73h,  25h,  63h,  0ah,  0dh    ; uncompressed
  8938                              <1>                   	  db	 3dh,  3ch,  39h                      ; compressed
  8939                              <1> 
  8940                              <1> 	; db	"%s",NULL							; version string
  8941                              <1> 	; db	 25h,  73h,  00h    ; uncompressed
  8942                              <1> 	  db	 1dh                ; compressed
  8943                              <1> 
  8944                              <1> %endif
  8945                              <1> g_szDriveName:		; db	"%z",LF,CR,NULL
  8946                              <1>               		; db	 25h,  7ah,  0ah,  0dh,  00h    ; uncompressed
  8947                              <1>               		  db	 3eh,  19h                      ; compressed
  8948                              <1> 
  8949                              <1> 
  8950                              <1> 
  8951                              <1> ; Boot loader strings
  8952                              <1> g_szTryToBoot:			; db	"Booting %c",ANGLE_QUOTE_RIGHT,"%c",LF,CR,NULL
  8953                              <1>               			; db	 42h,  6fh,  6fh,  74h,  69h,  6eh,  67h,  20h,  25h,  63h, 0afh,  25h,  63h,  0ah,  0dh,  00h    ; uncompressed
  8954                              <1>               			  db	 48h,  75h,  75h,  7ah,  6fh,  74h, 0edh,  3ch,  24h,  3ch,  19h                                  ; compressed
  8955                              <1> 
  8956                              <1> g_szBootSectorNotFound:	; db	"Boot sector " 			; String fall through...
  8957                              <1>                        	; db	 42h,  6fh,  6fh,  74h,  20h,  73h,  65h,  63h,  74h,  6fh,  72h,  20h    ; uncompressed
  8958                              <1>                        	  db	 48h,  75h,  75h, 0fah,  79h,  6bh,  69h,  7ah,  75h, 0f8h                ; compressed
  8959                              <1> 
  8960                              <1> g_szNotFound:			; db	"not found",LF,CR,NULL
  8961                              <1>              			; db	 6eh,  6fh,  74h,  20h,  66h,  6fh,  75h,  6eh,  64h,  0ah,  0dh,  00h    ; uncompressed
  8962                              <1>              			  db	 74h,  75h, 0fah,  6ch,  75h,  7bh,  74h,  6ah,  19h                      ; compressed
  8963                              <1> 
  8964                              <1> g_szReadError:			; db	"Error %x!",LF,CR,NULL
  8965                              <1>               			; db	 45h,  72h,  72h,  6fh,  72h,  20h,  25h,  78h,  21h,  0ah,  0dh,  00h    ; uncompressed
  8966                              <1>               			  db	 4bh,  78h,  78h,  75h, 0f8h,  37h,  25h,  19h                            ; compressed
  8967                              <1> 
  8968                              <1> 
  8969                              <1> 
  8970                              <1> %ifdef MODULE_HOTKEYS
  8971                              <1> ; Hotkey Bar strings
  8972                              <1> g_szFDD:				; db	"FDD [%c]",NULL			; "FDD [A]"
  8973                              <1>         				; db	 46h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
  8974                              <1>         				  db	 4ch,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
  8975                              <1> 
  8976                              <1> g_szHDD:				; db	"HDD [%c]",NULL			; "HDD [C]"
  8977                              <1>         				; db	 48h,  44h,  44h,  20h,  5bh,  25h,  63h,  5dh,  00h    ; uncompressed
  8978                              <1>         				  db	 4eh,  4ah, 0cah,  61h,  3ch, 0a3h                      ; compressed
  8979                              <1> 
  8980                              <1> %ifdef MODULE_BOOT_MENU
  8981                              <1> g_szBootMenu:			; db	"BootMnu%c",NULL		; "BootMnu", location of %c doesn't matter
  8982                              <1>              			; db	 42h,  6fh,  6fh,  74h,  4dh,  6eh,  75h,  25h,  63h,  00h    ; uncompressed
  8983                              <1>              			  db	 48h,  75h,  75h,  7ah,  53h,  74h,  7bh,  1ch                ; compressed
  8984                              <1> 
  8985                              <1> %endif ; MODULE_BOOT_MENU
  8986                              <1> g_szHotkey:				; db	"%A%c%c%A%s%A ",NULL	; "CHDD [A] ", "F2BootMnu " or "F8RomBoot "
  8987                              <1>            				; db	 25h,  41h,  25h,  63h,  25h,  63h,  25h,  41h,  25h,  73h,  25h,  41h,  20h,  00h    ; uncompressed
  8988                              <1>            				  db	 3bh,  3ch,  3ch,  3bh,  3dh,  3bh,  00h                                              ; compressed
  8989                              <1> 
  8990                              <1> %ifdef MODULE_SERIAL
  8991                              <1> g_szHotComDetect:		; db	"ComDtct%c",NULL		; "ComDtct", location of %c doesn't matter
  8992                              <1>                  		; db	 43h,  6fh,  6dh,  44h,  74h,  63h,  74h,  25h,  63h,  00h    ; uncompressed
  8993                              <1>                  		  db	 49h,  75h,  73h,  4ah,  7ah,  69h,  7ah,  1ch                ; compressed
  8994                              <1> 
  8995                              <1> %endif ; MODULE_SERIAL
  8996                              <1> %endif ; MODULE_HOTKEYS
  8997                              <1> 
  8998                              <1> %ifdef MODULE_BOOT_MENU
  8999                              <1> g_szRomBootDash:		; db	" -  "					; String fall through to g_szRomBoot
  9000                              <1>                 		; db	 20h,  2dh,  20h,  20h    ; uncompressed
  9001                              <1>                 		  db	 20h,  28h,  20h,  20h    ; compressed
  9002                              <1> 
  9003                              <1> %endif
  9004                              <1> %ifdef MODULE_HOTKEYS OR MODULE_BOOT_MENU
  9005                              <1> g_szRomBoot:			; db	"Rom%cBoot",NULL		; "RomBoot" or "Rom Boot"
  9006                              <1>             			; db	 52h,  6fh,  6dh,  25h,  63h,  42h,  6fh,  6fh,  74h,  00h    ; uncompressed
  9007                              <1>             			  db	 58h,  75h,  73h,  3ch,  48h,  75h,  75h, 0bah                ; compressed
  9008                              <1> 
  9009                              <1> %endif
  9010                              <1> 
  9011                              <1> 
  9012                              <1> %ifdef MODULE_BOOT_MENU
  9013                              <1> ; Boot Menu Floppy Disk strings
  9014                              <1> ;
  9015                              <1> ; The following strings are used by BootMenuPrint_RefreshInformation
  9016                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
  9017                              <1> ; which is checked at assembly time below.
  9018                              <1> ;
  9019                              <1> g_szFddStart:
  9020                              <1> g_szFddUnknown:		; db	"Unknown",NULL
  9021                              <1>                		; db	 55h,  6eh,  6bh,  6eh,  6fh,  77h,  6eh,  00h    ; uncompressed
  9022                              <1>                		  db	 5bh,  74h,  71h,  74h,  75h,  7dh, 0b4h          ; compressed
  9023                              <1> 
  9024                              <1> g_szFddSizeOr:		; db	"5",ONE_QUARTER,QUOTATION_MARK," or 3",ONE_HALF,QUOTATION_MARK," DD",NULL
  9025                              <1>               		; db	 35h, 0ach,  22h,  20h,  6fh,  72h,  20h,  33h, 0abh,  22h,  20h,  44h,  44h,  00h    ; uncompressed
  9026                              <1>               		  db	 2eh,  21h,  26h,  20h,  75h, 0f8h,  2dh,  22h,  26h,  20h,  4ah,  8ah                ; compressed
  9027                              <1> 
  9028                              <1> g_szFddSize:		; db	"%s",QUOTATION_MARK,", %u kiB",NULL	; 3", 1440 kiB
  9029                              <1>             		; db	 25h,  73h,  22h,  2ch,  20h,  25h,  75h,  20h,  6bh,  69h,  42h,  00h    ; uncompressed
  9030                              <1>             		  db	 3dh,  26h,  27h,  20h,  35h,  20h,  71h,  6fh,  88h                      ; compressed
  9031                              <1> 
  9032                              <1> g_szFddThreeHalf:	; db	"3",ONE_HALF,NULL
  9033                              <1>                  	; db	 33h, 0abh,  00h    ; uncompressed
  9034                              <1>                  	  db	 2dh,  02h          ; compressed
  9035                              <1> 
  9036                              <1> g_szFddEnd:
  9037                              <1> g_szFddFiveQuarter:	; db	"5",ONE_QUARTER,NULL
  9038                              <1>                    	; db	 35h, 0ach,  00h    ; uncompressed
  9039                              <1>                    	  db	 2eh,  01h          ; compressed
  9040                              <1> 
  9041                              <1> 
  9042                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9043                              <1> %if ((g_szFddStart-$$) & 0xff00) <> ((g_szFddEnd-$$) & 0xff00)
  9044                              <1> %error "g_szFdd* strings must start on the same 256 byte page, required by the BootMenuPrint_RefreshInformation routines for floppy drives.  Please move this block up or down within Strings.asm"
  9045                              <1> %endif
  9046                              <1> %endif
  9047                              <1> 
  9048                              <1> 
  9049                              <1> g_szAddressingModes:
  9050                              <1> g_szNORMAL:		; db	"NORMAL",NULL
  9051                              <1>            		; db	 4eh,  4fh,  52h,  4dh,  41h,  4ch,  00h    ; uncompressed
  9052                              <1>            		  db	 54h,  55h,  58h,  53h,  47h,  92h          ; compressed
  9053                              <1> 
  9054                              <1> g_szLARGE:		; db	"LARGE ",NULL
  9055                              <1>           		; db	 4ch,  41h,  52h,  47h,  45h,  20h,  00h    ; uncompressed
  9056                              <1>           		  db	 52h,  47h,  58h,  4dh,  4bh,  00h          ; compressed
  9057                              <1> 
  9058                              <1> g_szLBA:		; db	"LBA   ",NULL
  9059                              <1>         		; db	 4ch,  42h,  41h,  20h,  20h,  20h,  00h    ; uncompressed
  9060                              <1>         		  db	 52h,  48h, 0c7h,  20h,  00h                ; compressed
  9061                              <1> 
  9062                              <1> g_szAddressingModes_Displacement equ (g_szLARGE - g_szAddressingModes)
  9063                              <1> ;
  9064                              <1> ; Ensure that addressing modes are correctly spaced in memory
  9065                              <1> ;
  9066                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9067                              <1> %if g_szNORMAL <> g_szAddressingModes
  9068                              <1> %error "g_szAddressingModes Displacement Incorrect 1"
  9069                              <1> %endif
  9070                              <1> %if g_szLARGE <> g_szNORMAL + g_szAddressingModes_Displacement
  9071                              <1> %error "g_szAddressingModes Displacement Incorrect 2"
  9072                              <1> %endif
  9073                              <1> %if g_szLBA <> g_szLARGE + g_szAddressingModes_Displacement
  9074                              <1> %error "g_szAddressingModes Displacement Incorrect 3"
  9075                              <1> %endif
  9076                              <1> %endif
  9077                              <1> 
  9078                              <1> 
  9079                              <1> g_szDeviceTypeValues:
  9080                              <1> g_szDeviceTypeValues_16bit:		; db	" 16",NULL
  9081                              <1>                            		; db	 20h,  31h,  36h,  00h    ; uncompressed
  9082                              <1>                            		  db	 20h,  2bh,  0fh          ; compressed
  9083                              <1> 
  9084                              <1> g_szDeviceTypeValues_32bit:		; db	" 32",NULL
  9085                              <1>                            		; db	 20h,  33h,  32h,  00h    ; uncompressed
  9086                              <1>                            		  db	 20h,  2dh,  0ch          ; compressed
  9087                              <1> 
  9088                              <1> g_szDeviceTypeValues_8bit:		; db	"  8",NULL
  9089                              <1>                           		; db	 20h,  20h,  38h,  00h    ; uncompressed
  9090                              <1>                           		  db	 20h,  20h,  10h          ; compressed
  9091                              <1> 
  9092                              <1> g_szDeviceTypeValues_XTIDEr1:	; db	"D8 ",NULL	; Dual 8-bit
  9093                              <1>                              	; db	 44h,  38h,  20h,  00h    ; uncompressed
  9094                              <1>                              	  db	 4ah,  30h,  00h          ; compressed
  9095                              <1> 
  9096                              <1> g_szDeviceTypeValues_XTIDEr2:	; db	"X8 ",NULL	; A0<->A3 swapped 8-bit
  9097                              <1>                              	; db	 58h,  38h,  20h,  00h    ; uncompressed
  9098                              <1>                              	  db	 5eh,  30h,  00h          ; compressed
  9099                              <1> 
  9100                              <1> g_szDeviceTypeValues_XTCFpio8:	; db	"T8 ",NULL	; True 8-bit
  9101                              <1>                               	; db	 54h,  38h,  20h,  00h    ; uncompressed
  9102                              <1>                               	  db	 5ah,  30h,  00h          ; compressed
  9103                              <1> 
  9104                              <1> g_szDeviceTypeValues_XTCFdma:	; db	"8MA",NULL	; DMA 8-bit
  9105                              <1>                              	; db	 38h,  4dh,  41h,  00h    ; uncompressed
  9106                              <1>                              	  db	 30h,  53h,  87h          ; compressed
  9107                              <1> 
  9108                              <1> g_szDeviceTypeValues_XTCFmem:	; db	"M8 ",NULL	; Memory Mapped 8-bit
  9109                              <1>                              	; db	 4dh,  38h,  20h,  00h    ; uncompressed
  9110                              <1>                              	  db	 53h,  30h,  00h          ; compressed
  9111                              <1> 
  9112                              <1> g_szDeviceTypeValues_JrIde:		; db	"M8 ",NULL
  9113                              <1>                            		; db	 4dh,  38h,  20h,  00h    ; uncompressed
  9114                              <1>                            		  db	 53h,  30h,  00h          ; compressed
  9115                              <1> 
  9116                              <1> g_szDeviceTypeValues_Serial:	; db	"SER",NULL
  9117                              <1>                             	; db	 53h,  45h,  52h,  00h    ; uncompressed
  9118                              <1>                             	  db	 59h,  4bh,  98h          ; compressed
  9119                              <1> 
  9120                              <1> 
  9121                              <1> g_szDeviceTypeValues_Displacement equ (g_szDeviceTypeValues_32bit - g_szDeviceTypeValues)
  9122                              <1> ;
  9123                              <1> ; Ensure that device type strings are correctly spaced in memory
  9124                              <1> ;
  9125                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9126                              <1> %if g_szDeviceTypeValues_16bit <> g_szDeviceTypeValues
  9127                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 1"
  9128                              <1> %endif
  9129                              <1> %if g_szDeviceTypeValues_32bit <> g_szDeviceTypeValues_16bit + g_szDeviceTypeValues_Displacement
  9130                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
  9131                              <1> %endif
  9132                              <1> %if g_szDeviceTypeValues_8bit <> g_szDeviceTypeValues_32bit + g_szDeviceTypeValues_Displacement
  9133                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 2"
  9134                              <1> %endif
  9135                              <1> %if g_szDeviceTypeValues_XTIDEr1 <> g_szDeviceTypeValues_8bit + g_szDeviceTypeValues_Displacement
  9136                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 3"
  9137                              <1> %endif
  9138                              <1> %if g_szDeviceTypeValues_XTIDEr2 <> g_szDeviceTypeValues_XTIDEr1 + g_szDeviceTypeValues_Displacement
  9139                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 4"
  9140                              <1> %endif
  9141                              <1> %if g_szDeviceTypeValues_XTCFpio8 <> g_szDeviceTypeValues_XTIDEr2 + g_szDeviceTypeValues_Displacement
  9142                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 5"
  9143                              <1> %endif
  9144                              <1> %if g_szDeviceTypeValues_XTCFdma <> g_szDeviceTypeValues_XTCFpio8 + g_szDeviceTypeValues_Displacement
  9145                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 6"
  9146                              <1> %endif
  9147                              <1> %if g_szDeviceTypeValues_XTCFmem <> g_szDeviceTypeValues_XTCFdma + g_szDeviceTypeValues_Displacement
  9148                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 7"
  9149                              <1> %endif
  9150                              <1> %if g_szDeviceTypeValues_JrIde <> g_szDeviceTypeValues_XTCFmem + g_szDeviceTypeValues_Displacement
  9151                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 8"
  9152                              <1> %endif
  9153                              <1> %if g_szDeviceTypeValues_Serial <> g_szDeviceTypeValues_JrIde + g_szDeviceTypeValues_Displacement
  9154                              <1> %error "g_szDeviceTypeValues Displacement Incorrect 9"
  9155                              <1> %endif
  9156                              <1> %endif
  9157                              <1> 
  9158                              <1> 
  9159                              <1> g_szSelectionTimeout:	; db	DOUBLE_BOTTOM_LEFT_CORNER,DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL,"%ASelection in %2-u s",NULL
  9160                              <1>                      	; db	0c8h, 0b5h,  25h,  41h,  53h,  65h,  6ch,  65h,  63h,  74h,  69h,  6fh,  6eh,  20h,  69h,  6eh,  20h,  25h,  32h,  2dh,  75h,  20h,  73h,  00h    ; uncompressed
  9161                              <1>                      	  db	 31h,  32h,  3bh,  59h,  6bh,  72h,  6bh,  69h,  7ah,  6fh,  75h, 0f4h,  6fh, 0f4h,  3ah,  20h, 0b9h                                              ; compressed
  9162                              <1> 
  9163                              <1> 
  9164                              <1> 
  9165                              <1> ; Boot Menu information strings
  9166                              <1> g_szCapacity:			; db	"Capacity : %s",NULL
  9167                              <1>              			; db	 43h,  61h,  70h,  61h,  63h,  69h,  74h,  79h,  20h,  3ah,  20h,  25h,  73h,  00h    ; uncompressed
  9168                              <1>              			  db	 49h,  67h,  76h,  67h,  69h,  6fh,  7ah, 0ffh, 0c0h,  1dh                            ; compressed
  9169                              <1> 
  9170                              <1> g_szCapacityNum:		; db	"%5-u.%u %ciB",NULL
  9171                              <1>                 		; db	 25h,  35h,  2dh,  75h,  2eh,  25h,  75h,  20h,  25h,  63h,  69h,  42h,  00h    ; uncompressed
  9172                              <1>                 		  db	 36h,  29h,  35h,  20h,  3ch,  6fh,  88h                                        ; compressed
  9173                              <1> 
  9174                              <1> g_szInformation:		; db	"%s",LF,CR
  9175                              <1>                 		; db	 25h,  73h,  0ah,  0dh    ; uncompressed
  9176                              <1>                 		  db	 3dh,  39h                ; compressed
  9177                              <1> 
  9178                              <1> 	; db	"Addr. ",SINGLE_VERTICAL,"Block",SINGLE_VERTICAL,"Bus",SINGLE_VERTICAL,"IRQ",SINGLE_VERTICAL,"Reset",LF,CR
  9179                              <1> 	; db	 41h,  64h,  64h,  72h,  2eh,  20h, 0b3h,  42h,  6ch,  6fh,  63h,  6bh, 0b3h,  42h,  75h,  73h, 0b3h,  49h,  52h,  51h, 0b3h,  52h,  65h,  73h,  65h,  74h,  0ah,  0dh    ; uncompressed
  9180                              <1> 	  db	 47h,  6ah,  6ah,  78h,  29h,  20h,  23h,  48h,  72h,  75h,  69h,  71h,  23h,  48h,  7bh,  79h,  23h,  4fh,  58h,  57h,  23h,  58h,  6bh,  79h,  6bh,  7ah,  39h          ; compressed
  9181                              <1> 
  9182                              <1> 	; db	"%s",SINGLE_VERTICAL,"%5-u",SINGLE_VERTICAL,"%s",SINGLE_VERTICAL," %2-I",SINGLE_VERTICAL,"%5-x",NULL
  9183                              <1> 	; db	 25h,  73h, 0b3h,  25h,  35h,  2dh,  75h, 0b3h,  25h,  73h, 0b3h,  20h,  25h,  32h,  2dh,  49h, 0b3h,  25h,  35h,  2dh,  78h,  00h    ; uncompressed
  9184                              <1> 	  db	 3dh,  23h,  36h,  23h,  3dh,  23h,  20h,  34h,  23h,  18h                                                                            ; compressed
  9185                              <1> 
  9186                              <1> 
  9187                              <1> 
  9188                              <1> ; Boot Menu menuitem strings
  9189                              <1> ;
  9190                              <1> ; The following strings are used by BootMenuPrint_* routines.
  9191                              <1> ; To support optimizations in that code, these strings must start on the same 256 byte page,
  9192                              <1> ; which is checked at assembly time below.
  9193                              <1> ;
  9194                              <1> g_szDriveNumSpace:		; db	" "							; leading space, used if drive number is less than 0fh
  9195                              <1>                   		; db	 20h    ; uncompressed
  9196                              <1>                   		  db	 20h    ; compressed
  9197                              <1> 
  9198                              <1> ; must come immediately before g_szDriveNum!
  9199                              <1> g_szBootMenuPrintStart:
  9200                              <1> g_szDriveNum:			; db	"%x %s",NULL
  9201                              <1>              			; db	 25h,  78h,  20h,  25h,  73h,  00h    ; uncompressed
  9202                              <1>              			  db	 37h,  20h,  1dh                      ; compressed
  9203                              <1> 
  9204                              <1> g_szDriveNumBNSpace:	; db	" "							; leading space, used if drive number is less than 0fh
  9205                              <1>                     	; db	 20h    ; uncompressed
  9206                              <1>                     	  db	 20h    ; compressed
  9207                              <1> 
  9208                              <1> ; must come immediately before g_szDriveNumBOOTNFO!
  9209                              <1> g_szDriveNumBOOTNFO:	; db	"%x %z",NULL
  9210                              <1>                     	; db	 25h,  78h,  20h,  25h,  7ah,  00h    ; uncompressed
  9211                              <1>                     	  db	 37h,  20h,  1eh                      ; compressed
  9212                              <1> 
  9213                              <1> g_szFloppyDrv:			; db	"Floppy Drive %c",NULL
  9214                              <1>               			; db	 46h,  6ch,  6fh,  70h,  70h,  79h,  20h,  44h,  72h,  69h,  76h,  65h,  20h,  25h,  63h,  00h    ; uncompressed
  9215                              <1>               			  db	 4ch,  72h,  75h,  76h,  76h, 0ffh,  4ah,  78h,  6fh,  7ch, 0ebh,  1ch                            ; compressed
  9216                              <1> 
  9217                              <1> g_szBootMenuPrintEnd:
  9218                              <1> g_szForeignHD:			; db	"Foreign Hard Disk",NULL
  9219                              <1>               			; db	 46h,  6fh,  72h,  65h,  69h,  67h,  6eh,  20h,  48h,  61h,  72h,  64h,  20h,  44h,  69h,  73h,  6bh,  00h    ; uncompressed
  9220                              <1>               			  db	 4ch,  75h,  78h,  6bh,  6fh,  6dh, 0f4h,  4eh,  67h,  78h, 0eah,  4ah,  6fh,  79h, 0b1h                      ; compressed
  9221                              <1> 
  9222                              <1> 
  9223                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9224                              <1> %if ((g_szBootMenuPrintStart-$$) & 0xff00) <> ((g_szBootMenuPrintEnd-$$) & 0xff00)
  9225                              <1> %error "g_szBootMenuPrint* strings must start on the same 256 byte page, required by the BootMenuPrint_* routines.  Please move this block up or down within Strings.asm"
  9226                              <1> %endif
  9227                              <1> %if g_szDriveNumSpace+1 != g_szDriveNum || g_szDriveNumBNSpace+1 != g_szDriveNumBOOTNFO
  9228                              <1> %error "g_szDriveNumSpace or g_szDriveNumBNSpace are out of position"
  9229                              <1> %endif
  9230                              <1> %endif
  9231                              <1> 
  9232                              <1> %endif ; MODULE_BOOT_MENU
  9233                              <1> 
  9234                              <1> 
  9235                              <1> ;------------------------------------------------------------------------------------------
  9236                              <1> ;
  9237                              <1> ; Tables for StringsCompress.pl
  9238                              <1> ;
  9239                              <1> ; Items can be added and removed from this table as needed, with the following rules:
  9240                              <1> ;  * Formats follow the special characters.  But other than that, order makes no difference.
  9241                              <1> ;  * Some of the formats require "even" and "odd" numbering.  Even tells the code that
  9242                              <1> ;    it is a "number-" format, otherwise it doesn't interpret a number first.  The easiest
  9243                              <1> ;    way to maintain this is to move one of the "n/a" items to/from the front of the format
  9244                              <1> ;    list to maintain the even/odd.
  9245                              <1> ;  * Values do not need to remain consistent across versions.  This table is only used
  9246                              <1> ;    internally to this file.
  9247                              <1> ;  * There can only be 32 of these (0-31).
  9248                              <1> ;  * Keeping the list short is good - this translates to a table in the compressed version.
  9249                              <1> ;    An error will be reported if a character or format is no longer being used by any
  9250                              <1> ;    strings above.
  9251                              <1> ;  * Please keep items sequential for ease of further editing.
  9252                              <1> ;
  9253                              <1> ;$translate{ord(' ')} = 0;    [StringsCompress Processed]
  9254                              <1> ;$translate{172}      = 1;     # ONE_QUARTER    [StringsCompress Processed]
  9255                              <1> ;$translate{171}      = 2;     # ONE_HALF    [StringsCompress Processed]
  9256                              <1> ;$translate{179}      = 3;     # SINGLE_VERTICAL    [StringsCompress Processed]
  9257                              <1> ;$translate{175}      = 4;     # ANGLE_QUOTE_RIGHT    [StringsCompress Processed]
  9258                              <1> ;$translate{ord('!')} = 5;    [StringsCompress Processed]
  9259                              <1> ;$translate{ord('"')} = 6;    [StringsCompress Processed]
  9260                              <1> ;$translate{ord(',')} = 7;    [StringsCompress Processed]
  9261                              <1> ;$translate{ord('-')} = 8;    [StringsCompress Processed]
  9262                              <1> ;$translate{ord('.')} = 9;    [StringsCompress Processed]
  9263                              <1> ;$translate{ord('/')} = 10;    [StringsCompress Processed]
  9264                              <1> ;$translate{ord('1')} = 11;    [StringsCompress Processed]
  9265                              <1> ;$translate{ord('2')} = 12;    [StringsCompress Processed]
  9266                              <1> ;$translate{ord('3')} = 13;    [StringsCompress Processed]
  9267                              <1> ;$translate{ord('5')} = 14;    [StringsCompress Processed]
  9268                              <1> ;$translate{ord('6')} = 15;    [StringsCompress Processed]
  9269                              <1> ;$translate{ord('8')} = 16;    [StringsCompress Processed]
  9270                              <1> ;$translate{200}      = 17;    # DOUBLE_BOTTOM_LEFT_CORNER    [StringsCompress Processed]
  9271                              <1> ;$translate{181}      = 18;    # DOUBLE_LEFT_HORIZONTAL_TO_SINGLE_VERTICAL    [StringsCompress Processed]
  9272                              <1> ;$translate{ord('0')} = 19;    [StringsCompress Processed]
  9273                              <1> ;
  9274                              <1> ; Formats begin immediately after the last Translated character (they are in the same table)
  9275                              <1> ;
  9276                              <1> ;$format_begin = 20;    [StringsCompress Processed]
  9277                              <1> ;
  9278                              <1> ;$format{"2-I"} = 20;        # must be even    [StringsCompress Processed]
  9279                              <1> ;$format{"u"}   = 21;        # must be odd    [StringsCompress Processed]
  9280                              <1> ;$format{"5-u"} = 22;        # must be even    [StringsCompress Processed]
  9281                              <1> ;$format{"x"}   = 23;        # must be odd    [StringsCompress Processed]
  9282                              <1> ;$format{"5-x"} = 24;        # must be even    [StringsCompress Processed]
  9283                              <1> ;$format{"nl"}  = 25;        # n/a    [StringsCompress Processed]
  9284                              <1> ;$format{"2-u"} = 26;        # must be even    [StringsCompress Processed]
  9285                              <1> ;$format{"A"}   = 27;        # n/a    [StringsCompress Processed]
  9286                              <1> ;$format{"c"}   = 28;        # n/a    [StringsCompress Processed]
  9287                              <1> ;$format{"s"}   = 29;        # n/a, normal string from DS    [StringsCompress Processed]
  9288                              <1> ;$format{"z"}   = 30;        # n/a, boot string from BDA    [StringsCompress Processed]
  9289                              <1> ;
  9290                              <1> ; NOTE: The last $format cannot exceed 31 (stored in a 5-bit quantity).
  9291                              <1> ;
  9292                              <1> ; Starting point for the "normal" range, typically around 0x40 to cover upper and lower case
  9293                              <1> ; letters.  If lower case 'z' is not used, 0x3a can be a good choice as it adds ':' to the
  9294                              <1> ; front end.
  9295                              <1> ;
  9296                              <1> ;$normal_base = 0x3a;    [StringsCompress Processed]
  9297                              <1> ;
  9298                              <1> ; End of StringsCompress.pl information
  9299                              <1> ;
  9300                              <1> ;;; end of input stream
  9301                              <1> 
  9302                              <1> %endif ; STRINGSCOMPRESSED_STRINGS
  9303                              <1> 
  9304                              <1> %ifdef STRINGSCOMPRESSED_TABLES
  9305                              <1> 
  9306                              <1> StringsCompressed_NormalBase     equ   58
  9307                              <1> 
  9308                              <1> StringsCompressed_FormatsBegin   equ   20
  9309                              <1> 
  9310                              <1> StringsCompressed_TranslatesAndFormats:
  9311 00000413 20                  <1>         db     32  ; 0
  9312 00000414 AC                  <1>         db     172  ; 1
  9313 00000415 AB                  <1>         db     171  ; 2
  9314 00000416 B3                  <1>         db     179  ; 3
  9315 00000417 AF                  <1>         db     175  ; 4
  9316 00000418 21                  <1>         db     33  ; 5
  9317 00000419 22                  <1>         db     34  ; 6
  9318 0000041A 2C                  <1>         db     44  ; 7
  9319 0000041B 2D                  <1>         db     45  ; 8
  9320 0000041C 2E                  <1>         db     46  ; 9
  9321 0000041D 2F                  <1>         db     47  ; 10
  9322 0000041E 31                  <1>         db     49  ; 11
  9323 0000041F 32                  <1>         db     50  ; 12
  9324 00000420 33                  <1>         db     51  ; 13
  9325 00000421 35                  <1>         db     53  ; 14
  9326 00000422 36                  <1>         db     54  ; 15
  9327 00000423 38                  <1>         db     56  ; 16
  9328 00000424 C8                  <1>         db     200  ; 17
  9329 00000425 B5                  <1>         db     181  ; 18
  9330 00000426 30                  <1>         db     48  ; 19
  9331 00000427 31                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I)    ; 20
  9332 00000428 28                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u)    ; 21
  9333 00000429 28                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u)    ; 22
  9334 0000042A 39                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x)    ; 23
  9335 0000042B 39                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x)    ; 24
  9336 0000042C 6C                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl)    ; 25
  9337 0000042D 2A                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u)    ; 26
  9338 0000042E 42                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A)    ; 27
  9339 0000042F 63                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c)    ; 28
  9340 00000430 00                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s)    ; 29
  9341 00000431 3E                  <1>         db     (DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z)    ; 30
  9342                              <1> 
  9343                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9344                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_I || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_I > 255
  9345                              <1> %error "DisplayFormatCompressed_Format_2_I is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9346                              <1> %endif
  9347                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_u > 255
  9348                              <1> %error "DisplayFormatCompressed_Format_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9349                              <1> %endif
  9350                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_u > 255
  9351                              <1> %error "DisplayFormatCompressed_Format_5_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9352                              <1> %endif
  9353                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_x > 255
  9354                              <1> %error "DisplayFormatCompressed_Format_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9355                              <1> %endif
  9356                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_5_x || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_5_x > 255
  9357                              <1> %error "DisplayFormatCompressed_Format_5_x is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9358                              <1> %endif
  9359                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_nl || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_nl > 255
  9360                              <1> %error "DisplayFormatCompressed_Format_nl is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9361                              <1> %endif
  9362                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_2_u || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_2_u > 255
  9363                              <1> %error "DisplayFormatCompressed_Format_2_u is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9364                              <1> %endif
  9365                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_A || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_A > 255
  9366                              <1> %error "DisplayFormatCompressed_Format_A is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9367                              <1> %endif
  9368                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_c || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_c > 255
  9369                              <1> %error "DisplayFormatCompressed_Format_c is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9370                              <1> %endif
  9371                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_s || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_s > 255
  9372                              <1> %error "DisplayFormatCompressed_Format_s is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9373                              <1> %endif
  9374                              <1> %if DisplayFormatCompressed_BaseFormatOffset < DisplayFormatCompressed_Format_z || DisplayFormatCompressed_BaseFormatOffset - DisplayFormatCompressed_Format_z > 255
  9375                              <1> %error "DisplayFormatCompressed_Format_z is out of range of DisplayFormatCompressed_BaseFormatOffset"
  9376                              <1> %endif
  9377                              <1> %endif
  9378                              <1> 
  9379                              <1> ;; translated usage stats
  9380                              <1> ;; 33:1
  9381                              <1> ;; 32:34
  9382                              <1> ;; 181:1
  9383                              <1> ;; 53:2
  9384                              <1> ;; 48:2
  9385                              <1> ;; 200:1
  9386                              <1> ;; 46:3
  9387                              <1> ;; 179:8
  9388                              <1> ;; 44:1
  9389                              <1> ;; 50:2
  9390                              <1> ;; 51:3
  9391                              <1> ;; 47:2
  9392                              <1> ;; 172:2
  9393                              <1> ;; 34:3
  9394                              <1> ;; 49:1
  9395                              <1> ;; 56:7
  9396                              <1> ;; 45:2
  9397                              <1> ;; 175:1
  9398                              <1> ;; 171:2
  9399                              <1> ;; 54:1
  9400                              <1> ;; total translated: 20
  9401                              <1> 
  9402                              <1> ;; format usage stats
  9403                              <1> ;; A:4
  9404                              <1> ;; 2-u:1
  9405                              <1> ;; 5-u:2
  9406                              <1> ;; x:5
  9407                              <1> ;; s:14
  9408                              <1> ;; 5-x:1
  9409                              <1> ;; nl:12
  9410                              <1> ;; 2-I:1
  9411                              <1> ;; u:6
  9412                              <1> ;; c:13
  9413                              <1> ;; z:2
  9414                              <1> ;; total format: 11
  9415                              <1> 
  9416                              <1> ;; alphabet usage stats
  9417                              <1> ;; 58,::2
  9418                              <1> ;; 59,;:
  9419                              <1> ;; 60,<:
  9420                              <1> ;; 61,=:
  9421                              <1> ;; 62,>:
  9422                              <1> ;; 63,?:
  9423                              <1> ;; 64,@:1
  9424                              <1> ;; 65,A:5
  9425                              <1> ;; 66,B:9
  9426                              <1> ;; 67,C:3
  9427                              <1> ;; 68,D:11
  9428                              <1> ;; 69,E:3
  9429                              <1> ;; 70,F:3
  9430                              <1> ;; 71,G:3
  9431                              <1> ;; 72,H:2
  9432                              <1> ;; 73,I:1
  9433                              <1> ;; 74,J:
  9434                              <1> ;; 75,K:1
  9435                              <1> ;; 76,L:4
  9436                              <1> ;; 77,M:7
  9437                              <1> ;; 78,N:2
  9438                              <1> ;; 79,O:2
  9439                              <1> ;; 80,P:1
  9440                              <1> ;; 81,Q:1
  9441                              <1> ;; 82,R:7
  9442                              <1> ;; 83,S:3
  9443                              <1> ;; 84,T:1
  9444                              <1> ;; 85,U:2
  9445                              <1> ;; 86,V:
  9446                              <1> ;; 87,W:
  9447                              <1> ;; 88,X:1
  9448                              <1> ;; 89,Y:
  9449                              <1> ;; 90,Z:
  9450                              <1> ;; 91,[:2
  9451                              <1> ;; 92,\:
  9452                              <1> ;; 93,]:2
  9453                              <1> ;; 94,^:
  9454                              <1> ;; 95,_:
  9455                              <1> ;; 96,`:
  9456                              <1> ;; 97,a:7
  9457                              <1> ;; 98,b:
  9458                              <1> ;; 99,c:6
  9459                              <1> ;; 100,d:6
  9460                              <1> ;; 101,e:15
  9461                              <1> ;; 102,f:1
  9462                              <1> ;; 103,g:2
  9463                              <1> ;; 104,h:
  9464                              <1> ;; 105,i:9
  9465                              <1> ;; 106,j:
  9466                              <1> ;; 107,k:4
  9467                              <1> ;; 108,l:5
  9468                              <1> ;; 109,m:2
  9469                              <1> ;; 110,n:11
  9470                              <1> ;; 111,o:20
  9471                              <1> ;; 112,p:3
  9472                              <1> ;; 113,q:
  9473                              <1> ;; 114,r:11
  9474                              <1> ;; 115,s:7
  9475                              <1> ;; 116,t:15
  9476                              <1> ;; 117,u:4
  9477                              <1> ;; 118,v:3
  9478                              <1> ;; 119,w:1
  9479                              <1> ;; 120,x:
  9480                              <1> ;; 121,y:2
  9481                              <1> ;; alphabet used count: 45
  9482                              <1> %endif ; STRINGSCOMPRESSED_TABLES
  9483                              <1> 
  9484                                  %endif
  9485                                  
  9486                                  	%include "Initialize.asm"		; For BIOS initialization
  9487                              <1> ; Project name	:	XTIDE Universal BIOS
  9488                              <1> ; Description	:	Functions for initializing the BIOS.
  9489                              <1> 
  9490                              <1> ;
  9491                              <1> ; XTIDE Universal BIOS and Associated Tools
  9492                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  9493                              <1> ;
  9494                              <1> ; This program is free software; you can redistribute it and/or modify
  9495                              <1> ; it under the terms of the GNU General Public License as published by
  9496                              <1> ; the Free Software Foundation; either version 2 of the License, or
  9497                              <1> ; (at your option) any later version.
  9498                              <1> ;
  9499                              <1> ; This program is distributed in the hope that it will be useful,
  9500                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9501                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9502                              <1> ; GNU General Public License for more details.
  9503                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  9504                              <1> ;
  9505                              <1> 
  9506                              <1> ; Section containing code
  9507                              <1> SECTION .text
  9508                              <1> 
  9509                              <1> ;--------------------------------------------------------------------
  9510                              <1> ; Initializes the BIOS.
  9511                              <1> ; This function is called from main BIOS ROM search routine.
  9512                              <1> ;
  9513                              <1> ; Initialize_FromMainBiosRomSearch
  9514                              <1> ;	Parameters:
  9515                              <1> ;		Nothing
  9516                              <1> ;	Returns:
  9517                              <1> ;		Nothing
  9518                              <1> ;	Corrupts registers:
  9519                              <1> ;		Nothing
  9520                              <1> ;--------------------------------------------------------------------
  9521                              <1> Initialize_FromMainBiosRomSearch:		; unused entrypoint ok
  9522 00000432 9C                  <1> 	pushf								; To store IF
  9523 00000433 1E                  <1> 	push	ds
  9524                              <1> 
  9525                              <1> %ifndef USE_186
  9526 00000434 50                  <1> 	push	ax
  9527                              <1> 	LOAD_BDA_SEGMENT_TO	ds, ax
  9528                              <2> %ifndef USE_186
  9529 00000435 31C0                <2>  xor %2, %2
  9530 00000437 8ED8                <2>  mov %1, %2
  9531                              <2> %elifidn %3, !
  9532                              <2>  xor %2, %2
  9533                              <2>  mov %1, %2
  9534                              <2> %else
  9535                              <2>  push BYTE 0
  9536                              <2>  pop %1
  9537                              <2> %endif
  9538                              <1> %else
  9539                              <1> 	push	BYTE 0
  9540                              <1> 	pop		ds
  9541                              <1> %endif
  9542                              <1> 
  9543 00000439 FB                  <1> 	sti									; Enable interrupts for keystrokes
  9544 0000043A F606170404          <1> 	test	BYTE [BDA.bKBFlgs1], (1<<2)	; Clears ZF if CTRL is held down
  9545 0000043F 750A                <1> 	jnz		SHORT .SkipRomInitialization
  9546                              <1> 
  9547                              <1> 	; Install INT 19h handler (boot loader) where drives are detected
  9548 00000441 C7066400[010B]      <1> 	mov		WORD [BIOS_BOOT_LOADER_INTERRUPT_19h*4], Int19h_BootLoaderHandler
  9549 00000447 8C0E6600            <1> 	mov		[BIOS_BOOT_LOADER_INTERRUPT_19h*4+2], cs
  9550                              <1> 
  9551                              <1> .SkipRomInitialization:
  9552                              <1> %ifndef USE_186
  9553 0000044B 58                  <1> 	pop		ax
  9554                              <1> %endif
  9555 0000044C 1F                  <1> 	pop		ds
  9556 0000044D 9D                  <1> 	popf
  9557 0000044E CB                  <1> 	retf
  9558                              <1> 
  9559                              <1> 
  9560                              <1> ;--------------------------------------------------------------------
  9561                              <1> ; Initializes the BIOS variables and detects IDE drives.
  9562                              <1> ;
  9563                              <1> ; Initialize_AndDetectDrives
  9564                              <1> ;	Parameters:
  9565                              <1> ;		ES:		BDA Segment
  9566                              <1> ;	Returns:
  9567                              <1> ;		DS:		RAMVARS segment
  9568                              <1> ;	Corrupts registers:
  9569                              <1> ;		All, except ES
  9570                              <1> ;--------------------------------------------------------------------
  9571                              <1> Initialize_AndDetectDrives:
  9572 0000044F E8C304              <1> 	call	DetectPrint_InitializeDisplayContext
  9573 00000452 E81305              <1> 	call	DetectPrint_RomFoundAtSegment
  9574 00000455 E84A00              <1> 	call	RamVars_Initialize
  9575 00000458 E8C300              <1> 	call	BootVars_Initialize
  9576 0000045B E8CB03              <1> 	call	DetectDrives_FromAllIDEControllers
  9577 0000045E E80A00              <1> 	call	Interrupts_InitializeInterruptVectors
  9578                              <1> 	; Fall to .ResetDetectedDrives
  9579                              <1> 
  9580                              <1> ;--------------------------------------------------------------------
  9581                              <1> ; .ResetDetectedDrives
  9582                              <1> ;	Parameters:
  9583                              <1> ;		DS:		RAMVARS segment
  9584                              <1> ;		ES:		BDA and interrupt vector segment (zero)
  9585                              <1> ;	Returns:
  9586                              <1> ;		Nothing
  9587                              <1> ;	Corrupts registers:
  9588                              <1> ;		All, except DS and ES
  9589                              <1> ;--------------------------------------------------------------------
  9590                              <1> .ResetDetectedDrives:
  9591 00000461 E87E07              <1> 	call	Idepack_FakeToSSBP
  9592 00000464 E86611              <1> 	call	AH0h_ResetAllOurHardDisksAtTheEndOfDriveInitialization
  9593 00000467 83C40C              <1> 	add		sp, BYTE SIZE_OF_IDEPACK_WITHOUT_INTPACK
  9594 0000046A C3                  <1> 	ret
  9595                                  	%include "Interrupts.asm"		; For Interrupt initialization
  9596                              <1> ; Project name	:	XTIDE Universal BIOS
  9597                              <1> ; Description	:	Functions for initializing the BIOS.
  9598                              <1> 
  9599                              <1> ;
  9600                              <1> ; XTIDE Universal BIOS and Associated Tools
  9601                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  9602                              <1> ;
  9603                              <1> ; This program is free software; you can redistribute it and/or modify
  9604                              <1> ; it under the terms of the GNU General Public License as published by
  9605                              <1> ; the Free Software Foundation; either version 2 of the License, or
  9606                              <1> ; (at your option) any later version.
  9607                              <1> ;
  9608                              <1> ; This program is distributed in the hope that it will be useful,
  9609                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9610                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9611                              <1> ; GNU General Public License for more details.
  9612                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  9613                              <1> ;
  9614                              <1> 
  9615                              <1> ; Section containing code
  9616                              <1> SECTION .text
  9617                              <1> 
  9618                              <1> ;--------------------------------------------------------------------
  9619                              <1> ; Drives must be detected before this function is called!
  9620                              <1> ;
  9621                              <1> ; Interrupts_InitializeInterruptVectors
  9622                              <1> ;	Parameters:
  9623                              <1> ;		DS:		RAMVARS segment
  9624                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9625                              <1> ;	Returns:
  9626                              <1> ;		Nothing
  9627                              <1> ;	Corrupts registers:
  9628                              <1> ;		All except segments
  9629                              <1> ;--------------------------------------------------------------------
  9630                              <1> Interrupts_InitializeInterruptVectors:
  9631                              <1> 	; Install INT 19h handler to properly reset the system
  9632 0000046B B019                <1> 	mov		al, BIOS_BOOT_LOADER_INTERRUPT_19h	; INT 19h interrupt vector offset
  9633 0000046D BE[DC0B]            <1> 	mov		si, Int19hReset_Handler				; INT 19h handler to reboot the system
  9634 00000470 E82200              <1> 	call	Interrupts_InstallHandlerToVectorInALFromCSSI
  9635                              <1> 
  9636                              <1> 	; If no drives detected, leave system INT 13h and 40h handlers
  9637                              <1> 	; in place. We need our INT 13h handler to swap drive letters.
  9638                              <1> %ifndef MODULE_DRIVEXLATE
  9639                              <1> 	cmp		BYTE [RAMVARS.bDrvCnt], 0
  9640                              <1> 	je		SHORT Interrupts_InstallHandlerToVectorInALFromCSSI.Interrupts_Return
  9641                              <1> %endif
  9642                              <1> 	; Fall to .InitializeInt13hAnd40h
  9643                              <1> 
  9644                              <1> ;--------------------------------------------------------------------
  9645                              <1> ; .InitializeInt13hAnd40h
  9646                              <1> ;	Parameters:
  9647                              <1> ;		DS:		RAMVARS segment
  9648                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9649                              <1> ;	Returns:
  9650                              <1> ;		Nothing
  9651                              <1> ;	Corrupts registers:
  9652                              <1> ;		AX, BX, CX, DX, SI, DI
  9653                              <1> ;--------------------------------------------------------------------
  9654                              <1> .InitializeInt13hAnd40h:
  9655 00000473 26A14E00            <1> 	mov		ax, [es:BIOS_DISK_INTERRUPT_13h*4+2]; Load old INT 13h segment
  9656 00000477 A30200              <1> 	mov		[RAMVARS.fpOldI13h+2], ax			; Store old INT 13h segment
  9657 0000047A 92                  <1> 	xchg	dx, ax
  9658 0000047B 26A14C00            <1> 	mov		ax, [es:BIOS_DISK_INTERRUPT_13h*4]	; Load old INT 13h offset
  9659 0000047F A30000              <1> 	mov		[RAMVARS.fpOldI13h], ax				; Store old INT 13h offset
  9660                              <1> 
  9661                              <1> %ifdef COPY_13H_HANDLER_TO_40H
  9662                              <1> 	; Only store INT 13h handler to 40h if 40h is not already installed.
  9663                              <1> 	; At least AMI BIOS for 286 stores 40h handler by itself and calls
  9664                              <1> 	; 40h from 13h. That system locks to infinite loop if we copy 13h to 40h.
  9665 00000482 E8C100              <1> 	call	FloppyDrive_IsInt40hInstalled
  9666 00000485 7209                <1> 	jc		SHORT .Int40hAlreadyInstalled
  9667 00000487 26A30001            <1> 	mov		[es:BIOS_DISKETTE_INTERRUPT_40h*4], ax		; Store old INT 13h offset
  9668 0000048B 2689160201          <1> 	mov		[es:BIOS_DISKETTE_INTERRUPT_40h*4+2], dx	; Store old INT 13h segment
  9669                              <1> .Int40hAlreadyInstalled:
  9670                              <1> %endif ; COPY_13H_HANDLER_TO_40H
  9671                              <1> 
  9672 00000490 B013                <1> 	mov		al, BIOS_DISK_INTERRUPT_13h			; INT 13h interrupt vector offset
  9673                              <1> %ifdef RELOCATE_INT13H_STACK
  9674                              <1> 	mov		si, Int13h_DiskFunctionsHandlerWithStackChange
  9675                              <1> %else
  9676 00000492 BE[3914]            <1> 	mov		si, Int13h_DiskFunctionsHandler
  9677                              <1> %endif
  9678                              <1> 
  9679                              <1> %ifndef MODULE_IRQ
  9680                              <1> 	; Fall to Interrupts_InstallHandlerToVectorInALFromCSSI
  9681                              <1> %else
  9682                              <1> 	call	Interrupts_InstallHandlerToVectorInALFromCSSI
  9683                              <1> 	; Fall to .InitializeHardwareIrqHandlers
  9684                              <1> 
  9685                              <1> ;--------------------------------------------------------------------
  9686                              <1> ; .InitializeHardwareIrqHandlers
  9687                              <1> ;	Parameters:
  9688                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9689                              <1> ;	Returns:
  9690                              <1> ;		Nothing
  9691                              <1> ;	Corrupts registers:
  9692                              <1> ;		BX, CX, DX, SI, DI, AX
  9693                              <1> ;--------------------------------------------------------------------
  9694                              <1> .InitializeHardwareIrqHandlers:
  9695                              <1> 	call	RamVars_GetIdeControllerCountToCX
  9696                              <1> 	mov		di, ROMVARS.ideVars0+IDEVARS.bIRQ	; CS:SI points to first IDEVARS
  9697                              <1> .IdeControllerLoop:
  9698                              <1> 	mov		al, [cs:di]
  9699                              <1> 	add		di, BYTE IDEVARS_size			; Increment to next controller
  9700                              <1> 	call	.InstallLowOrHighIrqHandler
  9701                              <1> 	loop	.IdeControllerLoop
  9702                              <1> .Return:
  9703                              <1> 	ret		; This ret is shared with .InstallLowOrHighIrqHandler
  9704                              <1> 
  9705                              <1> ;--------------------------------------------------------------------
  9706                              <1> ; .InstallLowOrHighIrqHandler
  9707                              <1> ;	Parameters:
  9708                              <1> ;		AL:		IRQ number, 0 if IRQ disabled
  9709                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9710                              <1> ;	Returns:
  9711                              <1> ;		Nothing
  9712                              <1> ;	Corrupts registers:
  9713                              <1> ;		BX, SI
  9714                              <1> ;--------------------------------------------------------------------
  9715                              <1> .InstallLowOrHighIrqHandler:
  9716                              <1> 	test	al, al
  9717                              <1> 	jz		SHORT .Return	; IRQ not used
  9718                              <1> 	cmp		al, 8
  9719                              <1> 	jb		SHORT .InstallLowIrqHandler
  9720                              <1> 	; Fall to .InstallHighIrqHandler
  9721                              <1> 
  9722                              <1> ;--------------------------------------------------------------------
  9723                              <1> ; .InstallHighIrqHandler
  9724                              <1> ;	Parameters:
  9725                              <1> ;		BX:		IRQ number (8...15)
  9726                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9727                              <1> ;	Returns:
  9728                              <1> ;		Nothing
  9729                              <1> ;	Corrupts registers:
  9730                              <1> ;		AL, BX, SI
  9731                              <1> ;--------------------------------------------------------------------
  9732                              <1> .InstallHighIrqHandler:
  9733                              <1> 	add		al, BYTE HARDWARE_IRQ_8_INTERRUPT_70h - 8	; Interrupt vector number
  9734                              <1> 	mov		si, IdeIrq_InterruptServiceRoutineForIrqs8to15
  9735                              <1> 	jmp		SHORT Interrupts_InstallHandlerToVectorInALFromCSSI
  9736                              <1> 
  9737                              <1> ;--------------------------------------------------------------------
  9738                              <1> ; .InstallLowIrqHandler
  9739                              <1> ;	Parameters:
  9740                              <1> ;		AL:		IRQ number (0...7)
  9741                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9742                              <1> ;	Returns:
  9743                              <1> ;		Nothing
  9744                              <1> ;	Corrupts registers:
  9745                              <1> ;		AL, BX, SI
  9746                              <1> ;--------------------------------------------------------------------
  9747                              <1> .InstallLowIrqHandler:
  9748                              <1> 	add		al, BYTE HARDWARE_IRQ_0_INTERRUPT_08h		; Interrupt vector number
  9749                              <1> 	mov		si, IdeIrq_InterruptServiceRoutineForIrqs2to7
  9750                              <1> 	; Fall to Interrupts_InstallHandlerToVectorInALFromCSSI
  9751                              <1> %endif ; MODULE_IRQ
  9752                              <1> 
  9753                              <1> 
  9754                              <1> ;--------------------------------------------------------------------
  9755                              <1> ; Interrupts_InstallHandlerToVectorInALFromCSSI
  9756                              <1> ;	Parameters:
  9757                              <1> ;		AL:		Interrupt vector number (for example 13h)
  9758                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
  9759                              <1> ;		CS:SI:	Ptr to interrupt handler
  9760                              <1> ;	Returns:
  9761                              <1> ;		Nothing
  9762                              <1> ;	Corrupts registers:
  9763                              <1> ;		AX, BX
  9764                              <1> ;--------------------------------------------------------------------
  9765                              <1> Interrupts_InstallHandlerToVectorInALFromCSSI:
  9766 00000495 B304                <1> 	mov		bl, 4					; Shift for DWORD offset, MUL smaller than other alternatives
  9767 00000497 F6E3                <1> 	mul		bl
  9768 00000499 93                  <1> 	xchg	ax, bx
  9769 0000049A 268937              <1> 	mov		[es:bx], si				; Store offset
  9770 0000049D 268C4F02            <1> 	mov		[es:bx+2], cs			; Store segment
  9771                              <1> .Interrupts_Return:
  9772 000004A1 C3                  <1> 	ret
  9773                              <1> 
  9774                              <1> 
  9775                              <1> %ifdef MODULE_IRQ
  9776                              <1> ;--------------------------------------------------------------------
  9777                              <1> ; Interrupts_UnmaskInterruptControllerForDriveInDSDI
  9778                              <1> ;	Parameters:
  9779                              <1> ;		DS:DI:	Ptr to DPT
  9780                              <1> ;	Returns:
  9781                              <1> ;		Nothing
  9782                              <1> ;	Corrupts registers:
  9783                              <1> ;		AX, BX, DX
  9784                              <1> ;--------------------------------------------------------------------
  9785                              <1> Interrupts_UnmaskInterruptControllerForDriveInDSDI:
  9786                              <1> 	eMOVZX	bx, [di+DPT.bIdevarsOffset]
  9787                              <1> 	mov		al, [cs:bx+IDEVARS.bIRQ]
  9788                              <1> 	test	al, al
  9789                              <1> 	jz		SHORT .Return	; Interrupts disabled
  9790                              <1> 	cmp		al, 8
  9791                              <1> 	jb		SHORT .UnmaskLowIrqController
  9792                              <1> 	; Fall to .UnmaskHighIrqController
  9793                              <1> 
  9794                              <1> ;--------------------------------------------------------------------
  9795                              <1> ; .UnmaskHighIrqController
  9796                              <1> ;	Parameters:
  9797                              <1> ;		AL:		IRQ number (8...15)
  9798                              <1> ;	Returns:
  9799                              <1> ;		Nothing
  9800                              <1> ;	Corrupts registers:
  9801                              <1> ;		AX, DX
  9802                              <1> ;--------------------------------------------------------------------
  9803                              <1> .UnmaskHighIrqController:
  9804                              <1> 	sub		al, 8				; Slave interrupt number
  9805                              <1> 	mov		dx, SLAVE_8259_IMR
  9806                              <1> 	call	.ClearBitFrom8259MaskRegister
  9807                              <1> 	mov		al, 2				; Master IRQ 2 to allow slave IRQs
  9808                              <1> 	; Fall to .UnmaskLowIrqController
  9809                              <1> 
  9810                              <1> ;--------------------------------------------------------------------
  9811                              <1> ; .UnmaskLowIrqController
  9812                              <1> ;	Parameters:
  9813                              <1> ;		AL:		IRQ number (0...7)
  9814                              <1> ;	Returns:
  9815                              <1> ;		Nothing
  9816                              <1> ;	Corrupts registers:
  9817                              <1> ;		AX, DX
  9818                              <1> ;--------------------------------------------------------------------
  9819                              <1> .UnmaskLowIrqController:
  9820                              <1> 	mov		dx, MASTER_8259_IMR
  9821                              <1> 	; Fall to .ClearBitFrom8259MaskRegister
  9822                              <1> 
  9823                              <1> ;--------------------------------------------------------------------
  9824                              <1> ; .ClearBitFrom8259MaskRegister
  9825                              <1> ;	Parameters:
  9826                              <1> ;		AL:		8259 interrupt index (0...7)
  9827                              <1> ;		DX:		Port address to Interrupt Mask Register
  9828                              <1> ;	Returns:
  9829                              <1> ;		Nothing
  9830                              <1> ;	Corrupts registers:
  9831                              <1> ;		AX
  9832                              <1> ;--------------------------------------------------------------------
  9833                              <1> .ClearBitFrom8259MaskRegister:
  9834                              <1> 	push	cx
  9835                              <1> 	xchg	ax, cx				; IRQ index to CL
  9836                              <1> 	mov		ch, 1				; Load 1 to be shifted
  9837                              <1> 	shl		ch, cl				; Shift bit to correct position
  9838                              <1> 	not		ch					; Invert to create bit mask for clearing
  9839                              <1> 	in		al, dx				; Read Interrupt Mask Register
  9840                              <1> 	and		al, ch				; Clear wanted bit
  9841                              <1> 	out		dx, al				; Write modified Interrupt Mask Register
  9842                              <1> 	pop		cx
  9843                              <1> .Return:
  9844                              <1> 	ret
  9845                              <1> 
  9846                              <1> %endif ; MODULE_IRQ
  9847                                  	%include "RamVars.asm"			; For RAMVARS initialization and access
  9848                              <1> ; Project name	:	XTIDE Universal BIOS
  9849                              <1> ; Description	:	Functions for accessings RAMVARS.
  9850                              <1> 
  9851                              <1> ;
  9852                              <1> ; XTIDE Universal BIOS and Associated Tools
  9853                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
  9854                              <1> ;
  9855                              <1> ; This program is free software; you can redistribute it and/or modify
  9856                              <1> ; it under the terms of the GNU General Public License as published by
  9857                              <1> ; the Free Software Foundation; either version 2 of the License, or
  9858                              <1> ; (at your option) any later version.
  9859                              <1> ;
  9860                              <1> ; This program is distributed in the hope that it will be useful,
  9861                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  9862                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  9863                              <1> ; GNU General Public License for more details.
  9864                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
  9865                              <1> ;
  9866                              <1> 
  9867                              <1> ; Section containing code
  9868                              <1> SECTION .text
  9869                              <1> 
  9870                              <1> ;--------------------------------------------------------------------
  9871                              <1> ; Initializes RAMVARS.
  9872                              <1> ; Drive detection can be started after this function returns.
  9873                              <1> ;
  9874                              <1> ; RamVars_Initialize
  9875                              <1> ;	Parameters:
  9876                              <1> ;		Nothing
  9877                              <1> ;	Returns:
  9878                              <1> ;		DS:		RAMVARS segment
  9879                              <1> ;	Corrupts registers:
  9880                              <1> ;		AX, CX, DI
  9881                              <1> ;--------------------------------------------------------------------
  9882                              <1> RamVars_Initialize:
  9883 000004A2 06                  <1> 	push	es
  9884                              <1> 	; Fall to .StealMemoryForRAMVARS
  9885                              <1> 
  9886                              <1> ;--------------------------------------------------------------------
  9887                              <1> ; .StealMemoryForRAMVARS
  9888                              <1> ;	Parameters:
  9889                              <1> ;		Nothing
  9890                              <1> ;	Returns:
  9891                              <1> ;		DS:		RAMVARS segment
  9892                              <1> ;	Corrupts registers:
  9893                              <1> ;		AX
  9894                              <1> ;--------------------------------------------------------------------
  9895                              <1> .StealMemoryForRAMVARS:
  9896                              <1> %ifndef USE_AT
  9897 000004A3 B83000              <1> 	mov		ax, LITE_MODE_RAMVARS_SEGMENT
  9898 000004A6 2EF606460001        <1> 	test	BYTE [cs:ROMVARS.wFlags], FLG_ROMVARS_FULLMODE
  9899 000004AC 7415                <1> 	jz		SHORT .InitializeRamvars	; No need to steal RAM
  9900                              <1> %endif
  9901                              <1> 
  9902                              <1> 	LOAD_BDA_SEGMENT_TO	ds, ax, !		; Zero AX
  9903                              <2> %ifndef USE_186
  9904 000004AE 31C0                <2>  xor %2, %2
  9905 000004B0 8ED8                <2>  mov %1, %2
  9906                              <2> %elifidn %3, !
  9907                              <2>  xor %2, %2
  9908                              <2>  mov %1, %2
  9909                              <2> %else
  9910                              <2>  push BYTE 0
  9911                              <2>  pop %1
  9912                              <2> %endif
  9913 000004B2 2EA04F00            <1> 	mov		al, [cs:ROMVARS.bStealSize]
  9914 000004B6 29061304            <1> 	sub		[BDA.wBaseMem], ax
  9915 000004BA A11304              <1> 	mov		ax, [BDA.wBaseMem]
  9916                              <1> 	eSHL_IM	ax, 6						; Segment to first stolen kB (*=40h)
  9917                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9918                              <2> %ifdef USE_386
  9919                              <2>  %if %2 = 1
  9920                              <2>  add %1, %1
  9921                              <2>  %else
  9922                              <2>  eSHIFT_IM %1, %2, shl
  9923                              <2>  %endif
  9924                              <2> %else
  9925                              <2>  eSHIFT_IM %1, %2, shl
  9926                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
  9927                              <3> %ifndef USE_186
  9928                              <3>  %ifidni %1, cl
  9929                              <3>  times %2 %3 %1, 1
  9930                              <3>  %elifidni %1, ch
  9931                              <3>  times %2 %3 %1, 1
  9932                              <3>  %elifidni %1, cx
  9933                              <3>  times %2 %3 %1, 1
  9934                              <3>  %else
  9935                              <3>  %if %2 > 3
  9936 000004BD 51                  <3>  push cx
  9937 000004BE B106                <3>  mov cl, %2
  9938 000004C0 D3E0                <3>  %3 %1, cl
  9939 000004C2 59                  <3>  pop cx
  9940                              <3>  %else
  9941                              <3>  times %2 %3 %1, 1
  9942                              <3>  %endif
  9943                              <3>  %endif
  9944                              <3> 
  9945                              <3> %else
  9946                              <3>  %3 %1, %2
  9947                              <3> %endif
  9948                              <3> %endif
  9949                              <2> %endif
  9950                              <2> %endif
  9951                              <1> 	; Fall to .InitializeRamvars
  9952                              <1> 
  9953                              <1> ;--------------------------------------------------------------------
  9954                              <1> ; .InitializeRamvars
  9955                              <1> ;	Parameters:
  9956                              <1> ;		AX:		RAMVARS segment
  9957                              <1> ;	Returns:
  9958                              <1> ;		DS:		RAMVARS segment
  9959                              <1> ;	Corrupts registers:
  9960                              <1> ;		AX, CX, DI, ES
  9961                              <1> ;--------------------------------------------------------------------
  9962                              <1> .InitializeRamvars:
  9963 000004C3 8ED8                <1> 	mov		ds, ax
  9964 000004C5 8EC0                <1> 	mov		es, ax
  9965 000004C7 B90E00              <1> 	mov		cx, RAMVARS_size
  9966 000004CA 31FF                <1> 	xor		di, di
  9967 000004CC E80EFF              <1> 	call	Memory_ZeroESDIwithSizeInCX
  9968 000004CF C70600005A5A        <1> 	mov		WORD [RAMVARS.wDrvDetectSignature], RAMVARS_DRV_DETECT_SIGNATURE
  9969 000004D5 C70604005875        <1> 	mov		WORD [RAMVARS.wSignature], RAMVARS_RAM_SIGNATURE
  9970                              <1> ;; There used to be a DriveXlate_Reset call here.  It isn't necessary, as we reset
  9971                              <1> ;; when entering the boot menu and also before transferring control at boot time and
  9972                              <1> ;; for ROM boots (in int19h.asm).
  9973                              <1> 
  9974 000004DB 07                  <1> 	pop		es
  9975 000004DC C3                  <1> 	ret
  9976                              <1> 
  9977                              <1> ;--------------------------------------------------------------------
  9978                              <1> ; Returns segment to RAMVARS.
  9979                              <1> ; RAMVARS might be located at the top of interrupt vectors (0030:0000h)
  9980                              <1> ; or at the top of system base RAM.
  9981                              <1> ;
  9982                              <1> ; RamVars_GetSegmentToDS
  9983                              <1> ;	Parameters:
  9984                              <1> ;		Nothing
  9985                              <1> ;	Returns:
  9986                              <1> ;		DS:		RAMVARS segment
  9987                              <1> ;	Corrupts registers:
  9988                              <1> ;		DI
  9989                              <1> ;--------------------------------------------------------------------
  9990                              <1> ALIGN JUMP_ALIGN
  9991                              <1> RamVars_GetSegmentToDS:
  9992                              <1> 
  9993                              <1> %ifndef USE_AT	; Always in Full Mode for AT builds
  9994 000004DD 2EF606460001        <1> 	test	BYTE [cs:ROMVARS.wFlags], FLG_ROMVARS_FULLMODE
  9995 000004E3 7506                <1> 	jnz		SHORT .GetStolenSegmentToDS
  9996                              <1> 	%ifndef USE_186
  9997 000004E5 BF3000              <1> 		mov		di, LITE_MODE_RAMVARS_SEGMENT
  9998 000004E8 8EDF                <1> 		mov		ds, di
  9999                              <1> 	%else
 10000                              <1> 		push	LITE_MODE_RAMVARS_SEGMENT
 10001                              <1> 		pop		ds
 10002                              <1> 	%endif
 10003 000004EA C3                  <1> 	ret
 10004                              <1> %endif
 10005                              <1> 
 10006                              <1> ALIGN JUMP_ALIGN
 10007                              <1> .GetStolenSegmentToDS:
 10008                              <1> 	LOAD_BDA_SEGMENT_TO	ds, di
 10009                              <2> %ifndef USE_186
 10010 000004EB 31FF                <2>  xor %2, %2
 10011 000004ED 8EDF                <2>  mov %1, %2
 10012                              <2> %elifidn %3, !
 10013                              <2>  xor %2, %2
 10014                              <2>  mov %1, %2
 10015                              <2> %else
 10016                              <2>  push BYTE 0
 10017                              <2>  pop %1
 10018                              <2> %endif
 10019 000004EF 8B3E1304            <1> 	mov		di, [BDA.wBaseMem]		; Load available base memory size in kB
 10020                              <1> 	eSHL_IM	di, 6					; Segment to first stolen kB (*=40h)
 10021                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10022                              <2> %ifdef USE_386
 10023                              <2>  %if %2 = 1
 10024                              <2>  add %1, %1
 10025                              <2>  %else
 10026                              <2>  eSHIFT_IM %1, %2, shl
 10027                              <2>  %endif
 10028                              <2> %else
 10029                              <2>  eSHIFT_IM %1, %2, shl
 10030                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10031                              <3> %ifndef USE_186
 10032                              <3>  %ifidni %1, cl
 10033                              <3>  times %2 %3 %1, 1
 10034                              <3>  %elifidni %1, ch
 10035                              <3>  times %2 %3 %1, 1
 10036                              <3>  %elifidni %1, cx
 10037                              <3>  times %2 %3 %1, 1
 10038                              <3>  %else
 10039                              <3>  %if %2 > 3
 10040 000004F3 51                  <3>  push cx
 10041 000004F4 B106                <3>  mov cl, %2
 10042 000004F6 D3E7                <3>  %3 %1, cl
 10043 000004F8 59                  <3>  pop cx
 10044                              <3>  %else
 10045                              <3>  times %2 %3 %1, 1
 10046                              <3>  %endif
 10047                              <3>  %endif
 10048                              <3> 
 10049                              <3> %else
 10050                              <3>  %3 %1, %2
 10051                              <3> %endif
 10052                              <3> %endif
 10053                              <2> %endif
 10054                              <2> %endif
 10055                              <1> ALIGN JUMP_ALIGN
 10056                              <1> .LoopStolenKBs:
 10057 000004F9 8EDF                <1> 	mov		ds, di					; EBDA segment to DS
 10058 000004FB 83C740              <1> 	add		di, BYTE 64				; DI to next stolen kB
 10059 000004FE 813E04005875        <1> 	cmp		WORD [RAMVARS.wSignature], RAMVARS_RAM_SIGNATURE
 10060 00000504 75F3                <1> 	jne		SHORT .LoopStolenKBs	; Loop until sign found (always found eventually)
 10061 00000506 C3                  <1> 	ret
 10062                              <1> 
 10063                              <1> 
 10064                              <1> ;--------------------------------------------------------------------
 10065                              <1> ; RamVars_GetHardDiskCountFromBDAtoAX
 10066                              <1> ;	Parameters:
 10067                              <1> ;		DS:		RAMVARS segment
 10068                              <1> ;	Returns:
 10069                              <1> ;		AX:		Total hard disk count
 10070                              <1> ;	Corrupts registers:
 10071                              <1> ;		BX
 10072                              <1> ;--------------------------------------------------------------------
 10073                              <1> %ifdef MODULE_BOOT_MENU
 10074                              <1> RamVars_GetHardDiskCountFromBDAtoAX:
 10075                              <1> 	call	RamVars_GetCountOfKnownDrivesToAX
 10076                              <1> 	push	ds
 10077                              <1> 	LOAD_BDA_SEGMENT_TO	ds, bx
 10078                              <1> 	mov		bl, [BDA.bHDCount]
 10079                              <1> 	MAX_U	al, bl
 10080                              <1> 	pop		ds
 10081                              <1> 	ret
 10082                              <1> %endif
 10083                              <1> 
 10084                              <1> 
 10085                              <1> ;--------------------------------------------------------------------
 10086                              <1> ; RamVars_GetCountOfKnownDrivesToAX
 10087                              <1> ;	Parameters:
 10088                              <1> ;		DS:		RAMVARS segment
 10089                              <1> ;	Returns:
 10090                              <1> ;		AX:		Total hard disk count
 10091                              <1> ;	Corrupts registers:
 10092                              <1> ;		None
 10093                              <1> ;--------------------------------------------------------------------
 10094                              <1> ALIGN JUMP_ALIGN
 10095                              <1> RamVars_GetCountOfKnownDrivesToAX:
 10096 00000507 A10800              <1> 	mov		ax, [RAMVARS.wFirstDrvAndCount]
 10097 0000050A 00E0                <1> 	add		al, ah
 10098 0000050C 83E07F              <1> 	and		ax, BYTE 7fh
 10099 0000050F C3                  <1> 	ret
 10100                              <1> 
 10101                              <1> ;--------------------------------------------------------------------
 10102                              <1> ; RamVars_GetIdeControllerCountToCX
 10103                              <1> ;	Parameters:
 10104                              <1> ;		Nothing
 10105                              <1> ;	Returns:
 10106                              <1> ;		CX:		Number of IDE controllers to handle
 10107                              <1> ;	Corrupts registers:
 10108                              <1> ;		Nothing
 10109                              <1> ;--------------------------------------------------------------------
 10110                              <1> ALIGN JUMP_ALIGN
 10111                              <1> RamVars_GetIdeControllerCountToCX:
 10112                              <1> 	eMOVZX	cx, [cs:ROMVARS.bIdeCnt]
 10113                              <2> %ifndef USE_386
 10114                              <2>  %ifidni %1, ax
 10115                              <2>  mov al, %2
 10116                              <2>  xor ah, ah
 10117                              <2>  %elifidni %1, bx
 10118                              <2>  mov bl, %2
 10119                              <2>  xor bh, bh
 10120                              <2>  %elifidni %1, cx
 10121 00000510 2E8A0E4C00          <2>  mov cl, %2
 10122 00000515 30ED                <2>  xor ch, ch
 10123                              <2>  %elifidni %1, dx
 10124                              <2>  mov dl, %2
 10125                              <2>  xor dh, dh
 10126                              <2>  %else
 10127                              <2>  push ax
 10128                              <2>  mov al, %2
 10129                              <2>  xor ah, ah
 10130                              <2>  xchg ax, %1
 10131                              <2>  pop ax
 10132                              <2>  %endif
 10133                              <2> 
 10134                              <2> %else
 10135                              <2>  movzx %1, %2
 10136                              <2> %endif
 10137 00000517 C3                  <1> 	ret
 10138                              <1> 
 10139                              <1> 
 10140                              <1> %ifdef MODULE_SERIAL_FLOPPY
 10141                              <1> ;--------------------------------------------------------------------
 10142                              <1> ; RamVars_UnpackFlopCntAndFirstToAL
 10143                              <1> ;	Parameters:
 10144                              <1> ;		DS:		RAMVARS segment
 10145                              <1> ;	Returns:
 10146                              <1> ;		AL:		First floppy drive number supported
 10147                              <1> ;       CF:		Number of floppy drives supported (clear = 1, set = 2)
 10148                              <1> ;		SF:		Emulating drives (clear = yes, set = no)
 10149                              <1> ;	Corrupts registers:
 10150                              <1> ;		Nothing
 10151                              <1> ;--------------------------------------------------------------------
 10152                              <1> ALIGN JUMP_ALIGN
 10153                              <1> RamVars_UnpackFlopCntAndFirstToAL:
 10154 00000518 A00A00              <1> 	mov		al, [RAMVARS.xlateVars+XLATEVARS.bFlopCntAndFirst]
 10155 0000051B D0F8                <1> 	sar		al, 1
 10156 0000051D C3                  <1> 	ret
 10157                              <1> %endif
 10158                              <1> 
 10159                              <1> 
 10160                              <1> %if 0							; unused...
 10161                              <1> ;--------------------------------------------------------------------
 10162                              <1> ; RamVars_IsDriveDetectionInProgress
 10163                              <1> ;	Parameters:
 10164                              <1> ;		DS:		RAMVARS segment
 10165                              <1> ;	Returns:
 10166                              <1> ;		ZF:		Set if drive detection is in progress (ROM initialization)
 10167                              <1> ;	Corrupts registers:
 10168                              <1> ;		None
 10169                              <1> ;--------------------------------------------------------------------
 10170                              <1> RamVars_IsDriveDetectionInProgress:
 10171                              <1> 	cmp		WORD [RAMVARS.wSignature], RAMVARS_DRV_DETECT_SIGNATURE
 10172                              <1> 	ret
 10173                              <1> %endif
 10174                                  	%include "BootVars.asm"			; For initializing variables used during init and boot
 10175                              <1> ; Project name	:	XTIDE Universal BIOS
 10176                              <1> ; Description	:	Functions for accessings BOOTVARS.
 10177                              <1> 
 10178                              <1> ;
 10179                              <1> ; XTIDE Universal BIOS and Associated Tools
 10180                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 10181                              <1> ;
 10182                              <1> ; This program is free software; you can redistribute it and/or modify
 10183                              <1> ; it under the terms of the GNU General Public License as published by
 10184                              <1> ; the Free Software Foundation; either version 2 of the License, or
 10185                              <1> ; (at your option) any later version.
 10186                              <1> ;
 10187                              <1> ; This program is distributed in the hope that it will be useful,
 10188                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10189                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10190                              <1> ; GNU General Public License for more details.
 10191                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 10192                              <1> ;
 10193                              <1> 
 10194                              <1> ; Section containing code
 10195                              <1> SECTION .text
 10196                              <1> 
 10197                              <1> ;--------------------------------------------------------------------
 10198                              <1> ; BootVars_Initialize
 10199                              <1> ;	Parameters:
 10200                              <1> ;		DS:		RAMVARS Segment
 10201                              <1> ;		ES:		BDA Segment
 10202                              <1> ;	Returns:
 10203                              <1> ;		Nothing
 10204                              <1> ;	Corrupts registers:
 10205                              <1> ;		AX, CX, DX, DI
 10206                              <1> ;--------------------------------------------------------------------
 10207                              <1> BootVars_Initialize:
 10208                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 10209 0000051E 26C706047F4001      <1> 	mov		WORD [es:BOOTVARS.wNextXTCFportToScan], XTCF_BASE_PORT_DETECTION_SEED
 10210                              <1> %endif
 10211                              <1> 
 10212                              <1> 	; Clear all DRVDETECTINFO structs to zero
 10213 00000525 B02C                <1> 	mov		al, DRVDETECTINFO_size
 10214 00000527 2EF6264C00          <1> 	mul		BYTE [cs:ROMVARS.bIdeCnt]
 10215 0000052C BF0C7F              <1> 	mov		di, BOOTVARS.rgDrvDetectInfo	; We must not initialize anything before this!
 10216 0000052F 91                  <1> 	xchg	cx, ax
 10217                              <1> %ifndef MODULE_HOTKEYS
 10218                              <1> 	jmp		Memory_ZeroESDIwithSizeInCX
 10219                              <1> 
 10220                              <1> %else ; if MODULE_HOTKEYS
 10221 00000530 E8AAFE              <1> 	call	Memory_ZeroESDIwithSizeInCX
 10222                              <1> 
 10223                              <1> 	; Initialize HOTKEYVARS by storing default drives to boot from
 10224 00000533 E80800              <1> 	call	BootVars_StoreDefaultDriveLettersToHotkeyVars
 10225 00000536 2E8A164D00          <1> 	mov		dl, [cs:ROMVARS.bBootDrv]
 10226 0000053B E91205              <1> 	jmp		HotkeyBar_StoreHotkeyToBootvarsForDriveNumberInDL
 10227                              <1> 
 10228                              <1> 
 10229                              <1> ;--------------------------------------------------------------------
 10230                              <1> ; BootVars_StoreDefaultDriveLettersToHotkeyVars
 10231                              <1> ;	Parameters:
 10232                              <1> ;		ES:		BDA Segment
 10233                              <1> ;	Returns:
 10234                              <1> ;		Nothing
 10235                              <1> ;	Corrupts registers:
 10236                              <1> ;		Nothing
 10237                              <1> ;--------------------------------------------------------------------
 10238                              <1> BootVars_StoreDefaultDriveLettersToHotkeyVars:
 10239 0000053E 26C706087F4143      <1> 	mov		WORD [es:BOOTVARS.hotkeyVars+HOTKEYVARS.wFddAndHddLetters], DEFAULT_FLOPPY_DRIVE_LETTER | (DEFAULT_HARD_DRIVE_LETTER<<8)
 10240 00000545 C3                  <1> 	ret
 10241                              <1> 
 10242                              <1> %endif ; MODULE_HOTKEYS
 10243                                  	%include "FloppyDrive.asm"		; Floppy Drive related functions
 10244                              <1> ; Project name	:	XTIDE Universal BIOS
 10245                              <1> ; Description	:	Various floppy drive related functions that
 10246                              <1> ;					Boot Menu uses.
 10247                              <1> 
 10248                              <1> ;
 10249                              <1> ; XTIDE Universal BIOS and Associated Tools
 10250                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 10251                              <1> ;
 10252                              <1> ; This program is free software; you can redistribute it and/or modify
 10253                              <1> ; it under the terms of the GNU General Public License as published by
 10254                              <1> ; the Free Software Foundation; either version 2 of the License, or
 10255                              <1> ; (at your option) any later version.
 10256                              <1> ;
 10257                              <1> ; This program is distributed in the hope that it will be useful,
 10258                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10259                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10260                              <1> ; GNU General Public License for more details.
 10261                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 10262                              <1> ;
 10263                              <1> 
 10264                              <1> ; Section containing code
 10265                              <1> SECTION .text
 10266                              <1> 
 10267                              <1> %ifdef COPY_13H_HANDLER_TO_40H
 10268                              <1> ;--------------------------------------------------------------------
 10269                              <1> ; Checks is floppy drive handler installed to interrupt vector 40h.
 10270                              <1> ;
 10271                              <1> ; FloppyDrive_IsInt40hInstalled
 10272                              <1> ;	Parameters:
 10273                              <1> ;		ES:		BDA and Interrupt Vector segment (zero)
 10274                              <1> ;	Returns:
 10275                              <1> ;		CF:		Set if INT 40h is installed
 10276                              <1> ;				Cleared if INT 40h is not installed
 10277                              <1> ;	Corrupts registers:
 10278                              <1> ;		BX, CX, DI
 10279                              <1> ;--------------------------------------------------------------------
 10280                              <1> FloppyDrive_IsInt40hInstalled:
 10281 00000546 26813E020100C0      <1> 	cmp		WORD [es:BIOS_DISKETTE_INTERRUPT_40h*4+2], 0C000h	; Any ROM segment?
 10282                              <1> %ifdef USE_AT	; No need to verify on XT systems.
 10283                              <1> 	jb		SHORT .Int40hHandlerIsNotInstalled
 10284                              <1> 	call	.VerifyInt40hHandlerSinceSomeBiosesSimplyReturnFromInt40h
 10285                              <1> .Int40hHandlerIsNotInstalled:
 10286                              <1> %endif
 10287 0000054D F5                  <1> 	cmc
 10288 0000054E C3                  <1> 	ret
 10289                              <1> 
 10290                              <1> ;--------------------------------------------------------------------
 10291                              <1> ; .VerifyInt40hHandlerSinceSomeBiosesSimplyReturnFromInt40h
 10292                              <1> ;	Parameters:
 10293                              <1> ;		Nothing
 10294                              <1> ;	Returns:
 10295                              <1> ;		CF:		Cleared if INT 40h is installed
 10296                              <1> ;				Set if INT 40h is not installed
 10297                              <1> ;	Corrupts registers:
 10298                              <1> ;		BX, CX, DI
 10299                              <1> ;--------------------------------------------------------------------
 10300                              <1> %ifdef USE_AT
 10301                              <1> .VerifyInt40hHandlerSinceSomeBiosesSimplyReturnFromInt40h:
 10302                              <1> 	push	es
 10303                              <1> 	push	dx
 10304                              <1> 	push	ax
 10305                              <1> 
 10306                              <1> 	call	.LoadInt40hVerifyParameters
 10307                              <1> 	int		BIOS_DISK_INTERRUPT_13h
 10308                              <1> 	jc		SHORT .Int40hIsInstalled	; Maybe there are not any floppy drives at all
 10309                              <1> 	push	es
 10310                              <1> 	push	di
 10311                              <1> 
 10312                              <1> 	call	.LoadInt40hVerifyParameters
 10313                              <1> 	int		BIOS_DISKETTE_INTERRUPT_40h
 10314                              <1> 
 10315                              <1> 	pop		dx
 10316                              <1> 	pop		cx
 10317                              <1> 	cmp		dx, di						; Difference in offsets?
 10318                              <1> 	jne		SHORT .Int40hNotInstalled
 10319                              <1> 	mov		dx, es
 10320                              <1> 	cmp		cx, dx						; Difference in segments?
 10321                              <1> 	je		SHORT .Int40hIsInstalled
 10322                              <1> .Int40hNotInstalled:
 10323                              <1> 	stc
 10324                              <1> .Int40hIsInstalled:
 10325                              <1> 	pop		ax
 10326                              <1> 	pop		dx
 10327                              <1> 	pop		es
 10328                              <1> 	ret
 10329                              <1> 
 10330                              <1> ;--------------------------------------------------------------------
 10331                              <1> ; .LoadInt40hVerifyParameters
 10332                              <1> ;	Parameters:
 10333                              <1> ;		Nothing
 10334                              <1> ;	Returns:
 10335                              <1> ;		AH:		08h (Get Drive Parameters)
 10336                              <1> ;		DL:		00h (floppy drive)
 10337                              <1> ;		ES:DI:	0:0h (to guard against BIOS bugs)
 10338                              <1> ;	Corrupts registers:
 10339                              <1> ;		DH
 10340                              <1> ;--------------------------------------------------------------------
 10341                              <1> .LoadInt40hVerifyParameters:
 10342                              <1> 	mov		ah, 08h				; Get Drive Parameters
 10343                              <1> 	cwd							; Floppy drive 0
 10344                              <1> 	mov		di, dx
 10345                              <1> 	mov		es, dx				; ES:DI = 0000:0000h to guard against BIOS bugs
 10346                              <1> 	ret
 10347                              <1> %endif
 10348                              <1> 
 10349                              <1> %endif ; COPY_13H_HANDLER_TO_40H
 10350                              <1> 
 10351                              <1> 
 10352                              <1> ;--------------------------------------------------------------------
 10353                              <1> ; Returns floppy drive type.
 10354                              <1> ; PC/XT system do not support AH=08h but FLOPPY_TYPE_525_OR_35_DD
 10355                              <1> ; is still returned for them.
 10356                              <1> ;
 10357                              <1> ; FloppyDrive_GetType
 10358                              <1> ;	Parameters:
 10359                              <1> ;		DL:		Floppy Drive number
 10360                              <1> ;	Returns:
 10361                              <1> ;		BX:		Floppy Drive Type:
 10362                              <1> ;					FLOPPY_TYPE_525_OR_35_DD
 10363                              <1> ;					FLOPPY_TYPE_525_DD
 10364                              <1> ;					FLOPPY_TYPE_525_HD
 10365                              <1> ;					FLOPPY_TYPE_35_DD
 10366                              <1> ;					FLOPPY_TYPE_35_HD
 10367                              <1> ;					FLOPPY_TYPE_35_ED
 10368                              <1> ;		CF:		Set if AH=08h not supported (XT systems) or error
 10369                              <1> ;				Cleared if type read correctly (AT systems)
 10370                              <1> ;	Corrupts registers:
 10371                              <1> ;		AX, CX, DX, DI, ES
 10372                              <1> ;--------------------------------------------------------------------
 10373                              <1> %ifdef MODULE_BOOT_MENU
 10374                              <1> FloppyDrive_GetType:
 10375                              <1> 	mov		ah, 08h			; Get Drive Parameters
 10376                              <1> 	xor		bx, bx			; FLOPPY_TYPE_525_OR_35_DD when function not supported
 10377                              <1> 	int		BIOS_DISKETTE_INTERRUPT_40h
 10378                              <1> 	ret
 10379                              <1> %endif
 10380                              <1> 
 10381                              <1> 
 10382                              <1> ;--------------------------------------------------------------------
 10383                              <1> ; Returns number of Floppy Drives in system.
 10384                              <1> ;
 10385                              <1> ; FloppyDrive_GetCountToAX
 10386                              <1> ;	Parameters:
 10387                              <1> ;		DS:		RAMVARS Segment
 10388                              <1> ;	Returns:
 10389                              <1> ;		AX:		Number of Floppy Drives
 10390                              <1> ;--------------------------------------------------------------------
 10391                              <1> FloppyDrive_GetCountToAX:
 10392                              <1> %ifdef MODULE_SERIAL_FLOPPY
 10393 0000054F E8C6FF              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
 10394 00000552 7804                <1> 	js		.UseBIOSorBDA				; We didn't add in any drives, counts here are not valid
 10395                              <1> 
 10396 00000554 1401                <1> 	adc		al,1						; adds in the drive count bit, and adds 1 for count vs. 0-index,
 10397 00000556 EB03                <1> 	jmp		.FinishCalc					; need to clear AH on the way out, and add in minimum drive numbers
 10398                              <1> 
 10399                              <1> .UseBIOSorBDA:
 10400                              <1> %endif
 10401 00000558 E80D00              <1> 	call	FloppyDrive_GetCountFromBIOS_or_BDA
 10402                              <1> 
 10403                              <1> .FinishCalc:
 10404 0000055B 2E8A264E00          <1> 	mov		ah, [cs:ROMVARS.bMinFddCnt]
 10405                              <1> 	MAX_U	al, ah
 10406 00000560 38E0                <2>  cmp %1, %2
 10407 00000562 7702                <2>  ja %%Return
 10408 00000564 88E0                <2>  mov %1, %2
 10409                              <2> ALIGN JUMP_ALIGN
 10410                              <2> %%Return:
 10411 00000566 98                  <1> 	cbw
 10412                              <1> 
 10413 00000567 C3                  <1> 	ret
 10414                              <1> 
 10415                              <1> FloppyDrive_GetCountFromBIOS_or_BDA:
 10416 00000568 06                  <1> 	push	es
 10417                              <1> 
 10418                              <1> ;--------------------------------------------------------------------
 10419                              <1> ; Reads Floppy Drive Count from BIOS.
 10420                              <1> ; Does not work on most XT systems. Call .GetCountFromBDA
 10421                              <1> ; if this function fails.
 10422                              <1> ;
 10423                              <1> ; .GetCountFromBIOS
 10424                              <1> ;	Parameters:
 10425                              <1> ;		Nothing
 10426                              <1> ;	Returns:
 10427                              <1> ;		AL:		Number of Floppy Drives
 10428                              <1> ;		CF:		Cleared if successful
 10429                              <1> ;				Set if BIOS function not supported
 10430                              <1> ;	Corrupts registers:
 10431                              <1> ;		ES
 10432                              <1> ;--------------------------------------------------------------------
 10433                              <1> %ifdef USE_AT
 10434                              <1> .GetCountFromBIOS:
 10435                              <1> 	push	di
 10436                              <1> 	push	bx
 10437                              <1> 	push	cx
 10438                              <1> 	push	dx
 10439                              <1> 
 10440                              <1> 	mov		ah, 08h					; Get Drive Parameters
 10441                              <1> 	cwd								; Floppy Drive 00h
 10442                              <1> 	int		BIOS_DISKETTE_INTERRUPT_40h
 10443                              <1> 	mov		al, dl					; Number of Floppy Drives to AL
 10444                              <1> 
 10445                              <1> 	pop		dx
 10446                              <1> 	pop		cx
 10447                              <1> 	pop		bx
 10448                              <1> 	pop		di
 10449                              <1> %endif
 10450                              <1> 
 10451                              <1> ;--------------------------------------------------------------------
 10452                              <1> ; Reads Floppy Drive Count (0...4) from BIOS Data Area.
 10453                              <1> ; This function should be used only if .GetCountFromBIOS fails.
 10454                              <1> ;
 10455                              <1> ; .GetCountFromBDA
 10456                              <1> ;	Parameters:
 10457                              <1> ;		Nothing
 10458                              <1> ;	Returns:
 10459                              <1> ;		AL:		Number of Floppy Drives
 10460                              <1> ;	Corrupts registers:
 10461                              <1> ;		AH, ES
 10462                              <1> ;--------------------------------------------------------------------
 10463                              <1> %ifndef USE_AT
 10464                              <1> .GetCountFromBDA:
 10465                              <1> 	LOAD_BDA_SEGMENT_TO	es, ax
 10466                              <2> %ifndef USE_186
 10467 00000569 31C0                <2>  xor %2, %2
 10468 0000056B 8EC0                <2>  mov %1, %2
 10469                              <2> %elifidn %3, !
 10470                              <2>  xor %2, %2
 10471                              <2>  mov %1, %2
 10472                              <2> %else
 10473                              <2>  push BYTE 0
 10474                              <2>  pop %1
 10475                              <2> %endif
 10476 0000056D 26A01004            <1> 	mov		al, [es:BDA.wEquipment]			; Load Equipment WORD low byte
 10477 00000571 88C4                <1> 	mov		ah, al							; Copy it to AH
 10478 00000573 2501C0              <1> 	and		ax, 0C001h						; Leave bits 15..14 and 0
 10479                              <1> 	eROL_IM	ah, 2							; EW low byte bits 7..6 to 1..0
 10480                              <2>  eSHIFT_IM %1, %2, rol
 10481                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10482                              <3> %ifndef USE_186
 10483                              <3>  %ifidni %1, cl
 10484                              <3>  times %2 %3 %1, 1
 10485                              <3>  %elifidni %1, ch
 10486                              <3>  times %2 %3 %1, 1
 10487                              <3>  %elifidni %1, cx
 10488                              <3>  times %2 %3 %1, 1
 10489                              <3>  %else
 10490                              <3>  %if %2 > 3
 10491                              <3>  push cx
 10492                              <3>  mov cl, %2
 10493                              <3>  %3 %1, cl
 10494                              <3>  pop cx
 10495                              <3>  %else
 10496 00000576 D0C4<rept>          <3>  times %2 %3 %1, 1
 10497                              <3>  %endif
 10498                              <3>  %endif
 10499                              <3> 
 10500                              <3> %else
 10501                              <3>  %3 %1, %2
 10502                              <3> %endif
 10503                              <3> %endif
 10504 0000057A 00E0                <1> 	add		al, ah							; AL = Floppy Drive count
 10505                              <1> %endif
 10506                              <1> 
 10507 0000057C 07                  <1> 	pop		es
 10508 0000057D C3                  <1> 	ret
 10509                                  	%include "CreateDPT.asm"		; For creating DPTs
 10510                              <1> ; Project name	:	XTIDE Universal BIOS
 10511                              <1> ; Description	:	Functions for creating Disk Parameter Table.
 10512                              <1> 
 10513                              <1> ;
 10514                              <1> ; XTIDE Universal BIOS and Associated Tools
 10515                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 10516                              <1> ;
 10517                              <1> ; This program is free software; you can redistribute it and/or modify
 10518                              <1> ; it under the terms of the GNU General Public License as published by
 10519                              <1> ; the Free Software Foundation; either version 2 of the License, or
 10520                              <1> ; (at your option) any later version.
 10521                              <1> ;
 10522                              <1> ; This program is distributed in the hope that it will be useful,
 10523                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10524                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10525                              <1> ; GNU General Public License for more details.
 10526                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 10527                              <1> ;
 10528                              <1> 
 10529                              <1> ; Section containing code
 10530                              <1> SECTION .text
 10531                              <1> 
 10532                              <1> ;--------------------------------------------------------------------
 10533                              <1> ; Creates new Disk Parameter Table for detected hard disk.
 10534                              <1> ; Drive is then fully accessible using any BIOS function.
 10535                              <1> ;
 10536                              <1> ; CreateDPT_FromAtaInformation
 10537                              <1> ;	Parameters:
 10538                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 10539                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 10540                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10541                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10542                              <1> ;		DS:		RAMVARS segment
 10543                              <1> ;		ES:		BDA Segment
 10544                              <1> ;	Returns:
 10545                              <1> ;		DS:DI:	Ptr to Disk Parameter Table (if successful)
 10546                              <1> ;		CF:		Cleared if DPT created successfully
 10547                              <1> ;				Set if any error
 10548                              <1> ;	Corrupts registers:
 10549                              <1> ;		AX, BX, CX, DH
 10550                              <1> ;--------------------------------------------------------------------
 10551                              <1> CreateDPT_FromAtaInformation:
 10552 0000057E E81401              <1> 	call	FindDPT_ForNewDriveToDSDI
 10553                              <1> 	; Fall to .InitializeDPT
 10554                              <1> 
 10555                              <1> ;--------------------------------------------------------------------
 10556                              <1> ; .InitializeDPT
 10557                              <1> ;	Parameters:
 10558                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 10559                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 10560                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10561                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10562                              <1> ;	Returns:
 10563                              <1> ;		Nothing
 10564                              <1> ;	Corrupts registers:
 10565                              <1> ;		AX
 10566                              <1> ;--------------------------------------------------------------------
 10567                              <1> .InitializeDPT:
 10568 00000581 E87900              <1> 	call	CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI
 10569                              <1> 	; Fall to .StoreDriveSelectAndDriveControlByte
 10570                              <1> 
 10571                              <1> ;--------------------------------------------------------------------
 10572                              <1> ; .StoreDriveSelectAndDriveControlByte
 10573                              <1> ;	Parameters:
 10574                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 10575                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10576                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10577                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10578                              <1> ;	Returns:
 10579                              <1> ;		Nothing
 10580                              <1> ;	Corrupts registers:
 10581                              <1> ;		AX
 10582                              <1> ;--------------------------------------------------------------------
 10583                              <1> .StoreDriveSelectAndDriveControlByte:
 10584 00000584 88F8                <1> 	mov		al, bh
 10585 00000586 83E010              <1> 	and		ax, BYTE FLG_DRVNHEAD_DRV		; AL now has Master/Slave bit
 10586                              <1> %ifdef MODULE_IRQ
 10587                              <1> 	cmp		[cs:bp+IDEVARS.bIRQ], ah		; Interrupts enabled?
 10588                              <1> 	jz		SHORT .StoreFlags				;  If not, do not set interrupt flag
 10589                              <1> 	or		al, FLGL_DPT_ENABLE_IRQ
 10590                              <1> .StoreFlags:
 10591                              <1> %endif
 10592 00000589 8905                <1> 	mov		[di+DPT.wFlags], ax
 10593                              <1> 	; Fall to .StoreCHSparametersAndAddressingMode
 10594                              <1> 
 10595                              <1> ;--------------------------------------------------------------------
 10596                              <1> ; .StoreCHSparametersAndAddressingMode
 10597                              <1> ;	Parameters:
 10598                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10599                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10600                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10601                              <1> ;	Returns:
 10602                              <1> ;		Nothing
 10603                              <1> ;	Corrupts registers:
 10604                              <1> ;		AX, BX, CX, DX
 10605                              <1> ;--------------------------------------------------------------------
 10606                              <1> .StoreCHSparametersAndAddressingMode:
 10607                              <1> 	; Check if CHS defined in ROMVARS
 10608 0000058B E88300              <1> 	call	GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS
 10609 0000058E F6C120              <1> 	test	cl, FLG_DRVPARAMS_USERCHS
 10610 00000591 7405                <1> 	jz		SHORT .AutodetectPCHSvalues
 10611                              <1> 
 10612                              <1> 	; Translate P-CHS to L-CHS
 10613 00000593 E8A201              <1> 	call	AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX
 10614 00000596 EB03                <1> 	jmp		SHORT .StoreLCHStoDPT
 10615                              <1> .AutodetectPCHSvalues:
 10616 00000598 E89A01              <1> 	call	AtaGeometry_GetLCHStoAXBLBHfromAtaInfoInESSIandTranslateModeInDX
 10617                              <1> 
 10618                              <1> .StoreLCHStoDPT:
 10619                              <1> 	eSHL_IM	dl, TRANSLATEMODE_FIELD_POSITION
 10620                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10621                              <2> %ifdef USE_386
 10622                              <2>  %if %2 = 1
 10623                              <2>  add %1, %1
 10624                              <2>  %else
 10625                              <2>  eSHIFT_IM %1, %2, shl
 10626                              <2>  %endif
 10627                              <2> %else
 10628                              <2>  eSHIFT_IM %1, %2, shl
 10629                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10630                              <3> %ifndef USE_186
 10631                              <3>  %ifidni %1, cl
 10632                              <3>  times %2 %3 %1, 1
 10633                              <3>  %elifidni %1, ch
 10634                              <3>  times %2 %3 %1, 1
 10635                              <3>  %elifidni %1, cx
 10636                              <3>  times %2 %3 %1, 1
 10637                              <3>  %else
 10638                              <3>  %if %2 > 3
 10639                              <3>  push cx
 10640                              <3>  mov cl, %2
 10641                              <3>  %3 %1, cl
 10642                              <3>  pop cx
 10643                              <3>  %else
 10644 0000059B D0E2<rept>          <3>  times %2 %3 %1, 1
 10645                              <3>  %endif
 10646                              <3>  %endif
 10647                              <3> 
 10648                              <3> %else
 10649                              <3>  %3 %1, %2
 10650                              <3> %endif
 10651                              <3> %endif
 10652                              <2> %endif
 10653                              <2> %endif
 10654 0000059F 08D1                <1> 	or		cl, dl
 10655 000005A1 080D                <1> 	or		[di+DPT.bFlagsLow], cl		; Shift count and addressing mode
 10656 000005A3 894506              <1> 	mov		[di+DPT.wLchsCylinders], ax
 10657 000005A6 895D08              <1> 	mov		[di+DPT.wLchsHeadsAndSectors], bx
 10658                              <1> 
 10659                              <1> 	; Store P-CHS to DPT
 10660 000005A9 E8B401              <1> 	call	AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI
 10661 000005AC 885D0A              <1> 	mov		[di+DPT.bPchsHeads], bl
 10662                              <1> %ifdef MODULE_EBIOS
 10663 000005AF 89450C              <1> 	mov		[di+DPT.wPchsCylinders], ax
 10664 000005B2 887D0B              <1> 	mov		[di+DPT.bPchsSectorsPerTrack], bh
 10665                              <1> 	; Fall to .StoreNumberOfLbaSectors
 10666                              <1> 
 10667                              <1> ;--------------------------------------------------------------------
 10668                              <1> ; .StoreNumberOfLbaSectors
 10669                              <1> ;	Parameters:
 10670                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10671                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10672                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10673                              <1> ;	Returns:
 10674                              <1> ;		Nothing
 10675                              <1> ;	Corrupts registers:
 10676                              <1> ;		AX, BX, CX, DX
 10677                              <1> ;--------------------------------------------------------------------
 10678                              <1> 	; Check if LBA supported
 10679 000005B5 26F6446302          <1> 	test	BYTE [es:si+ATA1.wCaps+1], A1_wCaps_LBA>>8
 10680 000005BA 7426                <1> 	jz		SHORT .NoLbaSupportedSoNoEBIOS
 10681                              <1> 
 10682                              <1> 	; Store LBA 28/48 total sector count
 10683 000005BC E84F01              <1> 	call	AtaGeometry_GetLbaSectorCountToBXDXAXfromAtaInfoInESSI
 10684 000005BF E86A00              <1> 	call	StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX
 10685                              <1> 
 10686                              <1> 	; Load user defined LBA
 10687 000005C2 E84C00              <1> 	call	GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS
 10688 000005C5 F6C140              <1> 	test	cl, FLG_DRVPARAMS_USERLBA
 10689 000005C8 7418                <1> 	jz		SHORT .KeepTotalSectorsFromAtaID
 10690                              <1> 
 10691                              <1> 	; Compare user defined and ATA-ID sector count and select smaller
 10692 000005CA 89DA                <1> 	mov		dx, bx
 10693 000005CC 31DB                <1> 	xor		bx, bx		; User defined LBA now in BX:DX:AX
 10694 000005CE 3B5D12              <1> 	cmp		bx, [di+DPT.twLbaSectors+4]
 10695 000005D1 720C                <1> 	jb		SHORT .StoreUserDefinedSectorCountToDPT
 10696 000005D3 3B5510              <1> 	cmp		dx, [di+DPT.twLbaSectors+2]
 10697 000005D6 7207                <1> 	jb		SHORT .StoreUserDefinedSectorCountToDPT
 10698 000005D8 7708                <1> 	ja		SHORT .KeepTotalSectorsFromAtaID
 10699 000005DA 3B450E              <1> 	cmp		ax, [di+DPT.twLbaSectors]
 10700 000005DD 7303                <1> 	jae		SHORT .KeepTotalSectorsFromAtaID
 10701                              <1> .StoreUserDefinedSectorCountToDPT:
 10702                              <1> 	; CL bit FLGL_DPT_LBA48 is clear at this point
 10703 000005DF E84A00              <1> 	call	StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX
 10704                              <1> 
 10705                              <1> .KeepTotalSectorsFromAtaID:
 10706                              <1> .NoLbaSupportedSoNoEBIOS:
 10707                              <1> %endif ; MODULE_EBIOS
 10708                              <1> 	; Fall to .StoreBlockMode
 10709                              <1> 
 10710                              <1> ;--------------------------------------------------------------------
 10711                              <1> ; .StoreBlockMode
 10712                              <1> ;	Parameters:
 10713                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10714                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10715                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10716                              <1> ;	Returns:
 10717                              <1> ;		Nothing
 10718                              <1> ;	Corrupts registers:
 10719                              <1> ;		Nothing
 10720                              <1> ;--------------------------------------------------------------------
 10721                              <1> .StoreBlockMode:
 10722 000005E2 26807C5E01          <1> 	cmp		BYTE [es:si+ATA1.bBlckSize], 1	; Max block size in sectors
 10723 000005E7 7604                <1> 	jbe		SHORT .BlockModeTransfersNotSupported
 10724 000005E9 804D0102            <1> 	or		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_BLOCK_MODE_SUPPORTED
 10725                              <1> .BlockModeTransfersNotSupported:
 10726                              <1> 	; Fall to .StoreDeviceSpecificParameters
 10727                              <1> 
 10728                              <1> ;--------------------------------------------------------------------
 10729                              <1> ; .StoreDeviceSpecificParameters
 10730                              <1> ;	Parameters:
 10731                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10732                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 10733                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10734                              <1> ;	Returns:
 10735                              <1> ;		Nothing
 10736                              <1> ;	Corrupts registers:
 10737                              <1> ;		AX, BX, CX, DX
 10738                              <1> ;--------------------------------------------------------------------
 10739                              <1> .StoreDeviceSpecificParameters:
 10740 000005ED E86F06              <1> 	call	Device_FinalizeDPT
 10741                              <1> 
 10742                              <1> ;----------------------------------------------------------------------
 10743                              <1> ; Update drive counts (hard and floppy)
 10744                              <1> ;----------------------------------------------------------------------
 10745                              <1> 
 10746                              <1> %ifdef MODULE_SERIAL_FLOPPY
 10747                              <1> ;
 10748                              <1> ; These two instructions serve two purposes:
 10749                              <1> ; 1. If the drive is a floppy drive (CF set), then we effectively increment the counter.
 10750                              <1> ; 2. If this is a hard disk, and there have been any floppy drives previously added, then the hard disk is
 10751                              <1> ;    effectively discarded.  This is more of a safety check then code that should ever normally be hit (see below).
 10752                              <1> ;    Since the floppy DPT's come after the hard disk DPT's, without expensive (code size) code to relocate a DPT,
 10753                              <1> ;    this was necessary.  Now, this situation shouldn't happen in normal operation, for a couple of reasons:
 10754                              <1> ; 		A. xtidecfg always puts configured serial ports at the end of the IDEVARS list
 10755                              <1> ;       B. the auto serial code is always executed last
 10756                              <1> ;       C. the serial server always returns floppy drives last
 10757                              <1> ;
 10758 000005F0 80160A0000          <1> 	adc		byte [RAMVARS.xlateVars+XLATEVARS.bFlopCreateCnt], 0
 10759 000005F5 7504                <1> 	jnz		.AllDone
 10760                              <1> %else
 10761                              <1> ;
 10762                              <1> ; Even without floppy support enabled, we shouldn't try to mount a floppy image as a hard disk, which
 10763                              <1> ; could lead to unpredictable results since no MBR will be present, etc.  The server doesn't know that
 10764                              <1> ; floppies are supported, so it is important to still fail here if a floppy is seen during the drive scan.
 10765                              <1> ;
 10766                              <1> 	jc		.AllDone
 10767                              <1> %endif
 10768                              <1> 
 10769 000005F7 FE060900            <1> 	inc		BYTE [RAMVARS.bDrvCnt]		; Increment drive count to RAMVARS
 10770                              <1> 
 10771                              <1> .AllDone:
 10772 000005FB F8                  <1> 	clc
 10773 000005FC C3                  <1> 	ret
 10774                              <1> 
 10775                              <1> 
 10776                              <1> ;--------------------------------------------------------------------
 10777                              <1> ; CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI
 10778                              <1> ;	Parameters:
 10779                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 10780                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 10781                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 10782                              <1> ;	Returns:
 10783                              <1> ;		Nothing
 10784                              <1> ;	Corrupts registers:
 10785                              <1> ;		AX
 10786                              <1> ;--------------------------------------------------------------------
 10787                              <1> CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI:
 10788 000005FD 896D02              <1> 	mov		[di+DPT.bIdevarsOffset], bp		; IDEVARS must start in first 256 bytes of ROM
 10789                              <1> 
 10790                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 10791 00000600 E80303              <1> 	call	DetectDrives_DoesIdevarsInCSBPbelongToXTCF
 10792 00000603 7504                <1> 	jne		SHORT .DeviceUsesPortSpecifiedInIDEVARS
 10793 00000605 895504              <1> 	mov		[di+DPT.wBasePort], dx
 10794 00000608 C3                  <1> 	ret
 10795                              <1> .DeviceUsesPortSpecifiedInIDEVARS:
 10796                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 10797                              <1> 
 10798 00000609 2E8B4600            <1> 	mov		ax, [cs:bp+IDEVARS.wBasePort]
 10799 0000060D 894504              <1> 	mov		[di+DPT.wBasePort], ax
 10800 00000610 C3                  <1> 	ret
 10801                              <1> 
 10802                              <1> 
 10803                              <1> ;--------------------------------------------------------------------
 10804                              <1> ; GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS
 10805                              <1> ;	Parameters:
 10806                              <1> ;		DS:DI:		Ptr to Disk Parameter Table
 10807                              <1> ;	Returns:
 10808                              <1> ;		AX:			User defined P-CHS Cylinders or LBA low word
 10809                              <1> ;		BX:			User defined P-CHS Heads and Sectors or LBA high word
 10810                              <1> ;		DX:			Translate mode or TRANSLATEMODE_AUTO
 10811                              <1> ;		CX:			FLG_DRVPARAMS_USERCHS if user defined CHS in BX:AX
 10812                              <1> ;					FLG_DRVPARAMS_USERLBA if user defined LBA in BX:AX
 10813                              <1> ;					Zero if user has not defined capacity
 10814                              <1> ;	Corrupts registers:
 10815                              <1> ;		Nothing
 10816                              <1> ;--------------------------------------------------------------------
 10817                              <1> GetUserDefinedCapacityToBXAXandFlagsToCXandModeToDXfromROMVARS:
 10818 00000611 E8E500              <1> 	call	AccessDPT_GetPointerToDRVPARAMStoCSBX
 10819                              <1> 
 10820                              <1> 	; Get settings
 10821 00000614 2E8B0F              <1> 	mov		cx, [cs:bx+DRVPARAMS.wFlags]
 10822 00000617 89CA                <1> 	mov		dx, cx
 10823 00000619 83E160              <1> 	and		cx, BYTE FLG_DRVPARAMS_USERCHS | FLG_DRVPARAMS_USERLBA
 10824 0000061C 83E20C              <1> 	and		dx, BYTE MASK_DRVPARAMS_TRANSLATEMODE
 10825                              <1> 	eSHR_IM	dx, TRANSLATEMODE_FIELD_POSITION
 10826                              <2>  eSHIFT_IM %1, %2, shr
 10827                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 10828                              <3> %ifndef USE_186
 10829                              <3>  %ifidni %1, cl
 10830                              <3>  times %2 %3 %1, 1
 10831                              <3>  %elifidni %1, ch
 10832                              <3>  times %2 %3 %1, 1
 10833                              <3>  %elifidni %1, cx
 10834                              <3>  times %2 %3 %1, 1
 10835                              <3>  %else
 10836                              <3>  %if %2 > 3
 10837                              <3>  push cx
 10838                              <3>  mov cl, %2
 10839                              <3>  %3 %1, cl
 10840                              <3>  pop cx
 10841                              <3>  %else
 10842 0000061F D1EA<rept>          <3>  times %2 %3 %1, 1
 10843                              <3>  %endif
 10844                              <3>  %endif
 10845                              <3> 
 10846                              <3> %else
 10847                              <3>  %3 %1, %2
 10848                              <3> %endif
 10849                              <3> %endif
 10850                              <1> 
 10851                              <1> 	; Get capacity
 10852 00000623 2E8B4702            <1> 	mov		ax, [cs:bx+DRVPARAMS.wCylinders]		; Or .dwMaximumLBA
 10853 00000627 2E8B5F04            <1> 	mov		bx, [cs:bx+DRVPARAMS.wHeadsAndSectors]	; Or .dwMaximumLBA+2
 10854 0000062B C3                  <1> 	ret
 10855                              <1> 
 10856                              <1> 
 10857                              <1> %ifdef MODULE_EBIOS
 10858                              <1> ;--------------------------------------------------------------------
 10859                              <1> ; StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX
 10860                              <1> ;	Parameters:
 10861                              <1> ;		BX:DX:AX:	Total Sector Count
 10862                              <1> ;		CL:			FLGL_DPT_LBA48 if LBA48 supported
 10863                              <1> ;		DS:DI:		Ptr to Disk Parameter Table
 10864                              <1> ;	Returns:
 10865                              <1> ;		Nothing
 10866                              <1> ;	Corrupts registers:
 10867                              <1> ;		CL
 10868                              <1> ;--------------------------------------------------------------------
 10869                              <1> StoreLba48AddressingFromCLandTotalSectorCountFromBXDXAX:
 10870 0000062C 80C940              <1> 	or		cl, FLGL_DPT_LBA_AND_EBIOS_SUPPORTED
 10871 0000062F 80257F              <1> 	and		BYTE [di+DPT.bFlagsLow], ~FLGL_DPT_LBA48
 10872 00000632 080D                <1> 	or		[di+DPT.bFlagsLow], cl
 10873 00000634 89450E              <1> 	mov		[di+DPT.twLbaSectors], ax
 10874 00000637 895510              <1> 	mov		[di+DPT.twLbaSectors+2], dx
 10875 0000063A 895D12              <1> 	mov		[di+DPT.twLbaSectors+4], bx
 10876 0000063D C3                  <1> 	ret
 10877                              <1> %endif ; MODULE_EBIOS
 10878                                  	%include "FindDPT.asm"			; For finding DPTs
 10879                              <1> ; Project name	:	XTIDE Universal BIOS
 10880                              <1> ; Description	:	Functions for finding Disk Parameter Table.
 10881                              <1> 
 10882                              <1> ;
 10883                              <1> ; XTIDE Universal BIOS and Associated Tools
 10884                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 10885                              <1> ;
 10886                              <1> ; This program is free software; you can redistribute it and/or modify
 10887                              <1> ; it under the terms of the GNU General Public License as published by
 10888                              <1> ; the Free Software Foundation; either version 2 of the License, or
 10889                              <1> ; (at your option) any later version.
 10890                              <1> ;
 10891                              <1> ; This program is distributed in the hope that it will be useful,
 10892                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 10893                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 10894                              <1> ; GNU General Public License for more details.
 10895                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 10896                              <1> ;
 10897                              <1> 
 10898                              <1> ; Section containing code
 10899                              <1> SECTION .text
 10900                              <1> 
 10901                              <1> ;--------------------------------------------------------------------
 10902                              <1> ; Checks if drive is handled by this BIOS, and return DPT pointer.
 10903                              <1> ;
 10904                              <1> ; FindDPT_ForDriveNumberInDL
 10905                              <1> ;	Parameters:
 10906                              <1> ;		DL:		Drive number
 10907                              <1> ;		DS:		RAMVARS segment
 10908                              <1> ;	Returns:
 10909                              <1> ;		CF:		Cleared if drive is handled by this BIOS
 10910                              <1> ;				Set if drive belongs to some other BIOS
 10911                              <1> ;		DI:		DPT Pointer if drive is handled by this BIOS
 10912                              <1> ;				Zero if drive belongs to some other BIOS
 10913                              <1> ;	Corrupts registers:
 10914                              <1> ;		Nothing
 10915                              <1> ;--------------------------------------------------------------------
 10916                              <1> ALIGN JUMP_ALIGN
 10917                              <1> FindDPT_ForDriveNumberInDL:
 10918 0000063E 97                  <1> 	xchg	di, ax								; Save the contents of AX in DI
 10919                              <1> 
 10920                              <1> ;
 10921                              <1> ; Check Our Hard Disks
 10922                              <1> ;
 10923 0000063F A10800              <1> 	mov		ax, [RAMVARS.wFirstDrvAndCount]		; Drive count to AH, First number to AL
 10924 00000642 00C4                <1> 	add		ah, al								; One past last drive to AH
 10925                              <1> 
 10926                              <1> %ifdef MODULE_SERIAL_FLOPPY
 10927 00000644 38E2                <1> 	cmp		dl, ah								; Above last supported?
 10928 00000646 7304                <1> 	jae		SHORT .HardDiskNotHandledByThisBIOS
 10929                              <1> 
 10930 00000648 38C2                <1> 	cmp		dl, al								; Below first supported?
 10931 0000064A 7310                <1> 	jae		SHORT .CalcDPTForDriveNumber
 10932                              <1> 
 10933                              <1> ALIGN JUMP_ALIGN
 10934                              <1> .HardDiskNotHandledByThisBIOS:
 10935                              <1> ;
 10936                              <1> ; Check Our Floppy Disks
 10937                              <1> ;
 10938 0000064C E8C9FE              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
 10939 0000064F 7824                <1> 	js		SHORT .DiskIsNotHandledByThisBIOS
 10940                              <1> 
 10941 00000651 98                  <1> 	cbw											; Always 0h (no floppy drive covered above)
 10942 00000652 10C4                <1> 	adc		ah, al								; Add in first drive number and number of drives
 10943                              <1> 
 10944 00000654 38D4                <1> 	cmp		ah, dl								; Check second drive if two, first drive if only one
 10945 00000656 7404                <1> 	jz		SHORT .CalcDPTForDriveNumber
 10946 00000658 38D0                <1> 	cmp		al, dl								; Check first drive in all cases, redundant but OK to repeat
 10947 0000065A 7519                <1> 	jnz		SHORT .DiskIsNotHandledByThisBIOS
 10948                              <1> %else
 10949                              <1> 	cmp		dl, ah								; Above last supported?
 10950                              <1> 	jae		SHORT .DiskIsNotHandledByThisBIOS
 10951                              <1> 
 10952                              <1> 	cmp		dl, al								; Below first supported?
 10953                              <1> 	jb		SHORT .DiskIsNotHandledByThisBIOS
 10954                              <1> %endif
 10955                              <1> 	; fall-through to CalcDPTForDriveNumber
 10956                              <1> 
 10957                              <1> ;--------------------------------------------------------------------
 10958                              <1> ; Finds Disk Parameter Table for drive number.
 10959                              <1> ; Not intended to be called except by FindDPT_ForDriveNumberInDL
 10960                              <1> ;
 10961                              <1> ; CalcDPTForDriveNumber
 10962                              <1> ;	Parameters:
 10963                              <1> ;		DL:		Drive number
 10964                              <1> ;		DS:		RAMVARS segment
 10965                              <1> ;       DI:     Saved copy of AX from entry at FindDPT_ForDriveNumberInDL
 10966                              <1> ;	Returns:
 10967                              <1> ;		DS:DI:	Ptr to DPT
 10968                              <1> ;       CF:     Clear
 10969                              <1> ;	Corrupts registers:
 10970                              <1> ;		Nothing
 10971                              <1> ;--------------------------------------------------------------------
 10972                              <1> ALIGN JUMP_ALIGN
 10973                              <1> .CalcDPTForDriveNumber:
 10974 0000065C 52                  <1> 	push	dx
 10975                              <1> 
 10976                              <1> %ifdef MODULE_SERIAL_FLOPPY
 10977 0000065D A10800              <1> 	mov		ax, [RAMVARS.wFirstDrvAndCount]
 10978                              <1> 
 10979 00000660 84D2                <1> 	test	dl, dl
 10980 00000662 7805                <1> 	js		.harddisk
 10981                              <1> 
 10982 00000664 E8B1FE              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
 10983 00000667 00E2                <1> 	add		dl, ah						; add in end of hard disk DPT list, floppies start immediately after
 10984                              <1> 
 10985                              <1> ALIGN JUMP_ALIGN
 10986                              <1> .harddisk:
 10987 00000669 28C2                <1> 	sub		dl, al						; subtract off beginning of either hard disk or floppy list (as appropriate)
 10988                              <1> %else
 10989                              <1> 	sub		dl, [RAMVARS.bFirstDrv]		; subtract off beginning of hard disk list
 10990                              <1> %endif
 10991                              <1> 
 10992                              <1> .CalcDPTForNewDrive:
 10993 0000066B B016                <1> 	mov		al, LARGEST_DPT_SIZE
 10994                              <1> 
 10995 0000066D F6E2                <1> 	mul		dl
 10996 0000066F 83C00E              <1> 	add		ax, RAMVARS_size			; Clears CF (will not overflow)
 10997                              <1> 
 10998 00000672 5A                  <1> 	pop		dx
 10999                              <1> 
 11000 00000673 97                  <1> 	xchg	di, ax						; Restore AX from entry at FindDPT_ForDriveNumber, put DPT pointer in DI
 11001 00000674 C3                  <1> 	ret
 11002                              <1> 
 11003                              <1> ALIGN JUMP_ALIGN
 11004                              <1> .DiskIsNotHandledByThisBIOS:
 11005                              <1> ;
 11006                              <1> ; Drive not found...
 11007                              <1> ;
 11008 00000675 31C0                <1> 	xor		ax, ax								; Clear DPT pointer
 11009 00000677 F9                  <1> 	stc											; Is not supported by our BIOS
 11010                              <1> 
 11011 00000678 97                  <1> 	xchg	di, ax								; Restore AX from save at top
 11012 00000679 C3                  <1> 	ret
 11013                              <1> 
 11014                              <1> 
 11015                              <1> ;--------------------------------------------------------------------
 11016                              <1> ; FindDPT_MasterOrSingleForIdevarsOffsetInDL
 11017                              <1> ;	Parameters:
 11018                              <1> ;		DL:		Offset to IDEVARS to search for
 11019                              <1> ;		DS:		RAMVARS segment
 11020                              <1> ;	Returns:
 11021                              <1> ;		DS:DI:		Ptr to first DPT with same IDEVARS as in DL
 11022                              <1> ;		CF:			Clear if wanted DPT found
 11023                              <1> ;					Set if DPT not found, or no DPTs present
 11024                              <1> ;	Corrupts registers:
 11025                              <1> ;		SI
 11026                              <1> ;--------------------------------------------------------------------
 11027                              <1> FindDPT_MasterOrSingleForIdevarsOffsetInDL:
 11028 0000067A BE[8E06]            <1> 	mov		si, IterateFindFirstDPTforIdevars			; iteration routine (see below)
 11029 0000067D EB2B                <1> 	jmp		SHORT FindDPT_IterateAllDPTs				; look for the first drive on this controller, if any
 11030                              <1> 
 11031                              <1> ;--------------------------------------------------------------------
 11032                              <1> ; FindDPT_SlaveForIdevarsOffsetInDL
 11033                              <1> ;	Parameters:
 11034                              <1> ;		DL:		Offset to IDEVARS to search for
 11035                              <1> ;		DS:		RAMVARS segment
 11036                              <1> ;	Returns:
 11037                              <1> ;		DS:DI:		Ptr to second DPT with same IDEVARS as in DL
 11038                              <1> ;		CF:			Clear if wanted DPT found
 11039                              <1> ;					Set if DPT not found, or no DPTs present
 11040                              <1> ;	Corrupts registers:
 11041                              <1> ;		SI
 11042                              <1> ;--------------------------------------------------------------------
 11043                              <1> FindDPT_SlaveForIdevarsOffsetInDL:
 11044 0000067F BE[8406]            <1> 	mov		si, IterateFindSecondDPTforIdevars			; iteration routine (see below)
 11045 00000682 EB26                <1> 	jmp		SHORT FindDPT_IterateAllDPTs				; look for the second drive on this controller, if any
 11046                              <1> 
 11047                              <1> ;--------------------------------------------------------------------
 11048                              <1> ; Iteration routines for FindDPT_MasterOrSingleForIdevarsOffsetInDL and
 11049                              <1> ; FindDPT_SlaveForIdevarsOffsetInDL, for use with IterateAllDPTs
 11050                              <1> ;
 11051                              <1> ; Returns when DPT is found on the controller with Idevars offset in DL
 11052                              <1> ;
 11053                              <1> ; IterateFindSecondDPTforIdevars
 11054                              <1> ; IterateFindFirstDPTforIdevars
 11055                              <1> ;       DL:		Offset to IDEVARS to search from DPTs
 11056                              <1> ;		SI:		Offset to this callback function
 11057                              <1> ;		DS:DI:	Ptr to DPT to examine
 11058                              <1> ;	Returns:
 11059                              <1> ;		CF:		Clear if wanted DPT found
 11060                              <1> ;				Set if wrong DPT
 11061                              <1> ;--------------------------------------------------------------------
 11062                              <1> IterateFindSecondDPTforIdevars:
 11063 00000684 E80700              <1> 	call	IterateFindFirstDPTforIdevars
 11064 00000687 7203                <1> 	jc		SHORT .WrongController
 11065 00000689 BE[8E06]            <1> 	mov		si, IterateFindFirstDPTforIdevars
 11066                              <1> .WrongController:
 11067 0000068C F9                  <1> 	stc
 11068 0000068D C3                  <1> 	ret
 11069                              <1> 
 11070                              <1> IterateFindFirstDPTforIdevars:
 11071 0000068E 3A5502              <1> 	cmp		dl, [di+DPT.bIdevarsOffset]			; Clears CF if matched
 11072 00000691 7401                <1> 	je		.done
 11073 00000693 F9                  <1> 	stc											; Set CF for not found
 11074                              <1> .done:
 11075 00000694 C3                  <1> 	ret
 11076                              <1> 
 11077                              <1> 
 11078                              <1> ;--------------------------------------------------------------------
 11079                              <1> ; Finds pointer to first unused Disk Parameter Table.
 11080                              <1> ; Should only be used before DetectDrives is complete (not valid after this time).
 11081                              <1> ;
 11082                              <1> ; FindDPT_ForNewDriveToDSDI
 11083                              <1> ;	Parameters:
 11084                              <1> ;		DS:		RAMVARS segment
 11085                              <1> ;	Returns:
 11086                              <1> ;		DS:DI:	Ptr to first unused DPT
 11087                              <1> ;	Corrupts registers:
 11088                              <1> ;		AX
 11089                              <1> ;--------------------------------------------------------------------
 11090                              <1> ALIGN JUMP_ALIGN
 11091                              <1> FindDPT_ForNewDriveToDSDI:
 11092 00000695 52                  <1> 	push	dx
 11093                              <1> 
 11094                              <1> %ifdef MODULE_SERIAL_FLOPPY
 11095 00000696 8B160900            <1> 	mov		dx, [RAMVARS.wDrvCntAndFlopCnt]
 11096 0000069A 00F2                <1> 	add		dl, dh
 11097                              <1> %else
 11098                              <1> 	mov		dl, [RAMVARS.bDrvCnt]
 11099                              <1> %endif
 11100                              <1> 
 11101 0000069C EBCD                <1> 	jmp		short FindDPT_ForDriveNumberInDL.CalcDPTForNewDrive
 11102                              <1> 
 11103                              <1> ;--------------------------------------------------------------------
 11104                              <1> ; IterateToDptWithFlagsHighInBL
 11105                              <1> ;	Parameters:
 11106                              <1> ;		DS:DI:	Ptr to DPT to examine
 11107                              <1> ;       BL:		Bit(s) to test in DPT.bFlagsHigh
 11108                              <1> ;	Returns:
 11109                              <1> ;		CF:		Clear if wanted DPT found
 11110                              <1> ;				Set if wrong DPT
 11111                              <1> ;	Corrupts registers:
 11112                              <1> ;		Nothing
 11113                              <1> ;--------------------------------------------------------------------
 11114                              <1> ALIGN JUMP_ALIGN
 11115                              <1> IterateToDptWithFlagsHighInBL:
 11116 0000069E 845D01              <1> 	test	[di+DPT.bFlagsHigh], bl				; Clears CF
 11117 000006A1 7501                <1> 	jnz		SHORT .ReturnRightDPT
 11118 000006A3 F9                  <1> 	stc
 11119                              <1> .ReturnRightDPT:
 11120 000006A4 C3                  <1> 	ret
 11121                              <1> 
 11122                              <1> ;--------------------------------------------------------------------
 11123                              <1> ; FindDPT_ToDSDIforSerialDevice
 11124                              <1> ;	Parameters:
 11125                              <1> ;		DS:		RAMVARS segment
 11126                              <1> ;	Returns:
 11127                              <1> ;		DS:DI:	Ptr to DPT
 11128                              <1> ;		CF:		Set if wanted DPT found
 11129                              <1> ;				Cleared if DPT not found
 11130                              <1> ;	Corrupts registers:
 11131                              <1> ;		SI
 11132                              <1> ;--------------------------------------------------------------------
 11133                              <1> %ifdef MODULE_SERIAL
 11134                              <1> ALIGN JUMP_ALIGN
 11135                              <1> FindDPT_ToDSDIforSerialDevice:
 11136 000006A5 B304                <1> 	mov		bl, FLGH_DPT_SERIAL_DEVICE
 11137                              <1> ; fall-through
 11138                              <1> %endif
 11139                              <1> 
 11140                              <1> ;--------------------------------------------------------------------
 11141                              <1> ; FindDPT_ToDSDIforFlagsHigh
 11142                              <1> ;	Parameters:
 11143                              <1> ;		DS:		RAMVARS segment
 11144                              <1> ;       BL:		Bit(s) to test in DPT.bFlagsHigh
 11145                              <1> ;	Returns:
 11146                              <1> ;		DS:DI:	Ptr to DPT
 11147                              <1> ;		CF:		Set if wanted DPT found
 11148                              <1> ;				Cleared if DPT not found
 11149                              <1> ;	Corrupts registers:
 11150                              <1> ;		SI
 11151                              <1> ;--------------------------------------------------------------------
 11152                              <1> %ifdef MODULE_IRQ
 11153                              <1> ALIGN JUMP_ALIGN
 11154                              <1> FindDPT_ToDSDIforFlagsHighInBL:
 11155                              <1> %endif
 11156 000006A7 BE[9E06]            <1> 	mov		si, IterateToDptWithFlagsHighInBL
 11157                              <1> 	; Fall to IterateAllDPTs
 11158                              <1> 
 11159                              <1> ;--------------------------------------------------------------------
 11160                              <1> ; Iterates all Disk Parameter Tables.
 11161                              <1> ;
 11162                              <1> ; FindDPT_IterateAllDPTs
 11163                              <1> ;	Parameters:
 11164                              <1> ;		AX,BX,DX:	Parameters to callback function
 11165                              <1> ;		CS:SI:		Ptr to callback function
 11166                              <1> ;                   Callback routine should return CF=clear if found
 11167                              <1> ;		DS:			RAMVARS segment
 11168                              <1> ;	Returns:
 11169                              <1> ;		DS:DI:		Ptr to wanted DPT (if found)
 11170                              <1> ;					If not found, points to first empty DPT
 11171                              <1> ;		CF:			Clear if wanted DPT found
 11172                              <1> ;					Set if DPT not found, or no DPTs present
 11173                              <1> ;	Corrupts registers:
 11174                              <1> ;		Nothing unless corrupted by callback function
 11175                              <1> ;--------------------------------------------------------------------
 11176                              <1> ALIGN JUMP_ALIGN
 11177                              <1> FindDPT_IterateAllDPTs:
 11178 000006AA 51                  <1> 	push	cx
 11179                              <1> 
 11180 000006AB BF0E00              <1> 	mov		di, RAMVARS_size			; Point DS:DI to first DPT
 11181                              <1> 	eMOVZX	cx, [RAMVARS.bDrvCnt]
 11182                              <2> %ifndef USE_386
 11183                              <2>  %ifidni %1, ax
 11184                              <2>  mov al, %2
 11185                              <2>  xor ah, ah
 11186                              <2>  %elifidni %1, bx
 11187                              <2>  mov bl, %2
 11188                              <2>  xor bh, bh
 11189                              <2>  %elifidni %1, cx
 11190 000006AE 8A0E0900            <2>  mov cl, %2
 11191 000006B2 30ED                <2>  xor ch, ch
 11192                              <2>  %elifidni %1, dx
 11193                              <2>  mov dl, %2
 11194                              <2>  xor dh, dh
 11195                              <2>  %else
 11196                              <2>  push ax
 11197                              <2>  mov al, %2
 11198                              <2>  xor ah, ah
 11199                              <2>  xchg ax, %1
 11200                              <2>  pop ax
 11201                              <2>  %endif
 11202                              <2> 
 11203                              <2> %else
 11204                              <2>  movzx %1, %2
 11205                              <2> %endif
 11206 000006B4 E309                <1> 	jcxz	.NotFound					; Return if no drives
 11207                              <1> 
 11208                              <1> ALIGN JUMP_ALIGN
 11209                              <1> .LoopWhileDPTsLeft:
 11210 000006B6 FFD6                <1> 	call	si							; Is wanted DPT?
 11211 000006B8 7306                <1> 	jnc		SHORT .Found				;  If so, return
 11212 000006BA 83C716              <1> 	add		di, BYTE LARGEST_DPT_SIZE	; Point to next DPT
 11213 000006BD E2F7                <1> 	loop	.LoopWhileDPTsLeft
 11214                              <1> 
 11215                              <1> ALIGN JUMP_ALIGN
 11216                              <1> .NotFound:
 11217 000006BF F9                  <1> 	stc
 11218                              <1> 
 11219                              <1> ALIGN JUMP_ALIGN
 11220                              <1> .Found:
 11221 000006C0 59                  <1> 	pop		cx
 11222 000006C1 C3                  <1> 	ret
 11223                                  	%include "AccessDPT.asm"		; For accessing DPTs
 11224                              <1> ; Project name	:	XTIDE Universal BIOS
 11225                              <1> ; Description	:	Functions for accessing DPT data.
 11226                              <1> 
 11227                              <1> ;
 11228                              <1> ; XTIDE Universal BIOS and Associated Tools
 11229                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 11230                              <1> ;
 11231                              <1> ; This program is free software; you can redistribute it and/or modify
 11232                              <1> ; it under the terms of the GNU General Public License as published by
 11233                              <1> ; the Free Software Foundation; either version 2 of the License, or
 11234                              <1> ; (at your option) any later version.
 11235                              <1> ;
 11236                              <1> ; This program is distributed in the hope that it will be useful,
 11237                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 11238                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 11239                              <1> ; GNU General Public License for more details.
 11240                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 11241                              <1> ;
 11242                              <1> 
 11243                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 11244                              <1> 
 11245                              <1> ; Section containing code
 11246                              <1> SECTION .text
 11247                              <1> 
 11248                              <1> ;--------------------------------------------------------------------
 11249                              <1> ; AccessDPT_GetDriveSelectByteForOldInt13hToAL
 11250                              <1> ; AccessDPT_GetDriveSelectByteForEbiosToAL
 11251                              <1> ;	Parameters:
 11252                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11253                              <1> ;	Returns:
 11254                              <1> ;		AL:		Drive Select Byte
 11255                              <1> ;	Corrupts registers:
 11256                              <1> ;		Nothing
 11257                              <1> ;--------------------------------------------------------------------
 11258                              <1> ALIGN JUMP_ALIGN
 11259                              <1> AccessDPT_GetDriveSelectByteForOldInt13hToAL:
 11260 000006C2 8A05                <1> 	mov		al, [di+DPT.bFlagsLow]
 11261 000006C4 A808                <1> 	test	al, FLGL_DPT_ASSISTED_LBA
 11262 000006C6 7507                <1> 	jnz		SHORT GetDriveSelectByteForAssistedLBAtoAL
 11263                              <1> 
 11264 000006C8 2410                <1> 	and		al, FLG_DRVNHEAD_DRV	; Clear all but drive select bit
 11265 000006CA 0CA0                <1> 	or		al, MASK_DRVNHEAD_SET	; Bits set to 1 for old drives
 11266 000006CC C3                  <1> 	ret
 11267                              <1> 
 11268                              <1> %ifdef MODULE_EBIOS
 11269                              <1> ALIGN JUMP_ALIGN
 11270                              <1> AccessDPT_GetDriveSelectByteForEbiosToAL:
 11271 000006CD 8A05                <1> 	mov		al, [di+DPT.bFlagsLow]
 11272                              <1> 	; Fall to GetDriveSelectByteForAssistedLBAtoAL
 11273                              <1> %endif ; MODULE_EBIOS
 11274                              <1> 
 11275                              <1> ALIGN JUMP_ALIGN
 11276                              <1> GetDriveSelectByteForAssistedLBAtoAL:
 11277 000006CF 2410                <1> 	and		al, FLG_DRVNHEAD_DRV	; Master / Slave select
 11278 000006D1 0CE0                <1> 	or		al, FLG_DRVNHEAD_LBA | MASK_DRVNHEAD_SET
 11279 000006D3 C3                  <1> 	ret
 11280                              <1> 
 11281                              <1> 
 11282                              <1> ;--------------------------------------------------------------------
 11283                              <1> ; AccessDPT_GetDeviceControlByteToAL
 11284                              <1> ;	Parameters:
 11285                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11286                              <1> ;	Returns:
 11287                              <1> ;		AL:		Device Control Byte
 11288                              <1> ;	Corrupts registers:
 11289                              <1> ;		Nothing
 11290                              <1> ;--------------------------------------------------------------------
 11291                              <1> ALIGN JUMP_ALIGN
 11292                              <1> AccessDPT_GetDeviceControlByteToAL:
 11293                              <1> %ifdef MODULE_IRQ
 11294                              <1> 
 11295                              <1> %ifndef USE_UNDOC_INTEL
 11296                              <1> 	xor		al, al
 11297                              <1> %endif
 11298                              <1> 
 11299                              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_ENABLE_IRQ	; Clears CF
 11300                              <1> 
 11301                              <1> %ifdef USE_UNDOC_INTEL
 11302                              <1> 	eSALC	; Clears AL using CF while preserving flags
 11303                              <1> %endif
 11304                              <1> 
 11305                              <1> 	jnz		SHORT .EnableDeviceIrq
 11306                              <1> 	or		al, FLG_DEVCONTROL_nIEN	; Disable IRQ
 11307                              <1> .EnableDeviceIrq:
 11308                              <1> %else
 11309 000006D4 B002                <1> 	mov		al, FLG_DEVCONTROL_nIEN	; Disable IRQ
 11310                              <1> %endif ; MODULE_IRQ
 11311 000006D6 C3                  <1> 	ret
 11312                              <1> 
 11313                              <1> 
 11314                              <1> ;--------------------------------------------------------------------
 11315                              <1> ; AccessDPT_GetLCHStoAXBLBH
 11316                              <1> ;	Parameters:
 11317                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11318                              <1> ;	Returns:
 11319                              <1> ;		AX:		Number of L-CHS cylinders
 11320                              <1> ;		BL:		Number of L-CHS heads
 11321                              <1> ;		BH:		Number of L-CHS sectors per track
 11322                              <1> ;	Corrupts registers:
 11323                              <1> ;		Nothing
 11324                              <1> ;--------------------------------------------------------------------
 11325                              <1> AccessDPT_GetLCHStoAXBLBH:
 11326 000006D7 8B4506              <1> 	mov		ax, [di+DPT.wLchsCylinders]
 11327 000006DA 8B5D08              <1> 	mov		bx, [di+DPT.wLchsHeadsAndSectors]
 11328 000006DD C3                  <1> 	ret
 11329                              <1> 
 11330                              <1> 
 11331                              <1> %ifdef MODULE_8BIT_IDE
 11332                              <1> ;--------------------------------------------------------------------
 11333                              <1> ; AccessDPT_IsThisDeviceXTCF
 11334                              <1> ;	Parameters:
 11335                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11336                              <1> ;	Returns:
 11337                              <1> ;		AH:		Device Type
 11338                              <1> ;		ZF:		Set if XTCF
 11339                              <1> ;				Cleared if some other device
 11340                              <1> ;	Corrupts registers:
 11341                              <1> ;		Nothing
 11342                              <1> ;--------------------------------------------------------------------
 11343                              <1> AccessDPT_IsThisDeviceXTCF:
 11344 000006DE 8A6514              <1> 	mov		ah, [di+DPT_ATA.bDevice]
 11345 000006E1 80FC0A              <1> 	cmp		ah, DEVICE_8BIT_XTCF_PIO8
 11346 000006E4 7408                <1> 	je		SHORT .DeviceIsXTCF
 11347 000006E6 80FC0C              <1> 	cmp		ah, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
 11348 000006E9 7403                <1> 	je		SHORT .DeviceIsXTCF
 11349 000006EB 80FC0E              <1> 	cmp		ah, DEVICE_8BIT_XTCF_DMA
 11350                              <1> .DeviceIsXTCF:
 11351 000006EE C3                  <1> 	ret		; note also executed if device *not* XT-CF
 11352                              <1> %endif ; MODULE_8BIT_IDE
 11353                              <1> 
 11354                              <1> 
 11355                              <1> %ifdef MODULE_EBIOS
 11356                              <1> ;--------------------------------------------------------------------
 11357                              <1> ; AccessDPT_GetLbaSectorCountToBXDXAX
 11358                              <1> ;	Parameters:
 11359                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11360                              <1> ;	Returns:
 11361                              <1> ;		BX:DX:AX:	48-bit sector count
 11362                              <1> ;	Corrupts registers:
 11363                              <1> ;		Nothing
 11364                              <1> ;--------------------------------------------------------------------
 11365                              <1> AccessDPT_GetLbaSectorCountToBXDXAX:
 11366 000006EF 8B450E              <1> 	mov		ax, [di+DPT.twLbaSectors]
 11367 000006F2 8B5510              <1> 	mov		dx, [di+DPT.twLbaSectors+2]
 11368 000006F5 8B5D12              <1> 	mov		bx, [di+DPT.twLbaSectors+4]
 11369 000006F8 C3                  <1> 	ret
 11370                              <1> %endif ; MODULE_EBIOS
 11371                              <1> 
 11372                              <1> 
 11373                              <1> ;--------------------------------------------------------------------
 11374                              <1> ; Returns pointer to DRVPARAMS for master or slave drive.
 11375                              <1> ;
 11376                              <1> ; AccessDPT_GetPointerToDRVPARAMStoCSBX
 11377                              <1> ;	Parameters:
 11378                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11379                              <1> ;	Returns:
 11380                              <1> ;		CS:BX:	Ptr to DRVPARAMS
 11381                              <1> ;	Corrupts registers:
 11382                              <1> ;		Nothing
 11383                              <1> ;--------------------------------------------------------------------
 11384                              <1> AccessDPT_GetPointerToDRVPARAMStoCSBX:
 11385 000006F9 E80C00              <1> 	call	AccessDPT_GetIdevarsToCSBX
 11386 000006FC 83C306              <1> 	add		bx, BYTE IDEVARS.drvParamsMaster	; CS:BX points to Master Drive DRVPARAMS
 11387 000006FF F60510              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_SLAVE
 11388 00000702 7403                <1> 	jz		SHORT .ReturnPointerToDRVPARAMS
 11389 00000704 83C306              <1> 	add		bx, BYTE DRVPARAMS_size				; CS:BX points to Slave Drive DRVPARAMS
 11390                              <1> .ReturnPointerToDRVPARAMS:
 11391 00000707 C3                  <1> 	ret
 11392                              <1> 
 11393                              <1> 
 11394                              <1> ;--------------------------------------------------------------------
 11395                              <1> ; Needed many times during initialization so it is better to
 11396                              <1> ; make it as a function to save bytes.
 11397                              <1> ;
 11398                              <1> ; AccessDPT_GetIdevarsToCSBX
 11399                              <1> ;	Parameters:
 11400                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11401                              <1> ;	Returns:
 11402                              <1> ;		CS:BX:	Ptr to IDEVARS for the drive
 11403                              <1> ;	Corrupts registers:
 11404                              <1> ;		Nothing
 11405                              <1> ;--------------------------------------------------------------------
 11406                              <1> AccessDPT_GetIdevarsToCSBX:
 11407                              <1> 	eMOVZX	bx, BYTE [di+DPT.bIdevarsOffset]
 11408                              <2> %ifndef USE_386
 11409                              <2>  %ifidni %1, ax
 11410                              <2>  mov al, %2
 11411                              <2>  xor ah, ah
 11412                              <2>  %elifidni %1, bx
 11413 00000708 8A5D02              <2>  mov bl, %2
 11414 0000070B 30FF                <2>  xor bh, bh
 11415                              <2>  %elifidni %1, cx
 11416                              <2>  mov cl, %2
 11417                              <2>  xor ch, ch
 11418                              <2>  %elifidni %1, dx
 11419                              <2>  mov dl, %2
 11420                              <2>  xor dh, dh
 11421                              <2>  %else
 11422                              <2>  push ax
 11423                              <2>  mov al, %2
 11424                              <2>  xor ah, ah
 11425                              <2>  xchg ax, %1
 11426                              <2>  pop ax
 11427                              <2>  %endif
 11428                              <2> 
 11429                              <2> %else
 11430                              <2>  movzx %1, %2
 11431                              <2> %endif
 11432 0000070D C3                  <1> 	ret
 11433                              <1> 
 11434                              <1> 
 11435                              <1> ;--------------------------------------------------------------------
 11436                              <1> ; ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF
 11437                              <1> ;	Parameters:
 11438                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11439                              <1> ;	Returns:
 11440                              <1> ;		AX:		Translate Mode (TRANSLATEMODE_NORMAL, TRANSLATEMODE_LARGE or TRANSLATEMODE_ASSISTED_LBA)
 11441                              <1> ;               unshifted (still shifted where it is in bFlagsLow)
 11442                              <1> ;       ZF:     Set based on value in AL
 11443                              <1> ;	Corrupts registers:
 11444                              <1> ;		Nothing
 11445                              <1> ;--------------------------------------------------------------------
 11446                              <1> ;
 11447                              <1> ; Converted to a macro since only called in two places, and the call/ret overhead
 11448                              <1> ; is not worth it for these two instructions (4 bytes total)
 11449                              <1> ;
 11450                              <1> %macro ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF 0
 11451                              <1> 	mov		al, [di+DPT.bFlagsLow]
 11452                              <1> 	and		ax, BYTE MASKL_DPT_TRANSLATEMODE
 11453                              <1> %endmacro
 11454                                  	%include "AtaGeometry.asm"		; For generating L-CHS parameters
 11455                              <1> ; Project name	:	XTIDE Universal BIOS
 11456                              <1> ; Description	:	Functions for generating L-CHS parameters for
 11457                              <1> ;					drives with more than 1024 cylinders.
 11458                              <1> ;
 11459                              <1> ; 					These algorithms are taken from: http://www.mossywell.com/boot-sequence
 11460                              <1> ; 					Take a look at it for more detailed information.
 11461                              <1> ;
 11462                              <1> ;					This file is shared with BIOS Drive Information Tool.
 11463                              <1> 
 11464                              <1> ;
 11465                              <1> ; XTIDE Universal BIOS and Associated Tools
 11466                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 11467                              <1> ;
 11468                              <1> ; This program is free software; you can redistribute it and/or modify
 11469                              <1> ; it under the terms of the GNU General Public License as published by
 11470                              <1> ; the Free Software Foundation; either version 2 of the License, or
 11471                              <1> ; (at your option) any later version.
 11472                              <1> ;
 11473                              <1> ; This program is distributed in the hope that it will be useful,
 11474                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 11475                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 11476                              <1> ; GNU General Public License for more details.
 11477                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 11478                              <1> ;
 11479                              <1> 
 11480                              <1> ; Section containing code
 11481                              <1> SECTION .text
 11482                              <1> 
 11483                              <1> %ifdef MODULE_EBIOS
 11484                              <1> ;--------------------------------------------------------------------
 11485                              <1> ; AtaGeometry_GetLbaSectorCountToBXDXAXfromAtaInfoInESSI
 11486                              <1> ;	Parameters:
 11487                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11488                              <1> ;	Returns:
 11489                              <1> ;		BX:DX:AX:	48-bit sector count
 11490                              <1> ;		CL:			FLGL_DPT_LBA48 if LBA48 supported
 11491                              <1> ;					Zero if only LBA28 is supported
 11492                              <1> ;	Corrupts registers:
 11493                              <1> ;		Nothing
 11494                              <1> ;--------------------------------------------------------------------
 11495                              <1> AtaGeometry_GetLbaSectorCountToBXDXAXfromAtaInfoInESSI:
 11496 0000070E BB[BA03]            <1> 	mov		bx, Registers_ExchangeDSSIwithESDI
 11497 00000711 FFD3                <1> 	call	bx	; ATA info now in DS:DI
 11498 00000713 53                  <1> 	push	bx	; We will return via Registers_ExchangeDSSIwithESDI
 11499                              <1> 
 11500                              <1> 	; Check if LBA48 supported
 11501 00000714 F685A70004          <1> 	test	BYTE [di+ATA6.wSetSup83+1], A6_wSetSup83_LBA48>>8
 11502 00000719 740F                <1> 	jz		SHORT .GetLba28SectorCount
 11503                              <1> 
 11504                              <1> 	; Get LBA48 sector count
 11505 0000071B B180                <1> 	mov		cl, FLGL_DPT_LBA48
 11506 0000071D 8B85C800            <1> 	mov		ax, [di+ATA6.qwLBACnt]
 11507 00000721 8B95CA00            <1> 	mov		dx, [di+ATA6.qwLBACnt+2]
 11508 00000725 8B9DCC00            <1> 	mov		bx, [di+ATA6.qwLBACnt+4]
 11509 00000729 C3                  <1> 	ret
 11510                              <1> 
 11511                              <1> .GetLba28SectorCount:
 11512 0000072A 30C9                <1> 	xor		cl, cl
 11513 0000072C 31DB                <1> 	xor		bx, bx
 11514 0000072E 8B4578              <1> 	mov		ax, [di+ATA1.dwLBACnt]
 11515 00000731 8B557A              <1> 	mov		dx, [di+ATA1.dwLBACnt+2]
 11516 00000734 C3                  <1> 	ret
 11517                              <1> %endif	; MODULE_EBIOS
 11518                              <1> 
 11519                              <1> 
 11520                              <1> ;--------------------------------------------------------------------
 11521                              <1> ; AtaGeometry_GetLCHStoAXBLBHfromAtaInfoInESSIandTranslateModeInDX
 11522                              <1> ; AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX
 11523                              <1> ;	Parameters:
 11524                              <1> ;		DX:		Wanted translate mode or TRANSLATEMODE_AUTO to autodetect
 11525                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11526                              <1> ;	Returns:
 11527                              <1> ;		AX:		Number of L-CHS cylinders (1...1027, yes 1027)
 11528                              <1> ;		BL:		Number of L-CHS heads (1...255)
 11529                              <1> ;		BH:		Number of L-CHS sectors per track (1...63)
 11530                              <1> ;		CX:		Number of bits shifted (0...3)
 11531                              <1> ;		DL:		CHS Translate Mode
 11532                              <1> ;	Corrupts registers:
 11533                              <1> ;		DH
 11534                              <1> ;--------------------------------------------------------------------
 11535                              <1> AtaGeometry_GetLCHStoAXBLBHfromAtaInfoInESSIandTranslateModeInDX:
 11536 00000735 E82800              <1> 	call	AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI
 11537                              <1> 	; Fall to AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX
 11538                              <1> 
 11539                              <1> AtaGeometry_GetLCHStoAXBLBHfromPCHSinAXBLBHandTranslateModeInDX:
 11540                              <1> 	; Check if user defined translate mode
 11541 00000738 4A                  <1> 	dec		dx						; Set ZF if TRANSLATEMODE_LARGE, SF if TRANSLATEMODE_NORMAL
 11542 00000739 7909                <1> 	jns		SHORT .CheckIfLargeTranslationWanted
 11543                              <1> 	MIN_U	ax, MAX_LCHS_CYLINDERS	; TRANSLATEMODE_NORMAL maximum cylinders
 11544 0000073B 3D0004              <2>  cmp %1, %2
 11545 0000073E 7203                <2>  jb %%Return
 11546 00000740 B80004              <2>  mov %1, %2
 11547                              <2> ALIGN JUMP_ALIGN
 11548                              <2> %%Return:
 11549 00000743 42                  <1> 	inc		dx
 11550                              <1> .CheckIfLargeTranslationWanted:
 11551 00000744 742D                <1> 	jz		SHORT ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL
 11552 00000746 4A                  <1> 	dec		dx						; Set ZF if TRANSLATEMODE_ASSISTED_LBA
 11553 00000747 7405                <1> 	jz		SHORT .UseAssistedLBA
 11554                              <1> 	; TRANSLATEMODE_AUTO set
 11555                              <1> 
 11556                              <1> 	; Generate L-CHS using simple bit shift algorithm (ECHS) if
 11557                              <1> 	; 8192 or less cylinders.
 11558 00000749 3D0020              <1> 	cmp		ax, 8192
 11559 0000074C 7639                <1> 	jbe		SHORT ConvertPCHfromAXBLtoEnhancedCHinAXBL
 11560                              <1> 
 11561                              <1> 	; We have 8193 or more cylinders so two algorithms are available:
 11562                              <1> 	; Revised ECHS or Assisted LBA. The Assisted LBA provides larger
 11563                              <1> 	; capacity but requires LBA support from drive (drives this large
 11564                              <1> 	; always support LBA but user might have unintentionally set LBA).
 11565                              <1> .UseAssistedLBA:
 11566 0000074E 26F6446302          <1> 	test	BYTE [es:si+ATA1.wCaps+1], A1_wCaps_LBA>>8
 11567 00000753 741E                <1> 	jz		SHORT ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL
 11568                              <1> 
 11569                              <1> 	; Drive supports LBA
 11570 00000755 E81500              <1> 	call	GetSectorCountToDXAXfromCHSinAXBLBH
 11571 00000758 E83E00              <1> 	call	ConvertChsSectorCountFromDXAXtoLbaAssistedLCHSinAXBLBH
 11572 0000075B 31C9                <1> 	xor		cx, cx		; No bits to shift
 11573 0000075D B202                <1> 	mov		dl, TRANSLATEMODE_ASSISTED_LBA
 11574 0000075F C3                  <1> 	ret
 11575                              <1> 
 11576                              <1> 
 11577                              <1> ;--------------------------------------------------------------------
 11578                              <1> ; AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI
 11579                              <1> ;	Parameters:
 11580                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11581                              <1> ;	Returns:
 11582                              <1> ;		AX:		Number of P-CHS cylinders (1...16383)
 11583                              <1> ;		BL:		Number of P-CHS heads (1...16)
 11584                              <1> ;		BH:		Number of P-CHS sectors per track (1...63)
 11585                              <1> ;	Corrupts registers:
 11586                              <1> ;		Nothing
 11587                              <1> ;--------------------------------------------------------------------
 11588                              <1> AtaGeometry_GetPCHStoAXBLBHfromAtaInfoInESSI:
 11589 00000760 268B4402            <1> 	mov		ax, [es:si+ATA1.wCylCnt]	; Cylinders (1...16383)
 11590 00000764 268A5C06            <1> 	mov		bl, [es:si+ATA1.wHeadCnt]	; Heads (1...16)
 11591 00000768 268A7C0C            <1> 	mov		bh, [es:si+ATA1.wSPT]		; Sectors per Track (1...63)
 11592 0000076C C3                  <1> 	ret
 11593                              <1> 
 11594                              <1> 
 11595                              <1> ;--------------------------------------------------------------------
 11596                              <1> ; GetSectorCountToDXAXfromCHSinAXBLBH
 11597                              <1> ;	Parameters:
 11598                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11599                              <1> ;		AX:		Number of cylinders (1...16383)
 11600                              <1> ;		BL:		Number of heads (1...255)
 11601                              <1> ;		BH:		Number of sectors per track (1...63)
 11602                              <1> ;	Returns:
 11603                              <1> ;		DX:AX:	Total number of CHS addressable sectors
 11604                              <1> ;	Corrupts registers:
 11605                              <1> ;		BX
 11606                              <1> ;--------------------------------------------------------------------
 11607                              <1> GetSectorCountToDXAXfromCHSinAXBLBH:
 11608 0000076D 93                  <1> 	xchg	ax, bx
 11609 0000076E F6E4                <1> 	mul		ah			; AX = Heads * Sectors per track
 11610 00000770 F7E3                <1> 	mul		bx
 11611 00000772 C3                  <1> 	ret
 11612                              <1> 
 11613                              <1> 
 11614                              <1> ;--------------------------------------------------------------------
 11615                              <1> ; Revised Enhanced CHS calculation (Revised ECHS)
 11616                              <1> ;
 11617                              <1> ; This algorithm translates P-CHS sector count to L-CHS sector count
 11618                              <1> ; with bit shift algorithm. Since 256 heads are not allowed
 11619                              <1> ; (DOS limit), this algorithm makes translations so that maximum of
 11620                              <1> ; 240 L-CHS heads can be used. This makes the maximum addressable capacity
 11621                              <1> ; to 7,927,234,560 bytes ~ 7.38 GiB. LBA addressing needs to be used to
 11622                              <1> ; get more capacity.
 11623                              <1> ;
 11624                              <1> ; L-CHS parameters generated here require the drive to use CHS addressing.
 11625                              <1> ;
 11626                              <1> ; Here is the algorithm:
 11627                              <1> ; If cylinders > 8192 and heads = 16
 11628                              <1> ;  Heads = 15
 11629                              <1> ;  Cylinders = cylinders * 16 / 15 (losing the fraction component)
 11630                              <1> ;  Do a standard ECHS translation
 11631                              <1> ;
 11632                              <1> ; ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL:
 11633                              <1> ;	Parameters:
 11634                              <1> ;		AX:		Number of P-CHS cylinders (8193...16383)
 11635                              <1> ;		BL:		Number of P-CHS heads (1...16)
 11636                              <1> ;	Returns:
 11637                              <1> ;		AX:		Number of L-CHS cylinders (?...1024)
 11638                              <1> ;		BL:		Number of L-CHS heads (?...240)
 11639                              <1> ;		CX:		Number of bits shifted (0...3)
 11640                              <1> ;		DL:		ADDRESSING_MODE_NORMAL or ADDRESSING_MODE_LARGE
 11641                              <1> ;	Corrupts registers:
 11642                              <1> ;		Nothing
 11643                              <1> ;--------------------------------------------------------------------
 11644                              <1> ConvertPCHfromAXBLtoRevisedEnhancedCHinAXBL:
 11645                              <1> 	; Generate L-CHS using simple bit shift algorithm (ECHS) if
 11646                              <1> 	; 8192 or less cylinders
 11647 00000773 3D0020              <1> 	cmp		ax, 8192
 11648 00000776 760F                <1> 	jbe		SHORT ConvertPCHfromAXBLtoEnhancedCHinAXBL
 11649 00000778 80FB10              <1> 	cmp		bl, 16	; Drives with 8193 or more cylinders can report 15 heads
 11650 0000077B 720A                <1> 	jb		SHORT ConvertPCHfromAXBLtoEnhancedCHinAXBL
 11651                              <1> 
 11652                              <1> 	eMOVZX	cx, bl	; CX = 16
 11653                              <2> %ifndef USE_386
 11654                              <2>  %ifidni %1, ax
 11655                              <2>  mov al, %2
 11656                              <2>  xor ah, ah
 11657                              <2>  %elifidni %1, bx
 11658                              <2>  mov bl, %2
 11659                              <2>  xor bh, bh
 11660                              <2>  %elifidni %1, cx
 11661 0000077D 88D9                <2>  mov cl, %2
 11662 0000077F 30ED                <2>  xor ch, ch
 11663                              <2>  %elifidni %1, dx
 11664                              <2>  mov dl, %2
 11665                              <2>  xor dh, dh
 11666                              <2>  %else
 11667                              <2>  push ax
 11668                              <2>  mov al, %2
 11669                              <2>  xor ah, ah
 11670                              <2>  xchg ax, %1
 11671                              <2>  pop ax
 11672                              <2>  %endif
 11673                              <2> 
 11674                              <2> %else
 11675                              <2>  movzx %1, %2
 11676                              <2> %endif
 11677 00000781 4B                  <1> 	dec		bx		; Heads = 15
 11678 00000782 F7E1                <1> 	mul		cx		; DX:AX = Cylinders * 16
 11679 00000784 49                  <1> 	dec		cx		; CX = 15
 11680 00000785 F7F1                <1> 	div		cx		; AX = (Cylinders * 16) / 15
 11681                              <1> 	; Fall to ConvertPCHfromAXBXtoEnhancedCHinAXBX
 11682                              <1> 
 11683                              <1> 
 11684                              <1> ;--------------------------------------------------------------------
 11685                              <1> ; Enhanced CHS calculation (ECHS)
 11686                              <1> ;
 11687                              <1> ; This algorithm translates P-CHS sector count to L-CHS sector count
 11688                              <1> ; with simple bit shift algorithm. Since 256 heads are not allowed
 11689                              <1> ; (DOS limit), this algorithm require that there are at most 8192
 11690                              <1> ; P-CHS cylinders. This makes the maximum addressable capacity
 11691                              <1> ; to 4,227,858,432 bytes ~ 3.94 GiB. Use Revised ECHS or Assisted LBA
 11692                              <1> ; algorithms if there are more than 8192 P-CHS cylinders.
 11693                              <1> ;
 11694                              <1> ; L-CHS parameters generated here require the drive to use CHS addressing.
 11695                              <1> ;
 11696                              <1> ; Here is the algorithm:
 11697                              <1> ;  Multiplier = 1
 11698                              <1> ;  Cylinder = Cylinder - 1
 11699                              <1> ;  Is Cylinder < 1024? If not:
 11700                              <1> ;  Do a right bitwise rotation on the cylinder (i.e., divide by 2)
 11701                              <1> ;  Do a left bitwise rotation on the multiplier (i.e., multiply by 2)
 11702                              <1> ;  Use the multiplier on the Cylinder and Head values to obtain the translated values.
 11703                              <1> ;
 11704                              <1> ; ConvertPCHfromAXBLtoEnhancedCHinAXBL:
 11705                              <1> ;	Parameters:
 11706                              <1> ;		AX:		Number of P-CHS cylinders (1...8192)
 11707                              <1> ;		BL:		Number of P-CHS heads (1...16)
 11708                              <1> ;	Returns:
 11709                              <1> ;		AX:		Number of L-CHS cylinders (?...1024)
 11710                              <1> ;		BL:		Number of L-CHS heads (?...128)
 11711                              <1> ;		CX:		Number of bits shifted (0...3)
 11712                              <1> ;		DL:		TRANSLATEMODE_NORMAL or TRANSLATEMODE_LARGE
 11713                              <1> ;	Corrupts registers:
 11714                              <1> ;		Nothing
 11715                              <1> ;--------------------------------------------------------------------
 11716                              <1> ConvertPCHfromAXBLtoEnhancedCHinAXBL:
 11717 00000787 31C9                <1> 	xor		cx, cx		; No bits to shift initially
 11718 00000789 30D2                <1> 	xor		dl, dl		; Assume TRANSLATEMODE_NORMAL
 11719                              <1> .ShiftIfMoreThan1024Cylinder:
 11720 0000078B 3D0004              <1> 	cmp		ax, MAX_LCHS_CYLINDERS
 11721 0000078E 7633                <1> 	jbe		SHORT ReturnLCHSinAXBLBH
 11722 00000790 D1E8                <1> 	shr		ax, 1		; Halve cylinders
 11723                              <1> 	eSHL_IM	bl, 1		; Double heads
 11724                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 11725                              <2> %ifdef USE_386
 11726                              <2>  %if %2 = 1
 11727                              <2>  add %1, %1
 11728                              <2>  %else
 11729                              <2>  eSHIFT_IM %1, %2, shl
 11730                              <2>  %endif
 11731                              <2> %else
 11732                              <2>  eSHIFT_IM %1, %2, shl
 11733                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 11734                              <3> %ifndef USE_186
 11735                              <3>  %ifidni %1, cl
 11736                              <3>  times %2 %3 %1, 1
 11737                              <3>  %elifidni %1, ch
 11738                              <3>  times %2 %3 %1, 1
 11739                              <3>  %elifidni %1, cx
 11740                              <3>  times %2 %3 %1, 1
 11741                              <3>  %else
 11742                              <3>  %if %2 > 3
 11743                              <3>  push cx
 11744                              <3>  mov cl, %2
 11745                              <3>  %3 %1, cl
 11746                              <3>  pop cx
 11747                              <3>  %else
 11748 00000792 D0E3                <3>  times %2 %3 %1, 1
 11749                              <3>  %endif
 11750                              <3>  %endif
 11751                              <3> 
 11752                              <3> %else
 11753                              <3>  %3 %1, %2
 11754                              <3> %endif
 11755                              <3> %endif
 11756                              <2> %endif
 11757                              <2> %endif
 11758 00000794 41                  <1> 	inc		cx			; Increment bit shift count
 11759 00000795 B201                <1> 	mov		dl, TRANSLATEMODE_LARGE
 11760 00000797 EBF2                <1> 	jmp		SHORT .ShiftIfMoreThan1024Cylinder
 11761                              <1> 
 11762                              <1> 
 11763                              <1> ;--------------------------------------------------------------------
 11764                              <1> ; LBA assist calculation (or Assisted LBA)
 11765                              <1> ;
 11766                              <1> ; This algorithm translates P-CHS sector count up to largest possible
 11767                              <1> ; L-CHS sector count (1024, 255, 63). Note that INT 13h interface allows
 11768                              <1> ; 256 heads but DOS supports up to 255 head. That is why BIOSes never
 11769                              <1> ; use 256 heads.
 11770                              <1> ;
 11771                              <1> ; L-CHS parameters generated here require the drive to use LBA addressing.
 11772                              <1> ;
 11773                              <1> ; Here is the algorithm:
 11774                              <1> ; If cylinders > 8192
 11775                              <1> ;  Variable CH = Total CHS Sectors / 63
 11776                              <1> ;  Divide (CH  1) by 1024 and add 1
 11777                              <1> ;  Round the result up to the nearest of 16, 32, 64, 128 and 255. This is the value to be used for the number of heads.
 11778                              <1> ;  Divide CH by the number of heads. This is the value to be used for the number of cylinders.
 11779                              <1> ;
 11780                              <1> ; ConvertChsSectorCountFromDXAXtoLbaAssistedLCHSinAXBLBH:
 11781                              <1> ;	Parameters:
 11782                              <1> ;		DX:AX:	Total number of P-CHS sectors for CHS addressing
 11783                              <1> ;				(max = 16383 * 16 * 63 = 16,514,064)
 11784                              <1> ;	Returns:
 11785                              <1> ;		AX:		Number of cylinders (?...1027)
 11786                              <1> ;		BL:		Number of heads (16, 32, 64, 128 or 255)
 11787                              <1> ;		BH:		Number of sectors per track (always 63)
 11788                              <1> ;	Corrupts registers:
 11789                              <1> ;		CX, DX
 11790                              <1> ;--------------------------------------------------------------------
 11791                              <1> ConvertChsSectorCountFromDXAXtoLbaAssistedLCHSinAXBLBH:
 11792                              <1> 	; Value CH = Total sector count / 63
 11793                              <1> 	; Max = 16,514,064 / 63 = 262128
 11794 00000799 B93F00              <1> 	mov		cx, LBA_ASSIST_SPT			; CX = 63
 11795 0000079C E80FFC              <1> 	call	Math_DivDXAXbyCX
 11796 0000079F 52                  <1> 	push	dx
 11797 000007A0 50                  <1> 	push	ax							; Value CH stored for later use
 11798                              <1> 
 11799                              <1> 	; BX:DX:AX = Value CH - 1
 11800                              <1> 	; Max = 262128 - 1 = 262127
 11801 000007A1 31DB                <1> 	xor		bx, bx
 11802 000007A3 83E801              <1> 	sub		ax, BYTE 1
 11803 000007A6 19DA                <1> 	sbb		dx, bx
 11804                              <1> 
 11805                              <1> 	; AX = Number of heads = ((Value CH - 1) / 1024) + 1
 11806                              <1> 	; Max = (262127 / 1024) + 1 = 256
 11807 000007A8 56                  <1> 	push	si
 11808 000007A9 E84BFC              <1> 	call	Size_DivideSizeInBXDXAXby1024andIncrementMagnitudeInCX
 11809 000007AC 5E                  <1> 	pop		si
 11810 000007AD 40                  <1> 	inc		ax							; + 1
 11811                              <1> 
 11812                              <1> 	; Heads must be 16, 32, 64, 128 or 255 (round up to the nearest)
 11813                              <1> 	; Max = 255
 11814 000007AE B91000              <1> 	mov		cx, 16						; Min number of heads
 11815                              <1> .CompareNextValidNumberOfHeads:
 11816 000007B1 39C8                <1> 	cmp		ax, cx
 11817 000007B3 7606                <1> 	jbe		SHORT .NumberOfHeadsNowInCX
 11818                              <1> 	eSHL_IM	cl, 1						; Double number of heads
 11819                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 11820                              <2> %ifdef USE_386
 11821                              <2>  %if %2 = 1
 11822                              <2>  add %1, %1
 11823                              <2>  %else
 11824                              <2>  eSHIFT_IM %1, %2, shl
 11825                              <2>  %endif
 11826                              <2> %else
 11827                              <2>  eSHIFT_IM %1, %2, shl
 11828                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 11829                              <3> %ifndef USE_186
 11830                              <3>  %ifidni %1, cl
 11831 000007B5 D0E1                <3>  times %2 %3 %1, 1
 11832                              <3>  %elifidni %1, ch
 11833                              <3>  times %2 %3 %1, 1
 11834                              <3>  %elifidni %1, cx
 11835                              <3>  times %2 %3 %1, 1
 11836                              <3>  %else
 11837                              <3>  %if %2 > 3
 11838                              <3>  push cx
 11839                              <3>  mov cl, %2
 11840                              <3>  %3 %1, cl
 11841                              <3>  pop cx
 11842                              <3>  %else
 11843                              <3>  times %2 %3 %1, 1
 11844                              <3>  %endif
 11845                              <3>  %endif
 11846                              <3> 
 11847                              <3> %else
 11848                              <3>  %3 %1, %2
 11849                              <3> %endif
 11850                              <3> %endif
 11851                              <2> %endif
 11852                              <2> %endif
 11853 000007B7 75F8                <1> 	jnz		SHORT .CompareNextValidNumberOfHeads	; Reached 256 heads?
 11854 000007B9 FEC9                <1> 	dec		cl							;  If so, limit heads to 255
 11855                              <1> .NumberOfHeadsNowInCX:
 11856 000007BB 89CB                <1> 	mov		bx, cx						; Number of heads are returned in BL
 11857 000007BD B73F                <1> 	mov		bh, LBA_ASSIST_SPT			; Sectors per Track
 11858                              <1> 
 11859                              <1> 	; DX:AX = Number of cylinders = Value CH (without - 1) / number of heads
 11860                              <1> 	; Max = 262128 / 255 = 1027
 11861 000007BF 58                  <1> 	pop		ax
 11862 000007C0 5A                  <1> 	pop		dx							; Value CH back to DX:AX
 11863 000007C1 F7F1                <1> 	div		cx
 11864                              <1> 
 11865                              <1> 	; Return L-CHS
 11866                              <1> ReturnLCHSinAXBLBH:
 11867 000007C3 C3                  <1> 	ret
 11868                                  	%include "DrvDetectInfo.asm"	; For creating DRVDETECTINFO structs
 11869                              <1> ; Project name	:	XTIDE Universal BIOS
 11870                              <1> ; Description	:	Functions for generating and accessing drive
 11871                              <1> ;					information to be displayed on boot menu.
 11872                              <1> 
 11873                              <1> ;
 11874                              <1> ; XTIDE Universal BIOS and Associated Tools
 11875                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 11876                              <1> ;
 11877                              <1> ; This program is free software; you can redistribute it and/or modify
 11878                              <1> ; it under the terms of the GNU General Public License as published by
 11879                              <1> ; the Free Software Foundation; either version 2 of the License, or
 11880                              <1> ; (at your option) any later version.
 11881                              <1> ;
 11882                              <1> ; This program is distributed in the hope that it will be useful,
 11883                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 11884                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 11885                              <1> ; GNU General Public License for more details.
 11886                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 11887                              <1> ;
 11888                              <1> 
 11889                              <1> ; Section containing code
 11890                              <1> SECTION .text
 11891                              <1> 
 11892                              <1> ;--------------------------------------------------------------------
 11893                              <1> ; Creates new DRVDETECTINFO struct for detected hard disk.
 11894                              <1> ;
 11895                              <1> ; DriveDetectInfo_CreateForHardDisk
 11896                              <1> ;	Parameters:
 11897                              <1> ;		DL:		Drive number
 11898                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 11899                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11900                              <1> ;	Returns:
 11901                              <1> ;		ES:BX:	Ptr to DRVDETECTINFO (if successful)
 11902                              <1> ;	Corrupts registers:
 11903                              <1> ;		AX, BX, CX, DX, DI
 11904                              <1> ;--------------------------------------------------------------------
 11905                              <1> DriveDetectInfo_CreateForHardDisk:
 11906 000007C4 E81700              <1> 	call	DriveDetectInfo_ConvertDPTtoBX		; ES:BX now points to new DRVDETECTINFO
 11907                              <1> 
 11908                              <1> 	; Store Drive Name
 11909 000007C7 1E                  <1> 	push	ds									; Preserve RAMVARS
 11910 000007C8 56                  <1> 	push	si
 11911                              <1> 
 11912 000007C9 06                  <1> 	push	es									; ES copied to DS
 11913 000007CA 1F                  <1> 	pop		ds
 11914                              <1> 
 11915 000007CB 83C636              <1> 	add		si, BYTE ATA1.strModel				; DS:SI now points drive name (Clears CF)
 11916 000007CE 8D3F                <1> 	lea		di, [bx+DRVDETECTINFO.szDrvName]	; ES:DI now points to name destination
 11917 000007D0 B90F00              <1> 	mov		cx, MAX_HARD_DISK_NAME_LENGTH / 2	; Max number of WORDs allowed
 11918                              <1> .CopyNextWord:
 11919 000007D3 AD                  <1> 	lodsw
 11920 000007D4 86C4                <1> 	xchg	al, ah								; Change endianness
 11921 000007D6 AB                  <1> 	stosw
 11922 000007D7 E2FA                <1> 	loop	.CopyNextWord
 11923 000007D9 91                  <1> 	xchg	cx, ax								; Zero AX (CF already cleared from the ADD above)
 11924 000007DA AB                  <1> 	stosw										; Terminate with NULL
 11925                              <1> 
 11926 000007DB 5E                  <1> 	pop		si
 11927 000007DC 1F                  <1> 	pop		ds
 11928                              <1> 
 11929 000007DD C3                  <1> 	ret
 11930                              <1> 
 11931                              <1> 
 11932                              <1> ;--------------------------------------------------------------------
 11933                              <1> ; Returns offset to DRVDETECTINFO based on DPT pointer.
 11934                              <1> ;
 11935                              <1> ; DriveDetectInfo_ConvertDPTtoBX
 11936                              <1> ;	Parameters:
 11937                              <1> ;		DS:DI:	DPT Pointer
 11938                              <1> ;	Returns:
 11939                              <1> ;		BX:		Offset to DRVDETECTINFO struct
 11940                              <1> ;	Corrupts registers:
 11941                              <1> ;		AX
 11942                              <1> ;--------------------------------------------------------------------
 11943                              <1> DriveDetectInfo_ConvertDPTtoBX:
 11944 000007DE 8D45F2              <1> 	lea		ax, [di-RAMVARS_size]					; subtract off base of DPTs
 11945 000007E1 B302                <1> 	mov		bl, DPT_DRVDETECTINFO_SIZE_MULTIPLIER	; DRVDETECTINFO are a whole number multiple of DPT size
 11946 000007E3 F6E3                <1> 	mul		bl
 11947 000007E5 050C7F              <1> 	add		ax, BOOTVARS.rgDrvDetectInfo			; add base of DRVDETECTINFO
 11948 000007E8 93                  <1> 	xchg	bx, ax
 11949 000007E9 C3                  <1> 	ret
 11950                                  	%include "AtaID.asm"			; For ATA Identify Device information
 11951                              <1> ; Project name	:	XTIDE Universal BIOS
 11952                              <1> ; Description	:	Functions for accessing ATA information read with
 11953                              <1> ;					IDENTIFY DEVICE command.
 11954                              <1> 
 11955                              <1> ;
 11956                              <1> ; XTIDE Universal BIOS and Associated Tools
 11957                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 11958                              <1> ;
 11959                              <1> ; This program is free software; you can redistribute it and/or modify
 11960                              <1> ; it under the terms of the GNU General Public License as published by
 11961                              <1> ; the Free Software Foundation; either version 2 of the License, or
 11962                              <1> ; (at your option) any later version.
 11963                              <1> ;
 11964                              <1> ; This program is distributed in the hope that it will be useful,
 11965                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 11966                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 11967                              <1> ; GNU General Public License for more details.
 11968                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 11969                              <1> ;
 11970                              <1> 
 11971                              <1> ; Section containing code
 11972                              <1> SECTION .text
 11973                              <1> 
 11974                              <1> ;--------------------------------------------------------------------
 11975                              <1> ; AtaID_VerifyFromESSI
 11976                              <1> ;	Parameters:
 11977                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 11978                              <1> ;	Returns:
 11979                              <1> ;		CF:		Set if failed to verify ATA-ID
 11980                              <1> ;				Cleared if ATA-ID verified successfully
 11981                              <1> ;	Corrupts registers:
 11982                              <1> ;		AX, BX, CX
 11983                              <1> ;--------------------------------------------------------------------
 11984                              <1> AtaID_VerifyFromESSI:
 11985                              <1> 	; We cannot start by reading ATA version since the ID might be
 11986                              <1> 	; corrupted. We start by making sure P-CHS values are valid.
 11987                              <1> 	; If they are, we assume the ATA ID to be valid. Fortunately we can do
 11988                              <1> 	; further checking for ATA-5 and later since they contain signature and
 11989                              <1> 	; checksum bytes. Those are not available for ATA-4 and older.
 11990                              <1> 
 11991                              <1> 	; Verify P-CHS cylinders
 11992 000007EA BB0200              <1> 	mov		bx, ATA1.wCylCnt
 11993 000007ED B9FF3F              <1> 	mov		cx, MAX_VALID_PCHS_CYLINDERS
 11994 000007F0 E82600              <1> 	call	.CompareCHorSfromOffsetBXtoMaxValueInCX
 11995                              <1> 
 11996 000007F3 B306                <1> 	mov		bl, ATA1.wHeadCnt & 0FFh
 11997 000007F5 B91000              <1> 	mov		cx, MAX_VALID_PCHS_HEADS
 11998 000007F8 E81E00              <1> 	call	.CompareCHorSfromOffsetBXtoMaxValueInCX
 11999                              <1> 
 12000 000007FB B30C                <1> 	mov		bl, ATA1.wSPT & 0FFh
 12001 000007FD B13F                <1> 	mov		cl, MAX_VALID_PCHS_SECTORS_PER_TRACK
 12002 000007FF E81700              <1> 	call	.CompareCHorSfromOffsetBXtoMaxValueInCX
 12003                              <1> 
 12004                              <1> 	; Check signature byte. It is only found on ATA-5 and later. It should be zero on
 12005                              <1> 	; ATA-4 and older.
 12006 00000802 268A84FE01          <1> 	mov		al, [es:si+ATA6.bSignature]
 12007 00000807 84C0                <1> 	test	al, al
 12008 00000809 740C                <1> 	jz		SHORT .AtaIDverifiedSuccessfully	; Old ATA so Signature and Checksum is not available
 12009 0000080B 3CA5                <1> 	cmp		al, A6_wIntegrity_SIGNATURE
 12010 0000080D 7518                <1> 	jne		SHORT .FailedToVerifyAtaID
 12011                              <1> 
 12012                              <1> 	; Check checksum byte since signature was present
 12013 0000080F B90002              <1> 	mov		cx, ATA6_size
 12014 00000812 E8D6FB              <1> 	call	Memory_SumCXbytesFromESSItoAL		; Returns with ZF set according to result
 12015 00000815 7510                <1> 	jnz		SHORT .FailedToVerifyAtaID
 12016                              <1> 
 12017                              <1> 	; ATA-ID is now verified to be valid
 12018                              <1> .AtaIDverifiedSuccessfully:
 12019 00000817 F8                  <1> 	clc
 12020 00000818 C3                  <1> 	ret
 12021                              <1> 
 12022                              <1> ;--------------------------------------------------------------------
 12023                              <1> ; .CompareCHorSfromOffsetBXtoMaxValueInCX
 12024                              <1> ;	Parameters:
 12025                              <1> ;		BX:		C, H or S offset to ATA-ID
 12026                              <1> ;		CX:		Maximum valid C, H or S value
 12027                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 12028                              <1> ;	Returns:
 12029                              <1> ;		Exits from AtaID_VerifyFromESSI with CF set if invalid value
 12030                              <1> ;	Corrupts registers:
 12031                              <1> ;		AX
 12032                              <1> ;--------------------------------------------------------------------
 12033                              <1> .CompareCHorSfromOffsetBXtoMaxValueInCX:
 12034 00000819 268B00              <1> 	mov		ax, [es:bx+si]
 12035 0000081C 85C0                <1> 	test	ax, ax
 12036 0000081E 7404                <1> 	jz		SHORT .InvalidPCHorSinOffsetBX
 12037 00000820 39C8                <1> 	cmp		ax, cx			; Compare to max valid value
 12038 00000822 7604                <1> 	jbe		SHORT .ValidPCHorSinOffsetBX
 12039                              <1> .InvalidPCHorSinOffsetBX:
 12040 00000824 83C402              <1> 	add		sp, BYTE 2		; Clear return address for this function
 12041                              <1> .FailedToVerifyAtaID:
 12042 00000827 F9                  <1> 	stc						; Set carry to indicate invalid ATA-ID
 12043                              <1> .ValidPCHorSinOffsetBX:
 12044 00000828 C3                  <1> 	ret
 12045                              <1> 
 12046                              <1> 
 12047                              <1> %ifdef MODULE_ADVANCED_ATA
 12048                              <1> ;--------------------------------------------------------------------
 12049                              <1> ; AtaID_GetMaxPioModeToAXandMinCycleTimeToCX
 12050                              <1> ;	Parameters:
 12051                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 12052                              <1> ;	Returns:
 12053                              <1> ;		AL:		Max supported PIO mode
 12054                              <1> ;		AH:		FLGH_DPT_IORDY if IORDY supported, zero otherwise
 12055                              <1> ;		CX:		Minimum Cycle Time in nanosecs
 12056                              <1> ;	Corrupts registers:
 12057                              <1> ;		BX
 12058                              <1> ;--------------------------------------------------------------------
 12059                              <1> AtaID_GetMaxPioModeToAXandMinCycleTimeToCX:
 12060                              <1> 	; Get PIO mode and cycle time for PIO 0...2
 12061                              <1> 	mov		bx, [es:si+ATA1.bPioMode]
 12062                              <1> 	mov		ax, bx					; AH = 0, AL = PIO mode 0, 1 or 2
 12063                              <1> 	eSHL_IM	bx, 1					; Shift for WORD lookup
 12064                              <1> 	mov		cx, [cs:bx+.rgwPio0to2CycleTimeInNanosecs]
 12065                              <1> 
 12066                              <1> 	; Check if IORDY is supported
 12067                              <1> 	test	BYTE [es:si+ATA2.wCaps+1], A2_wCaps_IORDY >> 8
 12068                              <1> 	jz		SHORT .ReturnPioTimings	; No PIO 3 or higher if no IORDY
 12069                              <1> 	mov		ah, FLGH_DPT_IORDY
 12070                              <1> 
 12071                              <1> 	; Check if Advanced PIO modes are supported (3 and above)
 12072                              <1> 	test	BYTE [es:si+ATA2.wFields], A2_wFields_64to70
 12073                              <1> 	jz		SHORT .ReturnPioTimings
 12074                              <1> 
 12075                              <1> 	; Get Advanced PIO mode
 12076                              <1> 	; (Hard Disks supports up to 4 but CF cards can support 5 and 6)
 12077                              <1> 	mov		bl, [es:si+ATA2.bPIOSupp]
 12078                              <1> .CheckNextFlag:
 12079                              <1> 	inc		ax
 12080                              <1> 	shr		bl, 1
 12081                              <1> 	jnz		SHORT .CheckNextFlag
 12082                              <1> 	MIN_U	al, 6						; Make sure not above lookup tables
 12083                              <1> 	mov		cx, [es:si+ATA2.wPIOMinCyF]	; Advanced modes use IORDY
 12084                              <1> .ReturnPioTimings:
 12085                              <1> 	ret
 12086                              <1> 
 12087                              <1> .rgwPio0to2CycleTimeInNanosecs:
 12088                              <1> 	dw		PIO_0_MIN_CYCLE_TIME_NS
 12089                              <1> 	dw		PIO_1_MIN_CYCLE_TIME_NS
 12090                              <1> 	dw		PIO_2_MIN_CYCLE_TIME_NS
 12091                              <1> 
 12092                              <1> 
 12093                              <1> ;--------------------------------------------------------------------
 12094                              <1> ; AtaID_GetRecoveryTimeToAXfromPioModeInBXandCycleTimeInCX
 12095                              <1> ;	Parameters:
 12096                              <1> ;		BX:		PIO Mode
 12097                              <1> ;		CX:		PIO Cycle Time in nanosecs
 12098                              <1> ;	Returns:
 12099                              <1> ;		AX:		Active Time in nanosecs
 12100                              <1> ;	Corrupts registers:
 12101                              <1> ;		BX, CX
 12102                              <1> ;--------------------------------------------------------------------
 12103                              <1> AtaID_GetRecoveryTimeToAXfromPioModeInBXandCycleTimeInCX:
 12104                              <1> 	call	AtaID_GetActiveTimeToAXfromPioModeInBX
 12105                              <1> 	mov		bl, [cs:bx+.rgbPioModeToAddressValidTimeNs]
 12106                              <1> 	sub		cx, bx	; Cycle Time (t0) - Address Valid Time (t1)
 12107                              <1> 	sub		cx, ax	; - Active Time (t2)
 12108                              <1> 	xchg	ax, cx	; AX = Recovery Time (t2i)
 12109                              <1> 	ret
 12110                              <1> 
 12111                              <1> .rgbPioModeToAddressValidTimeNs:
 12112                              <1> 	db		PIO_0_MIN_ADDRESS_VALID_NS
 12113                              <1> 	db		PIO_1_MIN_ADDRESS_VALID_NS
 12114                              <1> 	db		PIO_2_MIN_ADDRESS_VALID_NS
 12115                              <1> 	db		PIO_3_MIN_ADDRESS_VALID_NS
 12116                              <1> 	db		PIO_4_MIN_ADDRESS_VALID_NS
 12117                              <1> 	db		PIO_5_MIN_ADDRESS_VALID_NS
 12118                              <1> 	db		PIO_6_MIN_ADDRESS_VALID_NS
 12119                              <1> 
 12120                              <1> 
 12121                              <1> ;--------------------------------------------------------------------
 12122                              <1> ; AtaID_GetActiveTimeToAXfromPioModeInBX
 12123                              <1> ;	Parameters:
 12124                              <1> ;		BX:		PIO Mode
 12125                              <1> ;	Returns:
 12126                              <1> ;		AX:		Active Time in nanosecs
 12127                              <1> ;	Corrupts registers:
 12128                              <1> ;		Nothing
 12129                              <1> ;--------------------------------------------------------------------
 12130                              <1> AtaID_GetActiveTimeToAXfromPioModeInBX:
 12131                              <1> 	eMOVZX	ax, [cs:bx+.rgbPioModeToActiveTimeNs]
 12132                              <1> 	ret
 12133                              <1> 
 12134                              <1> .rgbPioModeToActiveTimeNs:
 12135                              <1> 	db		PIO_0_MIN_ACTIVE_TIME_NS
 12136                              <1> 	db		PIO_1_MIN_ACTIVE_TIME_NS
 12137                              <1> 	db		PIO_2_MIN_ACTIVE_TIME_NS
 12138                              <1> 	db		PIO_3_MIN_ACTIVE_TIME_NS
 12139                              <1> 	db		PIO_4_MIN_ACTIVE_TIME_NS
 12140                              <1> 	db		PIO_5_MIN_ACTIVE_TIME_NS
 12141                              <1> 	db		PIO_6_MIN_ACTIVE_TIME_NS
 12142                              <1> 
 12143                              <1> %endif ; MODULE_ADVANCED_ATA
 12144                                  	%include "DetectDrives.asm"		; For detecting IDE drives
 12145                              <1> ; Project name	:	XTIDE Universal BIOS
 12146                              <1> ; Description	:	Functions for detecting drive for the BIOS.
 12147                              <1> 
 12148                              <1> ;
 12149                              <1> ; XTIDE Universal BIOS and Associated Tools
 12150                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 12151                              <1> ;
 12152                              <1> ; This program is free software; you can redistribute it and/or modify
 12153                              <1> ; it under the terms of the GNU General Public License as published by
 12154                              <1> ; the Free Software Foundation; either version 2 of the License, or
 12155                              <1> ; (at your option) any later version.
 12156                              <1> ;
 12157                              <1> ; This program is distributed in the hope that it will be useful,
 12158                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 12159                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 12160                              <1> ; GNU General Public License for more details.
 12161                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 12162                              <1> ;
 12163                              <1> 
 12164                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 12165                              <1> 
 12166                              <1> ; Section containing code
 12167                              <1> SECTION .text
 12168                              <1> 
 12169                              <1> ;--------------------------------------------------------------------
 12170                              <1> ; Detects all IDE hard disks to be controlled by this BIOS.
 12171                              <1> ;
 12172                              <1> ; DetectDrives_FromAllIDEControllers
 12173                              <1> ;	Parameters:
 12174                              <1> ;		DS:		RAMVARS segment
 12175                              <1> ;		ES:		BDA segment (zero)
 12176                              <1> ;	Returns:
 12177                              <1> ;		Nothing
 12178                              <1> ;	Corrupts registers:
 12179                              <1> ;		All (not segments)
 12180                              <1> ;--------------------------------------------------------------------
 12181                              <1> DetectDrives_FromAllIDEControllers:
 12182 00000829 E8E4FC              <1> 	call	RamVars_GetIdeControllerCountToCX
 12183 0000082C BD5100              <1> 	mov		bp, ROMVARS.ideVars0			; CS:BP now points to first IDEVARS
 12184                              <1> 
 12185                              <1> .DriveDetectLoop:							; Loop through IDEVARS
 12186 0000082F 51                  <1> 	push	cx
 12187                              <1> 
 12188 00000830 B9[AB00]            <1> 	mov		cx, g_szDetectMaster
 12189 00000833 B7A0                <1> 	mov		bh, MASK_DRVNHEAD_SET								; Select Master drive
 12190 00000835 E87300              <1> 	call	StartDetectionWithDriveSelectByteInBHandStringInCX	; Detect and create DPT + BOOTNFO
 12191                              <1> 
 12192 00000838 B9[B100]            <1> 	mov		cx, g_szDetectSlave
 12193 0000083B B7B0                <1> 	mov		bh, MASK_DRVNHEAD_SET | FLG_DRVNHEAD_DRV
 12194 0000083D E86B00              <1> 	call	StartDetectionWithDriveSelectByteInBHandStringInCX
 12195                              <1> 
 12196 00000840 59                  <1> 	pop		cx
 12197                              <1> 
 12198 00000841 83C512              <1> 	add		bp, BYTE IDEVARS_size			; Point to next IDEVARS
 12199                              <1> 
 12200                              <1> %ifdef MODULE_SERIAL
 12201 00000844 E31B                <1> 	jcxz	.AddHardDisks					; Set to zero on .ideVarsSerialAuto iteration (if any)
 12202                              <1> %endif
 12203 00000846 E2E7                <1> 	loop	.DriveDetectLoop
 12204                              <1> 
 12205                              <1> %ifdef MODULE_SERIAL
 12206                              <1> ;----------------------------------------------------------------------
 12207                              <1> ;
 12208                              <1> ; if serial drive detected, do not scan (avoids duplicate drives and isn't needed - we already have a connection)
 12209                              <1> ;
 12210 00000848 E85AFE              <1> 	call	FindDPT_ToDSDIforSerialDevice   ; does not modify AX
 12211 0000084B 7314                <1> 	jnc		.AddHardDisks
 12212                              <1> 
 12213 0000084D BD9900              <1> 	mov		bp, ROMVARS.ideVarsSerialAuto	; Point to our special IDEVARS structure, just for serial scans
 12214                              <1> 
 12215                              <1> %ifdef MODULE_HOTKEYS
 12216 00000850 3C40                <1> 	cmp		al, COM_DETECT_HOTKEY_SCANCODE  ; Set by last call to HotkeyBar_UpdateDuringDriveDetection above
 12217 00000852 74DB                <1> 	je		.DriveDetectLoop
 12218                              <1> %endif
 12219                              <1> 
 12220 00000854 2EA04600            <1> 	mov		al,[cs:ROMVARS.wFlags]			; Configurator set to always scan?
 12221 00000858 260A061704          <1> 	or		al,[es:BDA.bKBFlgs1]			; Or, did the user hold down the ALT key?
 12222 0000085D 2408                <1> 	and		al,8							; 8 = alt key depressed, same as FLG_ROMVARS_SERIAL_ALWAYSDETECT
 12223 0000085F 75CE                <1> 	jnz		.DriveDetectLoop
 12224                              <1> %endif
 12225                              <1> 
 12226                              <1> .AddHardDisks:
 12227                              <1> ;----------------------------------------------------------------------
 12228                              <1> ;
 12229                              <1> ; Add in hard disks to BDA, finalize our Count and First variables
 12230                              <1> ;
 12231                              <1> ; Note that we perform the add to bHDCount and store bFirstDrv even if the count is zero.
 12232                              <1> ; This is done because we use the value of .bFirstDrv to know how many drives were in the system
 12233                              <1> ; at the time of boot, and to return that number on int13h/8h calls.  Because the count is zero,
 12234                              <1> ; FindDPT_ForDriveNumber will not find any drives that are ours.
 12235                              <1> ;
 12236 00000861 8B0E0900            <1> 	mov		cx, [RAMVARS.wDrvCntAndFlopCnt]		; Our count of hard disks
 12237                              <1> 
 12238 00000865 26A07504            <1> 	mov		al, [es:BDA.bHDCount]
 12239 00000869 00C1                <1> 	add		cl, al						; Add our drives to the system count
 12240 0000086B 26880E7504          <1> 	mov		[es:BDA.bHDCount], cl
 12241 00000870 0C80                <1> 	or		al, 80h						; Or in hard disk flag
 12242 00000872 A20800              <1> 	mov		[RAMVARS.bFirstDrv], al		; Store first drive number
 12243                              <1> 
 12244                              <1> .AddFloppies:
 12245                              <1> %ifdef MODULE_SERIAL_FLOPPY
 12246                              <1> ;----------------------------------------------------------------------
 12247                              <1> ;
 12248                              <1> ; Add in any emulated serial floppy drives, finalize our packed Count and First variables
 12249                              <1> ;
 12250 00000875 FECD                <1> 	dec		ch
 12251 00000877 88E8                <1> 	mov		al, ch
 12252 00000879 782C                <1> 	js		.NoFloppies						; if no drives are present, we store 0ffh
 12253                              <1> 
 12254 0000087B E8EAFC              <1> 	call	FloppyDrive_GetCountFromBIOS_or_BDA
 12255                              <1> 
 12256 0000087E 50                  <1> 	push	ax
 12257                              <1> 
 12258 0000087F 00E8                <1> 	add		al, ch							; Add our drives to existing drive count
 12259 00000881 3C03                <1> 	cmp		al, 3							; For BDA, max out at 4 drives (ours is zero based)
 12260 00000883 7202                <1> 	jb		.MaxBDAFloppiesExceeded
 12261 00000885 B003                <1> 	mov		al, 3
 12262                              <1> .MaxBDAFloppiesExceeded:
 12263                              <1> 	eROR_IM	al, 2							; move to bits 6-7
 12264                              <2>  eSHIFT_IM %1, %2, ror
 12265                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 12266                              <3> %ifndef USE_186
 12267                              <3>  %ifidni %1, cl
 12268                              <3>  times %2 %3 %1, 1
 12269                              <3>  %elifidni %1, ch
 12270                              <3>  times %2 %3 %1, 1
 12271                              <3>  %elifidni %1, cx
 12272                              <3>  times %2 %3 %1, 1
 12273                              <3>  %else
 12274                              <3>  %if %2 > 3
 12275                              <3>  push cx
 12276                              <3>  mov cl, %2
 12277                              <3>  %3 %1, cl
 12278                              <3>  pop cx
 12279                              <3>  %else
 12280 00000887 D0C8<rept>          <3>  times %2 %3 %1, 1
 12281                              <3>  %endif
 12282                              <3>  %endif
 12283                              <3> 
 12284                              <3> %else
 12285                              <3>  %3 %1, %2
 12286                              <3> %endif
 12287                              <3> %endif
 12288 0000088B 40                  <1> 	inc		ax								; low order bit, indicating floppy drive exists
 12289                              <1> 
 12290 0000088C 268A261004          <1> 	mov		ah, [es:BDA.wEquipment]			; Load Equipment WORD low byte
 12291 00000891 80E43E              <1> 	and		ah, 03eh						; Mask off drive number and drives present bit
 12292 00000894 08E0                <1> 	or		al, ah							; Or in new values
 12293 00000896 26A21004            <1> 	mov		[es:BDA.wEquipment], al			; and store
 12294                              <1> 
 12295 0000089A B01E                <1> 	mov		al, 1eh							; BDA pointer to Floppy DPT
 12296 0000089C BE[9B16]            <1> 	mov		si, AH8h_FloppyDPT
 12297 0000089F E8F3FB              <1> 	call	Interrupts_InstallHandlerToVectorInALFromCSSI
 12298                              <1> 
 12299 000008A2 58                  <1> 	pop		ax
 12300                              <1> 
 12301 000008A3 D0ED                <1> 	shr		ch, 1							; number of drives, 1 or 2 only, to CF flag (clear=1, set=2)
 12302 000008A5 D0D0                <1> 	rcl		al, 1							; starting drive number in upper 7 bits, number of drives in low bit
 12303                              <1> .NoFloppies:
 12304 000008A7 A20A00              <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bFlopCntAndFirst], al
 12305                              <1> %endif
 12306                              <1> 
 12307 000008AA C3                  <1> 	ret
 12308                              <1> 
 12309                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 12310                              <1> 	%if FLG_ROMVARS_SERIAL_SCANDETECT != 8
 12311                              <1> 		%error "DetectDrives is currently coded to assume that FLG_ROMVARS_SERIAL_SCANDETECT is the same bit as the ALT key code in the BDA.  Changes in the code will be needed if these values are no longer the same."
 12312                              <1> 	%endif
 12313                              <1> %endif
 12314                              <1> 
 12315                              <1> 
 12316                              <1> ;--------------------------------------------------------------------
 12317                              <1> ; StartDetectionWithDriveSelectByteInBHandStringInCX
 12318                              <1> ;	Parameters:
 12319                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 12320                              <1> ;		CX:		Offset to "Master" or "Slave" string
 12321                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
 12322                              <1> ;		DS:		RAMVARS segment
 12323                              <1> ;		ES:		Zero (BDA segment)
 12324                              <1> ;	Returns:
 12325                              <1> ;       None
 12326                              <1> ;	Corrupts registers:
 12327                              <1> ;		AX, BL, CX, DX, SI, DI
 12328                              <1> ;--------------------------------------------------------------------
 12329                              <1> StartDetectionWithDriveSelectByteInBHandStringInCX:
 12330                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 12331                              <1> 	; Autodetect port for XT-CF
 12332 000008AB E85800              <1> 	call	DetectDrives_DoesIdevarsInCSBPbelongToXTCF
 12333 000008AE 7527                <1> 	jne		SHORT .SkipXTCFportDetection
 12334                              <1> 
 12335                              <1> 	; XT-CF do not support slave drives so skip detection
 12336 000008B0 F6C710              <1> 	test	bh, FLG_DRVNHEAD_DRV
 12337 000008B3 755F                <1> 	jnz		SHORT NoSlaveDriveAvailable
 12338                              <1> 
 12339                              <1> 	; XT-CF do not support slave drives so we can safely update port
 12340                              <1> 	; for next drive (another XT-CF card on same system)
 12341                              <1> .DetectNextPort:
 12342 000008B5 268B16047F          <1> 	mov		dx, [es:BOOTVARS.wNextXTCFportToScan]
 12343 000008BA 80F240              <1> 	xor		dl, 40h
 12344 000008BD 7507                <1> 	jnz		SHORT .StoreNextXTCFportToScan
 12345 000008BF FEC6                <1> 	inc		dh
 12346 000008C1 80FE03              <1> 	cmp		dh, XTCF_BASE_PORT_4 >> 8
 12347 000008C4 7711                <1> 	ja		SHORT .SkipXTCFportDetection		; XT-CF not found from any port
 12348                              <1> .StoreNextXTCFportToScan:
 12349 000008C6 268916047F          <1> 	mov		[es:BOOTVARS.wNextXTCFportToScan], dx
 12350                              <1> 
 12351 000008CB E84C0F              <1> 	call	AH1Eh_DetectXTCFwithBasePortInDX
 12352 000008CE 72E5                <1> 	jc		SHORT .DetectNextPort				; XT-CF not found from this port
 12353                              <1> 
 12354                              <1> 	; We now have autodetected port in DX
 12355 000008D0 52                  <1> 	push	dx
 12356 000008D1 92                  <1> 	xchg	ax, dx								; Port to print in AX
 12357 000008D2 E85000              <1> 	call	DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP
 12358 000008D5 EB04                <1> 	jmp		SHORT .DriveDetectionStringPrintedOnScreen
 12359                              <1> 
 12360                              <1> 	; Print detect string for devices that do not support autodetection
 12361                              <1> .SkipXTCFportDetection:
 12362 000008D7 52                  <1> 	push	dx
 12363                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 12364                              <1> 
 12365 000008D8 E84600              <1> 	call	DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
 12366                              <1> .DriveDetectionStringPrintedOnScreen:
 12367                              <1> %ifdef MODULE_HOTKEYS
 12368 000008DB E8D400              <1> 	call	HotkeyBar_UpdateDuringDriveDetection
 12369                              <1> %endif
 12370                              <1> 
 12371                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 12372 000008DE 5A                  <1> 	pop		dx
 12373                              <1> %endif
 12374                              <1> 	; Fall to .ReadAtaInfoFromHardDisk
 12375                              <1> 
 12376                              <1> 
 12377                              <1> ;--------------------------------------------------------------------
 12378                              <1> ; .ReadAtaInfoFromHardDisk
 12379                              <1> ;	Parameters:
 12380                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 12381                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 12382                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
 12383                              <1> ;		DS:		RAMVARS segment
 12384                              <1> ;		ES:		Zero (BDA segment)
 12385                              <1> ;	Returns:
 12386                              <1> ;		CF:		Cleared if ATA-information read successfully
 12387                              <1> ;				Set if any error
 12388                              <1> ;	Corrupts registers:
 12389                              <1> ;		AX, BL, CX, DX, SI, DI
 12390                              <1> ;--------------------------------------------------------------------
 12391                              <1> .ReadAtaInfoFromHardDisk:
 12392 000008DF BE007C              <1> 	mov		si, BOOTVARS.rgbAtaInfo		; ES:SI now points to ATA info location
 12393 000008E2 06                  <1> 	push	es
 12394 000008E3 56                  <1> 	push	si
 12395 000008E4 52                  <1> 	push	dx
 12396 000008E5 53                  <1> 	push	bx
 12397 000008E6 E88B03              <1> 	call	Device_IdentifyToBufferInESSIwithDriveSelectByteInBH
 12398 000008E9 5B                  <1> 	pop		bx
 12399 000008EA 5A                  <1> 	pop		dx
 12400 000008EB 5E                  <1> 	pop		si
 12401 000008EC 07                  <1> 	pop		es
 12402 000008ED 7306                <1> 	jnc		SHORT CreateBiosTablesForHardDisk
 12403                              <1> 	; Fall to .ReadAtapiInfoFromDrive
 12404                              <1> 
 12405                              <1> .ReadAtapiInfoFromDrive:				; Not yet implemented
 12406                              <1> 	;call	ReadAtapiInfoFromDrive		; Assume CD-ROM
 12407                              <1> 	;jnc	SHORT _CreateBiosTablesForCDROM
 12408                              <1> 
 12409                              <1> 	;jmp	short DetectDrives_DriveNotFound
 12410                              <1> ;;; fall-through instead of previous jmp instruction
 12411                              <1> ;--------------------------------------------------------------------
 12412                              <1> ; DetectDrives_DriveNotFound
 12413                              <1> ;	Parameters:
 12414                              <1> ;		Nothing
 12415                              <1> ;	Returns:
 12416                              <1> ;		CF:     Set (from DetectPrint_NullTerminatedStringFromCSSIandSetCF)
 12417                              <1> ;	Corrupts registers:
 12418                              <1> ;		AX, SI
 12419                              <1> ;--------------------------------------------------------------------
 12420                              <1> DetectDrives_DriveNotFound:
 12421 000008EF BE[0D01]            <1> 	mov		si, g_szNotFound
 12422 000008F2 E9B100              <1> 	jmp		DetectPrint_NullTerminatedStringFromCSSIandSetCF
 12423                              <1> 
 12424                              <1> 
 12425                              <1> ;--------------------------------------------------------------------
 12426                              <1> ; CreateBiosTablesForHardDisk
 12427                              <1> ;	Parameters:
 12428                              <1> ;		BH:		Drive Select byte for Drive and Head Register
 12429                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 12430                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
 12431                              <1> ;		ES:SI	Ptr to ATA information for the drive
 12432                              <1> ;		DS:		RAMVARS segment
 12433                              <1> ;		ES:		BDA segment
 12434                              <1> ;	Returns:
 12435                              <1> ;		Nothing
 12436                              <1> ;	Corrupts registers:
 12437                              <1> ;		AX, BX, CX, DX, SI, DI
 12438                              <1> ;--------------------------------------------------------------------
 12439                              <1> CreateBiosTablesForHardDisk:
 12440 000008F5 53                  <1> 	push	bx
 12441 000008F6 E8F1FE              <1> 	call	AtaID_VerifyFromESSI
 12442 000008F9 5B                  <1> 	pop		bx
 12443 000008FA 72F3                <1> 	jc		SHORT DetectDrives_DriveNotFound
 12444 000008FC E87FFC              <1> 	call	CreateDPT_FromAtaInformation
 12445 000008FF 72EE                <1> 	jc		SHORT DetectDrives_DriveNotFound
 12446 00000901 E8C0FE              <1> 	call	DriveDetectInfo_CreateForHardDisk
 12447 00000904 EB57                <1> 	jmp		SHORT DetectPrint_DriveNameFromDrvDetectInfoInESBX
 12448                              <1> 
 12449                              <1> 
 12450                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 12451                              <1> ;--------------------------------------------------------------------
 12452                              <1> ; DetectDrives_DoesIdevarsInCSBPbelongToXTCF
 12453                              <1> ;	Parameters:
 12454                              <1> ;		CS:BP:	Ptr to IDEVARS for the drive
 12455                              <1> ;	Returns:
 12456                              <1> ;		ZF:		Set if IDEVARS belongs to XT-CF device
 12457                              <1> ;				Cleared if some other device
 12458                              <1> ;	Corrupts registers:
 12459                              <1> ;		AL
 12460                              <1> ;--------------------------------------------------------------------
 12461                              <1> DetectDrives_DoesIdevarsInCSBPbelongToXTCF:
 12462 00000906 2E8A4604            <1> 	mov		al, [cs:bp+IDEVARS.bDevice]
 12463 0000090A 3C0A                <1> 	cmp		al, DEVICE_8BIT_XTCF_PIO8
 12464 0000090C 7406                <1> 	je		SHORT .DeviceIsXTCF
 12465 0000090E 3C0C                <1> 	cmp		al, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
 12466 00000910 7402                <1> 	je		SHORT .DeviceIsXTCF
 12467 00000912 3C0E                <1> 	cmp		al, DEVICE_8BIT_XTCF_DMA
 12468                              <1> .DeviceIsXTCF:
 12469                              <1> NoSlaveDriveAvailable:
 12470 00000914 C3                  <1> 	ret
 12471                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 12472                              <1> 
 12473                                  	%include "DetectPrint.asm"		; For printing drive detection strings
 12474                              <1> ; Project name	:	XTIDE Universal BIOS
 12475                              <1> ; Description	:	Functions for printing drive detection strings.
 12476                              <1> 
 12477                              <1> ;
 12478                              <1> ; XTIDE Universal BIOS and Associated Tools
 12479                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 12480                              <1> ;
 12481                              <1> ; This program is free software; you can redistribute it and/or modify
 12482                              <1> ; it under the terms of the GNU General Public License as published by
 12483                              <1> ; the Free Software Foundation; either version 2 of the License, or
 12484                              <1> ; (at your option) any later version.
 12485                              <1> ;
 12486                              <1> ; This program is distributed in the hope that it will be useful,
 12487                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 12488                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 12489                              <1> ; GNU General Public License for more details.
 12490                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 12491                              <1> ;
 12492                              <1> 
 12493                              <1> ; Section containing code
 12494                              <1> SECTION .text
 12495                              <1> 
 12496                              <1> ;--------------------------------------------------------------------
 12497                              <1> ; DetectPrint_InitializeDisplayContext
 12498                              <1> ;	Parameters:
 12499                              <1> ;		Nothing
 12500                              <1> ;	Returns:
 12501                              <1> ;		Nothing
 12502                              <1> ;	Corrupts registers:
 12503                              <1> ;		AX, DI
 12504                              <1> ;--------------------------------------------------------------------
 12505                              <1> DetectPrint_InitializeDisplayContext:
 12506                              <1> 	JMP_DISPLAY_LIBRARY InitializeDisplayContext
 12507                              <2>  %ifidn %1, PushDisplayContext
 12508                              <2>  jmp DisplayContext_Push
 12509                              <2>  %elifidn %1, PopDisplayContext
 12510                              <2>  call DisplayContext_Pop
 12511                              <2>  ret
 12512                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
 12513                              <2>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
 12514                              <2>  %elifidn %1, FormatNullTerminatedStringFromCSSI
 12515                              <2>  mov di, %1
 12516                              <2>  call Display_FunctionFromDI
 12517                              <2>  ret
 12518                              <2>  %else
 12519 00000915 BF[F201]            <2>  mov di, %1
 12520 00000918 E972F8              <2>  jmp Display_FunctionFromDI
 12521                              <2>  %endif
 12522                              <1> 
 12523                              <1> 
 12524                              <1> %ifdef MODULE_HOTKEYS
 12525                              <1> ;--------------------------------------------------------------------
 12526                              <1> ; DetectPrint_GetSoftwareCoordinatesToAX
 12527                              <1> ;	Parameters:
 12528                              <1> ;		Nothing
 12529                              <1> ;	Returns:
 12530                              <1> ;		Nothing
 12531                              <1> ;	Corrupts registers:
 12532                              <1> ;		AX, DI
 12533                              <1> ;--------------------------------------------------------------------
 12534                              <1> DetectPrint_GetSoftwareCoordinatesToAX:
 12535                              <1> 	JMP_DISPLAY_LIBRARY GetSoftwareCoordinatesToAX
 12536                              <2>  %ifidn %1, PushDisplayContext
 12537                              <2>  jmp DisplayContext_Push
 12538                              <2>  %elifidn %1, PopDisplayContext
 12539                              <2>  call DisplayContext_Pop
 12540                              <2>  ret
 12541                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
 12542                              <2>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
 12543                              <2>  %elifidn %1, FormatNullTerminatedStringFromCSSI
 12544                              <2>  mov di, %1
 12545                              <2>  call Display_FunctionFromDI
 12546                              <2>  ret
 12547                              <2>  %else
 12548 0000091B BF[5102]            <2>  mov di, %1
 12549 0000091E E96CF8              <2>  jmp Display_FunctionFromDI
 12550                              <2>  %endif
 12551                              <1> %endif
 12552                              <1> 
 12553                              <1> 
 12554                              <1> ;--------------------------------------------------------------------
 12555                              <1> ; DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP
 12556                              <1> ;	Parameters:
 12557                              <1> ;		CS:CX:	Ptr to "Master" or "Slave" string
 12558                              <1> ;		CS:BP:	Ptr to IDEVARS
 12559                              <1> ;	Returns:
 12560                              <1> ;		Nothing
 12561                              <1> ;	Corrupts registers:
 12562                              <1> ;		AX, CX, DX, SI, DI
 12563                              <1> ;--------------------------------------------------------------------
 12564                              <1> DetectPrint_StartDetectWithMasterOrSlaveStringInCXandIdeVarsInCSBP:
 12565 00000921 2E8B4600            <1> 	mov		ax, [cs:bp+IDEVARS.wBasePort]   ; for IDE: AX=port address, DH=.bDevice
 12566                              <1> 	; fall through to DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP
 12567                              <1> 
 12568                              <1> ;--------------------------------------------------------------------
 12569                              <1> ; DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP
 12570                              <1> ;	Parameters:
 12571                              <1> ;		AX:		Base Port Address
 12572                              <1> ;		CS:CX:	Ptr to "Master" or "Slave" string
 12573                              <1> ;		CS:BP:	Ptr to IDEVARS
 12574                              <1> ;	Returns:
 12575                              <1> ;		Nothing
 12576                              <1> ;	Corrupts registers:
 12577                              <1> ;		AX, CX, DX, SI, DI
 12578                              <1> ;--------------------------------------------------------------------
 12579                              <1> DetectPrint_StartDetectWithAutodetectedBasePortInAXandIdeVarsInCSBP:
 12580 00000925 2E8B5603            <1> 	mov		dx, [cs:bp+IDEVARS.bDevice-1]   ; for Serial: AL=port address>>2, AH=baud rate
 12581                              <1> 											;			  DL=COM number character, DH=.bDevice
 12582 00000929 55                  <1> 	push	bp								; setup stack for call to
 12583 0000092A 89E5                <1> 	mov		bp, sp							; BootMenuPrint_FormatCSSIfromParamsInSSBP
 12584                              <1> 
 12585 0000092C 51                  <1> 	push 	cx								; Push "Master" or "Slave"
 12586                              <1> 
 12587 0000092D B1D4                <1> 	mov		cl, (g_szDetectPort-$$) & 0xff	; Setup print string for standard IDE
 12588                              <1> 											; Note that we modify only the low order bits of CX a lot here,
 12589                              <1> 											; saving code space rather than reloading CX completely.
 12590                              <1> 											; This optimization requires that all the g_szDetect* strings are
 12591                              <1> 											; on the same 256 byte page, which is checked in strings.asm.
 12592                              <1> 
 12593                              <1> %ifdef MODULE_SERIAL
 12594 0000092F 80FE12              <1> 	cmp		dh, DEVICE_SERIAL_PORT		  	; Check if this is a serial device
 12595                              <1> 
 12596 00000932 7521                <1> 	jnz		.pushAndPrint					; CX = string to print, AX = port address, DX won't be used
 12597                              <1> 
 12598 00000934 B1BE                <1> 	mov		cl, (g_szDetectCOM-$$) & 0xff	; Setup print string for COM ports
 12599 00000936 51                  <1> 	push	cx								; And push now.  We use the fact that format strings can contain
 12600                              <1> 											; themselves format strings.
 12601                              <1> 
 12602 00000937 52                  <1> 	push	dx								; Push COM number character
 12603                              <1> 											; If the string is going to be "Auto", we will push a NULL (zero)
 12604                              <1> 											; here for the COM port number, which will be eaten by the
 12605                              <1> 											; print routine (DisplayPrint_CharacterFromAL), resulting in
 12606                              <1> 											; just "COM" being printed without a character after it.
 12607                              <1> 
 12608 00000938 B1C3                <1>  	mov		cl, (g_szDetectCOMAuto-$$) & 0xff	; Setup secondary print string for "Auto"
 12609                              <1> 
 12610 0000093A 84D2                <1> 	test	dl, dl							; Check if serial port "Auto"
 12611 0000093C 7417                <1> 	jz		.pushAndPrintSerial				; CX = string to print, AX and DX won't be used
 12612                              <1> 
 12613 0000093E B1CF                <1> 	mov		cl, (g_szDetectCOMLarge-$$) & 0xff	; Setup secondary print string for "COMn/xx.yK"
 12614                              <1> 
 12615 00000940 88E0                <1> 	mov		al,ah							; baud rate divisor to AL
 12616 00000942 98                  <1> 	cbw										; clear AH, AL will always be less than 128
 12617 00000943 96                  <1> 	xchg	si,ax							; move AX to SI for divide
 12618 00000944 B88004              <1> 	mov		ax,1152							; baud rate to display is 115200/divisor, the "00" is handled
 12619                              <1> 											; in the print strings
 12620 00000947 99                  <1> 	cwd										; clear top 16-bits of dividend
 12621 00000948 F7F6                <1> 	div		si								; and divide...  Now AX = baud rate/100, DX = 0 (always a clean divide)
 12622                              <1> 
 12623 0000094A BE0A00              <1> 	mov		si,10							; Now separate the whole portion from the fractional for "K" display
 12624 0000094D F7F6                <1> 	div		si								; and divide...  Now AX = baud rate/1000, DX = low order digit
 12625                              <1> 
 12626 0000094F 39F0                <1> 	cmp		ax,si							; < 10: "2400", "9600", etc.; >= 10: "19.2K", "38.4K", etc.
 12627 00000951 7302                <1> 	jae		.pushAndPrintSerial
 12628                              <1> 
 12629 00000953 B1CA                <1> 	mov		cl, (g_szDetectCOMSmall-$$) & 0xff	; Setup secondary print string for "COMn/XXy00"
 12630                              <1> 
 12631                              <1> .pushAndPrintSerial:
 12632                              <1> .pushAndPrint:
 12633                              <1> %endif
 12634                              <1> 
 12635 00000955 51                  <1> 	push	cx								; Push print string
 12636 00000956 50                  <1> 	push	ax								; Push high order digits, or port address, or N/A
 12637 00000957 52                  <1> 	push	dx								; Push low order digit, or N/A
 12638                              <1> 
 12639 00000958 BE[B700]            <1> 	mov		si, g_szDetectOuter				; Load SI with default wrapper string "IDE %s at %s: "
 12640                              <1> 
 12641 0000095B EB4C                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
 12642                              <1> 
 12643                              <1> 
 12644                              <1> ;--------------------------------------------------------------------
 12645                              <1> ; DetectPrint_DriveNameFromDrvDetectInfoInESBX
 12646                              <1> ;	Parameters:
 12647                              <1> ;		ES:BX:	Ptr to DRVDETECTINFO (if drive found)
 12648                              <1> ;	Returns:
 12649                              <1> ;		Nothing
 12650                              <1> ;	Corrupts registers:
 12651                              <1> ;		AX, SI, DI
 12652                              <1> ;--------------------------------------------------------------------
 12653                              <1> DetectPrint_DriveNameFromDrvDetectInfoInESBX:
 12654 0000095D 55                  <1> 	push	bp
 12655 0000095E 89E5                <1> 	mov		bp,sp
 12656 00000960 8D37                <1> 	lea		si,[bx+DRVDETECTINFO.szDrvName]
 12657 00000962 56                  <1> 	push	si
 12658 00000963 BE[F600]            <1> 	mov		si,g_szDriveName
 12659 00000966 EB41                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
 12660                              <1> 
 12661                              <1> 
 12662                              <1> ;--------------------------------------------------------------------
 12663                              <1> ; Prints BIOS name and segment address where it is found.
 12664                              <1> ;
 12665                              <1> ; DetectPrint_RomFoundAtSegment
 12666                              <1> ;	Parameters:
 12667                              <1> ;		Nothing
 12668                              <1> ;	Returns:
 12669                              <1> ;		Nothing
 12670                              <1> ;	Corrupts registers:
 12671                              <1> ;		AX, SI, DI
 12672                              <1> ;--------------------------------------------------------------------
 12673                              <1> DetectPrint_RomFoundAtSegment:
 12674 00000968 BE[D700]            <1> 	mov		si, g_szRomAt
 12675 0000096B 8CCF                <1> 	mov		di, cs						; BIOS segment address, for later inclusion in the output, parameterized
 12676                              <1> 										; so that it can be a different value when using .BootMenuEntry
 12677                              <1> 
 12678                              <1> .BootMenuEntry:
 12679 0000096D 55                  <1> 	push	bp
 12680 0000096E 89E5                <1> 	mov		bp, sp
 12681                              <1> 
 12682                              <1> %ifndef USE_186
 12683 00000970 B80E00              <1> 	mov		ax, ROMVARS.szTitle
 12684 00000973 50                  <1> 	push	ax
 12685 00000974 57                  <1> 	push	di							; BIOS segment
 12686 00000975 041F                <1> 	add		al, ROMVARS.szVersion - ROMVARS.szTitle
 12687 00000977 50                  <1> 	push	ax
 12688                              <1> %else
 12689                              <1> 	; szTitle and szVersion have the high order byte of their addresses zero,
 12690                              <1> 	; so these push instructions are only 2 bytes
 12691                              <1> 	;
 12692                              <1> 	push	ROMVARS.szTitle
 12693                              <1> 	push	di							; BIOS segment
 12694                              <1> 	push	ROMVARS.szVersion
 12695                              <1> %endif
 12696                              <1> 
 12697 00000978 EB2F                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
 12698                              <1> 
 12699                              <1> 
 12700                              <1> ;--------------------------------------------------------------------
 12701                              <1> ; DetectPrint_FailedToLoadFirstSector
 12702                              <1> ;	Parameters:
 12703                              <1> ;		AH:		INT 13h error code
 12704                              <1> ;	Returns:
 12705                              <1> ;		CF:		Set
 12706                              <1> ;	Corrupts registers:
 12707                              <1> ;		AX, CX, SI, DI
 12708                              <1> ;--------------------------------------------------------------------
 12709                              <1> DetectPrint_FailedToLoadFirstSector:
 12710 0000097A 55                  <1> 	push	bp
 12711 0000097B 89E5                <1> 	mov		bp, sp
 12712                              <1> 	eMOVZX	cx, ah
 12713                              <2> %ifndef USE_386
 12714                              <2>  %ifidni %1, ax
 12715                              <2>  mov al, %2
 12716                              <2>  xor ah, ah
 12717                              <2>  %elifidni %1, bx
 12718                              <2>  mov bl, %2
 12719                              <2>  xor bh, bh
 12720                              <2>  %elifidni %1, cx
 12721 0000097D 88E1                <2>  mov cl, %2
 12722 0000097F 30ED                <2>  xor ch, ch
 12723                              <2>  %elifidni %1, dx
 12724                              <2>  mov dl, %2
 12725                              <2>  xor dh, dh
 12726                              <2>  %else
 12727                              <2>  push ax
 12728                              <2>  mov al, %2
 12729                              <2>  xor ah, ah
 12730                              <2>  xchg ax, %1
 12731                              <2>  pop ax
 12732                              <2>  %endif
 12733                              <2> 
 12734                              <2> %else
 12735                              <2>  movzx %1, %2
 12736                              <2> %endif
 12737 00000981 51                  <1> 	push	cx					; Push INT 13h error code
 12738 00000982 BE[1601]            <1> 	mov		si, g_szReadError
 12739 00000985 EB22                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP	; Sets CF
 12740                              <1> 
 12741                              <1> 
 12742                              <1> ;--------------------------------------------------------------------
 12743                              <1> ; DetectPrint_TryToBootFromDL
 12744                              <1> ;	Parameters:
 12745                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
 12746                              <1> ;		DS:		RAMVARS segment
 12747                              <1> ;	Returns:
 12748                              <1> ;		Nothing
 12749                              <1> ;	Corrupts registers:
 12750                              <1> ;		AX, DH, SI, DI
 12751                              <1> ;--------------------------------------------------------------------
 12752                              <1> DetectPrint_TryToBootFromDL:
 12753 00000987 55                  <1> 	push	bp
 12754 00000988 89E5                <1> 	mov		bp, sp
 12755                              <1> 
 12756                              <1> %ifdef MODULE_DRIVEXLATE
 12757                              <1> 
 12758 0000098A E84301              <1> 	call	DriveXlate_ToOrBack	; DL = Untranslated Drive number
 12759 0000098D 88D6                <1> 	mov		dh, dl
 12760 0000098F E83E01              <1> 	call	DriveXlate_ToOrBack	; DL = Translated Drive number
 12761                              <1> 
 12762 00000992 E81F01              <1> 	call	DriveXlate_ConvertDriveNumberFromDLtoDriveLetter	; DL = Translated letter
 12763 00000995 86D6                <1> 	xchg	dl, dh
 12764 00000997 E81A01              <1> 	call	DriveXlate_ConvertDriveNumberFromDLtoDriveLetter	; DL = Untranslated letter
 12765 0000099A 52                  <1> 	push	dx
 12766 0000099B 86D6                <1> 	xchg	dl, dh
 12767 0000099D 52                  <1> 	push	dx
 12768                              <1> 
 12769 0000099E E80201              <1> 	call	DriveXlate_ConvertDriveLetterInDLtoDriveNumber	; Restore DL
 12770                              <1> 
 12771                              <1> %else
 12772                              <1> 	ePUSH_T	ax, ' '			; No drive translation so print space
 12773                              <1> 
 12774                              <1> 	; Get boot drive letters
 12775                              <1> 	call	FloppyDrive_GetCountToAX
 12776                              <1> 	mov		ah, 'A'			; AH = First Floppy Drive letter (always 'A')
 12777                              <1> 	add		al, ah
 12778                              <1> 	MAX_U	al, 'C'			; AL = First Hard Drive letter ('C', 'D', or 'E')
 12779                              <1> 	test	dl, dl
 12780                              <1> 	eCMOVNS	al, ah
 12781                              <1> 	push	ax
 12782                              <1> 
 12783                              <1> %endif ; MODULE_DRIVEXLATE
 12784                              <1> 
 12785 000009A1 BE[F800]            <1> 	mov		si, g_szTryToBoot
 12786 000009A4 EB03                <1> 	jmp		SHORT DetectPrint_FormatCSSIfromParamsInSSBP
 12787                              <1> 
 12788                              <1> 
 12789                              <1> ;--------------------------------------------------------------------
 12790                              <1> ; DetectPrint_NullTerminatedStringFromCSSI
 12791                              <1> ; DetectPrint_NullTerminatedStringFromCSSIandSetCF
 12792                              <1> ;	Parameters:
 12793                              <1> ;		CS:SI:	Ptr to NULL terminated string to print
 12794                              <1> ;	Returns:
 12795                              <1> ;		CF:		Set since menu event was handled successfully
 12796                              <1> ;	Corrupts registers:
 12797                              <1> ;		AX, DI
 12798                              <1> ;--------------------------------------------------------------------
 12799                              <1> DetectPrint_NullTerminatedStringFromCSSI:
 12800                              <1> DetectPrint_NullTerminatedStringFromCSSIandSetCF:
 12801                              <1> ;
 12802                              <1> ; We send all CSSI strings through the Format routine for the case of
 12803                              <1> ; compressed strings, but this doesn't hurt in the non-compressed case either
 12804                              <1> ; (perhaps a little slower, but shouldn't be noticeable to the user)
 12805                              <1> ; and results in smaller code size.
 12806                              <1> ;
 12807 000009A6 55                  <1> 	push	bp
 12808 000009A7 89E5                <1> 	mov		bp,sp
 12809                              <1> 	; Fall to DetectPrint_FormatCSSIfromParamsInSSBP
 12810                              <1> 
 12811                              <1> ;--------------------------------------------------------------------
 12812                              <1> ; DetectPrint_FormatCSSIfromParamsInSSBP
 12813                              <1> ;	Parameters:
 12814                              <1> ;		CS:SI:	Ptr to string to format
 12815                              <1> ;		BP:		SP before pushing parameters
 12816                              <1> ;	Returns:
 12817                              <1> ;		BP:		Popped from stack
 12818                              <1> ;		CF:		Set since menu event was handled successfully
 12819                              <1> ;	Corrupts registers:
 12820                              <1> ;		AX, DI
 12821                              <1> ;--------------------------------------------------------------------
 12822                              <1> DetectPrint_FormatCSSIfromParamsInSSBP:
 12823                              <1> 	CALL_DISPLAY_LIBRARY FormatNullTerminatedStringFromCSSI
 12824                              <2>  %ifidn %1, PushDisplayContext
 12825                              <2>  call DisplayContext_Push
 12826                              <2>  %elifidn %1, PopDisplayContext
 12827                              <2>  call DisplayContext_Pop
 12828                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
 12829                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
 12830                              <2>  %else
 12831 000009A9 BF[A501]            <2>  mov di, %1
 12832 000009AC E8DEF7              <2>  call Display_FunctionFromDI
 12833                              <2>  %endif
 12834 000009AF F9                  <1> 	stc				; Successful return from menu event
 12835 000009B0 5D                  <1> 	pop		bp
 12836 000009B1 C3                  <1> 	ret
 12837                                  
 12838                                  	; Hotkey Bar
 12839                                  %ifdef MODULE_HOTKEYS
 12840                                  	%include "HotkeyBar.asm"		; For hotkeys during drive detection and boot menu
 12841                              <1> ; Project name	:	XTIDE Universal BIOS
 12842                              <1> ; Description	:	Hotkey Bar related functions.
 12843                              <1> 
 12844                              <1> ;
 12845                              <1> ; XTIDE Universal BIOS and Associated Tools
 12846                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 12847                              <1> ;
 12848                              <1> ; This program is free software; you can redistribute it and/or modify
 12849                              <1> ; it under the terms of the GNU General Public License as published by
 12850                              <1> ; the Free Software Foundation; either version 2 of the License, or
 12851                              <1> ; (at your option) any later version.
 12852                              <1> ;
 12853                              <1> ; This program is distributed in the hope that it will be useful,
 12854                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 12855                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 12856                              <1> ; GNU General Public License for more details.
 12857                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 12858                              <1> ;
 12859                              <1> 
 12860                              <1> ; Section containing code
 12861                              <1> SECTION .text
 12862                              <1> 
 12863                              <1> ;--------------------------------------------------------------------
 12864                              <1> ; Scans key presses and draws any hotkey changes.
 12865                              <1> ;
 12866                              <1> ; HotkeyBar_UpdateDuringDriveDetection
 12867                              <1> ;	Parameters:
 12868                              <1> ;		DS:		RAMVARS segment
 12869                              <1> ;		ES:		BDA segment (zero)
 12870                              <1> ;	Returns:
 12871                              <1> ;		Nothing
 12872                              <1> ;	Corrupts registers:
 12873                              <1> ;		AX, CX, DX, SI, DI
 12874                              <1> ;--------------------------------------------------------------------
 12875                              <1> HotkeyBar_UpdateDuringDriveDetection:
 12876 000009B2 E8A600              <1> 	call	ScanHotkeysFromKeyBufferAndStoreToBootvars
 12877                              <1> 	; Fall to HotkeyBar_DrawToTopOfScreen
 12878                              <1> 
 12879                              <1> 
 12880                              <1> ;--------------------------------------------------------------------
 12881                              <1> ; HotkeyBar_DrawToTopOfScreen
 12882                              <1> ;	Parameters:
 12883                              <1> ;		DS:		RAMVARS segment
 12884                              <1> ;		ES:		BDA segment (zero)
 12885                              <1> ;	Returns:
 12886                              <1> ;		Nothing
 12887                              <1> ;	Corrupts registers:
 12888                              <1> ;		AX, CX, DX, SI, DI
 12889                              <1> ;--------------------------------------------------------------------
 12890                              <1> HotkeyBar_DrawToTopOfScreen:
 12891                              <1> 	; Store current screen coordinates to be restored
 12892                              <1> 	; when Hotkey Bar is rendered
 12893 000009B5 E863FF              <1> 	call	DetectPrint_GetSoftwareCoordinatesToAX
 12894 000009B8 50                  <1> 	push	ax
 12895                              <1> 
 12896 000009B9 E88C00              <1> 	call	MoveCursorToScreenTopLeftCorner
 12897                              <1> 	; Fall to .PrintFloppyDriveHotkeys
 12898                              <1> 
 12899                              <1> ;--------------------------------------------------------------------
 12900                              <1> ; .PrintFloppyDriveHotkeys
 12901                              <1> ;	Parameters:
 12902                              <1> ;		DS:		RAMVARS segment
 12903                              <1> ;		ES:		BDA segment (zero)
 12904                              <1> ;	Returns:
 12905                              <1> ;		Nothing
 12906                              <1> ;	Corrupts registers:
 12907                              <1> ;		AX, CX, DX, SI, DI
 12908                              <1> ;--------------------------------------------------------------------
 12909                              <1> .PrintFloppyDriveHotkeys:
 12910 000009BC E890FB              <1> 	call	FloppyDrive_GetCountToAX
 12911 000009BF 85C0                <1> 	test	ax, ax		; Any Floppy Drives?
 12912 000009C1 740E                <1> 	jz		SHORT .SkipFloppyDriveHotkeys
 12913                              <1> 
 12914 000009C3 B841AF              <1> 	mov		ax, (ANGLE_QUOTE_RIGHT << 8) | DEFAULT_FLOPPY_DRIVE_LETTER
 12915 000009C6 268A0E087F          <1> 	mov		cl, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bFddLetter]
 12916 000009CB BF[1E01]            <1> 	mov		di, g_szFDD
 12917 000009CE E85000              <1> 	call	FormatDriveHotkeyString
 12918                              <1> 
 12919                              <1> .SkipFloppyDriveHotkeys:
 12920                              <1> 	; Fall to .PrintHardDriveHotkeys
 12921                              <1> 
 12922                              <1> ;--------------------------------------------------------------------
 12923                              <1> ; .PrintHardDriveHotkeys
 12924                              <1> ;	Parameters:
 12925                              <1> ;		DS:		RAMVARS segment
 12926                              <1> ;		ES:		BDA segment (zero)
 12927                              <1> ;	Returns:
 12928                              <1> ;		Nothing
 12929                              <1> ;	Corrupts registers:
 12930                              <1> ;		AX, CX, DX, SI, DI
 12931                              <1> ;--------------------------------------------------------------------
 12932 000009D1 E8F000              <1> 	call	DriveXlate_GetLetterForFirstHardDriveToAX
 12933 000009D4 B4AF                <1> 	mov		ah, ANGLE_QUOTE_RIGHT
 12934 000009D6 268A0E097F          <1> 	mov		cl, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bHddLetter]
 12935 000009DB BF[2401]            <1> 	mov		di, g_szHDD
 12936 000009DE E84000              <1> 	call	FormatDriveHotkeyString
 12937                              <1> 	; Fall to .PrintBootMenuHotkey
 12938                              <1> 
 12939                              <1> ;--------------------------------------------------------------------
 12940                              <1> ; .PrintBootMenuHotkey
 12941                              <1> ;	Parameters:
 12942                              <1> ;		ES:		BDA segment (zero)
 12943                              <1> ;	Returns:
 12944                              <1> ;		Nothing
 12945                              <1> ;	Corrupts registers:
 12946                              <1> ;		AX, CX, DX, SI, DI
 12947                              <1> ;--------------------------------------------------------------------
 12948                              <1> .PrintBootMenuHotkey:
 12949                              <1> %ifdef MODULE_BOOT_MENU
 12950                              <1> 	mov		ax, BOOT_MENU_HOTKEY_SCANCODE | ('2' << 8)
 12951                              <1> 	mov		di, g_szBootMenu
 12952                              <1> 	call	FormatFunctionHotkeyString
 12953                              <1> %endif
 12954                              <1> 	; Fall to .PrintComDetectHotkey
 12955                              <1> 
 12956                              <1> ;--------------------------------------------------------------------
 12957                              <1> ; .PrintComDetectHotkey
 12958                              <1> ;	Parameters:
 12959                              <1> ;		ES:		BDA segment (zero)
 12960                              <1> ;	Returns:
 12961                              <1> ;		Nothing
 12962                              <1> ;	Corrupts registers:
 12963                              <1> ;		AX, CX, DX, SI, DI
 12964                              <1> ;--------------------------------------------------------------------
 12965                              <1> .PrintComDetectHotkey:
 12966                              <1> %ifdef MODULE_SERIAL
 12967 000009E1 B84036              <1> 	mov		ax, COM_DETECT_HOTKEY_SCANCODE | ('6' << 8)
 12968 000009E4 BF[3101]            <1> 	mov		di, g_szHotComDetect
 12969 000009E7 E82900              <1> 	call	FormatFunctionHotkeyString
 12970                              <1> %endif
 12971                              <1> 	; Fall to .PrintRomBootHotkey
 12972                              <1> 
 12973                              <1> ;--------------------------------------------------------------------
 12974                              <1> ; .PrintRomBootHotkey
 12975                              <1> ;	Parameters:
 12976                              <1> ;		ES:		BDA segment (zero)
 12977                              <1> ;	Returns:
 12978                              <1> ;		Nothing
 12979                              <1> ;	Corrupts registers:
 12980                              <1> ;		AX, CX, DX, SI, DI
 12981                              <1> ;--------------------------------------------------------------------
 12982                              <1> .PrintRomBootHotkey:
 12983 000009EA B84238              <1> 	mov		ax, ROM_BOOT_HOTKEY_SCANCODE | ('8' << 8)
 12984 000009ED BF[3901]            <1> 	mov		di, g_szRomBoot
 12985 000009F0 E82000              <1> 	call	FormatFunctionHotkeyString
 12986                              <1> 	; Fall to .EndHotkeyBarRendering
 12987                              <1> 
 12988                              <1> ;--------------------------------------------------------------------
 12989                              <1> ; .EndHotkeyBarRendering
 12990                              <1> ;	Parameters:
 12991                              <1> ;		Stack:	Screen coordinates before drawing Hotkey Bar
 12992                              <1> ;	Returns:
 12993                              <1> ;		Nothing
 12994                              <1> ;	Corrupts registers:
 12995                              <1> ;		AX, CX, DI
 12996                              <1> ;--------------------------------------------------------------------
 12997                              <1> .EndHotkeyBarRendering:
 12998 000009F3 E80300              <1> 	call	HotkeyBar_ClearRestOfTopRow
 12999 000009F6 58                  <1> 	pop		ax
 13000 000009F7 EB51                <1> 	jmp		SHORT HotkeyBar_RestoreCursorCoordinatesFromAX
 13001                              <1> 
 13002                              <1> 
 13003                              <1> ;--------------------------------------------------------------------
 13004                              <1> ; HotkeyBar_ClearRestOfTopRow
 13005                              <1> ;	Parameters:
 13006                              <1> ;		Nothing
 13007                              <1> ;	Returns:
 13008                              <1> ;		Nothing
 13009                              <1> ;	Corrupts registers:
 13010                              <1> ;		AX, CX, DI
 13011                              <1> ;--------------------------------------------------------------------
 13012                              <1> HotkeyBar_ClearRestOfTopRow:
 13013                              <1> 	CALL_DISPLAY_LIBRARY GetColumnsToALandRowsToAH
 13014                              <2>  %ifidn %1, PushDisplayContext
 13015                              <2>  call DisplayContext_Push
 13016                              <2>  %elifidn %1, PopDisplayContext
 13017                              <2>  call DisplayContext_Pop
 13018                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
 13019                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
 13020                              <2>  %else
 13021 000009F9 BF[9402]            <2>  mov di, %1
 13022 000009FC E88EF7              <2>  call Display_FunctionFromDI
 13023                              <2>  %endif
 13024                              <1> 	eMOVZX	cx, al
 13025                              <2> %ifndef USE_386
 13026                              <2>  %ifidni %1, ax
 13027                              <2>  mov al, %2
 13028                              <2>  xor ah, ah
 13029                              <2>  %elifidni %1, bx
 13030                              <2>  mov bl, %2
 13031                              <2>  xor bh, bh
 13032                              <2>  %elifidni %1, cx
 13033 000009FF 88C1                <2>  mov cl, %2
 13034 00000A01 30ED                <2>  xor ch, ch
 13035                              <2>  %elifidni %1, dx
 13036                              <2>  mov dl, %2
 13037                              <2>  xor dh, dh
 13038                              <2>  %else
 13039                              <2>  push ax
 13040                              <2>  mov al, %2
 13041                              <2>  xor ah, ah
 13042                              <2>  xchg ax, %1
 13043                              <2>  pop ax
 13044                              <2>  %endif
 13045                              <2> 
 13046                              <2> %else
 13047                              <2>  movzx %1, %2
 13048                              <2> %endif
 13049                              <1> 	CALL_DISPLAY_LIBRARY GetSoftwareCoordinatesToAX
 13050                              <2>  %ifidn %1, PushDisplayContext
 13051                              <2>  call DisplayContext_Push
 13052                              <2>  %elifidn %1, PopDisplayContext
 13053                              <2>  call DisplayContext_Pop
 13054                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
 13055                              <2>  call DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
 13056                              <2>  %else
 13057 00000A03 BF[5102]            <2>  mov di, %1
 13058 00000A06 E884F7              <2>  call Display_FunctionFromDI
 13059                              <2>  %endif
 13060 00000A09 28C1                <1> 	sub		cl, al
 13061 00000A0B B020                <1> 	mov		al, ' '
 13062                              <1> 	JMP_DISPLAY_LIBRARY PrintRepeatedCharacterFromALwithCountInCX
 13063                              <2>  %ifidn %1, PushDisplayContext
 13064                              <2>  jmp DisplayContext_Push
 13065                              <2>  %elifidn %1, PopDisplayContext
 13066                              <2>  call DisplayContext_Pop
 13067                              <2>  ret
 13068                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
 13069                              <2>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
 13070                              <2>  %elifidn %1, FormatNullTerminatedStringFromCSSI
 13071                              <2>  mov di, %1
 13072                              <2>  call Display_FunctionFromDI
 13073                              <2>  ret
 13074                              <2>  %else
 13075 00000A0D BF[C402]            <2>  mov di, %1
 13076 00000A10 E97AF7              <2>  jmp Display_FunctionFromDI
 13077                              <2>  %endif
 13078                              <1> 
 13079                              <1> 
 13080                              <1> ;--------------------------------------------------------------------
 13081                              <1> ; FormatDriveHotkeyString
 13082                              <1> ;	Parameters:
 13083                              <1> ;		CL:			Drive letter hotkey from BOOTVARS
 13084                              <1> ;		AL:			First character for drive key string
 13085                              <1> ;		AH:			Second character for drive key string (ANGLE_QUOTE_RIGHT)
 13086                              <1> ;		SI:			Offset to hotkey description string
 13087                              <1> ;		ES:			BDA segment (zero)
 13088                              <1> ;	Returns:
 13089                              <1> ;		Nothing
 13090                              <1> ;	Corrupts registers:
 13091                              <1> ;		AX, CX, DX, SI, DI
 13092                              <1> ;--------------------------------------------------------------------
 13093                              <1> ;; No work to do before going into FormatFunctionHotkeyString
 13094                              <1> FormatDriveHotkeyString  equ  GetNonSelectedHotkeyDescriptionAttributeToDX
 13095                              <1> 
 13096                              <1> ;--------------------------------------------------------------------
 13097                              <1> ; FormatFunctionHotkeyString
 13098                              <1> ;	Parameters:
 13099                              <1> ;		AL:			Scancode of function key, to know which if any to show as selected
 13100                              <1> ;					Later replaced with an 'F' for the call to the output routine
 13101                              <1> ;		AH:			Second character for drive key string
 13102                              <1> ;		SI:			Offset to hotkey description string
 13103                              <1> ;		ES:			BDA segment (zero)
 13104                              <1> ;	Returns:
 13105                              <1> ;		Nothing
 13106                              <1> ;	Corrupts registers:
 13107                              <1> ;		AX, CX, DX, SI, DI
 13108                              <1> ;--------------------------------------------------------------------
 13109                              <1> FormatFunctionHotkeyString:
 13110 00000A13 31C9                <1> 	xor		cx, cx		; Null character, eaten in output routines
 13111                              <1> 
 13112 00000A15 2638060B7F          <1> 	cmp		[es:BOOTVARS.hotkeyVars+HOTKEYVARS.bScancode], al
 13113 00000A1A B046                <1> 	mov		al, 'F'		; Replace scancode with character for output
 13114                              <1> 
 13115                              <1> %ifdef MODULE_BOOT_MENU
 13116                              <1> 
 13117                              <1> 	mov		si, ATTRIBUTE_CHARS.cHurryTimeout		; Selected hotkey
 13118                              <1> 	je		SHORT GetDescriptionAttributeToDX		; From compare with bScancode above
 13119                              <1> 
 13120                              <1> GetNonSelectedHotkeyDescriptionAttributeToDX:
 13121                              <1> 	mov		si, ATTRIBUTE_CHARS.cHighlightedItem	; Unselected hotkey
 13122                              <1> 
 13123                              <1> 	; Display Library should not be called like this
 13124                              <1> GetDescriptionAttributeToDX:
 13125                              <1> 	xchg	dx, ax
 13126                              <1> 	call	MenuAttribute_GetToAXfromTypeInSI
 13127                              <1> 	xchg	dx, ax					; DX = Description attribute
 13128                              <1> 	;;  fall through to PushHotkeyParamsAndFormat
 13129                              <1> 
 13130                              <1> 
 13131                              <1> %else ; if no MODULE_BOOT_MENU - No boot menu so use simpler attributes
 13132                              <1> 
 13133 00000A1C BAF03E              <1> 	mov		dx, (COLOR_ATTRIBUTE(COLOR_YELLOW, COLOR_CYAN) << 8) | MONO_REVERSE_BLINK
 13134 00000A1F 7403                <1> 	je		SHORT SelectAttributeFromDHorDLbasedOnVideoMode		; From compare with bScancode above
 13135                              <1> 
 13136                              <1> GetNonSelectedHotkeyDescriptionAttributeToDX:
 13137 00000A21 BA7030              <1> 	mov		dx, (COLOR_ATTRIBUTE(COLOR_BLACK, COLOR_CYAN) << 8) | MONO_REVERSE
 13138                              <1> 
 13139                              <1> SelectAttributeFromDHorDLbasedOnVideoMode:
 13140 00000A24 268A2E4904          <1> 	mov		ch, [es:BDA.bVidMode]		; We only need to preserve CL
 13141 00000A29 D0ED                <1> 	shr		ch, 1
 13142 00000A2B 7306                <1> 	jnc		SHORT .AttributeLoadedToDL	; Black & White modes
 13143 00000A2D D0ED                <1> 	shr		ch, 1
 13144 00000A2F 7502                <1> 	jnz		SHORT .AttributeLoadedToDL	; MDA
 13145 00000A31 88F2                <1> 	mov		dl, dh
 13146                              <1> .AttributeLoadedToDL:
 13147                              <1> 	;;  fall through to PushHotkeyParamsAndFormat
 13148                              <1> 
 13149                              <1> %endif ; MODULE_BOOT_MENU
 13150                              <1> 
 13151                              <1> 
 13152                              <1> ;--------------------------------------------------------------------
 13153                              <1> ; PushHotkeyParamsAndFormat
 13154                              <1> ;	Parameters:
 13155                              <1> ;		AL:			First character
 13156                              <1> ;		AH:			Second character
 13157                              <1> ;		DX:			Description Attribute
 13158                              <1> ;		CX:			Description string parameter
 13159                              <1> ;		CS:DI:		Description string
 13160                              <1> ;	Returns:
 13161                              <1> ;		Nothing
 13162                              <1> ;	Corrupts registers:
 13163                              <1> ;		AX, SI, DI
 13164                              <1> ;--------------------------------------------------------------------
 13165                              <1> PushHotkeyParamsAndFormat:
 13166 00000A33 55                  <1> 	push	bp
 13167 00000A34 89E5                <1> 	mov		bp, sp
 13168                              <1> 
 13169 00000A36 BE0F00              <1> 	mov		si, MONO_BRIGHT
 13170                              <1> 
 13171 00000A39 56                  <1> 	push	si				; Key attribute
 13172 00000A3A 50                  <1> 	push	ax				; First Character
 13173 00000A3B 88E0                <1> 	mov		al, ah
 13174 00000A3D 50                  <1> 	push	ax				; Second Character
 13175                              <1> 
 13176 00000A3E 52                  <1> 	push	dx				; Description attribute
 13177 00000A3F 57                  <1> 	push	di				; Description string
 13178 00000A40 51                  <1> 	push	cx				; Description string parameter
 13179                              <1> 
 13180 00000A41 56                  <1> 	push	si				; Key attribute for last space
 13181                              <1> 
 13182 00000A42 BE[2A01]            <1> 	mov		si, g_szHotkey
 13183 00000A45 E961FF              <1> 	jmp		DetectPrint_FormatCSSIfromParamsInSSBP
 13184                              <1> 
 13185                              <1> 
 13186                              <1> ;--------------------------------------------------------------------
 13187                              <1> ; MoveCursorToScreenTopLeftCorner
 13188                              <1> ;	Parameters:
 13189                              <1> ;		Nothing
 13190                              <1> ;	Returns:
 13191                              <1> ;		Nothing
 13192                              <1> ;	Corrupts registers:
 13193                              <1> ;		AX, DI
 13194                              <1> ;--------------------------------------------------------------------
 13195                              <1> MoveCursorToScreenTopLeftCorner:
 13196 00000A48 31C0                <1> 	xor		ax, ax			; Top left corner (0, 0)
 13197                              <1> 	; Fall to HotkeyBar_RestoreCursorCoordinatesFromAX
 13198                              <1> 
 13199                              <1> 
 13200                              <1> ;--------------------------------------------------------------------
 13201                              <1> ; HotkeyBar_RestoreCursorCoordinatesFromAX
 13202                              <1> ;	Parameters:
 13203                              <1> ;		Nothing
 13204                              <1> ;	Returns:
 13205                              <1> ;		Nothing
 13206                              <1> ;	Corrupts registers:
 13207                              <1> ;		AX, DI
 13208                              <1> ;--------------------------------------------------------------------
 13209                              <1> HotkeyBar_RestoreCursorCoordinatesFromAX:
 13210                              <1> 	JMP_DISPLAY_LIBRARY SetCursorCoordinatesFromAX
 13211                              <2>  %ifidn %1, PushDisplayContext
 13212                              <2>  jmp DisplayContext_Push
 13213                              <2>  %elifidn %1, PopDisplayContext
 13214                              <2>  call DisplayContext_Pop
 13215                              <2>  ret
 13216                              <2>  %elifidn %1, PrepareOffScreenBufferInESBXwithLengthInCX
 13217                              <2>  jmp DisplayContext_PrepareOffScreenBufferInESBXwithLengthInCX
 13218                              <2>  %elifidn %1, FormatNullTerminatedStringFromCSSI
 13219                              <2>  mov di, %1
 13220                              <2>  call Display_FunctionFromDI
 13221                              <2>  ret
 13222                              <2>  %else
 13223 00000A4A BF[3C02]            <2>  mov di, %1
 13224 00000A4D E93DF7              <2>  jmp Display_FunctionFromDI
 13225                              <2>  %endif
 13226                              <1> 
 13227                              <1> 
 13228                              <1> ;--------------------------------------------------------------------
 13229                              <1> ; HotkeyBar_StoreHotkeyToBootvarsForDriveNumberInDL
 13230                              <1> ;	Parameters:
 13231                              <1> ;		DS:		RAMVARS segment
 13232                              <1> ;		ES:		BDA segment (zero)
 13233                              <1> ;		DL:		Drive Number
 13234                              <1> ;	Returns:
 13235                              <1> ;		Nothing
 13236                              <1> ;	Corrupts registers:
 13237                              <1> ;		AX, CX, DL, DI
 13238                              <1> ;--------------------------------------------------------------------
 13239                              <1> HotkeyBar_StoreHotkeyToBootvarsForDriveNumberInDL:
 13240 00000A50 E86100              <1> 	call	DriveXlate_ConvertDriveNumberFromDLtoDriveLetter
 13241                              <1> 	; Fall to StoreHotkeyToBootvarsForDriveLetterInDL
 13242                              <1> 
 13243                              <1> 
 13244                              <1> ;--------------------------------------------------------------------
 13245                              <1> ; StoreHotkeyToBootvarsForDriveLetterInDL
 13246                              <1> ;	Parameters:
 13247                              <1> ;		DS:		RAMVARS segment
 13248                              <1> ;		ES:		BDA segment (zero)
 13249                              <1> ;		DL:		Drive Letter ('A'...)
 13250                              <1> ;	Returns:
 13251                              <1> ;		Nothing
 13252                              <1> ;	Corrupts registers:
 13253                              <1> ;		AX, CX, DI
 13254                              <1> ;--------------------------------------------------------------------
 13255                              <1> StoreHotkeyToBootvarsForDriveLetterInDL:
 13256                              <1> 	eMOVZX	ax, dl
 13257                              <2> %ifndef USE_386
 13258                              <2>  %ifidni %1, ax
 13259 00000A53 88D0                <2>  mov al, %2
 13260 00000A55 30E4                <2>  xor ah, ah
 13261                              <2>  %elifidni %1, bx
 13262                              <2>  mov bl, %2
 13263                              <2>  xor bh, bh
 13264                              <2>  %elifidni %1, cx
 13265                              <2>  mov cl, %2
 13266                              <2>  xor ch, ch
 13267                              <2>  %elifidni %1, dx
 13268                              <2>  mov dl, %2
 13269                              <2>  xor dh, dh
 13270                              <2>  %else
 13271                              <2>  push ax
 13272                              <2>  mov al, %2
 13273                              <2>  xor ah, ah
 13274                              <2>  xchg ax, %1
 13275                              <2>  pop ax
 13276                              <2>  %endif
 13277                              <2> 
 13278                              <2> %else
 13279                              <2>  movzx %1, %2
 13280                              <2> %endif
 13281 00000A57 0C20                <1> 	or		al, 32	; Upper case drive letter to lower case keystroke
 13282 00000A59 EB09                <1> 	jmp		SHORT HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX
 13283                              <1> 
 13284                              <1> 
 13285                              <1> ;--------------------------------------------------------------------
 13286                              <1> ; ScanHotkeysFromKeyBufferAndStoreToBootvars
 13287                              <1> ;	Parameters:
 13288                              <1> ;		DS:		RAMVARS segment
 13289                              <1> ;		ES:		BDA segment (zero)
 13290                              <1> ;	Returns:
 13291                              <1> ;		AL:		Last scancode value
 13292                              <1> ;	Corrupts registers:
 13293                              <1> ;		AH, CX
 13294                              <1> ;--------------------------------------------------------------------
 13295                              <1> ScanHotkeysFromKeyBufferAndStoreToBootvars:
 13296 00000A5B E831F9              <1> 	call	Keyboard_GetKeystrokeToAX
 13297 00000A5E 742A                <1> 	jz		SHORT NoHotkeyToProcess
 13298                              <1> 
 13299                              <1> 	; Prepare to read another key from buffer
 13300                              <1> 	ePUSH_T	cx, ScanHotkeysFromKeyBufferAndStoreToBootvars
 13301                              <2> %ifndef USE_186
 13302                              <2>  %ifidni %2, 0
 13303                              <2>  xor %1, %1
 13304                              <2>  %else
 13305 00000A60 B9[5B0A]            <2>  mov %1, %2
 13306                              <2>  %endif
 13307 00000A63 51                  <2>  push %1
 13308                              <2> 
 13309                              <2> %else
 13310                              <2>  push %2
 13311                              <2> %endif
 13312                              <1> 	; Fall to HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX
 13313                              <1> 
 13314                              <1> 
 13315                              <1> ;--------------------------------------------------------------------
 13316                              <1> ; HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX
 13317                              <1> ;	Parameters:
 13318                              <1> ;		AL:		Hotkey ASCII code
 13319                              <1> ;		AH:		Hotkey Scancode
 13320                              <1> ;		DS:		RAMVARS segment
 13321                              <1> ;		ES:		BDA segment (zero)
 13322                              <1> ;	Returns:
 13323                              <1> ;       AL:     Last scancode seen
 13324                              <1> ;		CF:		Set if valid hotkey in AL
 13325                              <1> ;				Clear if scancode in AL is not for any hotkey
 13326                              <1> ;	Corrupts registers:
 13327                              <1> ;		AH, CX, DI
 13328                              <1> ;--------------------------------------------------------------------
 13329                              <1> HotkeyBar_StoreHotkeyToBootvarsIfValidKeystrokeInAX:
 13330 00000A64 BF0B7F              <1> 	mov		di, BOOTVARS.hotkeyVars+HOTKEYVARS.bScancode
 13331                              <1> 
 13332                              <1> 	; All scancodes are saved, even if it wasn't a drive letter,
 13333                              <1> 	; which also covers our function key case.  Invalid function keys
 13334                              <1> 	; will not do anything (won't be printed, won't be accepted as input)
 13335 00000A67 268825              <1> 	mov		[es:di], ah
 13336                              <1> 
 13337                              <1> 	; Drive letter hotkeys remaining, allow 'a' to 'z'
 13338 00000A6A E82EF9              <1> 	call	Char_IsLowerCaseLetterInAL
 13339 00000A6D 731B                <1> 	jnc		SHORT .KeystrokeIsNotValidDriveLetter
 13340 00000A6F 24DF                <1> 	and		al, ~32					; We want to print upper case letters
 13341                              <1> 
 13342                              <1> 	; Clear HD First flag to assume Floppy Drive hotkey
 13343 00000A71 4F                  <1> 	dec		di
 13344 00000A72 268025FE            <1> 	and		BYTE [es:di], ~FLG_HOTKEY_HD_FIRST
 13345                              <1> 
 13346                              <1> 	; Determine if Floppy or Hard Drive hotkey
 13347 00000A76 91                  <1> 	xchg	cx, ax
 13348 00000A77 E84A00              <1> 	call	DriveXlate_GetLetterForFirstHardDriveToAX
 13349 00000A7A 38C1                <1> 	cmp		cl, al
 13350 00000A7C 7204                <1> 	jb		SHORT .StoreDriveLetter	; Store Floppy Drive letter
 13351                              <1> 
 13352                              <1> 	; Store Hard Drive letter
 13353 00000A7E 26800D01            <1> 	or		BYTE [es:di], FLG_HOTKEY_HD_FIRST
 13354                              <1> 
 13355                              <1> .StoreDriveLetter:
 13356 00000A82 83DF01              <1> 	sbb		di, BYTE 1				; Sub CF if Floppy Drive
 13357 00000A85 91                  <1> 	xchg	ax, cx
 13358 00000A86 268805              <1> 	mov		[es:di], al
 13359 00000A89 F9                  <1> 	stc								; Valid hotkey scancode returned in AL
 13360                              <1> 
 13361                              <1> .KeystrokeIsNotValidDriveLetter:
 13362                              <1> NoHotkeyToProcess:
 13363 00000A8A 26A00B7F            <1> 	mov		al, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bScancode]
 13364 00000A8E C3                  <1> 	ret
 13365                              <1> 
 13366                              <1> 
 13367                              <1> ;--------------------------------------------------------------------
 13368                              <1> ; HotkeyBar_GetBootDriveNumbersToDX
 13369                              <1> ;	Parameters:
 13370                              <1> ;		DS:		RAMVARS segment
 13371                              <1> ;		ES:		BDA segment (zero)
 13372                              <1> ;	Returns:
 13373                              <1> ;		DX:		Drives selected as boot device, DL is primary
 13374                              <1> ;	Corrupts registers:
 13375                              <1> ;		AX
 13376                              <1> ;--------------------------------------------------------------------
 13377                              <1> HotkeyBar_GetBootDriveNumbersToDX:
 13378 00000A8F 268B16087F          <1> 	mov		dx, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.wFddAndHddLetters]
 13379 00000A94 26F6060A7F01        <1> 	test	BYTE [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bFlags], FLG_HOTKEY_HD_FIRST
 13380 00000A9A 7502                <1> 	jnz		.noflip
 13381 00000A9C 86D6                <1> 	xchg	dl, dh
 13382                              <1> .noflip:
 13383 00000A9E E80200              <1> 	call	DriveXlate_ConvertDriveLetterInDLtoDriveNumber
 13384 00000AA1 86D6                <1> 	xchg	dl, dh
 13385                              <1> 	; Fall to HotkeyBar_FallThroughTo_DriveXlate_ConvertDriveLetterInDLtoDriveNumber
 13386                              <1> 
 13387                              <1> HotkeyBar_FallThroughTo_DriveXlate_ConvertDriveLetterInDLtoDriveNumber:
 13388                              <1> 
 13389                                  %endif
 13390                                  %ifdef MODULE_DRIVEXLATE
 13391                                  	%include "DriveXlate.asm"		; For swapping drive numbers, must come immediately after HotkeyBar.asm
 13392                              <1> ; Project name	:	XTIDE Universal BIOS
 13393                              <1> ; Description	:	Functions for swapping drive letters.
 13394                              <1> 
 13395                              <1> ;
 13396                              <1> ; XTIDE Universal BIOS and Associated Tools
 13397                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 13398                              <1> ;
 13399                              <1> ; This program is free software; you can redistribute it and/or modify
 13400                              <1> ; it under the terms of the GNU General Public License as published by
 13401                              <1> ; the Free Software Foundation; either version 2 of the License, or
 13402                              <1> ; (at your option) any later version.
 13403                              <1> ;
 13404                              <1> ; This program is distributed in the hope that it will be useful,
 13405                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 13406                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 13407                              <1> ; GNU General Public License for more details.
 13408                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 13409                              <1> ;
 13410                              <1> 
 13411                              <1> ; Section containing code
 13412                              <1> SECTION .text
 13413                              <1> 
 13414                              <1> ;--------------------------------------------------------------------
 13415                              <1> ; DriveXlate_ConvertDriveLetterInDLtoDriveNumber
 13416                              <1> ;	Parameters:
 13417                              <1> ;		DS:		RAMVARS segment
 13418                              <1> ;		DL:		Drive letter ('A'...)
 13419                              <1> ;	Returns:
 13420                              <1> ;		DL:		Drive number (0xh for Floppy Drives, 8xh for Hard Drives)
 13421                              <1> ;	Corrupts registers:
 13422                              <1> ;		AX
 13423                              <1> ;--------------------------------------------------------------------
 13424                              <1> DriveXlate_ConvertDriveLetterInDLtoDriveNumber:
 13425 00000AA3 E81E00              <1> 	call	DriveXlate_GetLetterForFirstHardDriveToAX
 13426 00000AA6 38C2                <1> 	cmp		dl, al
 13427 00000AA8 7206                <1> 	jb		SHORT .ConvertLetterInDLtoFloppyDriveNumber
 13428                              <1> 
 13429                              <1> 	; Convert letter in DL to Hard Drive number
 13430 00000AAA 28C2                <1> 	sub		dl, al
 13431 00000AAC 80CA80              <1> 	or		dl, 80h
 13432 00000AAF C3                  <1> 	ret
 13433                              <1> 
 13434                              <1> .ConvertLetterInDLtoFloppyDriveNumber:
 13435 00000AB0 80EA41              <1> 	sub		dl, DEFAULT_FLOPPY_DRIVE_LETTER
 13436 00000AB3 C3                  <1> 	ret
 13437                              <1> 
 13438                              <1> %ifdef MODULE_HOTKEY
 13439                              <1> %if HotkeyBar_FallThroughTo_DriveXlate_ConvertDriveLetterInDLtoDriveNumber <> DriveXlate_ConvertDriveLetterInDLtoDriveNumber
 13440                              <1> 	%error "DriveXlate_ConvertDriveLetterInDLtoDriveNumber must be at the top of DriveXlate.asm, and that file must immediately follow HotKeys.asm"
 13441                              <1> %endif
 13442                              <1> %endif
 13443                              <1> 
 13444                              <1> ;--------------------------------------------------------------------
 13445                              <1> ; DriveXlate_ConvertDriveNumberFromDLtoDriveLetter
 13446                              <1> ;	Parameters:
 13447                              <1> ;		DL:		Drive number (0xh for Floppy Drives, 8xh for Hard Drives)
 13448                              <1> ;		DS:		RAMVARS Segment
 13449                              <1> ;	Returns:
 13450                              <1> ;		DL:		Drive letter ('A'...)
 13451                              <1> ;		CF:		Set if Hard Drive
 13452                              <1> ;				Clear if Floppy Drive
 13453                              <1> ;	Corrupts registers:
 13454                              <1> ;		AX
 13455                              <1> ;--------------------------------------------------------------------
 13456                              <1> DriveXlate_ConvertDriveNumberFromDLtoDriveLetter:
 13457 00000AB4 80F280              <1> 	xor		dl, 80h
 13458 00000AB7 7807                <1> 	js		SHORT .GetDefaultFloppyDrive
 13459                              <1> 
 13460                              <1> 	; Store default hard drive to boot from
 13461 00000AB9 E80800              <1> 	call	DriveXlate_GetLetterForFirstHardDriveToAX
 13462 00000ABC 00C2                <1> 	add		dl, al
 13463 00000ABE F9                  <1> 	stc
 13464 00000ABF C3                  <1> 	ret
 13465                              <1> 
 13466                              <1> .GetDefaultFloppyDrive:
 13467 00000AC0 80EA3F              <1> 	sub		dl, 80h - DEFAULT_FLOPPY_DRIVE_LETTER	; Clears CF
 13468 00000AC3 C3                  <1> 	ret
 13469                              <1> 
 13470                              <1> 
 13471                              <1> ;--------------------------------------------------------------------
 13472                              <1> ; Returns letter for first hard disk. Usually it will be 'C' but it
 13473                              <1> ; can be higher if more than two floppy drives are found.
 13474                              <1> ;
 13475                              <1> ; DriveXlate_GetLetterForFirstHardDriveToAX
 13476                              <1> ;	Parameters:
 13477                              <1> ;		DS:		RAMVARS segment
 13478                              <1> ;	Returns:
 13479                              <1> ;		AX:		Upper case letter for first hard disk
 13480                              <1> ;	Corrupts registers:
 13481                              <1> ;		Nothing
 13482                              <1> ;--------------------------------------------------------------------
 13483                              <1> DriveXlate_GetLetterForFirstHardDriveToAX:
 13484 00000AC4 E888FA              <1> 	call	FloppyDrive_GetCountToAX
 13485 00000AC7 0441                <1> 	add		al, DEFAULT_FLOPPY_DRIVE_LETTER
 13486                              <1> 	MAX_U	al, DEFAULT_HARD_DRIVE_LETTER
 13487 00000AC9 3C43                <2>  cmp %1, %2
 13488 00000ACB 7702                <2>  ja %%Return
 13489 00000ACD B043                <2>  mov %1, %2
 13490                              <2> ALIGN JUMP_ALIGN
 13491                              <2> %%Return:
 13492 00000ACF C3                  <1> 	ret
 13493                              <1> 
 13494                              <1> 
 13495                              <1> ;--------------------------------------------------------------------
 13496                              <1> ; DriveXlate_ToOrBack
 13497                              <1> ;	Parameters:
 13498                              <1> ;		DL:		Drive number to be possibly translated
 13499                              <1> ;		DS:		RAMVARS segment
 13500                              <1> ;	Returns:
 13501                              <1> ;		DL:		Translated drive number
 13502                              <1> ;	Corrupts registers:
 13503                              <1> ;		DI
 13504                              <1> ;--------------------------------------------------------------------
 13505                              <1> ALIGN JUMP_ALIGN
 13506                              <1> DriveXlate_ToOrBack:
 13507 00000AD0 97                  <1> 	xchg	di, ax					; Backup AX
 13508                              <1> 
 13509 00000AD1 B480                <1> 	mov		ah, 80h					; Assume hard disk
 13510 00000AD3 A00D00              <1> 	mov		al, [RAMVARS.xlateVars+XLATEVARS.bHDSwap]
 13511 00000AD6 84E2                <1> 	test	dl, ah					; Hard disk?
 13512 00000AD8 7504                <1> 	jnz		SHORT .SwapDrive		; If so, jump to swap
 13513 00000ADA A00C00              <1> 	mov		al, [RAMVARS.xlateVars+XLATEVARS.bFDSwap]
 13514 00000ADD 98                  <1> 	cbw
 13515                              <1> 
 13516                              <1> ALIGN JUMP_ALIGN
 13517                              <1> .SwapDrive:
 13518 00000ADE 38D4                <1> 	cmp		ah, dl					; Swap DL from 00h/80h to xxh?
 13519 00000AE0 7406                <1> 	je		SHORT .SwapToXXhInAL
 13520 00000AE2 38D0                <1> 	cmp		al, dl					; Swap DL from xxh to 00h/80h?
 13521 00000AE4 7504                <1> 	jne		SHORT .RestoreAXandReturn
 13522 00000AE6 88E0                <1> 	mov		al, ah
 13523                              <1> ALIGN JUMP_ALIGN
 13524                              <1> .SwapToXXhInAL:
 13525 00000AE8 88C2                <1> 	mov		dl, al
 13526                              <1> ALIGN JUMP_ALIGN
 13527                              <1> .RestoreAXandReturn:
 13528 00000AEA 97                  <1> 	xchg	ax, di					; Restore AX
 13529 00000AEB C3                  <1> 	ret
 13530                              <1> 
 13531                              <1> 
 13532                              <1> ;--------------------------------------------------------------------
 13533                              <1> ; Resets drive swapping variables to defaults (no swapping).
 13534                              <1> ;
 13535                              <1> ; DriveXlate_Reset
 13536                              <1> ;	Parameters:
 13537                              <1> ;		DS:		RAMVARS segment
 13538                              <1> ;	Returns:
 13539                              <1> ;		Nothing
 13540                              <1> ;	Corrupts registers:
 13541                              <1> ;		Nothing
 13542                              <1> ;--------------------------------------------------------------------
 13543                              <1> DriveXlate_Reset:
 13544 00000AEC C7060C000080        <1> 	mov		WORD [RAMVARS.xlateVars+XLATEVARS.wFDandHDswap], 8000h
 13545 00000AF2 C3                  <1> 	ret
 13546                              <1> 
 13547                              <1> 
 13548                              <1> ;--------------------------------------------------------------------
 13549                              <1> ; Stores drive to be swapped.
 13550                              <1> ;
 13551                              <1> ; DriveXlate_SetDriveToSwap
 13552                              <1> ;	Parameters:
 13553                              <1> ;		DL:		Hard Drive to swap to first Hard Drive
 13554                              <1> ;				Floppy Drive to swap to first Floppy Drive
 13555                              <1> ;		DS:		RAMVARS segment
 13556                              <1> ;	Returns:
 13557                              <1> ;		Nothing
 13558                              <1> ;	Corrupts registers:
 13559                              <1> ;		Nothing
 13560                              <1> ;--------------------------------------------------------------------
 13561                              <1> DriveXlate_SetDriveToSwap:
 13562 00000AF3 84D2                <1> 	test	dl, dl				; Floppy drive?
 13563 00000AF5 7805                <1> 	js		SHORT .SetHardDriveToSwap
 13564                              <1> 
 13565                              <1> 	; Set Floppy Drive to swap
 13566 00000AF7 88160C00            <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bFDSwap], dl
 13567 00000AFB C3                  <1> 	ret
 13568                              <1> 
 13569                              <1> .SetHardDriveToSwap:
 13570 00000AFC 88160D00            <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bHDSwap], dl
 13571 00000B00 C3                  <1> 	ret
 13572                                  %endif
 13573                                  
 13574                                  	; Boot menu
 13575                                  %ifdef MODULE_BOOT_MENU
 13576                                  	%include "BootMenu.asm"			; For Boot Menu operations
 13577                                  	%include "BootMenuEvent.asm"	; For menu library event handling
 13578                                  									; NOTE: BootMenuPrint needs to come immediately after BootMenuEvent
 13579                                  									;       so that jump table entries in BootMenuEvent stay within 8-bits
 13580                                  	%include "BootMenuPrint.asm"	; For printing Boot Menu strings, also includes "BootMenuPrintCfg.asm"
 13581                                  %endif
 13582                                  
 13583                                  	; Boot loader
 13584                                  	%include "Int19h.asm"			; For Int 19h, Boot Loader
 13585                              <1> ; Project name	:	XTIDE Universal BIOS
 13586                              <1> ; Description	:	Int 19h Handler (Boot Loader).
 13587                              <1> 
 13588                              <1> ;
 13589                              <1> ; XTIDE Universal BIOS and Associated Tools
 13590                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 13591                              <1> ;
 13592                              <1> ; This program is free software; you can redistribute it and/or modify
 13593                              <1> ; it under the terms of the GNU General Public License as published by
 13594                              <1> ; the Free Software Foundation; either version 2 of the License, or
 13595                              <1> ; (at your option) any later version.
 13596                              <1> ;
 13597                              <1> ; This program is distributed in the hope that it will be useful,
 13598                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 13599                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 13600                              <1> ; GNU General Public License for more details.
 13601                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 13602                              <1> ;
 13603                              <1> 
 13604                              <1> ; Section containing code
 13605                              <1> SECTION .text
 13606                              <1> 
 13607                              <1> ;--------------------------------------------------------------------
 13608                              <1> ; Int19h_BootLoaderHandler
 13609                              <1> ;	Parameters:
 13610                              <1> ;		Nothing
 13611                              <1> ;	Returns:
 13612                              <1> ;		Never returns (loads operating system)
 13613                              <1> ;--------------------------------------------------------------------
 13614                              <1> Int19h_BootLoaderHandler:
 13615 00000B01 FB                  <1> 	sti									; Enable interrupts
 13616 00000B02 FC                  <1> 	cld									; String instructions to increment pointers
 13617                              <1> 	LOAD_BDA_SEGMENT_TO	es, ax			; Load BDA segment (zero) to ES
 13618                              <2> %ifndef USE_186
 13619 00000B03 31C0                <2>  xor %2, %2
 13620 00000B05 8EC0                <2>  mov %1, %2
 13621                              <2> %elifidn %3, !
 13622                              <2>  xor %2, %2
 13623                              <2>  mov %1, %2
 13624                              <2> %else
 13625                              <2>  push BYTE 0
 13626                              <2>  pop %1
 13627                              <2> %endif
 13628                              <1> 	; Fall to .PrepareBootLoaderStack
 13629                              <1> 
 13630                              <1> 
 13631                              <1> ;--------------------------------------------------------------------
 13632                              <1> ; Drive detection and boot menu use lots of stack so it is
 13633                              <1> ; wise to relocate stack. Otherwise something important from
 13634                              <1> ; interrupt vectors are likely corrupted, likely our own DPTs if
 13635                              <1> ; they are located to 30:0h.
 13636                              <1> ;
 13637                              <1> ; .PrepareBootLoaderStack
 13638                              <1> ;	Parameters:
 13639                              <1> ;		ES:		BDA and interrupt vector segment (zero)
 13640                              <1> ;	Returns:
 13641                              <1> ;		Never returns (loads operating system)
 13642                              <1> ;--------------------------------------------------------------------
 13643                              <1> .PrepareBootLoaderStack:
 13644                              <1> 	STORE_POST_STACK_POINTER
 13645 00000B07 268926007F          <2>  mov [es:BOOTVARS.dwPostStack], sp
 13646 00000B0C 268C16027F          <2>  mov [es:BOOTVARS.dwPostStack+2], ss
 13647                              <1> 	SWITCH_TO_BOOT_MENU_STACK
 13648                              <2> %ifndef USE_186
 13649 00000B11 FA                  <2>  cli
 13650                              <2> %endif
 13651                              <2>  LOAD_BDA_SEGMENT_TO ss, sp
 13652                              <3> %ifndef USE_186
 13653 00000B12 31E4                <3>  xor %2, %2
 13654 00000B14 8ED4                <3>  mov %1, %2
 13655                              <3> %elifidn %3, !
 13656                              <3>  xor %2, %2
 13657                              <3>  mov %1, %2
 13658                              <3> %else
 13659                              <3>  push BYTE 0
 13660                              <3>  pop %1
 13661                              <3> %endif
 13662 00000B16 BC007F              <2>  mov sp, BOOTVARS.rgbMnuStack
 13663                              <2> %ifndef USE_186
 13664 00000B19 FB                  <2>  sti
 13665                              <2> %endif
 13666                              <1> 	; Fall to .InitializeDisplay
 13667                              <1> 
 13668                              <1> 
 13669                              <1> ;--------------------------------------------------------------------
 13670                              <1> ; .InitializeDisplay
 13671                              <1> ;	Parameters:
 13672                              <1> ;		ES:		BDA and interrupt vector segment (zero)
 13673                              <1> ;	Returns:
 13674                              <1> ;		Never returns (loads operating system)
 13675                              <1> ;--------------------------------------------------------------------
 13676                              <1> .InitializeDisplay:
 13677                              <1> 	; Change display mode if necessary
 13678 00000B1A 2EA14800            <1> 	mov		ax, [cs:ROMVARS.wDisplayMode]	; AH 00h = Set Video Mode
 13679 00000B1E 3C04                <1> 	cmp		al, DEFAULT_TEXT_MODE
 13680 00000B20 7402                <1> 	je		SHORT .InitializeDisplayLibrary
 13681 00000B22 CD10                <1> 	int		BIOS_VIDEO_INTERRUPT_10h
 13682                              <1> .InitializeDisplayLibrary:
 13683 00000B24 E8EEFD              <1> 	call	DetectPrint_InitializeDisplayContext
 13684                              <1> 	; Fall to .InitializeBiosAndDetectDrives
 13685                              <1> 
 13686                              <1> 
 13687                              <1> ;--------------------------------------------------------------------
 13688                              <1> ; .InitializeBiosAndDetectDrives
 13689                              <1> ;	Parameters:
 13690                              <1> ;		ES:		BDA and interrupt vector segment (zero)
 13691                              <1> ;	Returns:
 13692                              <1> ;		DS:		RAMVARS segment
 13693                              <1> ;--------------------------------------------------------------------
 13694                              <1> %ifdef MODULE_HOTKEYS
 13695 00000B27 E87AF8              <1> 	call	TimerTicks_ReadFromBdaToAX
 13696 00000B2A 26A3067F            <1> 	mov		[es:BOOTVARS.hotkeyVars+HOTKEYVARS.wTimeWhenDisplayed], ax
 13697                              <1> %endif
 13698                              <1> 
 13699 00000B2E E81EF9              <1> 	call	Initialize_AndDetectDrives
 13700                              <1> 
 13701                              <1> %ifdef MODULE_HOTKEYS
 13702                              <1> .WaitUntilTimeToCloseHotkeyBar:
 13703 00000B31 E870F8              <1> 	call	TimerTicks_ReadFromBdaToAX
 13704 00000B34 262B06067F          <1> 	sub		ax, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.wTimeWhenDisplayed]
 13705 00000B39 83F848              <1> 	cmp		ax, MIN_TIME_TO_DISPLAY_HOTKEY_BAR
 13706 00000B3C 72F3                <1> 	jb		SHORT .WaitUntilTimeToCloseHotkeyBar
 13707                              <1> %endif
 13708                              <1> 	; Fall to SelectDriveToBootFrom
 13709                              <1> 
 13710                              <1> 
 13711                              <1> ;--------------------------------------------------------------------
 13712                              <1> ; SelectDriveToBootFrom
 13713                              <1> ;	Parameters:
 13714                              <1> ;		DS:		RAMVARS segment
 13715                              <1> ;		ES:		BDA and interrupt vector segment (zero)
 13716                              <1> ;	Returns:
 13717                              <1> ;		Never returns (loads operating system)
 13718                              <1> ;--------------------------------------------------------------------
 13719                              <1> ; The following macro could be easily inlined below.  Why a macro?  Depending on the combination
 13720                              <1> ; of MODULE_HOTKEYS or MODULE_BOOT_MENU, this code needs to either come before or after the
 13721                              <1> ; call to the boot menu.
 13722                              <1> ;
 13723                              <1> %macro TRY_TO_BOOT_DL_AND_DH_DRIVES 0
 13724                              <1> 	push	dx									; it's OK if this is left on the stack, if we are
 13725                              <1> 												; successful, the following call does not return
 13726                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
 13727                              <1> 	pop		dx
 13728                              <1> 	mov		dl, dh
 13729                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
 13730                              <1> %endmacro
 13731                              <1> 
 13732                              <1> 
 13733                              <1> SelectDriveToBootFrom:		; Function starts here
 13734                              <1> %ifdef MODULE_HOTKEYS
 13735 00000B3E E871FE              <1> 	call	HotkeyBar_UpdateDuringDriveDetection
 13736 00000B41 26A00B7F            <1> 	mov		al, [es:BOOTVARS.hotkeyVars+HOTKEYVARS.bScancode]
 13737 00000B45 3C42                <1> 	cmp		al, ROM_BOOT_HOTKEY_SCANCODE
 13738 00000B47 741A                <1> 	je		SHORT .RomBoot						; CF clear so ROM boot
 13739                              <1> %ifdef MODULE_BOOT_MENU
 13740                              <1> 	cmp		al, BOOT_MENU_HOTKEY_SCANCODE
 13741                              <1> 	je		SHORT .BootMenu
 13742                              <1> %endif ; MODULE_BOOT_MENU
 13743                              <1> 
 13744                              <1> .TryUsingHotKeysCode:
 13745 00000B49 E843FF              <1> 	call	HotkeyBar_GetBootDriveNumbersToDX
 13746 00000B4C E8A4FF              <1> 	call	DriveXlate_SetDriveToSwap			; Enable primary boot device translation
 13747 00000B4F 86D6                <1> 	xchg	dl, dh
 13748 00000B51 E89FFF              <1> 	call	DriveXlate_SetDriveToSwap			; Enable secondary boot device translation
 13749 00000B54 86D6                <1> 	xchg	dl, dh
 13750 00000B56 E877FF              <1> 	call	DriveXlate_ToOrBack					; Tranlate now so boot device will appear as 00h or 80h to OS
 13751                              <1> 	TRY_TO_BOOT_DL_AND_DH_DRIVES
 13752 00000B59 52                  <2>  push dx
 13753                              <2> 
 13754 00000B5A E82800              <2>  call BootSector_TryToLoadFromDriveDL_AndBoot
 13755 00000B5D 5A                  <2>  pop dx
 13756 00000B5E 88F2                <2>  mov dl, dh
 13757 00000B60 E82200              <2>  call BootSector_TryToLoadFromDriveDL_AndBoot
 13758                              <1> 	;; falls through to boot menu, if it is present.  If not present, falls through to rom boot.
 13759                              <1> %endif ; MODULE_HOTKEYS
 13760                              <1> 
 13761                              <1> 
 13762                              <1> %ifdef MODULE_BOOT_MENU
 13763                              <1> .BootMenu:
 13764                              <1> 	call	BootMenu_DisplayAndReturnDriveInDLRomBootClearCF
 13765                              <1> 	jnc		SHORT .RomBoot						; CF clear so ROM boot
 13766                              <1> 
 13767                              <1> 	call	DriveXlate_Reset
 13768                              <1> %ifdef MODULE_HOTKEYS
 13769                              <1> 	jmp		SHORT .TryUsingHotKeysCode			; Selected drive stored as hotkey
 13770                              <1> %else ; Boot menu without hotkeys, secondary boot drive is always 00h or 80h
 13771                              <1> 	mov		dh, dl								; Setup for secondary drive
 13772                              <1> 	not		dh									; Floppy goes to HD, or vice versa
 13773                              <1> 	and		dh, 80h								; Go to first drive of the floppy or HD set
 13774                              <1> 	call	DriveXlate_SetDriveToSwap
 13775                              <1> 	call	DriveXlate_ToOrBack
 13776                              <1> 	TRY_TO_BOOT_DL_AND_DH_DRIVES
 13777                              <1> 	jmp		SHORT .BootMenu						; Show boot menu again
 13778                              <1> %endif ; MODULE_HOTKEYS
 13779                              <1> 
 13780                              <1> %endif ; MODULE_BOOT_MENU
 13781                              <1> 
 13782                              <1> ; No hotkeys and no boot menu means fixed "A then C" boot order
 13783                              <1> %ifndef MODULE_HOTKEYS OR MODULE_BOOT_MENU
 13784                              <1> 	xor		dl, dl							; Try to boot from Floppy Drive A
 13785                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
 13786                              <1> 	mov		dl, DEFAULT_HARD_DRIVE_LETTER	; Try to boot from Hard Drive C
 13787                              <1> 	call	BootSector_TryToLoadFromDriveDL_AndBoot
 13788                              <1> %endif
 13789                              <1> 
 13790                              <1> .RomBoot:
 13791                              <1> %ifdef MODULE_DRIVEXLATE
 13792 00000B63 E886FF              <1> 	call	DriveXlate_Reset					; Clean up any drive mappings before Rom Boot
 13793                              <1> %endif
 13794 00000B66 F8                  <1> 	clc
 13795                              <1> 	;; fall through to Int19_JumpToBootSectorOrRomBoot
 13796                              <1> 
 13797                              <1> ;--------------------------------------------------------------------
 13798                              <1> ; Int19_JumpToBootSectorOrRomBoot
 13799                              <1> ;
 13800                              <1> ; Switches back to the POST stack, clears the DS and ES registers,
 13801                              <1> ; and either jumps to the MBR (Master Boot Record) that was just read,
 13802                              <1> ; or calls the ROM's boot routine on interrupt 18.
 13803                              <1> ;
 13804                              <1> ;	Parameters:
 13805                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
 13806                              <1> ;       CF:     Set for Boot Sector Boot
 13807                              <1> ;               Clear for ROM Boot
 13808                              <1> ;	   	ES:BX:	(if CF set) Ptr to boot sector
 13809                              <1> ;
 13810                              <1> ;	Returns:
 13811                              <1> ;		Never returns
 13812                              <1> ;--------------------------------------------------------------------
 13813                              <1> Int19_JumpToBootSectorOrRomBoot:
 13814 00000B67 8CC1                <1> 	mov		cx, es		; Preserve MBR segment (can't push because of stack change)
 13815 00000B69 B80000              <1> 	mov		ax, 0		; NOTE: can't use XOR (LOAD_BDA_SEGMENT_TO) as it impacts CF
 13816                              <1> 	SWITCH_BACK_TO_POST_STACK
 13817                              <2> %ifndef USE_386
 13818 00000B6C FA                  <2>  cli
 13819 00000B6D 8ED0                <2>  mov ss, ax
 13820 00000B6F 368B26007F          <2>  mov sp, [ss:BOOTVARS.dwPostStack]
 13821 00000B74 368E16027F          <2>  mov ss, [ss:BOOTVARS.dwPostStack+2]
 13822 00000B79 FB                  <2>  sti
 13823                              <2> %else
 13824                              <2>  mov ss, ax
 13825                              <2>  lss sp, [ss:BOOTVARS.dwPostStack]
 13826                              <2> %endif
 13827                              <1> 
 13828                              <1> ; clear segment registers before boot sector or rom call
 13829 00000B7A 8ED8                <1> 	mov		ds, ax
 13830 00000B7C 8EC0                <1> 	mov		es, ax
 13831                              <1> %ifdef USE_386
 13832                              <1> 	mov		fs, ax
 13833                              <1> 	mov		gs, ax
 13834                              <1> %endif
 13835 00000B7E 7303                <1> 	jnc		SHORT .romboot
 13836                              <1> 
 13837                              <1> ; jump to boot sector
 13838 00000B80 51                  <1> 	push	cx			; sgment address for MBR
 13839 00000B81 53                  <1> 	push	bx			; offset address for MBR
 13840 00000B82 CB                  <1> 	retf				; NOTE:	DL is set to the drive number
 13841                              <1> 
 13842                              <1> ; Boot by calling INT 18h (ROM Basic of ROM DOS)
 13843                              <1> .romboot:
 13844 00000B83 CD18                <1> 	int		BIOS_BOOT_FAILURE_INTERRUPT_18h	; Never returns
 13845                                  	%include "BootSector.asm"		; For loading boot sector
 13846                              <1> ; Project name	:	XTIDE Universal BIOS
 13847                              <1> ; Description	:	Reading and jumping to boot sector.
 13848                              <1> 
 13849                              <1> ;
 13850                              <1> ; XTIDE Universal BIOS and Associated Tools
 13851                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 13852                              <1> ;
 13853                              <1> ; This program is free software; you can redistribute it and/or modify
 13854                              <1> ; it under the terms of the GNU General Public License as published by
 13855                              <1> ; the Free Software Foundation; either version 2 of the License, or
 13856                              <1> ; (at your option) any later version.
 13857                              <1> ;
 13858                              <1> ; This program is distributed in the hope that it will be useful,
 13859                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 13860                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 13861                              <1> ; GNU General Public License for more details.
 13862                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 13863                              <1> ;
 13864                              <1> 
 13865                              <1> ; Section containing code
 13866                              <1> SECTION .text
 13867                              <1> 
 13868                              <1> ;--------------------------------------------------------------------
 13869                              <1> ; BootSector_TryToLoadFromDriveDL_AndBoot
 13870                              <1> ;	Parameters:
 13871                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
 13872                              <1> ;		DS:		RAMVARS segment
 13873                              <1> ;	Returns:
 13874                              <1> ;		ES:BX:	Ptr to boot sector (if successful)
 13875                              <1> ;		CF:		Set if boot sector loaded successfully
 13876                              <1> ;				Cleared if failed to load boot sector
 13877                              <1> ;	Corrupts registers:
 13878                              <1> ;		AX, CX, DH, SI, DI, (DL if failed to read boot sector)
 13879                              <1> ;--------------------------------------------------------------------
 13880                              <1> BootSector_TryToLoadFromDriveDL_AndBoot:
 13881 00000B85 E8FFFD              <1> 	call	DetectPrint_TryToBootFromDL
 13882 00000B88 E82B00              <1> 	call	LoadFirstSectorFromDriveDL
 13883 00000B8B 7311                <1> 	jnc		SHORT .FirstSectorLoadedToESBX
 13884                              <1> 
 13885                              <1> 	; Do not display timeout error (80h) for floppy drives since
 13886                              <1> 	; it most likely mean no diskette in drive. This way we do not
 13887                              <1> 	; display error code every time user intends to boot from hard disk
 13888                              <1> 	; when A then C boot order is used.
 13889 00000B8D 780A                <1> 	js		SHORT .PrintFailedToLoadErrorCode	; Hard Drive
 13890 00000B8F 80FC80              <1> 	cmp		ah, RET_HD_TIMEOUT
 13891 00000B92 7420                <1> 	je		SHORT .ReturnWithCFclearSinceFailedToLoadBootSector
 13892 00000B94 80FC31              <1> 	cmp		ah, RET_HD_NOMEDIA
 13893 00000B97 741B                <1> 	je		SHORT .ReturnWithCFclearSinceFailedToLoadBootSector
 13894                              <1> .PrintFailedToLoadErrorCode:
 13895                              <1> %ifdef USE_186
 13896                              <1> 	push	.ReturnWithCFclearSinceFailedToLoadBootSector
 13897                              <1> 	jmp		DetectPrint_FailedToLoadFirstSector
 13898                              <1> %else
 13899 00000B99 E8DEFD              <1> 	call	DetectPrint_FailedToLoadFirstSector
 13900 00000B9C EB16                <1> 	jmp		.ReturnWithCFclearSinceFailedToLoadBootSector
 13901                              <1> %endif
 13902                              <1> 
 13903                              <1> 
 13904                              <1> .FirstSectorLoadedToESBX:
 13905 00000B9E 84D2                <1> 	test	dl, dl
 13906 00000BA0 7909                <1> 	jns		SHORT .AlwaysBootFromFloppyDriveForBooterGames
 13907 00000BA2 2681BFFE0155AA      <1> 	cmp		WORD [es:bx+510], 0AA55h		; Valid boot sector?
 13908 00000BA9 7503                <1> 	jne		SHORT .FirstHardDiskSectorNotBootable
 13909                              <1> .AlwaysBootFromFloppyDriveForBooterGames:
 13910 00000BAB F9                  <1> 	stc		; Boot Sector loaded succesfully
 13911 00000BAC EBB9                <1> 	jmp		SHORT Int19_JumpToBootSectorOrRomBoot
 13912                              <1> 
 13913                              <1> .FirstHardDiskSectorNotBootable:
 13914 00000BAE BE[0301]            <1> 	mov		si, g_szBootSectorNotFound
 13915 00000BB1 E8F2FD              <1> 	call	DetectPrint_NullTerminatedStringFromCSSI
 13916                              <1> .ReturnWithCFclearSinceFailedToLoadBootSector:
 13917 00000BB4 F8                  <1> 	clc
 13918 00000BB5 C3                  <1> 	ret
 13919                              <1> 
 13920                              <1> 
 13921                              <1> ;--------------------------------------------------------------------
 13922                              <1> ; LoadFirstSectorFromDriveDL
 13923                              <1> ;	Parameters:
 13924                              <1> ;		DL:		Drive to boot from (translated, 00h or 80h)
 13925                              <1> ;	Returns:
 13926                              <1> ;		AH:		INT 13h error code
 13927                              <1> ;		ES:BX:	Ptr to boot sector (if successful)
 13928                              <1> ;		CF:		Cleared if read successful
 13929                              <1> ;				Set if any error
 13930                              <1> ;	Corrupts registers:
 13931                              <1> ;		AL, CX, DH, DI
 13932                              <1> ;--------------------------------------------------------------------
 13933                              <1> LoadFirstSectorFromDriveDL:
 13934                              <1> 	LOAD_BDA_SEGMENT_TO	es, bx				; ES:BX now points to...
 13935                              <2> %ifndef USE_186
 13936 00000BB6 31DB                <2>  xor %2, %2
 13937 00000BB8 8EC3                <2>  mov %1, %2
 13938                              <2> %elifidn %3, !
 13939                              <2>  xor %2, %2
 13940                              <2>  mov %1, %2
 13941                              <2> %else
 13942                              <2>  push BYTE 0
 13943                              <2>  pop %1
 13944                              <2> %endif
 13945 00000BBA BB007C              <1> 	mov		bx, BOOTVARS.rgbBootSect		; ...boot sector location
 13946 00000BBD BF0300              <1> 	mov		di, BOOT_READ_RETRY_TIMES		; Initialize retry counter
 13947                              <1> 
 13948                              <1> .ReadRetryLoop:
 13949 00000BC0 B80102              <1> 	mov		ax, 0201h						; Read 1 sector
 13950 00000BC3 B90100              <1> 	mov		cx, 1							; Cylinder 0, Sector 1
 13951 00000BC6 30F6                <1> 	xor		dh, dh							; Head 0
 13952 00000BC8 CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h
 13953 00000BCA 7201                <1> 	jc		SHORT .FailedToLoadFirstSector
 13954                              <1> .Return:
 13955 00000BCC C3                  <1> 	ret
 13956                              <1> 
 13957                              <1> .FailedToLoadFirstSector:
 13958 00000BCD 4F                  <1> 	dec		di								; Decrement retry counter (preserve CF)
 13959 00000BCE 74FC                <1> 	jz		SHORT .Return					; Loop while retries left
 13960                              <1> 
 13961                              <1> 	; Reset drive and retry
 13962 00000BD0 31C0                <1> 	xor		ax, ax							; AH=00h, Disk Controller Reset
 13963 00000BD2 84D2                <1> 	test	dl, dl							; Floppy drive?
 13964                              <1> 	eCMOVS	ah, RESET_HARD_DISK				; AH=0Dh, Reset Hard Disk (Alternate reset)
 13965 00000BD4 7902                <2>  jns SHORT %%Return
 13966 00000BD6 B40D                <2>  mov %1, %2
 13967                              <2> %%Return:
 13968 00000BD8 CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h
 13969 00000BDA EBE4                <1> 	jmp		SHORT .ReadRetryLoop
 13970                              <1> 
 13971                                  	%include "Int19hReset.asm"		; INT 19h handler for proper system reset
 13972                              <1> ; Project name	:	XTIDE Universal BIOS
 13973                              <1> ; Description	:	Int 19h Handler (Boot Loader).
 13974                              <1> 
 13975                              <1> ;
 13976                              <1> ; XTIDE Universal BIOS and Associated Tools
 13977                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 13978                              <1> ;
 13979                              <1> ; This program is free software; you can redistribute it and/or modify
 13980                              <1> ; it under the terms of the GNU General Public License as published by
 13981                              <1> ; the Free Software Foundation; either version 2 of the License, or
 13982                              <1> ; (at your option) any later version.
 13983                              <1> ;
 13984                              <1> ; This program is distributed in the hope that it will be useful,
 13985                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 13986                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 13987                              <1> ; GNU General Public License for more details.
 13988                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 13989                              <1> ;
 13990                              <1> 
 13991                              <1> ; Section containing code
 13992                              <1> SECTION .text
 13993                              <1> 
 13994                              <1> ;--------------------------------------------------------------------
 13995                              <1> ; INT 19h handler that properly reboots the computer when
 13996                              <1> ; INT 19h is called.
 13997                              <1> ;
 13998                              <1> ; Int19hReset_Handler
 13999                              <1> ;	Parameters:
 14000                              <1> ;		Nothing
 14001                              <1> ;	Returns:
 14002                              <1> ;		Never returns (reboots computer)
 14003                              <1> ;--------------------------------------------------------------------
 14004                              <1> Int19hReset_Handler:
 14005 00000BDC B83412              <1> 	mov		ax, BOOT_FLAG_WARM				; Skip memory tests
 14006 00000BDF E9DFF7              <1> 	jmp		Reboot_ComputerWithBootFlagInAX
 14007                                  
 14008                                  	; For all device types
 14009                                  	%include "Idepack.asm"
 14010                              <1> ; Project name	:	XTIDE Universal BIOS
 14011                              <1> ; Description	:	Functions for managing IDEPACK struct.
 14012                              <1> 
 14013                              <1> ;
 14014                              <1> ; XTIDE Universal BIOS and Associated Tools
 14015                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 14016                              <1> ;
 14017                              <1> ; This program is free software; you can redistribute it and/or modify
 14018                              <1> ; it under the terms of the GNU General Public License as published by
 14019                              <1> ; the Free Software Foundation; either version 2 of the License, or
 14020                              <1> ; (at your option) any later version.
 14021                              <1> ;
 14022                              <1> ; This program is distributed in the hope that it will be useful,
 14023                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 14024                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14025                              <1> ; GNU General Public License for more details.
 14026                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 14027                              <1> ;
 14028                              <1> 
 14029                              <1> ; Section containing code
 14030                              <1> SECTION .text
 14031                              <1> 
 14032                              <1> ;--------------------------------------------------------------------
 14033                              <1> ; Idepack_FakeToSSBP
 14034                              <1> ;	Parameters:
 14035                              <1> ;		Nothing
 14036                              <1> ;	Returns:
 14037                              <1> ;		SS:BP:	Ptr to IDEPACK
 14038                              <1> ;	Corrupts registers:
 14039                              <1> ;		AX
 14040                              <1> ;--------------------------------------------------------------------
 14041                              <1> Idepack_FakeToSSBP:
 14042 00000BE2 58                  <1> 	pop		ax
 14043 00000BE3 83EC0C              <1> 	sub		sp, BYTE SIZE_OF_IDEPACK_WITHOUT_INTPACK
 14044 00000BE6 89E5                <1> 	mov		bp, sp
 14045 00000BE8 FFE0                <1> 	jmp		ax
 14046                              <1> 
 14047                              <1> 
 14048                              <1> ;--------------------------------------------------------------------
 14049                              <1> ; Idepack_ConvertDapToIdepackAndIssueCommandFromAH
 14050                              <1> ;	Parameters:
 14051                              <1> ;		AH:		IDE command to issue
 14052                              <1> ;		BH:		Timeout ticks
 14053                              <1> ;		BL:		IDE Status Register flag to wait after command
 14054                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14055                              <1> ;		ES:SI:	Ptr to DAP (EBIOS Disk Address Packet)
 14056                              <1> ;		SS:BP:	Ptr to IDEPACK
 14057                              <1> ;	Returns:
 14058                              <1> ;		AH:		INT 13h Error Code
 14059                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
 14060                              <1> ;		CF:		Cleared if success, Set if error
 14061                              <1> ;	Corrupts registers:
 14062                              <1> ;		AL, BX, (CX), DX, SI, ES
 14063                              <1> ;--------------------------------------------------------------------
 14064                              <1> %ifdef MODULE_EBIOS
 14065                              <1> ALIGN JUMP_ALIGN
 14066                              <1> Idepack_ConvertDapToIdepackAndIssueCommandFromAH:
 14067 00000BEA 268A4402            <1> 	mov		al, [es:si+DAP.wSectorCount]
 14068 00000BEE 884602              <1> 	mov		[bp+IDEPACK.bSectorCount], al
 14069 00000BF1 886606              <1> 	mov		[bp+IDEPACK.bCommand], ah
 14070                              <1> 
 14071 00000BF4 268A4408            <1> 	mov		al, [es:si+DAP.qwLBA]		; LBA byte 0
 14072 00000BF8 884603              <1> 	mov		[bp+IDEPACK.bLbaLow], al
 14073 00000BFB 268B4409            <1> 	mov		ax, [es:si+DAP.qwLBA+1]		; LBA bytes 1 and 2
 14074 00000BFF 894604              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHigh], ax
 14075 00000C02 268A640B            <1> 	mov		ah, [es:si+DAP.qwLBA+3]		; LBA byte 3, LBA28 bits 24...27
 14076 00000C06 886609              <1> 	mov		[bp+IDEPACK.bLbaLowExt], ah
 14077 00000C09 268B4C0C            <1> 	mov		cx, [es:si+DAP.qwLBA+4]		; LBA bytes 4 and 5
 14078 00000C0D 894E0A              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHighExt], cx
 14079                              <1> 
 14080 00000C10 80E40F              <1> 	and		ah, 0Fh						; Limit bits for LBA28
 14081 00000C13 E8B7FA              <1> 	call	AccessDPT_GetDriveSelectByteForEbiosToAL
 14082 00000C16 08E0                <1> 	or		al, ah
 14083 00000C18 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
 14084                              <1> 
 14085                              <1> 	; Load data buffer pointer to ES:SI
 14086 00000C1B 26C47404            <1> 	les		si, [es:si+DAP.dwMemoryAddress]
 14087 00000C1F EB19                <1> 	jmp		SHORT GetDeviceControlByteToIdepackAndStartTransfer
 14088                              <1> %endif ; MODULE_EBIOS
 14089                              <1> 
 14090                              <1> 
 14091                              <1> ;--------------------------------------------------------------------
 14092                              <1> ; Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 14093                              <1> ;	Parameters:
 14094                              <1> ;		AH:		IDE command to issue
 14095                              <1> ;		AL:		Number of sectors to transfer (for xfer commands)
 14096                              <1> ;		BH:		Timeout ticks
 14097                              <1> ;		BL:		IDE Status Register flag to wait after command
 14098                              <1> ;		CH:		Cylinder number, bits 7...0
 14099                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 14100                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 14101                              <1> ;		DH:		Starting head number (0...255)
 14102                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14103                              <1> ;		ES:SI:	Ptr to normalized data buffer (for xfer commands)
 14104                              <1> ;		SS:BP:	Ptr to IDEPACK (containing INTPACK)
 14105                              <1> ;	Returns:
 14106                              <1> ;		AH:		INT 13h Error Code
 14107                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
 14108                              <1> ;		CF:		Cleared if success, Set if error
 14109                              <1> ;	Corrupts registers:
 14110                              <1> ;		AL, BX, (CX), DX
 14111                              <1> ;--------------------------------------------------------------------
 14112                              <1> ALIGN JUMP_ALIGN
 14113                              <1> Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH:
 14114 00000C21 884602              <1> 	mov		[bp+IDEPACK.bSectorCount], al
 14115 00000C24 886606              <1> 	mov		[bp+IDEPACK.bCommand], ah
 14116                              <1> 
 14117 00000C27 53                  <1> 	push	bx
 14118 00000C28 E86E0C              <1> 	call	Address_OldInt13hAddressToIdeAddress
 14119 00000C2B E894FA              <1> 	call	AccessDPT_GetDriveSelectByteForOldInt13hToAL
 14120 00000C2E 08F8                <1> 	or		al, bh			; AL now has Drive and Head Select Byte
 14121 00000C30 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
 14122 00000C33 885E03              <1> 	mov		[bp+IDEPACK.bLbaLow], bl
 14123 00000C36 894E04              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHigh], cx
 14124 00000C39 5B                  <1> 	pop		bx
 14125                              <1> 
 14126                              <1> GetDeviceControlByteToIdepackAndStartTransfer:
 14127 00000C3A E897FA              <1> 	call	AccessDPT_GetDeviceControlByteToAL
 14128 00000C3D 884607              <1> 	mov		[bp+IDEPACK.bDeviceControl], al
 14129 00000C40 EB3E                <1> 	jmp		Device_OutputCommandWithParameters
 14130                              <1> 
 14131                              <1> 
 14132                              <1> ;--------------------------------------------------------------------
 14133                              <1> ; Idepack_StoreNonExtParametersAndIssueCommandFromAL
 14134                              <1> ;	Parameters:
 14135                              <1> ;		BH:		Timeout ticks
 14136                              <1> ;		BL:		IDE Status Register flag to wait after command
 14137                              <1> ;		AL:		IDE command to issue
 14138                              <1> ;		AH:		Parameter to Drive and Head Select Register (Head bits only)
 14139                              <1> ;		DL:		Parameter to Sector Count Register
 14140                              <1> ;		DH:		Parameter to LBA Low / Sector Number Register
 14141                              <1> ;		CL:		Parameter to LBA Middle / Cylinder Low Register
 14142                              <1> ;		CH:		Parameter to LBA High / Cylinder High Register
 14143                              <1> ;		SI:		Parameter to Features Register
 14144                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14145                              <1> ;		SS:BP:	Ptr to IDEPACK
 14146                              <1> ;	Returns:
 14147                              <1> ;		AH:		INT 13h Error Code
 14148                              <1> ;		CF:		Cleared if success, Set if error
 14149                              <1> ;	Corrupts registers:
 14150                              <1> ;		AL, BX, CX, DX
 14151                              <1> ;--------------------------------------------------------------------
 14152                              <1> ALIGN JUMP_ALIGN
 14153                              <1> Idepack_StoreNonExtParametersAndIssueCommandFromAL:
 14154 00000C42 897600              <1> 	mov		[bp+IDEPACK.bFeatures], si
 14155 00000C45 884606              <1> 	mov		[bp+IDEPACK.bCommand], al
 14156 00000C48 895602              <1> 	mov		[bp+IDEPACK.wSectorCountAndLbaLow], dx
 14157 00000C4B 894E04              <1> 	mov		[bp+IDEPACK.wLbaMiddleAndHigh], cx
 14158                              <1> 
 14159                              <1> 	; Drive and Head select byte
 14160 00000C4E 80E40F              <1> 	and		ah, MASK_DRVNHEAD_HEAD		; Keep head bits only
 14161 00000C51 E86EFA              <1> 	call	AccessDPT_GetDriveSelectByteForOldInt13hToAL
 14162 00000C54 08E0                <1> 	or		al, ah
 14163 00000C56 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
 14164                              <1> 
 14165                              <1> 	; Device Control byte with interrupts disabled
 14166 00000C59 C6460702            <1> 	mov		BYTE [bp+IDEPACK.bDeviceControl], FLG_DEVCONTROL_nIEN
 14167                              <1> 
 14168 00000C5D EB21                <1> 	jmp		Device_OutputCommandWithParameters
 14169                                  	%include "Device.asm"
 14170                              <1> ; Project name	:	XTIDE Universal BIOS
 14171                              <1> ; Description	:	Command and port direction functions for different device types.
 14172                              <1> 
 14173                              <1> ;
 14174                              <1> ; XTIDE Universal BIOS and Associated Tools
 14175                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 14176                              <1> ;
 14177                              <1> ; This program is free software; you can redistribute it and/or modify
 14178                              <1> ; it under the terms of the GNU General Public License as published by
 14179                              <1> ; the Free Software Foundation; either version 2 of the License, or
 14180                              <1> ; (at your option) any later version.
 14181                              <1> ;
 14182                              <1> ; This program is distributed in the hope that it will be useful,
 14183                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 14184                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14185                              <1> ; GNU General Public License for more details.
 14186                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 14187                              <1> ;
 14188                              <1> 
 14189                              <1> ; Section containing code
 14190                              <1> SECTION .text
 14191                              <1> 
 14192                              <1> 
 14193                              <1> %macro TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE 1
 14194                              <1> 	test	BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE
 14195                              <1> 	jnz		SHORT %1
 14196                              <1> %endmacro
 14197                              <1> 
 14198                              <1> %macro CMP_USING_IDEVARS_IN_CSBP_AND_JUMP_IF 2
 14199                              <1> 	cmp		BYTE [cs:bp+IDEVARS.bDevice], %1
 14200                              <1> 	je		SHORT %2
 14201                              <1> %endmacro
 14202                              <1> 
 14203                              <1> 
 14204                              <1> 
 14205                              <1> ;--------------------------------------------------------------------
 14206                              <1> ; Device_FinalizeDPT
 14207                              <1> ;	Parameters:
 14208                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 14209                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 14210                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 14211                              <1> ;	Returns:
 14212                              <1> ;		Nothing
 14213                              <1> ;	Corrupts registers:
 14214                              <1> ;		AX, BX, CX, DX
 14215                              <1> ;--------------------------------------------------------------------
 14216                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 14217                              <1> Device_FinalizeDPT:
 14218                              <1> 	; needs to check IDEVARS vs. checking the DPT as the serial bit in the DPT is set in the Finalize routine
 14219                              <1> 	CMP_USING_IDEVARS_IN_CSBP_AND_JUMP_IF	DEVICE_SERIAL_PORT, .FinalizeDptForSerialPortDevice
 14220 00000C5F 2E807E0412          <2>  cmp BYTE [cs:bp+IDEVARS.bDevice], %1
 14221 00000C64 7403                <2>  je SHORT %2
 14222 00000C66 E94005              <1> 	jmp		IdeDPT_Finalize
 14223                              <1> .FinalizeDptForSerialPortDevice:
 14224 00000C69 E9BA07              <1> 	jmp		SerialDPT_Finalize
 14225                              <1> 
 14226                              <1> %else					; IDE
 14227                              <1> 	Device_FinalizeDPT		EQU		IdeDPT_Finalize
 14228                              <1> %endif
 14229                              <1> 
 14230                              <1> 
 14231                              <1> ;--------------------------------------------------------------------
 14232                              <1> ; Device_ResetMasterAndSlaveController
 14233                              <1> ;	Parameters:
 14234                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14235                              <1> ;	Returns:
 14236                              <1> ;		AH:		INT 13h Error Code
 14237                              <1> ;		CF:		Cleared if success, Set if error
 14238                              <1> ;	Corrupts registers:
 14239                              <1> ;		AL, BX, CX, DX
 14240                              <1> ;--------------------------------------------------------------------
 14241                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 14242                              <1> Device_ResetMasterAndSlaveController:
 14243                              <1> 	TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE	ReturnSuccessForSerialPort
 14244 00000C6C F6450104            <2>  test BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE
 14245 00000C70 7523                <2>  jnz SHORT %1
 14246 00000C72 EB5F                <1> 	jmp		IdeCommand_ResetMasterAndSlaveController
 14247                              <1> 
 14248                              <1> %else					; IDE
 14249                              <1> 	Device_ResetMasterAndSlaveController	EQU		IdeCommand_ResetMasterAndSlaveController
 14250                              <1> %endif
 14251                              <1> 
 14252                              <1> 
 14253                              <1> ;--------------------------------------------------------------------
 14254                              <1> ; Device_IdentifyToBufferInESSIwithDriveSelectByteInBH
 14255                              <1> ;	Parameters:
 14256                              <1> ;		BH:		Drive Select byte for Drive and Head Select Register
 14257                              <1> ;		DX:		Autodetected port (for devices that support autodetection)
 14258                              <1> ;		DS:		Segment to RAMVARS
 14259                              <1> ;		ES:SI:	Ptr to buffer to receive 512-byte IDE Information
 14260                              <1> ;		CS:BP:	Ptr to IDEVARS
 14261                              <1> ;	Returns:
 14262                              <1> ;		AH:		INT 13h Error Code
 14263                              <1> ;		CF:		Cleared if success, Set if error
 14264                              <1> ;	Corrupts registers:
 14265                              <1> ;		AL, BX, CX, DX, SI, DI, ES
 14266                              <1> ;--------------------------------------------------------------------
 14267                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 14268                              <1> Device_IdentifyToBufferInESSIwithDriveSelectByteInBH:
 14269                              <1> 	CMP_USING_IDEVARS_IN_CSBP_AND_JUMP_IF	DEVICE_SERIAL_PORT, .IdentifyDriveFromSerialPort
 14270 00000C74 2E807E0412          <2>  cmp BYTE [cs:bp+IDEVARS.bDevice], %1
 14271 00000C79 7402                <2>  je SHORT %2
 14272 00000C7B EB7E                <1> 	jmp		IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
 14273                              <1> .IdentifyDriveFromSerialPort:
 14274 00000C7D E92507              <1> 	jmp		SerialCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
 14275                              <1> 
 14276                              <1> %else					; IDE
 14277                              <1> 	Device_IdentifyToBufferInESSIwithDriveSelectByteInBH	EQU		IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
 14278                              <1> %endif
 14279                              <1> 
 14280                              <1> 
 14281                              <1> ;--------------------------------------------------------------------
 14282                              <1> ; Device_OutputCommandWithParameters
 14283                              <1> ;	Parameters:
 14284                              <1> ;		BH:		Default system timer ticks for timeout (can be ignored)
 14285                              <1> ;		BL:		IDE Status Register bit to poll after command
 14286                              <1> ;		ES:SI:	Ptr to buffer (for data transfer commands)
 14287                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14288                              <1> ;		SS:BP:	Ptr to IDEPACK
 14289                              <1> ;	Returns:
 14290                              <1> ;		AH:		INT 13h Error Code
 14291                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
 14292                              <1> ;		CF:		Cleared if success, Set if error
 14293                              <1> ;	Corrupts registers:
 14294                              <1> ;		AL, BX, (CX), DX, (ES:SI for data transfer commands)
 14295                              <1> ;--------------------------------------------------------------------
 14296                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 14297                              <1> ALIGN JUMP_ALIGN
 14298                              <1> Device_OutputCommandWithParameters:
 14299                              <1> 	TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE .OutputCommandToSerialPort
 14300 00000C80 F6450104            <2>  test BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE
 14301 00000C84 7503                <2>  jnz SHORT %1
 14302 00000C86 E9B200              <1> 	jmp		IdeCommand_OutputWithParameters
 14303                              <1> 
 14304                              <1> ALIGN JUMP_ALIGN
 14305                              <1> .OutputCommandToSerialPort:
 14306 00000C89 E9C805              <1> 	jmp		SerialCommand_OutputWithParameters
 14307                              <1> 
 14308                              <1> %else					; IDE
 14309                              <1> 	Device_OutputCommandWithParameters		EQU		IdeCommand_OutputWithParameters
 14310                              <1> %endif
 14311                              <1> 
 14312                              <1> 
 14313                              <1> ;--------------------------------------------------------------------
 14314                              <1> ; Device_SelectDrive
 14315                              <1> ;	Parameters:
 14316                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14317                              <1> ;		SS:BP:	Ptr to IDEPACK
 14318                              <1> ;	Returns:
 14319                              <1> ;		AH:		INT 13h Error Code
 14320                              <1> ;		CF:		Cleared if success, Set if error
 14321                              <1> ;	Corrupts registers:
 14322                              <1> ;		AL, BX, CX, DX
 14323                              <1> ;--------------------------------------------------------------------
 14324                              <1> %ifdef MODULE_SERIAL	; IDE + Serial
 14325                              <1> Device_SelectDrive:
 14326                              <1> 	TEST_USING_DPT_AND_JUMP_IF_SERIAL_DEVICE	ReturnSuccessForSerialPort
 14327 00000C8C F6450104            <2>  test BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE
 14328 00000C90 7503                <2>  jnz SHORT %1
 14329 00000C92 E9EC00              <1> 	jmp		IdeCommand_SelectDrive
 14330                              <1> 
 14331                              <1> %else					; IDE
 14332                              <1> 	Device_SelectDrive		EQU		IdeCommand_SelectDrive
 14333                              <1> %endif
 14334                              <1> 
 14335                              <1> 
 14336                              <1> %ifdef MODULE_SERIAL
 14337                              <1> ALIGN JUMP_ALIGN
 14338                              <1> ReturnSuccessForSerialPort:
 14339 00000C95 31C0                <1> 	xor		ax, ax
 14340 00000C97 C3                  <1> 	ret
 14341                              <1> %endif
 14342                                  	%include "Timer.asm"			; For timeout and delay
 14343                              <1> ; Project name	:	XTIDE Universal BIOS
 14344                              <1> ; Description	:	Timeout and delay functions for INT 13h services.
 14345                              <1> 
 14346                              <1> ;
 14347                              <1> ; XTIDE Universal BIOS and Associated Tools
 14348                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 14349                              <1> ;
 14350                              <1> ; This program is free software; you can redistribute it and/or modify
 14351                              <1> ; it under the terms of the GNU General Public License as published by
 14352                              <1> ; the Free Software Foundation; either version 2 of the License, or
 14353                              <1> ; (at your option) any later version.
 14354                              <1> ;
 14355                              <1> ; This program is distributed in the hope that it will be useful,
 14356                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 14357                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14358                              <1> ; GNU General Public License for more details.
 14359                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 14360                              <1> ;
 14361                              <1> 
 14362                              <1> ; Section containing code
 14363                              <1> SECTION .text
 14364                              <1> 
 14365                              <1> ;--------------------------------------------------------------------
 14366                              <1> ; Timer_InitializeTimeoutWithTicksInCL
 14367                              <1> ;	Parameters:
 14368                              <1> ;		CL:		Timeout value in system timer ticks
 14369                              <1> ;		DS:		Segment to RAMVARS
 14370                              <1> ;	Returns:
 14371                              <1> ;		Nothing
 14372                              <1> ;	Corrupts registers:
 14373                              <1> ;		CX
 14374                              <1> ;--------------------------------------------------------------------
 14375                              <1> ALIGN JUMP_ALIGN
 14376                              <1> Timer_InitializeTimeoutWithTicksInCL:
 14377 00000C98 880E0600            <1> 	mov		[RAMVARS.bTimeoutTicksLeft], cl		; Ticks until timeout
 14378 00000C9C E82900              <1> 	call	ReadTimeFromBdaToCX
 14379 00000C9F 880E0700            <1> 	mov		[RAMVARS.bLastTimeoutUpdate], cl	; Start time
 14380 00000CA3 C3                  <1> 	ret
 14381                              <1> 
 14382                              <1> 
 14383                              <1> ;--------------------------------------------------------------------
 14384                              <1> ; Timer_SetCFifTimeout
 14385                              <1> ;	Parameters:
 14386                              <1> ;		DS:		Segment to RAMVARS
 14387                              <1> ;	Returns:
 14388                              <1> ;		CF:		Set if timeout
 14389                              <1> ;				Cleared if time left
 14390                              <1> ;	Corrupts registers:
 14391                              <1> ;		CX
 14392                              <1> ;--------------------------------------------------------------------
 14393                              <1> ALIGN JUMP_ALIGN
 14394                              <1> Timer_SetCFifTimeout:
 14395 00000CA4 E82100              <1> 	call	ReadTimeFromBdaToCX
 14396 00000CA7 3A0E0700            <1> 	cmp		cl, [RAMVARS.bLastTimeoutUpdate]
 14397 00000CAB 7409                <1> 	je		SHORT .StillPollingTheSameTick
 14398 00000CAD 880E0700            <1> 	mov		[RAMVARS.bLastTimeoutUpdate], cl
 14399 00000CB1 802E060001          <1> 	sub		BYTE [RAMVARS.bTimeoutTicksLeft], 1	; DEC does not update CF
 14400                              <1> .StillPollingTheSameTick:
 14401 00000CB6 C3                  <1> 	ret
 14402                              <1> 
 14403                              <1> 
 14404                              <1> ;--------------------------------------------------------------------
 14405                              <1> ; Delay is always at least one millisecond since
 14406                              <1> ; RTC resolution is 977 microsecs.
 14407                              <1> ;
 14408                              <1> ; Timer_DelayMicrosecondsFromAX
 14409                              <1> ;	Parameters:
 14410                              <1> ;		AX:		Number of microsecs to wait
 14411                              <1> ;	Returns:
 14412                              <1> ;		Nothing
 14413                              <1> ;	Corrupts registers:
 14414                              <1> ;		AX
 14415                              <1> ;--------------------------------------------------------------------
 14416                              <1> Timer_DelayMicrosecondsFromAX:
 14417                              <1> %ifndef USE_AT
 14418 00000CB7 B80200              <1> 	mov		ax, 2
 14419                              <1> 	; Fall to Timer_DelayTimerTicksFromAX
 14420                              <1> %else
 14421                              <1> 	push	dx
 14422                              <1> 	push	cx
 14423                              <1> 
 14424                              <1> 	xor		cx, cx
 14425                              <1> 	xchg	dx, ax						; Microsecs now in CX:DX
 14426                              <1> 	mov		ah, EVENT_WAIT
 14427                              <1> 	int		BIOS_SYSTEM_INTERRUPT_15h
 14428                              <1> 	sti									; XT BIOSes return with interrupts disabled. TODO: Maybe we can remove this since it's in an AT-only block?
 14429                              <1> 
 14430                              <1> 	pop		cx
 14431                              <1> 	pop		dx
 14432                              <1> 	mov		ax, 1								; Prepare to wait 1 timer tick
 14433                              <1> 	jc		SHORT Timer_DelayTimerTicksFromAX	; Event Wait was unsupported or busy
 14434                              <1> 	ret
 14435                              <1> %endif
 14436                              <1> 
 14437                              <1> 
 14438                              <1> ;--------------------------------------------------------------------
 14439                              <1> ; First tick might take 0...54.9 ms and remaining ticks
 14440                              <1> ; will occur at 54.9 ms intervals.
 14441                              <1> ;
 14442                              <1> ; Timer_DelayTimerTicksFromAX
 14443                              <1> ;	Parameters:
 14444                              <1> ;		AX:		Number of timer ticks to wait
 14445                              <1> ;	Returns:
 14446                              <1> ;		Nothing
 14447                              <1> ;	Corrupts registers:
 14448                              <1> ;		AX
 14449                              <1> ;--------------------------------------------------------------------
 14450                              <1> Timer_DelayTimerTicksFromAX:
 14451 00000CBA FB                  <1> 	sti								; Make sure that interrupts are enabled
 14452 00000CBB E80A00              <1> 	call	ReadTimeFromBdaToCX
 14453 00000CBE 01C8                <1> 	add		ax, cx					; AX = end time
 14454                              <1> .WaitLoop:
 14455 00000CC0 E80500              <1> 	call	ReadTimeFromBdaToCX
 14456 00000CC3 39C1                <1> 	cmp		cx, ax
 14457 00000CC5 75F9                <1> 	jne		SHORT .WaitLoop			; Loop until end time is reached
 14458 00000CC7 C3                  <1> 	ret
 14459                              <1> 
 14460                              <1> 
 14461                              <1> ;--------------------------------------------------------------------
 14462                              <1> ; ReadTimeFromBdaToCX
 14463                              <1> ;	Parameters
 14464                              <1> ;		Nothing
 14465                              <1> ;	Returns:
 14466                              <1> ;		CX:		System time in 54.9 ms ticks
 14467                              <1> ;	Corrupts registers:
 14468                              <1> ;		Nothing
 14469                              <1> ;--------------------------------------------------------------------
 14470                              <1> ALIGN JUMP_ALIGN
 14471                              <1> ReadTimeFromBdaToCX:
 14472 00000CC8 1E                  <1> 	push	ds
 14473                              <1> 	LOAD_BDA_SEGMENT_TO	ds, cx
 14474                              <2> %ifndef USE_186
 14475 00000CC9 31C9                <2>  xor %2, %2
 14476 00000CCB 8ED9                <2>  mov %1, %2
 14477                              <2> %elifidn %3, !
 14478                              <2>  xor %2, %2
 14479                              <2>  mov %1, %2
 14480                              <2> %else
 14481                              <2>  push BYTE 0
 14482                              <2>  pop %1
 14483                              <2> %endif
 14484 00000CCD 8B0E6C04            <1> 	mov		cx, [BDA.dwTimerTicks]	; Read low WORD only
 14485 00000CD1 1F                  <1> 	pop		ds
 14486 00000CD2 C3                  <1> 	ret
 14487                                  
 14488                                  	; IDE Device support
 14489                                  %ifdef MODULE_ADVANCED_ATA
 14490                                  	%include "AdvAtaInit.asm"		; For initializing VLB and PCI controllers
 14491                                  	%include "Vision.asm"			; QDI Vision QD6500 and QD6580 support
 14492                                  %endif
 14493                                  	%include "IdeCommand.asm"
 14494                              <1> ; Project name	:	XTIDE Universal BIOS
 14495                              <1> ; Description	:	IDE Device Command functions.
 14496                              <1> 
 14497                              <1> ;
 14498                              <1> ; XTIDE Universal BIOS and Associated Tools
 14499                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 14500                              <1> ;
 14501                              <1> ; This program is free software; you can redistribute it and/or modify
 14502                              <1> ; it under the terms of the GNU General Public License as published by
 14503                              <1> ; the Free Software Foundation; either version 2 of the License, or
 14504                              <1> ; (at your option) any later version.
 14505                              <1> ;
 14506                              <1> ; This program is distributed in the hope that it will be useful,
 14507                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 14508                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14509                              <1> ; GNU General Public License for more details.
 14510                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 14511                              <1> ;
 14512                              <1> 
 14513                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 14514                              <1> 
 14515                              <1> ; Section containing code
 14516                              <1> SECTION .text
 14517                              <1> 
 14518                              <1> ;--------------------------------------------------------------------
 14519                              <1> ; IdeCommand_ResetMasterAndSlaveController
 14520                              <1> ;	Parameters:
 14521                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14522                              <1> ;	Returns:
 14523                              <1> ;		AH:		INT 13h Error Code
 14524                              <1> ;		CF:		Cleared if success, Set if error
 14525                              <1> ;	Corrupts registers:
 14526                              <1> ;		AL, BX, CX, DX
 14527                              <1> ;--------------------------------------------------------------------
 14528                              <1> IdeCommand_ResetMasterAndSlaveController:
 14529                              <1> 	; HSR0: Set_SRST
 14530 00000CD3 E8FEF9              <1> 	call	AccessDPT_GetDeviceControlByteToAL
 14531 00000CD6 0C06                <1> 	or		al, FLG_DEVCONTROL_SRST | FLG_DEVCONTROL_nIEN	; Set Reset bit
 14532                              <1> 	OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER		DEVICE_CONTROL_REGISTER_out
 14533                              <2> %ifndef MODULE_8BIT_IDE
 14534                              <2> 
 14535                              <2>  %ifnidni %1, dx
 14536                              <2>  mov dx, %1
 14537                              <2>  %endif
 14538                              <2>  eMOVZX bx, BYTE [di+DPT.bIdevarsOffset]
 14539                              <2>  add dx, [cs:bx+IDEVARS.wControlBlockPort]
 14540                              <2>  out dx, al
 14541                              <2> 
 14542                              <2> %else
 14543                              <2> 
 14544                              <2>  %ifnidni %1, dl
 14545 00000CD8 B206                <2>  mov dl, %1
 14546                              <2>  %endif
 14547 00000CDA E81305              <2>  call IdeIO_OutputALtoIdeControlBlockRegisterInDL
 14548                              <2> 
 14549                              <2> %endif
 14550 00000CDD B80600              <1> 	mov		ax, HSR0_RESET_WAIT_US
 14551 00000CE0 E8D4FF              <1> 	call	Timer_DelayMicrosecondsFromAX
 14552                              <1> 
 14553                              <1> 	; HSR1: Clear_wait
 14554 00000CE3 E8EEF9              <1> 	call	AccessDPT_GetDeviceControlByteToAL
 14555 00000CE6 0C02                <1> 	or		al, FLG_DEVCONTROL_nIEN
 14556 00000CE8 24FB                <1> 	and		al, ~FLG_DEVCONTROL_SRST						; Clear reset bit
 14557                              <1> 	OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER		DEVICE_CONTROL_REGISTER_out
 14558                              <2> %ifndef MODULE_8BIT_IDE
 14559                              <2> 
 14560                              <2>  %ifnidni %1, dx
 14561                              <2>  mov dx, %1
 14562                              <2>  %endif
 14563                              <2>  eMOVZX bx, BYTE [di+DPT.bIdevarsOffset]
 14564                              <2>  add dx, [cs:bx+IDEVARS.wControlBlockPort]
 14565                              <2>  out dx, al
 14566                              <2> 
 14567                              <2> %else
 14568                              <2> 
 14569                              <2>  %ifnidni %1, dl
 14570 00000CEA B206                <2>  mov dl, %1
 14571                              <2>  %endif
 14572 00000CEC E80105              <2>  call IdeIO_OutputALtoIdeControlBlockRegisterInDL
 14573                              <2> 
 14574                              <2> %endif
 14575 00000CEF B83408              <1> 	mov		ax, HSR1_RESET_WAIT_US
 14576 00000CF2 E8C2FF              <1> 	call	Timer_DelayMicrosecondsFromAX
 14577                              <1> 
 14578                              <1> 	; HSR2: Check_status
 14579 00000CF5 BB80FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_MAXIMUM, FLG_STATUS_BSY)
 14580 00000CF8 E93404              <1> 	jmp		IdeWait_PollStatusFlagInBLwithTimeoutInBH
 14581                              <1> 
 14582                              <1> 
 14583                              <1> ;--------------------------------------------------------------------
 14584                              <1> ; IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
 14585                              <1> ;	Parameters:
 14586                              <1> ;		BH:		Drive Select byte for Drive and Head Select Register
 14587                              <1> ;		DX:		Autodetected port for XT-CF
 14588                              <1> ;		DS:		Segment to RAMVARS
 14589                              <1> ;		ES:SI:	Ptr to buffer to receive 512-byte IDE Information
 14590                              <1> ;		CS:BP:	Ptr to IDEVARS
 14591                              <1> ;	Returns:
 14592                              <1> ;		AH:		INT 13h Error Code
 14593                              <1> ;		CF:		Cleared if success, Set if error
 14594                              <1> ;	Corrupts registers:
 14595                              <1> ;		AL, BX, CX, DX, SI, DI, ES
 14596                              <1> ;--------------------------------------------------------------------
 14597                              <1> IdeCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH:
 14598                              <1> 	; Create fake DPT to be able to use Device.asm functions
 14599 00000CFB E897F9              <1> 	call	FindDPT_ForNewDriveToDSDI
 14600                              <1> 	eMOVZX	ax, bh
 14601                              <2> %ifndef USE_386
 14602                              <2>  %ifidni %1, ax
 14603 00000CFE 88F8                <2>  mov al, %2
 14604 00000D00 30E4                <2>  xor ah, ah
 14605                              <2>  %elifidni %1, bx
 14606                              <2>  mov bl, %2
 14607                              <2>  xor bh, bh
 14608                              <2>  %elifidni %1, cx
 14609                              <2>  mov cl, %2
 14610                              <2>  xor ch, ch
 14611                              <2>  %elifidni %1, dx
 14612                              <2>  mov dl, %2
 14613                              <2>  xor dh, dh
 14614                              <2>  %else
 14615                              <2>  push ax
 14616                              <2>  mov al, %2
 14617                              <2>  xor ah, ah
 14618                              <2>  xchg ax, %1
 14619                              <2>  pop ax
 14620                              <2>  %endif
 14621                              <2> 
 14622                              <2> %else
 14623                              <2>  movzx %1, %2
 14624                              <2> %endif
 14625 00000D02 8905                <1> 	mov		[di+DPT.wFlags], ax
 14626 00000D04 E8F6F8              <1> 	call	CreateDPT_StoreIdevarsOffsetAndBasePortFromCSBPtoDPTinDSDI
 14627 00000D07 E8B404              <1> 	call	IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP
 14628 00000D0A C6451501            <1> 	mov		BYTE [di+DPT_ATA.bBlockSize], 1	; Block = 1 sector
 14629                              <1> 
 14630                              <1> 	; Wait until drive motors have reached full speed
 14631 00000D0E 83FD51              <1> 	cmp		bp, BYTE ROMVARS.ideVars0	; First controller?
 14632 00000D11 750B                <1> 	jne		SHORT .SkipLongWaitSinceDriveIsNotPrimaryMaster
 14633 00000D13 F6C710              <1> 	test		bh, FLG_DRVNHEAD_DRV		; Wait already done for Master
 14634 00000D16 7506                <1> 	jnz		SHORT .SkipLongWaitSinceDriveIsNotPrimaryMaster
 14635 00000D18 BB40B5              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_MOTOR_STARTUP, FLG_STATUS_DRDY)
 14636 00000D1B E81104              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
 14637                              <1> .SkipLongWaitSinceDriveIsNotPrimaryMaster:
 14638                              <1> 
 14639                              <1> 	; Create IDEPACK without INTPACK
 14640 00000D1E 55                  <1> 	push		bp
 14641 00000D1F E8C0FE              <1> 	call	Idepack_FakeToSSBP
 14642                              <1> 
 14643                              <1> %ifdef MODULE_8BIT_IDE
 14644                              <1> 	; Enable 8-bit PIO mode for 8-bit ATA and XT-CF
 14645 00000D22 56                  <1> 	push		si
 14646 00000D23 E8570A              <1> 	call	AH9h_Enable8bitModeForDevice8bitAta
 14647 00000D26 30C0                <1> 	xor		al, al						; XTCF_8BIT_PIO_MODE
 14648 00000D28 E84B0A              <1> 	call	AH9h_SetModeFromALtoXTCF
 14649 00000D2B 5E                  <1> 	pop		si
 14650                              <1> %endif ; MODULE_8BIT_IDE
 14651                              <1> 
 14652                              <1> 	; Prepare to output Identify Device command
 14653 00000D2C B201                <1> 	mov		dl, 1						; Sector count (required by IdeTransfer.asm)
 14654 00000D2E B0EC                <1> 	mov		al, COMMAND_IDENTIFY_DEVICE
 14655 00000D30 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 14656 00000D33 E80CFF              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
 14657                              <1> 
 14658                              <1> 	; Clean stack and return
 14659                              <1> .FailedToSet8bitMode:
 14660 00000D36 8D660C              <1> 	lea		sp, [bp+SIZE_OF_IDEPACK_WITHOUT_INTPACK]	; This assumes BP hasn't changed between Idepack_FakeToSSBP and here
 14661 00000D39 5D                  <1> 	pop		bp
 14662 00000D3A C3                  <1> 	ret
 14663                              <1> 
 14664                              <1> 
 14665                              <1> ;--------------------------------------------------------------------
 14666                              <1> ; IdeCommand_OutputWithParameters
 14667                              <1> ;	Parameters:
 14668                              <1> ;		BH:		System timer ticks for timeout
 14669                              <1> ;		BL:		IDE Status Register bit to poll after command
 14670                              <1> ;		ES:SI:	Ptr to buffer (for data transfer commands)
 14671                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14672                              <1> ;		SS:BP:	Ptr to IDEPACK
 14673                              <1> ;	Returns:
 14674                              <1> ;		AH:		INT 13h Error Code
 14675                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
 14676                              <1> ;		CF:		Cleared if success, Set if error
 14677                              <1> ;	Corrupts registers:
 14678                              <1> ;		AL, BX, (CX), DX, (ES:SI for data transfer commands)
 14679                              <1> ;--------------------------------------------------------------------
 14680                              <1> ALIGN JUMP_ALIGN
 14681                              <1> IdeCommand_OutputWithParameters:
 14682 00000D3B 53                  <1> 	push	bx						; Store status register bits to poll
 14683                              <1> 
 14684                              <1> 	; Select Master or Slave drive and output head number or LBA28 top bits
 14685 00000D3C E84200              <1> 	call	IdeCommand_SelectDrive
 14686 00000D3F 723E                <1> 	jc		SHORT .DriveNotReady
 14687                              <1> 
 14688                              <1> 	; Output Device Control Byte to enable or disable interrupts
 14689 00000D41 8A4607              <1> 	mov		al, [bp+IDEPACK.bDeviceControl]
 14690                              <1> %ifdef MODULE_IRQ
 14691                              <1> 	test	al, FLG_DEVCONTROL_nIEN	; Interrupts disabled?
 14692                              <1> 	jnz		SHORT .DoNotSetInterruptInServiceFlag
 14693                              <1> 
 14694                              <1> 	; Clear Task Flag and set Interrupt In-Service Flag
 14695                              <1> 	or		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_INTERRUPT_IN_SERVICE
 14696                              <1> 	push	ds
 14697                              <1> 	LOAD_BDA_SEGMENT_TO	ds, dx, !	; Also zero DX
 14698                              <1> 	mov		[BDA.bHDTaskFlg], dl
 14699                              <1> 	pop		ds
 14700                              <1> .DoNotSetInterruptInServiceFlag:
 14701                              <1> %endif
 14702                              <1> 	OUTPUT_AL_TO_IDE_CONTROL_BLOCK_REGISTER		DEVICE_CONTROL_REGISTER_out
 14703                              <2> %ifndef MODULE_8BIT_IDE
 14704                              <2> 
 14705                              <2>  %ifnidni %1, dx
 14706                              <2>  mov dx, %1
 14707                              <2>  %endif
 14708                              <2>  eMOVZX bx, BYTE [di+DPT.bIdevarsOffset]
 14709                              <2>  add dx, [cs:bx+IDEVARS.wControlBlockPort]
 14710                              <2>  out dx, al
 14711                              <2> 
 14712                              <2> %else
 14713                              <2> 
 14714                              <2>  %ifnidni %1, dl
 14715 00000D44 B206                <2>  mov dl, %1
 14716                              <2>  %endif
 14717 00000D46 E8A704              <2>  call IdeIO_OutputALtoIdeControlBlockRegisterInDL
 14718                              <2> 
 14719                              <2> %endif
 14720                              <1> 
 14721                              <1> 	; Output Feature Number
 14722 00000D49 8A4600              <1> 	mov		al, [bp+IDEPACK.bFeatures]
 14723                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	FEATURES_REGISTER_out
 14724                              <2> %ifndef MODULE_8BIT_IDE
 14725                              <2> 
 14726                              <2>  %ifnidni %1, dx
 14727                              <2>  mov dx, %1
 14728                              <2>  %endif
 14729                              <2>  add dx, [di+DPT.wBasePort]
 14730                              <2>  out dx, al
 14731                              <2> 
 14732                              <2> %else
 14733                              <2> 
 14734                              <2>  %ifnidni %1, dl
 14735 00000D4C B201                <2>  mov dl, %1
 14736                              <2>  %endif
 14737 00000D4E E8CE04              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 14738                              <2> 
 14739                              <2> %endif
 14740                              <1> 
 14741                              <1> 	; Output Sector Address High (only used by LBA48)
 14742                              <1> %ifdef MODULE_EBIOS
 14743                              <1> 	eMOVZX	ax, [bp+IDEPACK.bLbaLowExt]		; Zero sector count
 14744                              <2> %ifndef USE_386
 14745                              <2>  %ifidni %1, ax
 14746 00000D51 8A4609              <2>  mov al, %2
 14747 00000D54 30E4                <2>  xor ah, ah
 14748                              <2>  %elifidni %1, bx
 14749                              <2>  mov bl, %2
 14750                              <2>  xor bh, bh
 14751                              <2>  %elifidni %1, cx
 14752                              <2>  mov cl, %2
 14753                              <2>  xor ch, ch
 14754                              <2>  %elifidni %1, dx
 14755                              <2>  mov dl, %2
 14756                              <2>  xor dh, dh
 14757                              <2>  %else
 14758                              <2>  push ax
 14759                              <2>  mov al, %2
 14760                              <2>  xor ah, ah
 14761                              <2>  xchg ax, %1
 14762                              <2>  pop ax
 14763                              <2>  %endif
 14764                              <2> 
 14765                              <2> %else
 14766                              <2>  movzx %1, %2
 14767                              <2> %endif
 14768 00000D56 8B4E0A              <1> 	mov		cx, [bp+IDEPACK.wLbaMiddleAndHighExt]
 14769 00000D59 E84900              <1> 	call	OutputSectorCountAndAddress
 14770                              <1> %endif
 14771                              <1> 
 14772                              <1> 	; Output Sector Address Low
 14773 00000D5C 8B4602              <1> 	mov		ax, [bp+IDEPACK.wSectorCountAndLbaLow]
 14774 00000D5F 8B4E04              <1> 	mov		cx, [bp+IDEPACK.wLbaMiddleAndHigh]
 14775 00000D62 E84000              <1> 	call	OutputSectorCountAndAddress
 14776                              <1> 
 14777                              <1> 	; Output command
 14778 00000D65 8A4606              <1> 	mov		al, [bp+IDEPACK.bCommand]
 14779                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	COMMAND_REGISTER_out
 14780                              <2> %ifndef MODULE_8BIT_IDE
 14781                              <2> 
 14782                              <2>  %ifnidni %1, dx
 14783                              <2>  mov dx, %1
 14784                              <2>  %endif
 14785                              <2>  add dx, [di+DPT.wBasePort]
 14786                              <2>  out dx, al
 14787                              <2> 
 14788                              <2> %else
 14789                              <2> 
 14790                              <2>  %ifnidni %1, dl
 14791 00000D68 B207                <2>  mov dl, %1
 14792                              <2>  %endif
 14793 00000D6A E8B204              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 14794                              <2> 
 14795                              <2> %endif
 14796                              <1> 
 14797                              <1> 	; Wait until command completed
 14798 00000D6D 5B                  <1> 	pop		bx						; Pop status and timeout for polling
 14799 00000D6E 80FB08              <1> 	cmp		bl, FLG_STATUS_DRQ				; Data transfer started?
 14800 00000D71 7509                <1> 	jne		SHORT .WaitUntilNonTransferCommandCompletes
 14801                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 14802 00000D73 807D1410            <1> 	cmp		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_JRIDE_ISA
 14803 00000D77 7347                <1> 	jae		SHORT JrIdeTransfer_StartWithCommandInAL
 14804                              <1> %endif
 14805 00000D79 E97701              <1> 	jmp		IdeTransfer_StartWithCommandInAL
 14806                              <1> 
 14807                              <1> .WaitUntilNonTransferCommandCompletes:
 14808                              <1> %ifdef MODULE_IRQ
 14809                              <1> 	test	BYTE [bp+IDEPACK.bDeviceControl], FLG_DEVCONTROL_nIEN
 14810                              <1> 	jz		SHORT .PollStatusFlagInsteadOfWaitIrq
 14811                              <1> 	jmp		IdeWait_IRQorStatusFlagInBLwithTimeoutInBH
 14812                              <1> .PollStatusFlagInsteadOfWaitIrq:
 14813                              <1> %endif
 14814 00000D7C E9B003              <1> 	jmp		IdeWait_PollStatusFlagInBLwithTimeoutInBH
 14815                              <1> 
 14816                              <1> .DriveNotReady:
 14817 00000D7F 5B                  <1> 	pop		bx							; Clean stack
 14818 00000D80 C3                  <1> 	ret
 14819                              <1> 
 14820                              <1> 
 14821                              <1> ;--------------------------------------------------------------------
 14822                              <1> ; IdeCommand_SelectDrive
 14823                              <1> ;	Parameters:
 14824                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14825                              <1> ;		SS:BP:	Ptr to IDEPACK
 14826                              <1> ;	Returns:
 14827                              <1> ;		AH:		INT 13h Error Code
 14828                              <1> ;		CF:		Cleared if success, Set if error
 14829                              <1> ;	Corrupts registers:
 14830                              <1> ;		AL, BX, CX, DX
 14831                              <1> ;--------------------------------------------------------------------
 14832                              <1> ALIGN JUMP_ALIGN
 14833                              <1> IdeCommand_SelectDrive:
 14834                              <1> 	; We use different timeout value when detecting drives.
 14835                              <1> 	; This prevents unnecessary long delays when drive is not present.
 14836 00000D81 B940B5              <1> 	mov		cx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRDY, FLG_STATUS_DRDY)
 14837 00000D84 813E00005A5A        <1> 	cmp		WORD [RAMVARS.wDrvDetectSignature], RAMVARS_DRV_DETECT_SIGNATURE
 14838                              <1> 	eCMOVE	ch, TIMEOUT_SELECT_DRIVE_DURING_DRIVE_DETECTION
 14839                              <2>  eCMOVZ %1, %2
 14840 00000D8A 7502                <3>  jnz SHORT %%Return
 14841 00000D8C B509                <3>  mov %1, %2
 14842                              <3> %%Return:
 14843                              <1> 
 14844                              <1> 	; Select Master or Slave Drive
 14845 00000D8E 8A4601              <1> 	mov		al, [bp+IDEPACK.bDrvAndHead]
 14846                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	DRIVE_AND_HEAD_SELECT_REGISTER
 14847                              <2> %ifndef MODULE_8BIT_IDE
 14848                              <2> 
 14849                              <2>  %ifnidni %1, dx
 14850                              <2>  mov dx, %1
 14851                              <2>  %endif
 14852                              <2>  add dx, [di+DPT.wBasePort]
 14853                              <2>  out dx, al
 14854                              <2> 
 14855                              <2> %else
 14856                              <2> 
 14857                              <2>  %ifnidni %1, dl
 14858 00000D91 B206                <2>  mov dl, %1
 14859                              <2>  %endif
 14860 00000D93 E88904              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 14861                              <2> 
 14862                              <2> %endif
 14863 00000D96 89CB                <1> 	mov		bx, cx
 14864 00000D98 E89403              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
 14865                              <1> 
 14866                              <1> 	; Ignore errors from IDE Error Register (set by previous command)
 14867 00000D9B 80FC80              <1> 	cmp		ah, RET_HD_TIMEOUT
 14868 00000D9E 7403                <1> 	je		SHORT .FailedToSelectDrive
 14869 00000DA0 31C0                <1> 	xor		ax, ax					; Always success unless timeout
 14870 00000DA2 C3                  <1> 	ret
 14871                              <1> .FailedToSelectDrive:
 14872 00000DA3 F9                  <1> 	stc
 14873 00000DA4 C3                  <1> 	ret
 14874                              <1> 
 14875                              <1> 
 14876                              <1> ;--------------------------------------------------------------------
 14877                              <1> ; OutputSectorCountAndAddress
 14878                              <1> ;	Parameters:
 14879                              <1> ;		AH:		LBA low bits (Sector Number)
 14880                              <1> ;		AL:		Sector Count
 14881                              <1> ;		CL:		LBA middle bits (Cylinder Number low)
 14882                              <1> ;		CH:		LBA high bits (Cylinder Number high)
 14883                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 14884                              <1> ;	Returns:
 14885                              <1> ;		Nothing
 14886                              <1> ;	Corrupts registers:
 14887                              <1> ;		AL, BX, DX
 14888                              <1> ;--------------------------------------------------------------------
 14889                              <1> ALIGN JUMP_ALIGN
 14890                              <1> OutputSectorCountAndAddress:
 14891                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	SECTOR_COUNT_REGISTER
 14892                              <2> %ifndef MODULE_8BIT_IDE
 14893                              <2> 
 14894                              <2>  %ifnidni %1, dx
 14895                              <2>  mov dx, %1
 14896                              <2>  %endif
 14897                              <2>  add dx, [di+DPT.wBasePort]
 14898                              <2>  out dx, al
 14899                              <2> 
 14900                              <2> %else
 14901                              <2> 
 14902                              <2>  %ifnidni %1, dl
 14903 00000DA5 B202                <2>  mov dl, %1
 14904                              <2>  %endif
 14905 00000DA7 E87504              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 14906                              <2> 
 14907                              <2> %endif
 14908                              <1> 
 14909 00000DAA 88E0                <1> 	mov		al, ah
 14910                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	LBA_LOW_REGISTER
 14911                              <2> %ifndef MODULE_8BIT_IDE
 14912                              <2> 
 14913                              <2>  %ifnidni %1, dx
 14914                              <2>  mov dx, %1
 14915                              <2>  %endif
 14916                              <2>  add dx, [di+DPT.wBasePort]
 14917                              <2>  out dx, al
 14918                              <2> 
 14919                              <2> %else
 14920                              <2> 
 14921                              <2>  %ifnidni %1, dl
 14922 00000DAC B203                <2>  mov dl, %1
 14923                              <2>  %endif
 14924 00000DAE E86E04              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 14925                              <2> 
 14926                              <2> %endif
 14927                              <1> 
 14928 00000DB1 88C8                <1> 	mov		al, cl
 14929                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	LBA_MIDDLE_REGISTER
 14930                              <2> %ifndef MODULE_8BIT_IDE
 14931                              <2> 
 14932                              <2>  %ifnidni %1, dx
 14933                              <2>  mov dx, %1
 14934                              <2>  %endif
 14935                              <2>  add dx, [di+DPT.wBasePort]
 14936                              <2>  out dx, al
 14937                              <2> 
 14938                              <2> %else
 14939                              <2> 
 14940                              <2>  %ifnidni %1, dl
 14941 00000DB3 B204                <2>  mov dl, %1
 14942                              <2>  %endif
 14943 00000DB5 E86704              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 14944                              <2> 
 14945                              <2> %endif
 14946                              <1> 
 14947 00000DB8 88E8                <1> 	mov		al, ch
 14948                              <1> 	OUTPUT_AL_TO_IDE_REGISTER	LBA_HIGH_REGISTER
 14949                              <2> %ifndef MODULE_8BIT_IDE
 14950                              <2> 
 14951                              <2>  %ifnidni %1, dx
 14952                              <2>  mov dx, %1
 14953                              <2>  %endif
 14954                              <2>  add dx, [di+DPT.wBasePort]
 14955                              <2>  out dx, al
 14956                              <2> 
 14957                              <2> %else
 14958                              <2> 
 14959                              <2>  %ifnidni %1, dl
 14960 00000DBA B205                <2>  mov dl, %1
 14961                              <2>  %endif
 14962 00000DBC E86004              <2>  call IdeIO_OutputALtoIdeRegisterInDL
 14963                              <2> 
 14964                              <2> %endif
 14965 00000DBF C3                  <1> 	ret
 14966                                  %ifdef MODULE_8BIT_IDE_ADVANCED
 14967                                  	%include "JrIdeTransfer.asm"	; Must be included after IdeCommand.asm
 14968                              <1> ; Project name	:	XTIDE Universal BIOS
 14969                              <1> ; Description	:	Memory mapped IDE Device transfer functions.
 14970                              <1> 
 14971                              <1> ;
 14972                              <1> ; XTIDE Universal BIOS and Associated Tools
 14973                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 14974                              <1> ;
 14975                              <1> ; This program is free software; you can redistribute it and/or modify
 14976                              <1> ; it under the terms of the GNU General Public License as published by
 14977                              <1> ; the Free Software Foundation; either version 2 of the License, or
 14978                              <1> ; (at your option) any later version.
 14979                              <1> ;
 14980                              <1> ; This program is distributed in the hope that it will be useful,
 14981                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 14982                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 14983                              <1> ; GNU General Public License for more details.
 14984                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 14985                              <1> ;
 14986                              <1> 
 14987                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 14988                              <1> ; Note mods are actually stripping out old XT-CFv2 memory-mapped IO code.
 14989                              <1> 
 14990                              <1> ; Structure containing variables for PIO transfer functions.
 14991                              <1> ; This struct must not be larger than IDEPACK without INTPACK.
 14992                              <1> struc MEMPIOVARS	; Must not be larger than 9 bytes! See IDEPACK in RamVars.inc.
 14993 00000000 <res 00000002>      <1> 	.wSectorsInBlock		resb	2	; 0-1, Block size in sectors
 14994 00000002 <res 00000004>      <1> 	.fpDPT				resb	4	; 2-5, Far pointer to DPT
 14995 00000006 <res 00000001>      <1> 	.bSectorsLeft			resb	1	; 6, Sectors left to transfer
 14996 00000007 <res 00000001>      <1> 					resb	1	; 7, IDEPACK.bDeviceControl
 14997 00000008 <res 00000001>      <1> 	.bSectorsDone			resb	1	; 8, Number of sectors xferred
 14998                              <1> endstruc
 14999                              <1> 
 15000                              <1> SECTOR_ACCESS_WINDOW_SIZE		EQU	512	; 512 bytes
 15001                              <1> 
 15002                              <1> 
 15003                              <1> ; Section containing code
 15004                              <1> SECTION .text
 15005                              <1> 
 15006                              <1> ;--------------------------------------------------------------------
 15007                              <1> ; JrIdeTransfer_StartWithCommandInAL
 15008                              <1> ;	Parameters:
 15009                              <1> ;		AL:	IDE command that was used to start the transfer
 15010                              <1> ;			(all PIO read and write commands including Identify Device)
 15011                              <1> ;		ES:SI:	Ptr to data buffer
 15012                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15013                              <1> ;		SS:BP:	Ptr to IDEPACK
 15014                              <1> ;	Returns:
 15015                              <1> ;		AH:	INT 13h Error Code
 15016                              <1> ;		CX:	Number of successfully transferred sectors
 15017                              <1> ;		CF:	Cleared if success, Set if error
 15018                              <1> ;	Corrupts registers:
 15019                              <1> ;		AL, BX, DX, SI, ES
 15020                              <1> ;--------------------------------------------------------------------
 15021                              <1> ALIGN JUMP_ALIGN
 15022                              <1> JrIdeTransfer_StartWithCommandInAL:
 15023                              <1> 	; Initialize MEMPIOVARS
 15024 00000DC0 91                  <1> 	xchg		cx, ax				; IDE command to CL
 15025 00000DC1 31C0                <1> 	xor		ax, ax
 15026 00000DC3 884608              <1> 	mov		[bp+MEMPIOVARS.bSectorsDone], al
 15027 00000DC6 8A4602              <1> 	mov		al, [bp+IDEPACK.bSectorCount]
 15028 00000DC9 884606              <1> 	mov		[bp+MEMPIOVARS.bSectorsLeft], al
 15029 00000DCC 8A4515              <1> 	mov		al, [di+DPT_ATA.bBlockSize]
 15030 00000DCF 894600              <1> 	mov		[bp+MEMPIOVARS.wSectorsInBlock], ax
 15031 00000DD2 897E02              <1> 	mov		[bp+MEMPIOVARS.fpDPT], di
 15032 00000DD5 8C5E04              <1> 	mov		[bp+MEMPIOVARS.fpDPT+2], ds
 15033                              <1> 
 15034                              <1> 	; Normalize pointer
 15035 00000DD8 E8E501              <1> 	call	IdeTransfer_NormalizePointerInESSI
 15036                              <1> 
 15037                              <1> 	; Get far pointer to Sector Access Window
 15038 00000DDB 8B5504              <1> 	mov		dx, [di+DPT.wBasePort]
 15039                              <1> 
 15040                              <1> 	; Get Sector Access Window for JR-IDE/ISA
 15041 00000DDE BF003C              <1> 	mov		di, JRIDE_SECTOR_ACCESS_WINDOW_OFFSET
 15042 00000DE1 8EDA                <1> 	mov		ds, dx				; Segment for JR-IDE/ISA
 15043                              <1> 
 15044                              <1> 	; Are we reading or writing?
 15045 00000DE3 F6C110              <1> 	test		cl, 16				; Bit 4 is cleared on all the read commands,
 15046                              <1> 							; but set on 3 of the 4 write commands
 15047 00000DE6 754A                <1> 	jnz		SHORT WriteToSectorAccessWindow
 15048 00000DE8 80F9C5              <1> 	cmp		cl, COMMAND_WRITE_MULTIPLE
 15049 00000DEB 7445                <1> 	je		SHORT WriteToSectorAccessWindow
 15050                              <1> 	; Fall to ReadFromSectorAccessWindow
 15051                              <1> 
 15052                              <1> ;--------------------------------------------------------------------
 15053                              <1> ; ReadFromSectorAccessWindow
 15054                              <1> ;	Parameters:
 15055                              <1> ;		DS:DI:	Ptr to Sector Access Window
 15056                              <1> ;		ES:SI:	Normalized ptr to buffer to receive data
 15057                              <1> ;		SS:BP:	Ptr to MEMPIOVARS
 15058                              <1> ;	Returns:
 15059                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15060                              <1> ;		AH:	BIOS Error code
 15061                              <1> ;		CX:	Number of successfully transferred sectors
 15062                              <1> ;		CF:	0 if transfer successful
 15063                              <1> ;			1 if any error
 15064                              <1> ;	Corrupts registers:
 15065                              <1> ;		AL, BX, DX, SI
 15066                              <1> ;--------------------------------------------------------------------
 15067                              <1> ReadFromSectorAccessWindow:
 15068 00000DED 87F7                <1> 	xchg		si, di					; DS:SI = source, ES:DI = Destination
 15069 00000DEF E88F00              <1> 	call	WaitUntilReadyToTransferNextBlock
 15070 00000DF2 7235                <1> 	jc		SHORT ReturnWithMemoryIOtransferErrorInAH
 15071                              <1> 
 15072 00000DF4 8B4E00              <1> 	mov		cx, [bp+MEMPIOVARS.wSectorsInBlock]	; Clears CH
 15073 00000DF7 384E06              <1> 	cmp		[bp+MEMPIOVARS.bSectorsLeft], cl
 15074 00000DFA 7616                <1> 	jbe		SHORT .ReadLastBlockFromDrive
 15075                              <1> 
 15076                              <1> ALIGN JUMP_ALIGN
 15077                              <1> .ReadNextBlockFromDrive:
 15078 00000DFC E87200              <1> 	call	ReadSingleBlockFromSectorAccessWindowInDSSItoESDI
 15079 00000DFF E87F00              <1> 	call	WaitUntilReadyToTransferNextBlock
 15080 00000E02 7225                <1> 	jc	SHORT ReturnWithMemoryIOtransferErrorInAH
 15081                              <1> 
 15082                              <1> 	; Update number of successfully read sectors and sectors left to transfer.
 15083                              <1> 	; We cannot use SUB instruction as a comparison since it will not
 15084                              <1> 	; work in this situation:
 15085                              <1> 	; Before SUB we have 2 full blocks left to transfer. SUB command
 15086                              <1> 	; then compares 2 full blocks against one full block and updates
 15087                              <1> 	; sectors left to one full block and jumps to .ReadNextBlockFromDrive,
 15088                              <1> 	; since we have one full block left to transfer. After it has been
 15089                              <1> 	; transferred, there will be a wait for next block but DRQ is never
 15090                              <1> 	; set since all is transferred! Then we get timeout error.
 15091 00000E04 8B4E00              <1> 	mov		cx, [bp+MEMPIOVARS.wSectorsInBlock]
 15092 00000E07 284E06              <1> 	sub		[bp+MEMPIOVARS.bSectorsLeft], cl
 15093 00000E0A 004E08              <1> 	add		[bp+MEMPIOVARS.bSectorsDone], cl
 15094 00000E0D 384E06              <1> 	cmp		[bp+MEMPIOVARS.bSectorsLeft], cl
 15095 00000E10 77EA                <1> 	ja		SHORT .ReadNextBlockFromDrive
 15096                              <1> 
 15097                              <1> ALIGN JUMP_ALIGN
 15098                              <1> .ReadLastBlockFromDrive:
 15099 00000E12 8A4E06              <1> 	mov		cl, [bp+MEMPIOVARS.bSectorsLeft]
 15100 00000E15 51                  <1> 	push		cx
 15101 00000E16 E85800              <1> 	call	ReadSingleBlockFromSectorAccessWindowInDSSItoESDI
 15102                              <1> 
 15103                              <1> 	; Check for errors in last block
 15104                              <1> CheckErrorsAfterTransferringLastMemoryMappedBlock:
 15105 00000E19 C57E02              <1> 	lds		di, [bp+MEMPIOVARS.fpDPT]			; DPT now in DS:DI
 15106 00000E1C BB80FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_BSY)
 15107 00000E1F E80D03              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
 15108 00000E22 59                  <1> 	pop		cx	; [bp+MEMPIOVARS.bSectorsLeft]
 15109 00000E23 7204                <1> 	jc		SHORT ReturnWithMemoryIOtransferErrorInAH
 15110                              <1> 
 15111                              <1> 	; All sectors successfully transferred
 15112 00000E25 024E08              <1> 	add		cl, [bp+MEMPIOVARS.bSectorsDone]		; Never sets CF
 15113 00000E28 C3                  <1> 	ret
 15114                              <1> 
 15115                              <1> 	; Return number of successfully transferred sectors
 15116                              <1> ReturnWithMemoryIOtransferErrorInAH:
 15117 00000E29 C57E02              <1> 	lds		di, [bp+MEMPIOVARS.fpDPT]			; DPT now in DS:DI
 15118                              <1> %ifdef USE_386
 15119                              <1> 	movzx	cx, BYTE [bp+MEMPIOVARS.bSectorsDone]
 15120                              <1> %else
 15121 00000E2C B500                <1> 	mov		ch, 0						; Preserve CF
 15122 00000E2E 8A4E08              <1> 	mov		cl, [bp+MEMPIOVARS.bSectorsDone]
 15123                              <1> %endif
 15124 00000E31 C3                  <1> 	ret
 15125                              <1> 
 15126                              <1> 
 15127                              <1> ;--------------------------------------------------------------------
 15128                              <1> ; WriteToSectorAccessWindow
 15129                              <1> ;	Parameters:
 15130                              <1> ;		DS:DI:	Ptr to Sector Access Window
 15131                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
 15132                              <1> ;		SS:BP:	Ptr to MEMPIOVARS
 15133                              <1> ;	Returns:
 15134                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15135                              <1> ;		AH:		BIOS Error code
 15136                              <1> ;		CX:		Number of successfully transferred sectors
 15137                              <1> ;		CF:		0 if transfer successful
 15138                              <1> ;				1 if any error
 15139                              <1> ;	Corrupts registers:
 15140                              <1> ;		AL, BX, DX, SI, ES
 15141                              <1> ;--------------------------------------------------------------------
 15142                              <1> ALIGN JUMP_ALIGN
 15143                              <1> WriteToSectorAccessWindow:
 15144 00000E32 06                  <1> 	push		es
 15145 00000E33 1E                  <1> 	push		ds
 15146 00000E34 07                  <1> 	pop		es		; ES:DI = Sector Access Window (destination)
 15147 00000E35 1F                  <1> 	pop		ds		; DS:SI = Ptr to source buffer
 15148                              <1> 
 15149                              <1> 	; Always poll when writing first block (IRQs are generated for following blocks)
 15150 00000E36 E84800              <1> 	call	WaitUntilReadyToTransferNextBlock
 15151 00000E39 72EE                <1> 	jc		SHORT ReturnWithMemoryIOtransferErrorInAH
 15152                              <1> 
 15153 00000E3B 8B4E00              <1> 	mov		cx, [bp+MEMPIOVARS.wSectorsInBlock]
 15154 00000E3E 384E06              <1> 	cmp		[bp+MEMPIOVARS.bSectorsLeft], cl
 15155 00000E41 7616                <1> 	jbe		SHORT .WriteLastBlockToDrive
 15156                              <1> 
 15157                              <1> ALIGN JUMP_ALIGN
 15158                              <1> .WriteNextBlockToDrive:
 15159 00000E43 E81B00              <1> 	call	WriteSingleBlockFromDSSIToSectorAccessWindowInESDI
 15160 00000E46 E83800              <1> 	call	WaitUntilReadyToTransferNextBlock
 15161 00000E49 72DE                <1> 	jc		SHORT ReturnWithMemoryIOtransferErrorInAH
 15162                              <1> 
 15163                              <1> 	; Increment number of successfully written WORDs
 15164 00000E4B 8B4E00              <1> 	mov		cx, [bp+MEMPIOVARS.wSectorsInBlock]
 15165 00000E4E 284E06              <1> 	sub		[bp+MEMPIOVARS.bSectorsLeft], cl
 15166 00000E51 004E08              <1> 	add		[bp+MEMPIOVARS.bSectorsDone], cl
 15167 00000E54 384E06              <1> 	cmp		[bp+MEMPIOVARS.bSectorsLeft], cl
 15168 00000E57 77EA                <1> 	ja		SHORT .WriteNextBlockToDrive
 15169                              <1> 
 15170                              <1> ALIGN JUMP_ALIGN
 15171                              <1> .WriteLastBlockToDrive:
 15172 00000E59 8A4E06              <1> 	mov		cl, [bp+MEMPIOVARS.bSectorsLeft]
 15173 00000E5C 51                  <1> 	push		cx
 15174                              <1> 	ePUSH_T		bx, CheckErrorsAfterTransferringLastMemoryMappedBlock
 15175                              <2> %ifndef USE_186
 15176                              <2>  %ifidni %2, 0
 15177                              <2>  xor %1, %1
 15178                              <2>  %else
 15179 00000E5D BB[190E]            <2>  mov %1, %2
 15180                              <2>  %endif
 15181 00000E60 53                  <2>  push %1
 15182                              <2> 
 15183                              <2> %else
 15184                              <2>  push %2
 15185                              <2> %endif
 15186                              <1> 	; Fall to WriteSingleBlockFromDSSIToSectorAccessWindowInESDI
 15187                              <1> 
 15188                              <1> ;--------------------------------------------------------------------
 15189                              <1> ; WriteSingleBlockFromDSSIToSectorAccessWindowInESDI
 15190                              <1> ;	Parameters:
 15191                              <1> ;		CX:		Number of sectors in block
 15192                              <1> ;		DS:SI:	Normalized ptr to source buffer
 15193                              <1> ;		ES:DI:	Ptr to Sector Access Window
 15194                              <1> ;	Returns:
 15195                              <1> ;		CX, DX:	Zero
 15196                              <1> ;		SI:		Updated
 15197                              <1> ;	Corrupts registers:
 15198                              <1> ;		BX
 15199                              <1> ;--------------------------------------------------------------------
 15200                              <1> ALIGN JUMP_ALIGN
 15201                              <1> WriteSingleBlockFromDSSIToSectorAccessWindowInESDI:
 15202 00000E61 89FB                <1> 	mov		bx, di
 15203 00000E63 89CA                <1> 	mov		dx, cx
 15204 00000E65 30C9                <1> 	xor		cl, cl
 15205                              <1> ALIGN JUMP_ALIGN
 15206                              <1> .WriteNextSector:
 15207 00000E67 B501                <1> 	mov		ch, SECTOR_ACCESS_WINDOW_SIZE >> 9
 15208 00000E69 F3A5                <1> 	rep movsw
 15209 00000E6B 89DF                <1> 	mov		di, bx	; Reset for next sector
 15210 00000E6D 4A                  <1> 	dec		dx
 15211 00000E6E 75F7                <1> 	jnz		SHORT .WriteNextSector
 15212 00000E70 C3                  <1> 	ret
 15213                              <1> 
 15214                              <1> 
 15215                              <1> ;--------------------------------------------------------------------
 15216                              <1> ; ReadSingleBlockFromSectorAccessWindowInDSSItoESDI
 15217                              <1> ;	Parameters:
 15218                              <1> ;		CX	Number of sectors in full block or sectors in last partial block
 15219                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data (destination)
 15220                              <1> ;		DS:SI:	Ptr to Sector Access Window (source)
 15221                              <1> ;	Returns:
 15222                              <1> ;		CX, DX:	Zero
 15223                              <1> ;		DI:	Updated
 15224                              <1> ;	Corrupts registers:
 15225                              <1> ;		BX
 15226                              <1> ;--------------------------------------------------------------------
 15227                              <1> ALIGN JUMP_ALIGN
 15228                              <1> ReadSingleBlockFromSectorAccessWindowInDSSItoESDI:
 15229 00000E71 89F3                <1> 	mov		bx, si
 15230 00000E73 89CA                <1> 	mov		dx, cx
 15231 00000E75 30C9                <1> 	xor		cl, cl
 15232                              <1> ALIGN JUMP_ALIGN
 15233                              <1> .ReadNextSector:
 15234 00000E77 B501                <1> 	mov		ch, SECTOR_ACCESS_WINDOW_SIZE >> 9
 15235 00000E79 F3A5                <1> 	rep movsw
 15236 00000E7B 89DE                <1> 	mov		si, bx	; Reset for next sector
 15237 00000E7D 4A                  <1> 	dec		dx
 15238 00000E7E 75F7                <1> 	jnz		SHORT .ReadNextSector
 15239 00000E80 C3                  <1> 	ret
 15240                              <1> 
 15241                              <1> 
 15242                              <1> ;--------------------------------------------------------------------
 15243                              <1> ; WaitUntilReadyToTransferNextBlock
 15244                              <1> ;	Parameters:
 15245                              <1> ;		SS:BP:	Ptr to MEMPIOVARS
 15246                              <1> ;	Returns:
 15247                              <1> ;		AH:		INT 13h Error Code
 15248                              <1> ;		CF:		Cleared if success, Set if error
 15249                              <1> ;	Corrupts registers:
 15250                              <1> ;		AL, BX, CX, DX
 15251                              <1> ;--------------------------------------------------------------------
 15252                              <1> ALIGN JUMP_ALIGN
 15253                              <1> WaitUntilReadyToTransferNextBlock:
 15254 00000E81 1E                  <1> 	push		ds
 15255 00000E82 57                  <1> 	push		di
 15256 00000E83 C57E02              <1> 	lds		di, [bp+MEMPIOVARS.fpDPT]	; DPT now in DS:DI
 15257 00000E86 E8A302              <1> 	call	IdeWait_IRQorDRQ			; Always polls
 15258 00000E89 5F                  <1> 	pop		di
 15259 00000E8A 1F                  <1> 	pop		ds
 15260 00000E8B C3                  <1> 	ret
 15261                              <1> 
 15262                              <1> 
 15263                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15264                              <1> %if SECTOR_ACCESS_WINDOW_SIZE <> 512
 15265                              <1> 	%error "SECTOR_ACCESS_WINDOW_SIZE is no longer equal to 512. JrIdeTransfer.asm needs changes."
 15266                              <1> %endif
 15267                              <1> %endif
 15268                              <1> 
 15269                                  	%include "IdeDmaBlock.asm"
 15270                              <1> ; Project name	:	XTIDE Universal BIOS
 15271                              <1> ; Description	:	IDE Read/Write functions for transferring block using DMA
 15272                              <1> ;			for XT-CFv3 adapter.
 15273                              <1> ;
 15274                              <1> ;			These functions should only be called from IdeTransfer.asm.
 15275                              <1> 
 15276                              <1> ;
 15277                              <1> ; XTIDE Universal BIOS and Associated Tools
 15278                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2012 by XTIDE Universal BIOS Team.
 15279                              <1> ;
 15280                              <1> ; This program is free software; you can redistribute it and/or modify
 15281                              <1> ; it under the terms of the GNU General Public License as published by
 15282                              <1> ; the Free Software Foundation; either version 2 of the License, or
 15283                              <1> ; (at your option) any later version.
 15284                              <1> ;
 15285                              <1> ; This program is distributed in the hope that it will be useful,
 15286                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 15287                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 15288                              <1> ; GNU General Public License for more details.
 15289                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 15290                              <1> ;
 15291                              <1> 
 15292                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 15293                              <1> 
 15294                              <1> ; Section containing code
 15295                              <1> SECTION .text
 15296                              <1> 
 15297                              <1> ;--------------------------------------------------------------------
 15298                              <1> ; IdeDmaBlock_WriteToXTCF
 15299                              <1> ;	Parameters:
 15300                              <1> ;		CX:		Block size in 512 byte sectors
 15301                              <1> ;		DX:		XTCF Base Port Address
 15302                              <1> ;		ES:SI:		Physical address to buffer to receive data
 15303                              <1> ;	Returns:
 15304                              <1> ;		Nothing
 15305                              <1> ;	Corrupts registers:
 15306                              <1> ;		AX, BX, CX, DX
 15307                              <1> ;--------------------------------------------------------------------
 15308                              <1> ALIGN JUMP_ALIGN
 15309                              <1> IdeDmaBlock_WriteToXTCF:
 15310 00000E8C 87F7                <1> 	xchg		si, di
 15311 00000E8E B30B                <1> 	mov		bl, CHANNEL_3 | READ | AUTOINIT_DISABLE | ADDRESS_INCREMENT | DEMAND_MODE
 15312 00000E90 E80500              <1> 	call	TransferBlockToOrFromXTCF
 15313 00000E93 87FE                <1> 	xchg		di, si
 15314 00000E95 C3                  <1> 	ret
 15315                              <1> 
 15316                              <1> 
 15317                              <1> ;--------------------------------------------------------------------
 15318                              <1> ; IdeDmaBlock_ReadFromXTCF
 15319                              <1> ;	Parameters:
 15320                              <1> ;		CX:		Block size in 512 byte sectors
 15321                              <1> ;		DX:		XTCF Base Port Address
 15322                              <1> ;		ES:DI:		Physical address to buffer to receive data
 15323                              <1> ;	Returns:
 15324                              <1> ;		Nothing
 15325                              <1> ;	Corrupts registers:
 15326                              <1> ;		AX, BX, CX, DX
 15327                              <1> ;--------------------------------------------------------------------
 15328                              <1> ALIGN JUMP_ALIGN
 15329                              <1> IdeDmaBlock_ReadFromXTCF:
 15330 00000E96 B307                <1> 	mov		bl, CHANNEL_3 | WRITE | AUTOINIT_DISABLE | ADDRESS_INCREMENT | DEMAND_MODE
 15331                              <1> 	; Fall to TransferBlockToOrFromXTCF
 15332                              <1> 
 15333                              <1> 
 15334                              <1> ;--------------------------------------------------------------------
 15335                              <1> ; TransferBlockToOrFromXTCF
 15336                              <1> ; Updated for XT-CFv3, 20-Feb-13
 15337                              <1> ;	Parameters:
 15338                              <1> ;		BL:		Mode byte for DMA Mode Register
 15339                              <1> ;		CX:		Block size in 512 byte sectors
 15340                              <1> ;		DX:		XTCF Base Port Address
 15341                              <1> ;		ES:DI:		Physical address to buffer to receive data
 15342                              <1> ;	Returns:
 15343                              <1> ;		Nothing
 15344                              <1> ;	Corrupts registers:
 15345                              <1> ;		AX, BX, CX, DX
 15346                              <1> ;--------------------------------------------------------------------
 15347                              <1> TransferBlockToOrFromXTCF:
 15348                              <1> 	; 8-bit DMA transfers must be done within 64k physical page.
 15349                              <1> 	; XT-CFv3 support maximum of 64 sector (32768 bytes) blocks in DMA mode
 15350                              <1> 	; so we never need to separate transfer to more than 2 separate DMA operations.
 15351                              <1> 
 15352                              <1> 	; Load XT-CFv3 Control Register port to DX
 15353 00000E98 80C21F              <1> 	add		dl, XTCF_CONTROL_REGISTER
 15354                              <1> 
 15355                              <1> 	; Calculate bytes for first page
 15356 00000E9B 89F8                <1> 	mov		ax, di
 15357 00000E9D F7D8                <1> 	neg		ax								; AX = Max BYTEs for first page
 15358                              <1> %ifdef USE_186
 15359                              <1> 	shl		cx, 9								; CX = Block size in BYTEs
 15360                              <1> %else
 15361 00000E9F 86CD                <1> 	xchg		cl, ch
 15362 00000EA1 D1E1                <1> 	shl		cx, 1
 15363                              <1> %endif
 15364 00000EA3 39C1                <1> 	cmp		cx, ax								; if we won't cross a physical page boundary...
 15365 00000EA5 760F                <1> 	jbe	SHORT .TransferLastDmaPageWithSizeInCX					; ...perform the transfer in one operation
 15366                              <1> 
 15367                              <1> 	; Calculate how much we can transfer on first and second rounds
 15368 00000EA7 91                  <1> 	xchg		cx, ax								; CX = BYTEs for first transfer
 15369 00000EA8 29C8                <1> 	sub		ax, cx								; AX = BYTEs for second transfer
 15370 00000EAA 50                  <1> 	push		ax								; Save bytes for second transfer on stack
 15371                              <1> 
 15372                              <1> 	; Transfer first DMA page
 15373 00000EAB E80800              <1> 	call	StartDMAtransferForXTCFwithDmaModeInBL
 15374                              <1> 
 15375                              <1> 	; Increment physical address in ES:DI - will only ever be wrapping around to next
 15376                              <1> 	; physical segment (hence why it was split)
 15377 00000EAE 8CC1                <1> 	mov		cx, es
 15378 00000EB0 41                  <1> 	inc		cx
 15379 00000EB1 8EC1                <1> 	mov		es, cx								; increment CX via ES
 15380 00000EB3 31FF                <1> 	xor		di, di
 15381 00000EB5 59                  <1> 	pop		cx								; Get bytes for second DMA transfer from stack
 15382                              <1> 
 15383                              <1> .TransferLastDmaPageWithSizeInCX:
 15384                              <1> 	; Fall to StartDMAtransferForXTCFwithDmaModeInBL
 15385                              <1> 
 15386                              <1> ;--------------------------------------------------------------------
 15387                              <1> ; StartDMAtransferForXTCFwithDmaModeInBL
 15388                              <1> ; Updated for XT-CFv3, 26-Mar-13
 15389                              <1> ;	Parameters:
 15390                              <1> ;		BL:		Byte for DMA Mode Register
 15391                              <1> ;		CX:		Number of BYTEs to transfer (1...32768 since max block size is limited to 64)
 15392                              <1> ;		DX:		XT-CFv3 Control Register
 15393                              <1> ;		ES:		Bits 0..3 have physical address bits 19..16
 15394                              <1> ;		DI:		Physical address bits 15..0
 15395                              <1> ;	Returns:
 15396                              <1> ;		Nothing
 15397                              <1> ;	Corrupts registers:
 15398                              <1> ;		AX
 15399                              <1> ;--------------------------------------------------------------------
 15400                              <1> ALIGN JUMP_ALIGN
 15401                              <1> StartDMAtransferForXTCFwithDmaModeInBL:
 15402                              <1> 	; Program 8-bit DMA Controller
 15403                              <1> 	; Disable Interrupts and DMA Channel 3 during DMA setup
 15404 00000EB6 B007                <1> 	mov		al, SET_CH3_MASK_BIT
 15405 00000EB8 FA                  <1> 	cli									; Disable interrupts - programming must be atomic
 15406 00000EB9 E60A                <1> 	out		MASK_REGISTER_DMA8_out, al				; Disable DMA Channel 3
 15407                              <1> 
 15408                              <1> 	; Set DMA Mode (read or write using channel 3)
 15409 00000EBB 88D8                <1> 	mov		al, bl
 15410 00000EBD E60B                <1> 	out		MODE_REGISTER_DMA8_out, al
 15411                              <1> 
 15412                              <1> 	; Set address to DMA controller
 15413 00000EBF E60C                <1> 	out		CLEAR_FLIPFLOP_DMA8_out, al				; Reset flip-flop to low byte
 15414 00000EC1 8CC0                <1> 	mov		ax, es
 15415 00000EC3 E682                <1> 	out		PAGE_DMA8_CH_3, al
 15416 00000EC5 89F8                <1> 	mov		ax, di
 15417 00000EC7 E606                <1> 	out		BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH3_out, al	; Low byte
 15418 00000EC9 88E0                <1> 	mov		al, ah
 15419 00000ECB E606                <1> 	out		BASE_AND_CURRENT_ADDRESS_REGISTER_DMA8_CH3_out, al	; High byte
 15420                              <1> 
 15421                              <1> 	; Set number of bytes to transfer (DMA controller must be programmed number of bytes - 1)
 15422 00000ECD 89C8                <1> 	mov		ax, cx
 15423 00000ECF 48                  <1> 	dec		ax							; DMA controller is programmed for one byte less
 15424 00000ED0 E607                <1> 	out		BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH3_out, al	; Low byte
 15425 00000ED2 88E0                <1> 	mov		al, ah
 15426 00000ED4 E607                <1> 	out		BASE_AND_CURRENT_COUNT_REGISTER_DMA8_CH3_out, al	; High byte
 15427                              <1> 
 15428                              <1> 	; Enable DMA Channel 3
 15429 00000ED6 B003                <1> 	mov		al, CLEAR_CH3_MASK_BIT
 15430 00000ED8 E60A                <1> 	out		MASK_REGISTER_DMA8_out, al				; Enable DMA Channel 3
 15431 00000EDA FB                  <1> 	sti									; Enable interrupts
 15432                              <1> 
 15433                              <1> 	; XT-CF transfers 16 bytes at a time. We need to manually start transfer for every block by writing (anything)
 15434                              <1> 	; to the XT-CFv3 Control Register, which raises DRQ thereby passing system control to the 8237 DMA controller.
 15435                              <1> 	; The XT-CFv3 logic releases DRQ after 16 transfers, thereby handing control back to the CPU and allowing any other IRQs or
 15436                              <1> 	; DRQs to be serviced (which, on the PC and PC/XT will include DRAM refresh via DMA channel 0).  The 16-byte transfers can
 15437                              <1> 	; also be interrupted by the DMA controller raising TC (i.e. when done).  Each transfer cannot be otherwise interrupted
 15438                              <1> 	; and is therefore atomic (and hence fast).
 15439                              <1> 
 15440                              <1> %if 0	; Slow DMA code - works by checking 8237 status register after each 16-byte transfer, until it reports TC has been raised.
 15441                              <1> ALIGN JUMP_ALIGN
 15442                              <1> .TransferNextBlock:
 15443                              <1> 	cli								; We want no ISR to read DMA Status Register before we do
 15444                              <1> 	out		dx, al						; Transfer up to 16 bytes to/from XT-CF card
 15445                              <1> 	in		al, STATUS_REGISTER_DMA8_in
 15446                              <1> 	sti
 15447                              <1> 	test		al, FLG_CH3_HAS_REACHED_TERMINAL_COUNT
 15448                              <1> 	jz		SHORT .TransferNextBlock			; All bytes transferred?
 15449                              <1> %endif ; Slow DMA code
 15450                              <1> 
 15451                              <1> %if 1	; Fast DMA code - perform computed number of transfers, then check DMA status register to be sure
 15452 00000EDB 51                  <1> 	push		cx						; save number of bytes to transfer
 15453 00000EDC 83C10F              <1> 	add		cx, BYTE 15					; We'll divide transfers in 16-byte atomic transfers,
 15454                              <1> 	eSHR_IM		cx, 4						; so include any partial block
 15455                              <2>  eSHIFT_IM %1, %2, shr
 15456                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15457                              <3> %ifndef USE_186
 15458                              <3>  %ifidni %1, cl
 15459                              <3>  times %2 %3 %1, 1
 15460                              <3>  %elifidni %1, ch
 15461                              <3>  times %2 %3 %1, 1
 15462                              <3>  %elifidni %1, cx
 15463 00000EDF D1E9<rept>          <3>  times %2 %3 %1, 1
 15464                              <3>  %else
 15465                              <3>  %if %2 > 3
 15466                              <3>  push cx
 15467                              <3>  mov cl, %2
 15468                              <3>  %3 %1, cl
 15469                              <3>  pop cx
 15470                              <3>  %else
 15471                              <3>  times %2 %3 %1, 1
 15472                              <3>  %endif
 15473                              <3>  %endif
 15474                              <3> 
 15475                              <3> %else
 15476                              <3>  %3 %1, %2
 15477                              <3> %endif
 15478                              <3> %endif
 15479                              <1> ALIGN JUMP_ALIGN
 15480                              <1> .TransferNextDmaBlock:
 15481 00000EE7 EE                  <1> 	out		dx, al						; Transfer up to 16 bytes to/from XT-CF card
 15482 00000EE8 E2FD                <1> 	loop	.TransferNextDmaBlock					; dec CX and loop if CX > 0, also adds required wait-state
 15483 00000EEA 41                  <1> 	inc		cx						; set up CX, in case we need to do an extra iteration
 15484 00000EEB E408                <1> 	in		al, STATUS_REGISTER_DMA8_in			; check 8237 DMA controller status flags...
 15485 00000EED A808                <1> 	test		al, FLG_CH3_HAS_REACHED_TERMINAL_COUNT		; ... for channel 3 terminal count
 15486 00000EEF 74F6                <1> 	jz		SHORT .TransferNextDmaBlock			; If not set, get more bytes
 15487 00000EF1 59                  <1> 	pop		cx						; restore CX to the number of bytes transferred
 15488                              <1> %endif ; Fast DMA code
 15489                              <1> 
 15490 00000EF2 C3                  <1> 	ret
 15491                              <1> 
 15492                                  %endif
 15493                                  	%include "IdeTransfer.asm"
 15494                              <1> ; Project name	:	XTIDE Universal BIOS
 15495                              <1> ; Description	:	IDE Device transfer functions.
 15496                              <1> 
 15497                              <1> ;
 15498                              <1> ; XTIDE Universal BIOS and Associated Tools
 15499                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 15500                              <1> ;
 15501                              <1> ; This program is free software; you can redistribute it and/or modify
 15502                              <1> ; it under the terms of the GNU General Public License as published by
 15503                              <1> ; the Free Software Foundation; either version 2 of the License, or
 15504                              <1> ; (at your option) any later version.
 15505                              <1> ;
 15506                              <1> ; This program is distributed in the hope that it will be useful,
 15507                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 15508                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 15509                              <1> ; GNU General Public License for more details.
 15510                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 15511                              <1> ;
 15512                              <1> 
 15513                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 15514                              <1> 
 15515                              <1> ; Structure containing variables for PIO transfer functions.
 15516                              <1> ; This struct must not be larger than IDEPACK without INTPACK.
 15517                              <1> struc PIOVARS	; Must not be larger than 9 bytes! See IDEPACK in RamVars.inc.
 15518 00000000 <res 00000002>      <1> 	.wDataPort			resb	2	; 0-1, IDE Data Port
 15519 00000002 <res 00000002>      <1> 	.fnXfer				resb	2	; 2-3, Offset to transfer function
 15520 00000004 <res 00000002>      <1> 	.wSectorsInBlock		resb	2	; 4-5, Block size in sectors
 15521 00000006 <res 00000001>      <1> 	.bSectorsLeft			resb	1	; 6, Sectors left to transfer
 15522 00000007 <res 00000001>      <1> 					resb	1	; 7, IDEPACK.bDeviceControl
 15523 00000008 <res 00000001>      <1> 	.bSectorsDone			resb	1	; 8, Number of sectors xferred
 15524                              <1> endstruc
 15525                              <1> 
 15526                              <1> 
 15527                              <1> ; Section containing code
 15528                              <1> SECTION .text
 15529                              <1> 
 15530                              <1> ;--------------------------------------------------------------------
 15531                              <1> ; IdeTransfer_StartWithCommandInAL
 15532                              <1> ;	Parameters:
 15533                              <1> ;		AL:		IDE command that was used to start the transfer
 15534                              <1> ;				(all PIO read and write commands including Identify Device)
 15535                              <1> ;		ES:SI:	Ptr to data buffer
 15536                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15537                              <1> ;		SS:BP:	Ptr to IDEPACK
 15538                              <1> ;	Returns:
 15539                              <1> ;		AH:		INT 13h Error Code
 15540                              <1> ;		CX:		Number of successfully transferred sectors
 15541                              <1> ;		CF:		Cleared if success, Set if error
 15542                              <1> ;	Corrupts registers:
 15543                              <1> ;		AL, BX, DX, SI, ES
 15544                              <1> ;--------------------------------------------------------------------
 15545                              <1> ALIGN JUMP_ALIGN
 15546                              <1> IdeTransfer_StartWithCommandInAL:
 15547                              <1> 	; Are we reading or writing?
 15548 00000EF3 A810                <1> 	test	al, 16	; Bit 4 is cleared on all the read commands but set on 3 of the 4 write commands
 15549 00000EF5 8A6602              <1> 	mov		ah, [bp+IDEPACK.bSectorCount]
 15550 00000EF8 754F                <1> 	jnz		SHORT WriteToDrive
 15551 00000EFA 3CC5                <1> 	cmp		al, COMMAND_WRITE_MULTIPLE
 15552 00000EFC 744B                <1> 	je		SHORT WriteToDrive
 15553                              <1> 	; Fall to ReadFromDrive
 15554                              <1> 
 15555                              <1> ;--------------------------------------------------------------------
 15556                              <1> ; ReadFromDrive
 15557                              <1> ;	Parameters:
 15558                              <1> ;		AH:		Number of sectors to transfer (1...128)
 15559                              <1> ;		ES:SI:		Ptr to buffer to receive data
 15560                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 15561                              <1> ;		SS:BP:		Ptr to PIOVARS
 15562                              <1> ;	Returns:
 15563                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 15564                              <1> ;		AH:		BIOS Error code
 15565                              <1> ;		CX:		Number of successfully transferred sectors
 15566                              <1> ;		CF:		0 if transfer successful
 15567                              <1> ;				1 if any error
 15568                              <1> ;	Corrupts registers:
 15569                              <1> ;		AL, BX, DX, SI, ES
 15570                              <1> ;--------------------------------------------------------------------
 15571                              <1> ReadFromDrive:
 15572                              <1> 	; Prepare to read data to ESSI
 15573 00000EFE BB[D20F]            <1> 	mov		bx, g_rgfnPioRead
 15574 00000F01 E87A00              <1> 	call	InitializePiovarsInSSBPwithSectorCountInAH
 15575                              <1> 
 15576                              <1> 	; Wait until drive is ready to transfer
 15577 00000F04 E82502              <1> 	call	IdeWait_IRQorDRQ					; Wait until ready to transfer
 15578 00000F07 723A                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 15579 00000F09 87F7                <1> 	xchg	si, di							; ES:DI now points buffer
 15580                              <1> 
 15581 00000F0B 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]		; Max 128
 15582                              <1> 
 15583                              <1> ALIGN JUMP_ALIGN
 15584                              <1> .ReadNextBlockFromDrive:
 15585 00000F0E 8B5600              <1> 	mov		dx, [bp+PIOVARS.wDataPort]
 15586 00000F11 384E06              <1> 	cmp		[bp+PIOVARS.bSectorsLeft], cl
 15587 00000F14 7617                <1> 	jbe		SHORT .ReadLastBlockFromDrive
 15588 00000F16 FF5602              <1> 	call	[bp+PIOVARS.fnXfer]
 15589                              <1> 
 15590                              <1> 	; Wait until ready for next block and check for errors
 15591 00000F19 87FE                <1> 	xchg		di, si						; DS:DI now points DPT
 15592 00000F1B E80E02              <1> 	call	IdeWait_IRQorDRQ					; Wait until ready to transfer
 15593 00000F1E 7223                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 15594 00000F20 87F7                <1> 	xchg		si, di						; ES:DI now points buffer
 15595                              <1> 
 15596                              <1> 	; Increment number of successfully read sectors
 15597 00000F22 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]
 15598 00000F25 284E06              <1> 	sub		[bp+PIOVARS.bSectorsLeft], cl
 15599 00000F28 004E08              <1> 	add		[bp+PIOVARS.bSectorsDone], cl
 15600 00000F2B EBE1                <1> 	jmp		SHORT .ReadNextBlockFromDrive
 15601                              <1> 
 15602                              <1> ALIGN JUMP_ALIGN
 15603                              <1> .ReadLastBlockFromDrive:
 15604 00000F2D 8A4E06              <1> 	mov		cl, [bp+PIOVARS.bSectorsLeft]			; CH is already zero
 15605 00000F30 51                  <1> 	push	cx
 15606 00000F31 FF5602              <1> 	call	[bp+PIOVARS.fnXfer]					; Transfer possibly partial block
 15607                              <1> 
 15608                              <1> 	; Check for errors in last block
 15609 00000F34 89F7                <1> 	mov		di, si						; DS:DI now points DPT
 15610                              <1> CheckErrorsAfterTransferringLastBlock:
 15611 00000F36 BB80FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_BSY)
 15612 00000F39 E8F301              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
 15613 00000F3C 59                  <1> 	pop		cx	; [bp+PIOVARS.bSectorsLeft]
 15614 00000F3D 7204                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 15615                              <1> 
 15616                              <1> 	; All sectors successfully transferred
 15617 00000F3F 034E08              <1> 	add		cx, [bp+PIOVARS.bSectorsDone]			; Never sets CF
 15618 00000F42 C3                  <1> 	ret
 15619                              <1> 
 15620                              <1> 	; Return number of successfully read sectors
 15621                              <1> ReturnWithTransferErrorInAH:
 15622                              <1> %ifdef USE_386
 15623                              <1> 	movzx	cx, [bp+PIOVARS.bSectorsDone]
 15624                              <1> %else
 15625 00000F43 8A4E08              <1> 	mov		cl, [bp+PIOVARS.bSectorsDone]
 15626 00000F46 B500                <1> 	mov		ch, 0						; Preserve CF
 15627                              <1> %endif
 15628 00000F48 C3                  <1> 	ret
 15629                              <1> 
 15630                              <1> 
 15631                              <1> ;--------------------------------------------------------------------
 15632                              <1> ; WriteToDrive
 15633                              <1> ;	Parameters:
 15634                              <1> ;		AH:		Number of sectors to transfer (1...128)
 15635                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15636                              <1> ;		ES:SI:	Ptr to buffer containing data
 15637                              <1> ;		SS:BP:	Ptr to PIOVARS
 15638                              <1> ;	Returns:
 15639                              <1> ;		AH:		BIOS Error code
 15640                              <1> ;		CX:		Number of successfully transferred sectors
 15641                              <1> ;		CF:		0 if transfer successful
 15642                              <1> ;				1 if any error
 15643                              <1> ;	Corrupts registers:
 15644                              <1> ;		AL, BX, DX, SI, ES
 15645                              <1> ;--------------------------------------------------------------------
 15646                              <1> ALIGN JUMP_ALIGN
 15647                              <1> WriteToDrive:
 15648                              <1> 	; Prepare to write data from ESSI
 15649 00000F49 BB[E20F]            <1> 	mov		bx, g_rgfnPioWrite
 15650 00000F4C E82F00              <1> 	call	InitializePiovarsInSSBPwithSectorCountInAH
 15651                              <1> 
 15652                              <1> 	; Always poll when writing first block (IRQs are generated for following blocks)
 15653 00000F4F BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 15654 00000F52 E8DA01              <1> 	call	IdeWait_PollStatusFlagInBLwithTimeoutInBH
 15655 00000F55 72EC                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 15656                              <1> 
 15657 00000F57 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]		; Max 128
 15658                              <1> 
 15659                              <1> ALIGN JUMP_ALIGN
 15660                              <1> .WriteNextBlockToDrive:
 15661 00000F5A 8B5600              <1> 	mov		dx, [bp+PIOVARS.wDataPort]
 15662 00000F5D 384E06              <1> 	cmp		[bp+PIOVARS.bSectorsLeft], cl
 15663 00000F60 7613                <1> 	jbe		SHORT .WriteLastBlockToDrive
 15664 00000F62 FF5602              <1> 	call	[bp+PIOVARS.fnXfer]
 15665                              <1> 
 15666                              <1> 	; Wait until ready for next block and check for errors
 15667 00000F65 E8C401              <1> 	call	IdeWait_IRQorDRQ					; Wait until ready to transfer
 15668 00000F68 72D9                <1> 	jc		SHORT ReturnWithTransferErrorInAH
 15669                              <1> 
 15670                              <1> 	; Increment number of successfully written sectors
 15671 00000F6A 8B4E04              <1> 	mov		cx, [bp+PIOVARS.wSectorsInBlock]
 15672 00000F6D 284E06              <1> 	sub		[bp+PIOVARS.bSectorsLeft], cl
 15673 00000F70 004E08              <1> 	add		[bp+PIOVARS.bSectorsDone], cl
 15674 00000F73 EBE5                <1> 	jmp		SHORT .WriteNextBlockToDrive
 15675                              <1> 
 15676                              <1> ALIGN JUMP_ALIGN
 15677                              <1> .WriteLastBlockToDrive:
 15678 00000F75 8A4E06              <1> 	mov		cl, [bp+PIOVARS.bSectorsLeft]			; CH is already zero
 15679 00000F78 51                  <1> 	push		cx
 15680                              <1> %ifdef USE_186
 15681                              <1> 	push		CheckErrorsAfterTransferringLastBlock
 15682                              <1> 	jmp		[bp+PIOVARS.fnXfer]				; Transfer possibly partial block
 15683                              <1> %else
 15684 00000F79 FF5602              <1> 	call		[bp+PIOVARS.fnXfer]				; Transfer possibly partial block
 15685 00000F7C EBB8                <1> 	jmp		SHORT CheckErrorsAfterTransferringLastBlock
 15686                              <1> %endif
 15687                              <1> 
 15688                              <1> 
 15689                              <1> ;--------------------------------------------------------------------
 15690                              <1> ; InitializePiovarsInSSBPwithSectorCountInAH
 15691                              <1> ;	Parameters:
 15692                              <1> ;		AH:		Number of sectors to transfer (1...128)
 15693                              <1> ;		BX:		Offset to transfer function lookup table
 15694                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 15695                              <1> ;		ES:SI:	Ptr to data buffer
 15696                              <1> ;		SS:BP:	Ptr to PIOVARS
 15697                              <1> ;	Returns:
 15698                              <1> ;		Nothing
 15699                              <1> ;	Corrupts registers:
 15700                              <1> ;		AX, BX, DX
 15701                              <1> ;--------------------------------------------------------------------
 15702                              <1> ALIGN JUMP_ALIGN
 15703                              <1> InitializePiovarsInSSBPwithSectorCountInAH:
 15704                              <1> 	; Store sizes and Data Port
 15705 00000F7E 886606              <1> 	mov		[bp+PIOVARS.bSectorsLeft], ah
 15706 00000F81 8B4504              <1> 	mov		ax, [di+DPT.wBasePort]
 15707 00000F84 894600              <1> 	mov		[bp+PIOVARS.wDataPort], ax
 15708                              <1> 	eMOVZX		ax, [di+DPT_ATA.bBlockSize]
 15709                              <2> %ifndef USE_386
 15710                              <2>  %ifidni %1, ax
 15711 00000F87 8A4515              <2>  mov al, %2
 15712 00000F8A 30E4                <2>  xor ah, ah
 15713                              <2>  %elifidni %1, bx
 15714                              <2>  mov bl, %2
 15715                              <2>  xor bh, bh
 15716                              <2>  %elifidni %1, cx
 15717                              <2>  mov cl, %2
 15718                              <2>  xor ch, ch
 15719                              <2>  %elifidni %1, dx
 15720                              <2>  mov dl, %2
 15721                              <2>  xor dh, dh
 15722                              <2>  %else
 15723                              <2>  push ax
 15724                              <2>  mov al, %2
 15725                              <2>  xor ah, ah
 15726                              <2>  xchg ax, %1
 15727                              <2>  pop ax
 15728                              <2>  %endif
 15729                              <2> 
 15730                              <2> %else
 15731                              <2>  movzx %1, %2
 15732                              <2> %endif
 15733 00000F8C 894604              <1> 	mov		[bp+PIOVARS.wSectorsInBlock], ax
 15734 00000F8F 886608              <1> 	mov		[bp+PIOVARS.bSectorsDone], ah			; Zero
 15735                              <1> 
 15736                              <1> 	; Get transfer function based on bus type
 15737 00000F92 93                  <1> 	xchg		ax, bx						; Lookup table offset to AX
 15738 00000F93 8A5D14              <1> 	mov		bl, [di+DPT_ATA.bDevice]			; get device type to BX
 15739                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 15740 00000F96 88DA                <1> 	mov		dl, bl
 15741                              <1> %endif
 15742 00000F98 01C3                <1> 	add		bx, ax						; add table offset to device type (index)
 15743 00000F9A 2E8B07              <1> 	mov		ax, [cs:bx]					; Load offset to transfer function
 15744 00000F9D 894602              <1> 	mov		[bp+PIOVARS.fnXfer], ax
 15745                              <1> 
 15746                              <1> 	; Normalize pointer for PIO-transfers and convert to physical address for DMA transfers
 15747                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 15748 00000FA0 80FA0E              <1> 	cmp		dl, DEVICE_8BIT_XTCF_DMA
 15749 00000FA3 721B                <1> 	jb		SHORT IdeTransfer_NormalizePointerInESSI
 15750                              <1> 
 15751                              <1> 	; Convert ES:SI to physical address
 15752                              <1> %ifdef USE_186			; Bytes	EU Cycles(286)
 15753                              <1> 	mov		ax, es		; 2		2
 15754                              <1> 	rol		ax, 4		; 3		9
 15755                              <1> 	mov		dx, ax		; 2		2
 15756                              <1> 	and		ax, BYTE 0Fh	; 3		3
 15757                              <1> 	xor		dx, ax		; 2		2
 15758                              <1> 	add		si, dx		; 2		2
 15759                              <1> 	adc		al, ah		; 2		2
 15760                              <1> 	mov		es, ax		; 2		2
 15761                              <1> 	;------------------------------------
 15762                              <1> 						; 18	24
 15763                              <1> %else ; 808x
 15764                              <1> 
 15765                              <1> %if 0
 15766                              <1> 						; Bytes	EU Cycles(808x)
 15767                              <1> 	mov		al, 4		; 2		4
 15768                              <1> 	mov		dx, es		; 2		2
 15769                              <1> 	xchg	cx, ax		; 1		3
 15770                              <1> 	rol		dx, cl		; 2		24
 15771                              <1> 	mov		cx, dx		; 2		2
 15772                              <1> 	xchg	cx, ax		; 1		3
 15773                              <1> 	and		ax, BYTE 0Fh; 3		4
 15774                              <1> 	xor		dx, ax		; 2		3
 15775                              <1> 	add		si, dx		; 2		3
 15776                              <1> 	adc		al, ah		; 2		3
 15777                              <1> 	mov		es, ax		; 2		2
 15778                              <1> 	;------------------------------------
 15779                              <1> 						; 21	53
 15780                              <1> ;
 15781                              <1> ; Judging by the Execution Unit cycle count the above block of code is
 15782                              <1> ; apparently slower. However, the shifts and rotates in the block below
 15783                              <1> ; execute faster than the Bus Interface Unit on an 8088 can fetch them,
 15784                              <1> ; thus causing the EU to starve. The difference in true execution speed
 15785                              <1> ; (if any) might not be worth the extra 5 bytes.
 15786                              <1> ; In other words, we could use a real world test here.
 15787                              <1> ;
 15788                              <1> %endif ; 0
 15789                              <1> 						; Bytes	EU Cycles(808x/286)
 15790 00000FA5 31D2                <1> 	xor		dx, dx		; 2		3/2
 15791 00000FA7 8CC0                <1> 	mov		ax, es		; 2		2/2
 15792                              <1> %rep 4
 15793                              <1> 	shl		ax, 1		; 8		8/8
 15794                              <1> 	rcl		dx, 1		; 8		8/8
 15795                              <1> %endrep
 15796 00000FA9 D1E0                <2>  shl ax, 1
 15797 00000FAB D1D2                <2>  rcl dx, 1
 15798 00000FAD D1E0                <2>  shl ax, 1
 15799 00000FAF D1D2                <2>  rcl dx, 1
 15800 00000FB1 D1E0                <2>  shl ax, 1
 15801 00000FB3 D1D2                <2>  rcl dx, 1
 15802 00000FB5 D1E0                <2>  shl ax, 1
 15803 00000FB7 D1D2                <2>  rcl dx, 1
 15804 00000FB9 01C6                <1> 	add		si, ax		; 2		3/2
 15805 00000FBB 10F2                <1> 	adc		dl, dh		; 2		3/2
 15806 00000FBD 8EC2                <1> 	mov		es, dx		; 2		2/2
 15807                              <1> 	;------------------------------------
 15808                              <1> %endif					; 26	29/26
 15809 00000FBF C3                  <1> 	ret
 15810                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 15811                              <1> 	; Fall to IdeTransfer_NormalizePointerInESSI if no MODULE_8BIT_IDE
 15812                              <1> 
 15813                              <1> 
 15814                              <1> ;--------------------------------------------------------------------
 15815                              <1> ; IdeTransfer_NormalizePointerInESSI
 15816                              <1> ;	Parameters:
 15817                              <1> ;		ES:SI:	Ptr to be normalized
 15818                              <1> ;	Returns:
 15819                              <1> ;		ES:SI:	Normalized pointer (SI = 0...15)
 15820                              <1> ;	Corrupts registers:
 15821                              <1> ;		AX, DX
 15822                              <1> ;--------------------------------------------------------------------
 15823                              <1> IdeTransfer_NormalizePointerInESSI:
 15824                              <1> 	NORMALIZE_FAR_POINTER	es, si, ax, dx
 15825 00000FC0 89F2                <2>  mov %4, %2
 15826 00000FC2 83E60F              <2>  and %2, BYTE 0Fh
 15827                              <2>  eSHR_IM %4, 4
 15828                              <3>  eSHIFT_IM %1, %2, shr
 15829                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 15830                              <4> %ifndef USE_186
 15831                              <4>  %ifidni %1, cl
 15832                              <4>  times %2 %3 %1, 1
 15833                              <4>  %elifidni %1, ch
 15834                              <4>  times %2 %3 %1, 1
 15835                              <4>  %elifidni %1, cx
 15836                              <4>  times %2 %3 %1, 1
 15837                              <4>  %else
 15838                              <4>  %if %2 > 3
 15839 00000FC5 51                  <4>  push cx
 15840 00000FC6 B104                <4>  mov cl, %2
 15841 00000FC8 D3EA                <4>  %3 %1, cl
 15842 00000FCA 59                  <4>  pop cx
 15843                              <4>  %else
 15844                              <4>  times %2 %3 %1, 1
 15845                              <4>  %endif
 15846                              <4>  %endif
 15847                              <4> 
 15848                              <4> %else
 15849                              <4>  %3 %1, %2
 15850                              <4> %endif
 15851                              <4> %endif
 15852 00000FCB 8CC0                <2>  mov %3, %1
 15853 00000FCD 01D0                <2>  add %3, %4
 15854 00000FCF 8EC0                <2>  mov %1, %3
 15855 00000FD1 C3                  <1> 	ret
 15856                              <1> 
 15857                              <1> 
 15858                              <1> ; Lookup tables to get transfer function based on bus type
 15859                              <1> ALIGN WORD_ALIGN
 15860                              <1> g_rgfnPioRead:
 15861 00000FD2 [6610]              <1> 		dw		IdePioBlock_ReadFrom16bitDataPort	; 0, DEVICE_16BIT_ATA
 15862 00000FD4 [7F10]              <1> 		dw		IdePioBlock_ReadFrom32bitDataPort	; 1, DEVICE_32BIT_ATA
 15863                              <1> %ifdef MODULE_8BIT_IDE
 15864 00000FD6 [3D10]              <1> 		dw		IdePioBlock_ReadFrom8bitDataPort	; 2, DEVICE_8BIT_ATA
 15865 00000FD8 [F20F]              <1> 		dw		IdePioBlock_ReadFromXtideRev1		; 3, DEVICE_8BIT_XTIDE_REV1
 15866 00000FDA [6610]              <1> 		dw		IdePioBlock_ReadFrom16bitDataPort	; 4, DEVICE_8BIT_XTIDE_REV2
 15867 00000FDC [3D10]              <1> 		dw		IdePioBlock_ReadFrom8bitDataPort	; 5, DEVICE_8BIT_XTCF_PIO8
 15868 00000FDE [6610]              <1> 		dw		IdePioBlock_ReadFrom16bitDataPort	; 6, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
 15869 00000FE0 [960E]              <1> 		dw		IdeDmaBlock_ReadFromXTCF		; 7, DEVICE_8BIT_XTCF_DMA
 15870                              <1> %endif
 15871                              <1> 
 15872                              <1> 
 15873                              <1> g_rgfnPioWrite:
 15874 00000FE2 [0F11]              <1> 		dw		IdePioBlock_WriteTo16bitDataPort	; 0, DEVICE_16BIT_ATA
 15875 00000FE4 [2411]              <1> 		dw		IdePioBlock_WriteTo32bitDataPort	; 1, DEVICE_32BIT_ATA
 15876                              <1> %ifdef MODULE_8BIT_IDE
 15877 00000FE6 [F210]              <1> 		dw		IdePioBlock_WriteTo8bitDataPort		; 2, DEVICE_8BIT_ATA
 15878 00000FE8 [8610]              <1> 		dw		IdePioBlock_WriteToXtideRev1		; 3, DEVICE_8BIT_XTIDE_REV1
 15879 00000FEA [C110]              <1> 		dw		IdePioBlock_WriteToXtideRev2		; 4, DEVICE_8BIT_XTIDE_REV2
 15880 00000FEC [F210]              <1> 		dw		IdePioBlock_WriteTo8bitDataPort		; 5, DEVICE_8BIT_XTCF_PIO8
 15881 00000FEE [0F11]              <1> 		dw		IdePioBlock_WriteTo16bitDataPort	; 6, DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
 15882 00000FF0 [8C0E]              <1> 		dw		IdeDmaBlock_WriteToXTCF			; 7, DEVICE_8BIT_XTCF_DMA
 15883                              <1> %endif
 15884                                  	%include "IdePioBlock.asm"
 15885                              <1> ; Project name	:	XTIDE Universal BIOS
 15886                              <1> ; Description	:	IDE Read/Write functions for transferring
 15887                              <1> ;					block using PIO modes.
 15888                              <1> ;					These functions should only be called from IdeTransfer.asm.
 15889                              <1> 
 15890                              <1> ;
 15891                              <1> ; XTIDE Universal BIOS and Associated Tools
 15892                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 15893                              <1> ;
 15894                              <1> ; This program is free software; you can redistribute it and/or modify
 15895                              <1> ; it under the terms of the GNU General Public License as published by
 15896                              <1> ; the Free Software Foundation; either version 2 of the License, or
 15897                              <1> ; (at your option) any later version.
 15898                              <1> ;
 15899                              <1> ; This program is distributed in the hope that it will be useful,
 15900                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 15901                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 15902                              <1> ; GNU General Public License for more details.
 15903                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 15904                              <1> ;
 15905                              <1> 
 15906                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 15907                              <1> 
 15908                              <1> ; Section containing code
 15909                              <1> SECTION .text
 15910                              <1> 
 15911                              <1> 
 15912                              <1> ; --------------------------------------------------------------------------------------------------
 15913                              <1> ;
 15914                              <1> ; READ routines follow
 15915                              <1> ;
 15916                              <1> ; --------------------------------------------------------------------------------------------------
 15917                              <1> 
 15918                              <1> 
 15919                              <1> %ifdef MODULE_8BIT_IDE
 15920                              <1> 
 15921                              <1> ;--------------------------------------------------------------------
 15922                              <1> ; IdePioBlock_ReadFromXtideRev1
 15923                              <1> ;	Parameters:
 15924                              <1> ;		CX:		Block size in 512 byte sectors
 15925                              <1> ;		DX:		IDE Data port address
 15926                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data
 15927                              <1> ;	Returns:
 15928                              <1> ;		Nothing
 15929                              <1> ;	Corrupts registers:
 15930                              <1> ;		AX, BX, CX
 15931                              <1> ;--------------------------------------------------------------------
 15932                              <1> ALIGN JUMP_ALIGN
 15933                              <1> IdePioBlock_ReadFromXtideRev1:
 15934                              <1> 	UNROLL_SECTORS_IN_CX_TO_OWORDS
 15935                              <2> %ifdef USE_186
 15936                              <2>  shl cx, 5
 15937                              <2> %else
 15938                              <2> 
 15939                              <2> 
 15940 00000FF2 88CD                <2>  mov ch, cl
 15941 00000FF4 B103                <2>  mov cl, 3
 15942 00000FF6 D3E9                <2>  shr cx, cl
 15943                              <2> %endif
 15944 00000FF8 B308                <1> 	mov		bl, 8		; Bit mask for toggling data low/high reg
 15945                              <1> ALIGN JUMP_ALIGN
 15946                              <1> .InswLoop:
 15947                              <1> 	%rep 8 ; WORDs
 15948                              <1> 		XTIDE_INSW
 15949                              <1> 	%endrep
 15950                              <2>  XTIDE_INSW
 15951                              <3> %ifdef USE_186
 15952                              <3>  insb
 15953                              <3>  xor dl, bl
 15954                              <3>  insb
 15955                              <3>  xor dl, bl
 15956                              <3> %else
 15957 00000FFA EC                  <3>  in al, dx
 15958 00000FFB 30DA                <3>  xor dl, bl
 15959 00000FFD AA                  <3>  stosb
 15960 00000FFE EC                  <3>  in al, dx
 15961 00000FFF 30DA                <3>  xor dl, bl
 15962 00001001 AA                  <3>  stosb
 15963                              <3> %endif
 15964                              <2>  XTIDE_INSW
 15965                              <3> %ifdef USE_186
 15966                              <3>  insb
 15967                              <3>  xor dl, bl
 15968                              <3>  insb
 15969                              <3>  xor dl, bl
 15970                              <3> %else
 15971 00001002 EC                  <3>  in al, dx
 15972 00001003 30DA                <3>  xor dl, bl
 15973 00001005 AA                  <3>  stosb
 15974 00001006 EC                  <3>  in al, dx
 15975 00001007 30DA                <3>  xor dl, bl
 15976 00001009 AA                  <3>  stosb
 15977                              <3> %endif
 15978                              <2>  XTIDE_INSW
 15979                              <3> %ifdef USE_186
 15980                              <3>  insb
 15981                              <3>  xor dl, bl
 15982                              <3>  insb
 15983                              <3>  xor dl, bl
 15984                              <3> %else
 15985 0000100A EC                  <3>  in al, dx
 15986 0000100B 30DA                <3>  xor dl, bl
 15987 0000100D AA                  <3>  stosb
 15988 0000100E EC                  <3>  in al, dx
 15989 0000100F 30DA                <3>  xor dl, bl
 15990 00001011 AA                  <3>  stosb
 15991                              <3> %endif
 15992                              <2>  XTIDE_INSW
 15993                              <3> %ifdef USE_186
 15994                              <3>  insb
 15995                              <3>  xor dl, bl
 15996                              <3>  insb
 15997                              <3>  xor dl, bl
 15998                              <3> %else
 15999 00001012 EC                  <3>  in al, dx
 16000 00001013 30DA                <3>  xor dl, bl
 16001 00001015 AA                  <3>  stosb
 16002 00001016 EC                  <3>  in al, dx
 16003 00001017 30DA                <3>  xor dl, bl
 16004 00001019 AA                  <3>  stosb
 16005                              <3> %endif
 16006                              <2>  XTIDE_INSW
 16007                              <3> %ifdef USE_186
 16008                              <3>  insb
 16009                              <3>  xor dl, bl
 16010                              <3>  insb
 16011                              <3>  xor dl, bl
 16012                              <3> %else
 16013 0000101A EC                  <3>  in al, dx
 16014 0000101B 30DA                <3>  xor dl, bl
 16015 0000101D AA                  <3>  stosb
 16016 0000101E EC                  <3>  in al, dx
 16017 0000101F 30DA                <3>  xor dl, bl
 16018 00001021 AA                  <3>  stosb
 16019                              <3> %endif
 16020                              <2>  XTIDE_INSW
 16021                              <3> %ifdef USE_186
 16022                              <3>  insb
 16023                              <3>  xor dl, bl
 16024                              <3>  insb
 16025                              <3>  xor dl, bl
 16026                              <3> %else
 16027 00001022 EC                  <3>  in al, dx
 16028 00001023 30DA                <3>  xor dl, bl
 16029 00001025 AA                  <3>  stosb
 16030 00001026 EC                  <3>  in al, dx
 16031 00001027 30DA                <3>  xor dl, bl
 16032 00001029 AA                  <3>  stosb
 16033                              <3> %endif
 16034                              <2>  XTIDE_INSW
 16035                              <3> %ifdef USE_186
 16036                              <3>  insb
 16037                              <3>  xor dl, bl
 16038                              <3>  insb
 16039                              <3>  xor dl, bl
 16040                              <3> %else
 16041 0000102A EC                  <3>  in al, dx
 16042 0000102B 30DA                <3>  xor dl, bl
 16043 0000102D AA                  <3>  stosb
 16044 0000102E EC                  <3>  in al, dx
 16045 0000102F 30DA                <3>  xor dl, bl
 16046 00001031 AA                  <3>  stosb
 16047                              <3> %endif
 16048                              <2>  XTIDE_INSW
 16049                              <3> %ifdef USE_186
 16050                              <3>  insb
 16051                              <3>  xor dl, bl
 16052                              <3>  insb
 16053                              <3>  xor dl, bl
 16054                              <3> %else
 16055 00001032 EC                  <3>  in al, dx
 16056 00001033 30DA                <3>  xor dl, bl
 16057 00001035 AA                  <3>  stosb
 16058 00001036 EC                  <3>  in al, dx
 16059 00001037 30DA                <3>  xor dl, bl
 16060 00001039 AA                  <3>  stosb
 16061                              <3> %endif
 16062 0000103A E2BE                <1> 	loop	.InswLoop
 16063 0000103C C3                  <1> 	ret
 16064                              <1> 
 16065                              <1> 
 16066                              <1> ;--------------------------------------------------------------------
 16067                              <1> ; IdePioBlock_ReadFrom8bitDataPort
 16068                              <1> ;
 16069                              <1> ; 8-bit PIO from a single data port.
 16070                              <1> ;
 16071                              <1> ;	Parameters:
 16072                              <1> ;		CX:	Block size in 512 byte sectors
 16073                              <1> ;		DX:	IDE Data port address
 16074                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data
 16075                              <1> ;	Returns:
 16076                              <1> ;		Nothing
 16077                              <1> ;	Corrupts registers:
 16078                              <1> ;		AX, BX, CX
 16079                              <1> ;--------------------------------------------------------------------
 16080                              <1> ALIGN JUMP_ALIGN
 16081                              <1> IdePioBlock_ReadFrom8bitDataPort:
 16082                              <1> %ifdef USE_186
 16083                              <1> 	shl		cx, 9			; Sectors to BYTEs
 16084                              <1> 	rep insb
 16085                              <1> 	ret
 16086                              <1> %else ; If 8088/8086
 16087                              <1> 	UNROLL_SECTORS_IN_CX_TO_OWORDS
 16088                              <2> %ifdef USE_186
 16089                              <2>  shl cx, 5
 16090                              <2> %else
 16091                              <2> 
 16092                              <2> 
 16093 0000103D 88CD                <2>  mov ch, cl
 16094 0000103F B103                <2>  mov cl, 3
 16095 00001041 D3E9                <2>  shr cx, cl
 16096                              <2> %endif
 16097                              <1> ALIGN JUMP_ALIGN
 16098                              <1> .ReadNextOword:
 16099                              <1> 	%rep 16	; BYTEs
 16100                              <1> 		in		al, dx		; Read BYTE
 16101                              <1> 		stosb				; Store BYTE to [ES:DI]
 16102                              <1> 	%endrep
 16103 00001043 EC                  <2>  in al, dx
 16104 00001044 AA                  <2>  stosb
 16105 00001045 EC                  <2>  in al, dx
 16106 00001046 AA                  <2>  stosb
 16107 00001047 EC                  <2>  in al, dx
 16108 00001048 AA                  <2>  stosb
 16109 00001049 EC                  <2>  in al, dx
 16110 0000104A AA                  <2>  stosb
 16111 0000104B EC                  <2>  in al, dx
 16112 0000104C AA                  <2>  stosb
 16113 0000104D EC                  <2>  in al, dx
 16114 0000104E AA                  <2>  stosb
 16115 0000104F EC                  <2>  in al, dx
 16116 00001050 AA                  <2>  stosb
 16117 00001051 EC                  <2>  in al, dx
 16118 00001052 AA                  <2>  stosb
 16119 00001053 EC                  <2>  in al, dx
 16120 00001054 AA                  <2>  stosb
 16121 00001055 EC                  <2>  in al, dx
 16122 00001056 AA                  <2>  stosb
 16123 00001057 EC                  <2>  in al, dx
 16124 00001058 AA                  <2>  stosb
 16125 00001059 EC                  <2>  in al, dx
 16126 0000105A AA                  <2>  stosb
 16127 0000105B EC                  <2>  in al, dx
 16128 0000105C AA                  <2>  stosb
 16129 0000105D EC                  <2>  in al, dx
 16130 0000105E AA                  <2>  stosb
 16131 0000105F EC                  <2>  in al, dx
 16132 00001060 AA                  <2>  stosb
 16133 00001061 EC                  <2>  in al, dx
 16134 00001062 AA                  <2>  stosb
 16135 00001063 E2DE                <1> 	loop	.ReadNextOword
 16136 00001065 C3                  <1> 	ret
 16137                              <1> %endif
 16138                              <1> 
 16139                              <1> %endif	; MODULE_8BIT_IDE
 16140                              <1> 
 16141                              <1> 
 16142                              <1> ;--------------------------------------------------------------------
 16143                              <1> ; IdePioBlock_ReadFrom16bitDataPort
 16144                              <1> ;
 16145                              <1> ; 16-bit PIO from a single data port.
 16146                              <1> ;
 16147                              <1> ;	Parameters:
 16148                              <1> ;		CX:	Block size in 512 byte sectors
 16149                              <1> ;		DX:	IDE Data port address
 16150                              <1> ;		ES:DI:	Normalized ptr to buffer to receive data
 16151                              <1> ;	Returns:
 16152                              <1> ;		Nothing
 16153                              <1> ;	Corrupts registers:
 16154                              <1> ;		AX, BX, CX
 16155                              <1> ;--------------------------------------------------------------------
 16156                              <1> ALIGN JUMP_ALIGN
 16157                              <1> IdePioBlock_ReadFrom16bitDataPort:
 16158                              <1> %ifdef USE_186
 16159                              <1> 	xhcg		cl, ch			; Sectors to WORDs
 16160                              <1> 	rep
 16161                              <1> 	db		6Dh			; INSW
 16162                              <1> 	ret
 16163                              <1> %else ; If 8088/8086
 16164                              <1> 	UNROLL_SECTORS_IN_CX_TO_OWORDS
 16165                              <2> %ifdef USE_186
 16166                              <2>  shl cx, 5
 16167                              <2> %else
 16168                              <2> 
 16169                              <2> 
 16170 00001066 88CD                <2>  mov ch, cl
 16171 00001068 B103                <2>  mov cl, 3
 16172 0000106A D3E9                <2>  shr cx, cl
 16173                              <2> %endif
 16174                              <1> ALIGN JUMP_ALIGN
 16175                              <1> .ReadNextOword:
 16176                              <1> 	%rep 8	; WORDs
 16177                              <1> 		in		ax, dx		; Read BYTE
 16178                              <1> 		stosw				; Store BYTE to [ES:DI]
 16179                              <1> 	%endrep
 16180 0000106C ED                  <2>  in ax, dx
 16181 0000106D AB                  <2>  stosw
 16182 0000106E ED                  <2>  in ax, dx
 16183 0000106F AB                  <2>  stosw
 16184 00001070 ED                  <2>  in ax, dx
 16185 00001071 AB                  <2>  stosw
 16186 00001072 ED                  <2>  in ax, dx
 16187 00001073 AB                  <2>  stosw
 16188 00001074 ED                  <2>  in ax, dx
 16189 00001075 AB                  <2>  stosw
 16190 00001076 ED                  <2>  in ax, dx
 16191 00001077 AB                  <2>  stosw
 16192 00001078 ED                  <2>  in ax, dx
 16193 00001079 AB                  <2>  stosw
 16194 0000107A ED                  <2>  in ax, dx
 16195 0000107B AB                  <2>  stosw
 16196 0000107C E2EE                <1> 	loop	.ReadNextOword
 16197 0000107E C3                  <1> 	ret
 16198                              <1> %endif
 16199                              <1> 
 16200                              <1> 
 16201                              <1> ;--------------------------------------------------------------------
 16202                              <1> ALIGN JUMP_ALIGN
 16203                              <1> IdePioBlock_ReadFrom32bitDataPort:
 16204 0000107F C1                  <1> 	db		0C1h			; SHL
 16205 00001080 E1                  <1> 	db		0E1h			; CX
 16206 00001081 07                  <1> 	db		7			; 7	(Sectors to DWORDs)
 16207 00001082 F3                  <1> 	rep
 16208 00001083 66                  <1> 	db		66h			; Override operand size to 32-bit
 16209 00001084 6D                  <1> 	db		6Dh			; INSW/INSD
 16210 00001085 C3                  <1> 	ret
 16211                              <1> 
 16212                              <1> 
 16213                              <1> 
 16214                              <1> ; --------------------------------------------------------------------------------------------------
 16215                              <1> ;
 16216                              <1> ; WRITE routines follow
 16217                              <1> ;
 16218                              <1> ; --------------------------------------------------------------------------------------------------
 16219                              <1> 
 16220                              <1> %ifdef MODULE_8BIT_IDE
 16221                              <1> 
 16222                              <1> ;--------------------------------------------------------------------
 16223                              <1> ; IdePioBlock_WriteToXtideRev1
 16224                              <1> ;	Parameters:
 16225                              <1> ;		CX:	Block size in 512-byte sectors
 16226                              <1> ;		DX:	IDE Data port address
 16227                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
 16228                              <1> ;	Returns:
 16229                              <1> ;		Nothing
 16230                              <1> ;	Corrupts registers:
 16231                              <1> ;		AX, BX, CX, DX
 16232                              <1> ;--------------------------------------------------------------------
 16233                              <1> ALIGN JUMP_ALIGN
 16234                              <1> IdePioBlock_WriteToXtideRev1:
 16235 00001086 1E                  <1> 	push	ds
 16236                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
 16237                              <2> %ifdef USE_186
 16238                              <2>  shl cx, 6
 16239                              <2> %else
 16240                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
 16241                              <3> %ifdef USE_186
 16242                              <3>  shl cx, 7
 16243                              <3> %else
 16244 00001087 86CD                <3>  xchg cl, ch
 16245 00001089 D1E9                <3>  shr cx, 1
 16246                              <3> %endif
 16247 0000108B D1E9                <2>  shr cx, 1
 16248                              <2> %endif
 16249 0000108D B308                <1> 	mov		bl, 8		; Bit mask for toggling data low/high reg
 16250 0000108F 06                  <1> 	push		es		; Copy ES...
 16251 00001090 1F                  <1> 	pop		ds		; ...to DS
 16252                              <1> ALIGN JUMP_ALIGN
 16253                              <1> .OutswLoop:
 16254                              <1> 	%rep 4	; WORDs
 16255                              <1> 		XTIDE_OUTSW
 16256                              <1> 	%endrep
 16257                              <2>  XTIDE_OUTSW
 16258                              <3> %ifdef USE_186
 16259                              <3>  lodsb
 16260                              <3>  xor dl, bl
 16261                              <3>  outsb
 16262                              <3>  xor dl, bl
 16263                              <3>  out dx, al
 16264                              <3> %else
 16265 00001091 AD                  <3>  lodsw
 16266 00001092 30DA                <3>  xor dl, bl
 16267 00001094 86C4                <3>  xchg al, ah
 16268 00001096 EE                  <3>  out dx, al
 16269 00001097 30DA                <3>  xor dl, bl
 16270 00001099 88E0                <3>  mov al, ah
 16271 0000109B EE                  <3>  out dx, al
 16272                              <3> %endif
 16273                              <2>  XTIDE_OUTSW
 16274                              <3> %ifdef USE_186
 16275                              <3>  lodsb
 16276                              <3>  xor dl, bl
 16277                              <3>  outsb
 16278                              <3>  xor dl, bl
 16279                              <3>  out dx, al
 16280                              <3> %else
 16281 0000109C AD                  <3>  lodsw
 16282 0000109D 30DA                <3>  xor dl, bl
 16283 0000109F 86C4                <3>  xchg al, ah
 16284 000010A1 EE                  <3>  out dx, al
 16285 000010A2 30DA                <3>  xor dl, bl
 16286 000010A4 88E0                <3>  mov al, ah
 16287 000010A6 EE                  <3>  out dx, al
 16288                              <3> %endif
 16289                              <2>  XTIDE_OUTSW
 16290                              <3> %ifdef USE_186
 16291                              <3>  lodsb
 16292                              <3>  xor dl, bl
 16293                              <3>  outsb
 16294                              <3>  xor dl, bl
 16295                              <3>  out dx, al
 16296                              <3> %else
 16297 000010A7 AD                  <3>  lodsw
 16298 000010A8 30DA                <3>  xor dl, bl
 16299 000010AA 86C4                <3>  xchg al, ah
 16300 000010AC EE                  <3>  out dx, al
 16301 000010AD 30DA                <3>  xor dl, bl
 16302 000010AF 88E0                <3>  mov al, ah
 16303 000010B1 EE                  <3>  out dx, al
 16304                              <3> %endif
 16305                              <2>  XTIDE_OUTSW
 16306                              <3> %ifdef USE_186
 16307                              <3>  lodsb
 16308                              <3>  xor dl, bl
 16309                              <3>  outsb
 16310                              <3>  xor dl, bl
 16311                              <3>  out dx, al
 16312                              <3> %else
 16313 000010B2 AD                  <3>  lodsw
 16314 000010B3 30DA                <3>  xor dl, bl
 16315 000010B5 86C4                <3>  xchg al, ah
 16316 000010B7 EE                  <3>  out dx, al
 16317 000010B8 30DA                <3>  xor dl, bl
 16318 000010BA 88E0                <3>  mov al, ah
 16319 000010BC EE                  <3>  out dx, al
 16320                              <3> %endif
 16321 000010BD E2D2                <1> 	loop	.OutswLoop
 16322 000010BF 1F                  <1> 	pop		ds
 16323 000010C0 C3                  <1> 	ret
 16324                              <1> 
 16325                              <1> 
 16326                              <1> ;--------------------------------------------------------------------
 16327                              <1> ; IdePioBlock_WriteToXtideRev2	or rev 1 with swapped A0 and A3 (chuck-mod)
 16328                              <1> ;	Parameters:
 16329                              <1> ;		CX:	Block size in 512-byte sectors
 16330                              <1> ;		DX:	IDE Data port address
 16331                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
 16332                              <1> ;	Returns:
 16333                              <1> ;		Nothing
 16334                              <1> ;	Corrupts registers:
 16335                              <1> ;		AX, BX, CX, DX
 16336                              <1> ;--------------------------------------------------------------------
 16337                              <1> ALIGN JUMP_ALIGN
 16338                              <1> IdePioBlock_WriteToXtideRev2:
 16339                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
 16340                              <2> %ifdef USE_186
 16341                              <2>  shl cx, 6
 16342                              <2> %else
 16343                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
 16344                              <3> %ifdef USE_186
 16345                              <3>  shl cx, 7
 16346                              <3> %else
 16347 000010C1 86CD                <3>  xchg cl, ch
 16348 000010C3 D1E9                <3>  shr cx, 1
 16349                              <3> %endif
 16350 000010C5 D1E9                <2>  shr cx, 1
 16351                              <2> %endif
 16352 000010C7 1E                  <1> 	push		ds
 16353 000010C8 06                  <1> 	push		es			; Copy ES...
 16354 000010C9 1F                  <1> 	pop		ds			; ...to DS
 16355                              <1> ALIGN JUMP_ALIGN
 16356                              <1> .WriteNextQword:
 16357                              <1> 	%rep 4	; WORDs
 16358                              <1> 		XTIDE_MOD_OUTSW			; special macro
 16359                              <1> 	%endrep
 16360                              <2>  XTIDE_MOD_OUTSW
 16361                              <3> %ifdef USE_186
 16362                              <3>  lodsb
 16363                              <3>  inc dx
 16364                              <3>  outsb
 16365                              <3>  dec dx
 16366                              <3>  out dx, al
 16367                              <3> %else
 16368 000010CA AD                  <3>  lodsw
 16369 000010CB 42                  <3>  inc dx
 16370 000010CC 86C4                <3>  xchg al, ah
 16371 000010CE EE                  <3>  out dx, al
 16372 000010CF 4A                  <3>  dec dx
 16373 000010D0 88E0                <3>  mov al, ah
 16374 000010D2 EE                  <3>  out dx, al
 16375                              <3> %endif
 16376                              <2>  XTIDE_MOD_OUTSW
 16377                              <3> %ifdef USE_186
 16378                              <3>  lodsb
 16379                              <3>  inc dx
 16380                              <3>  outsb
 16381                              <3>  dec dx
 16382                              <3>  out dx, al
 16383                              <3> %else
 16384 000010D3 AD                  <3>  lodsw
 16385 000010D4 42                  <3>  inc dx
 16386 000010D5 86C4                <3>  xchg al, ah
 16387 000010D7 EE                  <3>  out dx, al
 16388 000010D8 4A                  <3>  dec dx
 16389 000010D9 88E0                <3>  mov al, ah
 16390 000010DB EE                  <3>  out dx, al
 16391                              <3> %endif
 16392                              <2>  XTIDE_MOD_OUTSW
 16393                              <3> %ifdef USE_186
 16394                              <3>  lodsb
 16395                              <3>  inc dx
 16396                              <3>  outsb
 16397                              <3>  dec dx
 16398                              <3>  out dx, al
 16399                              <3> %else
 16400 000010DC AD                  <3>  lodsw
 16401 000010DD 42                  <3>  inc dx
 16402 000010DE 86C4                <3>  xchg al, ah
 16403 000010E0 EE                  <3>  out dx, al
 16404 000010E1 4A                  <3>  dec dx
 16405 000010E2 88E0                <3>  mov al, ah
 16406 000010E4 EE                  <3>  out dx, al
 16407                              <3> %endif
 16408                              <2>  XTIDE_MOD_OUTSW
 16409                              <3> %ifdef USE_186
 16410                              <3>  lodsb
 16411                              <3>  inc dx
 16412                              <3>  outsb
 16413                              <3>  dec dx
 16414                              <3>  out dx, al
 16415                              <3> %else
 16416 000010E5 AD                  <3>  lodsw
 16417 000010E6 42                  <3>  inc dx
 16418 000010E7 86C4                <3>  xchg al, ah
 16419 000010E9 EE                  <3>  out dx, al
 16420 000010EA 4A                  <3>  dec dx
 16421 000010EB 88E0                <3>  mov al, ah
 16422 000010ED EE                  <3>  out dx, al
 16423                              <3> %endif
 16424 000010EE E2DA                <1> 	loop	.WriteNextQword
 16425 000010F0 1F                  <1> 	pop		ds
 16426 000010F1 C3                  <1> 	ret
 16427                              <1> 
 16428                              <1> 
 16429                              <1> ;--------------------------------------------------------------------
 16430                              <1> ; IdePioBlock_WriteTo8bitDataPort
 16431                              <1> ;	Parameters:
 16432                              <1> ;		CX:	Block size in 512-byte sectors
 16433                              <1> ;		DX:	IDE Data port address
 16434                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
 16435                              <1> ;	Returns:
 16436                              <1> ;		Nothing
 16437                              <1> ;	Corrupts registers:
 16438                              <1> ;		AX, BX, CX, DX
 16439                              <1> ;--------------------------------------------------------------------
 16440                              <1> ALIGN JUMP_ALIGN
 16441                              <1> IdePioBlock_WriteTo8bitDataPort:
 16442                              <1> %ifdef USE_186
 16443                              <1> 	shl		cx, 9		; Sectors to BYTEs
 16444                              <1> 	es				; Source is ES segment
 16445                              <1> 	rep outsb
 16446                              <1> 	ret
 16447                              <1> %else ; If 8088/8086
 16448                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
 16449                              <2> %ifdef USE_186
 16450                              <2>  shl cx, 6
 16451                              <2> %else
 16452                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
 16453                              <3> %ifdef USE_186
 16454                              <3>  shl cx, 7
 16455                              <3> %else
 16456 000010F2 86CD                <3>  xchg cl, ch
 16457 000010F4 D1E9                <3>  shr cx, 1
 16458                              <3> %endif
 16459 000010F6 D1E9                <2>  shr cx, 1
 16460                              <2> %endif
 16461 000010F8 1E                  <1> 	push		ds
 16462 000010F9 06                  <1> 	push		es
 16463 000010FA 1F                  <1> 	pop		ds
 16464                              <1> ALIGN JUMP_ALIGN
 16465                              <1> .WriteNextQword:
 16466                              <1> 	%rep 8	; BYTEs
 16467                              <1> 		lodsb			; Load BYTE from [DS:SI]
 16468                              <1> 		out	dx, al		; Write BYTE
 16469                              <1> 	%endrep
 16470 000010FB AC                  <2>  lodsb
 16471 000010FC EE                  <2>  out dx, al
 16472 000010FD AC                  <2>  lodsb
 16473 000010FE EE                  <2>  out dx, al
 16474 000010FF AC                  <2>  lodsb
 16475 00001100 EE                  <2>  out dx, al
 16476 00001101 AC                  <2>  lodsb
 16477 00001102 EE                  <2>  out dx, al
 16478 00001103 AC                  <2>  lodsb
 16479 00001104 EE                  <2>  out dx, al
 16480 00001105 AC                  <2>  lodsb
 16481 00001106 EE                  <2>  out dx, al
 16482 00001107 AC                  <2>  lodsb
 16483 00001108 EE                  <2>  out dx, al
 16484 00001109 AC                  <2>  lodsb
 16485 0000110A EE                  <2>  out dx, al
 16486 0000110B E2EE                <1> 	loop	.WriteNextQword
 16487 0000110D 1F                  <1> 	pop		ds
 16488 0000110E C3                  <1> 	ret
 16489                              <1> %endif
 16490                              <1> 
 16491                              <1> %endif ; MODULE_8BIT_IDE
 16492                              <1> 
 16493                              <1> 
 16494                              <1> ;--------------------------------------------------------------------
 16495                              <1> ; IdePioBlock_WriteTo16bitDataPort		Normal 16-bit IDE
 16496                              <1> ; IdePioBlock_WriteTo32bitDataPort		VLB/PCI 32-bit IDE
 16497                              <1> ;	Parameters:
 16498                              <1> ;		CX:	Block size in 512-byte sectors
 16499                              <1> ;		DX:	IDE Data port address
 16500                              <1> ;		ES:SI:	Normalized ptr to buffer containing data
 16501                              <1> ;	Returns:
 16502                              <1> ;		Nothing
 16503                              <1> ;	Corrupts registers:
 16504                              <1> ;		AX, BX, CX, DX
 16505                              <1> ;--------------------------------------------------------------------
 16506                              <1> ALIGN JUMP_ALIGN
 16507                              <1> IdePioBlock_WriteTo16bitDataPort:
 16508                              <1> %ifdef USE_186
 16509                              <1> 	xchg		cl, ch		; Sectors to WORDs
 16510                              <1> 	es				; Source is ES segment
 16511                              <1> 	rep
 16512                              <1> 	db		6Fh		; OUTSW
 16513                              <1> 	ret
 16514                              <1> %else ; If 8088/8086
 16515                              <1> 	UNROLL_SECTORS_IN_CX_TO_QWORDS
 16516                              <2> %ifdef USE_186
 16517                              <2>  shl cx, 6
 16518                              <2> %else
 16519                              <2>  UNROLL_SECTORS_IN_CX_TO_DWORDS
 16520                              <3> %ifdef USE_186
 16521                              <3>  shl cx, 7
 16522                              <3> %else
 16523 0000110F 86CD                <3>  xchg cl, ch
 16524 00001111 D1E9                <3>  shr cx, 1
 16525                              <3> %endif
 16526 00001113 D1E9                <2>  shr cx, 1
 16527                              <2> %endif
 16528 00001115 1E                  <1> 	push		ds
 16529 00001116 06                  <1> 	push		es
 16530 00001117 1F                  <1> 	pop		ds
 16531                              <1> ALIGN JUMP_ALIGN
 16532                              <1> .WriteNextQword:
 16533                              <1> 	%rep 4	; WORDs
 16534                              <1> 		lodsw			; Load BYTE from [DS:SI]
 16535                              <1> 		out	dx, ax		; Write BYTE
 16536                              <1> 	%endrep
 16537 00001118 AD                  <2>  lodsw
 16538 00001119 EF                  <2>  out dx, ax
 16539 0000111A AD                  <2>  lodsw
 16540 0000111B EF                  <2>  out dx, ax
 16541 0000111C AD                  <2>  lodsw
 16542 0000111D EF                  <2>  out dx, ax
 16543 0000111E AD                  <2>  lodsw
 16544 0000111F EF                  <2>  out dx, ax
 16545 00001120 E2F6                <1> 	loop	.WriteNextQword
 16546 00001122 1F                  <1> 	pop		ds
 16547 00001123 C3                  <1> 	ret
 16548                              <1> %endif	; if/else USE_186
 16549                              <1> 
 16550                              <1> ;--------------------------------------------------------------------
 16551                              <1> ALIGN JUMP_ALIGN
 16552                              <1> IdePioBlock_WriteTo32bitDataPort:
 16553 00001124 C1                  <1> 	db		0C1h		; SHL
 16554 00001125 E1                  <1> 	db		0E1h		; CX
 16555 00001126 07                  <1> 	db		7		; 7	(Sectors to DWORDs)
 16556 00001127 26                  <1> 	es				; Source is ES segment
 16557 00001128 F3                  <1> 	rep
 16558 00001129 66                  <1> 	db		66h		; Override operand size to 32-bit
 16559 0000112A 6F                  <1> 	db		6Fh		; OUTSW/OUTSD
 16560 0000112B C3                  <1> 	ret
 16561                              <1> 
 16562                              <1> 
 16563                                  	%include "IdeWait.asm"
 16564                              <1> ; Project name	:	XTIDE Universal BIOS
 16565                              <1> ; Description	:	IDE Device wait functions.
 16566                              <1> 
 16567                              <1> ;
 16568                              <1> ; XTIDE Universal BIOS and Associated Tools
 16569                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16570                              <1> ;
 16571                              <1> ; This program is free software; you can redistribute it and/or modify
 16572                              <1> ; it under the terms of the GNU General Public License as published by
 16573                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16574                              <1> ; (at your option) any later version.
 16575                              <1> ;
 16576                              <1> ; This program is distributed in the hope that it will be useful,
 16577                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16578                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16579                              <1> ; GNU General Public License for more details.
 16580                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16581                              <1> ;
 16582                              <1> 
 16583                              <1> ; Section containing code
 16584                              <1> SECTION .text
 16585                              <1> 
 16586                              <1> ;--------------------------------------------------------------------
 16587                              <1> ; IdeWait_IRQorDRQ
 16588                              <1> ;	Parameters:
 16589                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16590                              <1> ;		SS:BP:	Ptr to IDEPACK, PIOVARS or MEMPIOVARS
 16591                              <1> ;	Returns:
 16592                              <1> ;		AH:		INT 13h Error Code
 16593                              <1> ;		CF:		Cleared if success, Set if error
 16594                              <1> ;	Corrupts registers:
 16595                              <1> ;		AL, BX, CX, DX
 16596                              <1> ;--------------------------------------------------------------------
 16597                              <1> IdeWait_IRQorDRQ:
 16598 0000112C BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 16599                              <1> 
 16600                              <1> %ifdef MODULE_IRQ
 16601                              <1> 	test	BYTE [bp+IDEPACK.bDeviceControl], FLG_DEVCONTROL_nIEN
 16602                              <1> 	jnz		SHORT IdeWait_PollStatusFlagInBLwithTimeoutInBH	; Interrupt disabled
 16603                              <1> %endif
 16604                              <1> 	; Fall to IdeWait_IRQorStatusFlagInBLwithTimeoutInBH
 16605                              <1> 
 16606                              <1> 
 16607                              <1> ;--------------------------------------------------------------------
 16608                              <1> ; IdeWait_IRQorStatusFlagInBLwithTimeoutInBH
 16609                              <1> ;	Parameters:
 16610                              <1> ;		BH:		Timeout ticks
 16611                              <1> ;		BL:		IDE Status Register bit to wait
 16612                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16613                              <1> ;	Returns:
 16614                              <1> ;		AH:		INT 13h Error Code
 16615                              <1> ;		CF:		Cleared if success, Set if error
 16616                              <1> ;	Corrupts registers:
 16617                              <1> ;		AL, BX, CX, DX
 16618                              <1> ;--------------------------------------------------------------------
 16619                              <1> IdeWait_IRQorStatusFlagInBLwithTimeoutInBH:
 16620                              <1> %ifdef MODULE_IRQ
 16621                              <1> 	call	IdeIrq_WaitForIRQ
 16622                              <1> %endif
 16623                              <1> 	; Always fall to IdeWait_PollStatusFlagInBLwithTimeoutInBH for error processing
 16624                              <1> 
 16625                              <1> 
 16626                              <1> ;--------------------------------------------------------------------
 16627                              <1> ; IdeWait_PollStatusFlagInBLwithTimeoutInBH
 16628                              <1> ;	Parameters:
 16629                              <1> ;		BH:		Timeout ticks
 16630                              <1> ;		BL:		IDE Status Register bit to poll
 16631                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16632                              <1> ;	Returns:
 16633                              <1> ;		AH:		INT 13h Error Code
 16634                              <1> ;		CF:		Cleared if success, Set if error
 16635                              <1> ;	Corrupts registers:
 16636                              <1> ;		AL, BX, CX, DX
 16637                              <1> ;--------------------------------------------------------------------
 16638                              <1> IdeWait_PollStatusFlagInBLwithTimeoutInBH:
 16639 0000112F 88DC                <1> 	mov		ah, bl
 16640 00001131 88F9                <1> 	mov		cl, bh
 16641 00001133 E862FB              <1> 	call	Timer_InitializeTimeoutWithTicksInCL
 16642 00001136 80E47F              <1> 	and		ah, ~FLG_STATUS_BSY
 16643 00001139 741C                <1> 	jz		SHORT PollBsyOnly
 16644                              <1> 	; Fall to PollBsyAndFlgInAH
 16645                              <1> 
 16646                              <1> ;--------------------------------------------------------------------
 16647                              <1> ; PollBsyAndFlgInAH
 16648                              <1> ;	Parameters:
 16649                              <1> ;		AH:		Status Register Flag to poll (until set) when device not busy
 16650                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16651                              <1> ;	Returns:
 16652                              <1> ;		AH:		BIOS Error code
 16653                              <1> ;		CF:		Clear if wait completed successfully (no errors)
 16654                              <1> ;				Set if any error
 16655                              <1> ;	Corrupts registers:
 16656                              <1> ;		AL, BX, CX, DX
 16657                              <1> ;--------------------------------------------------------------------
 16658                              <1> PollBsyAndFlgInAH:
 16659 0000113B E88800              <1> 	call	IdeIO_InputStatusRegisterToAL		; Discard contents of first read
 16660                              <1> 
 16661                              <1> .PollLoop:
 16662 0000113E E88500              <1> 	call	IdeIO_InputStatusRegisterToAL
 16663 00001141 A880                <1> 	test	al, FLG_STATUS_BSY					; Controller busy?
 16664 00001143 7504                <1> 	jnz		SHORT .UpdateTimeout				;  If so, jump to timeout update
 16665 00001145 84E0                <1> 	test	al, ah								; Test secondary flag
 16666 00001147 751F                <1> 	jnz		SHORT IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 16667                              <1> .UpdateTimeout:
 16668 00001149 E858FB              <1> 	call	Timer_SetCFifTimeout
 16669 0000114C 73F0                <1> 	jnc		SHORT .PollLoop						; Loop if time left
 16670 0000114E E81700              <1> 	call	IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 16671 00001151 7203                <1> 	jc		SHORT .ReturnErrorCodeInAH
 16672 00001153 B480                <1> 	mov		ah, RET_HD_TIMEOUT					; Expected bit never got set
 16673 00001155 F9                  <1> 	stc
 16674                              <1> .ReturnErrorCodeInAH:
 16675 00001156 C3                  <1> 	ret
 16676                              <1> 
 16677                              <1> 
 16678                              <1> ;--------------------------------------------------------------------
 16679                              <1> ; PollBsyOnly
 16680                              <1> ;	Parameters:
 16681                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16682                              <1> ;	Returns:
 16683                              <1> ;		AH:		BIOS Error code
 16684                              <1> ;		CF:		Clear if wait completed successfully (no errors)
 16685                              <1> ;				Set if any error
 16686                              <1> ;	Corrupts registers:
 16687                              <1> ;		AL, BX, CX, DX
 16688                              <1> ;--------------------------------------------------------------------
 16689                              <1> PollBsyOnly:
 16690 00001157 E86C00              <1> 	call	IdeIO_InputStatusRegisterToAL		; Discard contents of first read
 16691                              <1> 
 16692                              <1> .PollLoop:
 16693 0000115A E86900              <1> 	call	IdeIO_InputStatusRegisterToAL
 16694 0000115D A880                <1> 	test	al, FLG_STATUS_BSY					; Controller busy?
 16695 0000115F 7407                <1> 	jz		SHORT IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 16696 00001161 E840FB              <1> 	call	Timer_SetCFifTimeout				; Update timeout counter
 16697 00001164 73F4                <1> 	jnc		SHORT .PollLoop						; Loop if time left (sets CF on timeout)
 16698 00001166 EB00                <1> 	jmp		SHORT IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 16699                                  	%include "IdeError.asm"			; Must be included after IdeWait.asm
 16700                              <1> ; Project name	:	XTIDE Universal BIOS
 16701                              <1> ; Description	:	IDE Device error functions.
 16702                              <1> 
 16703                              <1> ;
 16704                              <1> ; XTIDE Universal BIOS and Associated Tools
 16705                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16706                              <1> ;
 16707                              <1> ; This program is free software; you can redistribute it and/or modify
 16708                              <1> ; it under the terms of the GNU General Public License as published by
 16709                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16710                              <1> ; (at your option) any later version.
 16711                              <1> ;
 16712                              <1> ; This program is distributed in the hope that it will be useful,
 16713                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16714                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16715                              <1> ; GNU General Public License for more details.
 16716                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16717                              <1> ;
 16718                              <1> 
 16719                              <1> ; Section containing code
 16720                              <1> SECTION .text
 16721                              <1> 
 16722                              <1> ;--------------------------------------------------------------------
 16723                              <1> ; IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL
 16724                              <1> ;	Parameters:
 16725                              <1> ;		AL:		IDE Status Register contents
 16726                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 16727                              <1> ;	Returns:
 16728                              <1> ;		AH:		BIOS error code
 16729                              <1> ;		CF:		Set if error
 16730                              <1> ;				Cleared if no error
 16731                              <1> ;	Corrupts registers:
 16732                              <1> ;		AL, BX, DX
 16733                              <1> ;--------------------------------------------------------------------
 16734                              <1> ALIGN JUMP_ALIGN
 16735                              <1> IdeError_GetBiosErrorCodeToAHfromPolledStatusRegisterInAL:
 16736 00001168 88C4                <1> 	mov		ah, al			; IDE Status Register to AH
 16737                              <1> 	INPUT_TO_AL_FROM_IDE_REGISTER	ERROR_REGISTER_in
 16738                              <2> %ifndef MODULE_8BIT_IDE
 16739                              <2> 
 16740                              <2>  %ifnidni %1, dx
 16741                              <2>  mov dx, %1
 16742                              <2>  %endif
 16743                              <2>  add dx, [di+DPT.wBasePort]
 16744                              <2>  in al, dx
 16745                              <2> 
 16746                              <2> %else
 16747                              <2> 
 16748                              <2>  %ifnidni %1, dl
 16749 0000116A B201                <2>  mov dl, %1
 16750                              <2>  %endif
 16751 0000116C E85900              <2>  call IdeIO_InputToALfromIdeRegisterInDL
 16752                              <2> 
 16753                              <2> %endif
 16754 0000116F 86C4                <1> 	xchg	al, ah			; Status Register now in AL, Error Register now in AH
 16755                              <1> 	; Fall to GetBiosErrorCodeToAHfromStatusAndErrorRegistersInAX
 16756                              <1> 
 16757                              <1> 
 16758                              <1> ;--------------------------------------------------------------------
 16759                              <1> ; GetBiosErrorCodeToAHfromStatusAndErrorRegistersInAX
 16760                              <1> ;	Parameters:
 16761                              <1> ;		AL:		IDE Status Register contents
 16762                              <1> ;		AH:		IDE Error Register contents
 16763                              <1> ;	Returns:
 16764                              <1> ;		AH:		BIOS INT 13h error code
 16765                              <1> ;		CF:		Set if error
 16766                              <1> ;				Cleared if no error
 16767                              <1> ;	Corrupts registers:
 16768                              <1> ;		BX
 16769                              <1> ;--------------------------------------------------------------------
 16770                              <1> ALIGN JUMP_ALIGN
 16771                              <1> GetBiosErrorCodeToAHfromStatusAndErrorRegistersInAX:
 16772 00001171 A880                <1> 	test	al, FLG_STATUS_BSY
 16773 00001173 7404                <1> 	jz		SHORT .CheckErrorBitsFromStatusRegisterInAL
 16774 00001175 B480                <1> 	mov		ah, RET_HD_TIMEOUT
 16775 00001177 EB25                <1> 	jmp		SHORT .ReturnBiosErrorCodeInAH
 16776                              <1> 
 16777                              <1> ALIGN JUMP_ALIGN
 16778                              <1> .CheckErrorBitsFromStatusRegisterInAL:
 16779 00001179 A825                <1> 	test	al, FLG_STATUS_DF | FLG_STATUS_CORR | FLG_STATUS_ERR
 16780 0000117B 7503                <1> 	jnz		SHORT .ProcessErrorFromStatusRegisterInAL
 16781 0000117D 30E4                <1> 	xor		ah, ah					; No errors, zero AH and CF
 16782 0000117F C3                  <1> 	ret
 16783                              <1> 
 16784                              <1> .ProcessErrorFromStatusRegisterInAL:
 16785 00001180 A801                <1> 	test	al, FLG_STATUS_ERR		; Error specified in Error register?
 16786 00001182 750A                <1> 	jnz		SHORT .ConvertBiosErrorToAHfromErrorRegisterInAH
 16787 00001184 B411                <1> 	mov		ah, RET_HD_ECC			; Assume ECC corrected error
 16788 00001186 A804                <1> 	test	al, FLG_STATUS_CORR		; ECC corrected error?
 16789 00001188 7514                <1> 	jnz		SHORT .ReturnBiosErrorCodeInAH
 16790 0000118A B420                <1> 	mov		ah, RET_HD_CONTROLLER	; Must be Device Fault
 16791 0000118C EB10                <1> 	jmp		SHORT .ReturnBiosErrorCodeInAH
 16792                              <1> 
 16793                              <1> .ConvertBiosErrorToAHfromErrorRegisterInAH:
 16794 0000118E 31DB                <1> 	xor		bx, bx					; Clear CF
 16795                              <1> .ErrorBitLoop:
 16796 00001190 D0DC                <1> 	rcr		ah, 1					; Set CF if error bit set
 16797 00001192 7205                <1> 	jc		SHORT .LookupErrorCode
 16798 00001194 43                  <1> 	inc		bx
 16799 00001195 84E4                <1> 	test	ah, ah					; Clear CF
 16800 00001197 75F7                <1> 	jnz		SHORT .ErrorBitLoop
 16801                              <1> .LookupErrorCode:
 16802 00001199 2E8AA7[A011]        <1> 	mov		ah, [cs:bx+.rgbRetCodeLookup]
 16803                              <1> .ReturnBiosErrorCodeInAH:
 16804 0000119E F9                  <1> 	stc								; Set CF since error
 16805 0000119F C3                  <1> 	ret
 16806                              <1> 
 16807                              <1> .rgbRetCodeLookup:
 16808 000011A0 02                  <1> 	db	RET_HD_ADDRMARK		; Bit0=AMNF, Address Mark Not Found
 16809 000011A1 40                  <1> 	db	RET_HD_SEEK_FAIL	; Bit1=TK0NF, Track 0 Not Found
 16810 000011A2 01                  <1> 	db	RET_HD_INVALID		; Bit2=ABRT, Aborted Command
 16811 000011A3 B0                  <1> 	db	RET_HD_NOTLOCKED	; Bit3=MCR, Media Change Requested
 16812 000011A4 04                  <1> 	db	RET_HD_NOT_FOUND	; Bit4=IDNF, ID Not Found
 16813 000011A5 B1                  <1> 	db	RET_HD_LOCKED		; Bit5=MC, Media Changed
 16814 000011A6 10                  <1> 	db	RET_HD_UNCORRECC	; Bit6=UNC, Uncorrectable Data Error
 16815 000011A7 0A                  <1> 	db	RET_HD_BADSECTOR	; Bit7=BBK, Bad Block Detected
 16816 000011A8 E0                  <1> 	db	RET_HD_STATUSERR	; When Error Register is zero
 16817                                  	%include "IdeDPT.asm"
 16818                              <1> ; Project name	:	XTIDE Universal BIOS
 16819                              <1> ; Description	:	Sets IDE Device specific parameters to DPT.
 16820                              <1> 
 16821                              <1> ;
 16822                              <1> ; XTIDE Universal BIOS and Associated Tools
 16823                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16824                              <1> ;
 16825                              <1> ; This program is free software; you can redistribute it and/or modify
 16826                              <1> ; it under the terms of the GNU General Public License as published by
 16827                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16828                              <1> ; (at your option) any later version.
 16829                              <1> ;
 16830                              <1> ; This program is distributed in the hope that it will be useful,
 16831                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16832                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16833                              <1> ; GNU General Public License for more details.
 16834                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16835                              <1> ;
 16836                              <1> 
 16837                              <1> ; Section containing code
 16838                              <1> SECTION .text
 16839                              <1> 
 16840                              <1> ;--------------------------------------------------------------------
 16841                              <1> ; IdeDPT_Finalize
 16842                              <1> ;	Parameters:
 16843                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 16844                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 16845                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 16846                              <1> ;	Returns:
 16847                              <1> ;		CF:		Clear, IDE interface only supports hard disks
 16848                              <1> ;	Corrupts registers:
 16849                              <1> ;		AX, BX, CX, DX
 16850                              <1> ;--------------------------------------------------------------------
 16851                              <1> IdeDPT_Finalize:
 16852                              <1> 
 16853                              <1> %ifdef MODULE_FEATURE_SETS
 16854                              <1> ;--------------------------------------------------------------------
 16855                              <1> ; .DetectPowerManagementSupport
 16856                              <1> ;	Parameters:
 16857                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 16858                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 16859                              <1> ;	Returns:
 16860                              <1> ;		Nothing
 16861                              <1> ;	Corrupts registers:
 16862                              <1> ;		Nothing
 16863                              <1> ;--------------------------------------------------------------------
 16864                              <1> .DetectPowerManagementSupport:
 16865 000011A9 26F684A40008        <1> 	test	BYTE [es:si+ATA6.wSetSup82], A6_wSetSup82_POWERMAN
 16866 000011AF 7404                <1> 	jz		SHORT .NoPowerManagementSupport
 16867 000011B1 804D0120            <1> 	or		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_POWER_MANAGEMENT_SUPPORTED
 16868                              <1> .NoPowerManagementSupport:
 16869                              <1> %endif ; MODULE_FEATURE_SETS
 16870                              <1> 
 16871                              <1> 
 16872                              <1> ;--------------------------------------------------------------------
 16873                              <1> ; .StoreDeviceType
 16874                              <1> ;	Parameters:
 16875                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 16876                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 16877                              <1> ;	Returns:
 16878                              <1> ;		Nothing
 16879                              <1> ;	Corrupts registers:
 16880                              <1> ;		AL
 16881                              <1> ;--------------------------------------------------------------------
 16882                              <1> .StoreDeviceType:
 16883 000011B5 E80600              <1> 	call	IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP
 16884                              <1> 
 16885                              <1> 
 16886                              <1> ;--------------------------------------------------------------------
 16887                              <1> ; .StoreBlockMode
 16888                              <1> ;	Parameters:
 16889                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 16890                              <1> ;	Returns:
 16891                              <1> ;		Nothing
 16892                              <1> ;	Corrupts registers:
 16893                              <1> ;		Nothing
 16894                              <1> ;--------------------------------------------------------------------
 16895                              <1> .StoreBlockMode:
 16896 000011B8 C6451501            <1> 	mov		BYTE [di+DPT_ATA.bBlockSize], 1
 16897                              <1> 
 16898                              <1> 
 16899                              <1> %ifdef MODULE_ADVANCED_ATA
 16900                              <1> ;--------------------------------------------------------------------
 16901                              <1> ; .StorePioModeAndTimings
 16902                              <1> ;	Parameters:
 16903                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 16904                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 16905                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 16906                              <1> ;	Returns:
 16907                              <1> ;		Nothing
 16908                              <1> ;	Corrupts registers:
 16909                              <1> ;		AX, BX, CX
 16910                              <1> ;--------------------------------------------------------------------
 16911                              <1> .StorePioMode:
 16912                              <1> 	call	AtaID_GetMaxPioModeToAXandMinCycleTimeToCX
 16913                              <1> 	mov		[di+DPT_ADVANCED_ATA.wMinPioCycleTime], cx
 16914                              <1> 	mov		[di+DPT_ADVANCED_ATA.bPioMode], al
 16915                              <1> 	or		[di+DPT.bFlagsHigh], ah
 16916                              <1> 
 16917                              <1> 
 16918                              <1> ;--------------------------------------------------------------------
 16919                              <1> ; .DetectAdvancedIdeController
 16920                              <1> ;	Parameters:
 16921                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 16922                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 16923                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 16924                              <1> ;	Returns:
 16925                              <1> ;		Nothing
 16926                              <1> ;	Corrupts registers:
 16927                              <1> ;		AX, BX, CX, DX
 16928                              <1> ;--------------------------------------------------------------------
 16929                              <1> .DetectAdvancedIdeController:
 16930                              <1> 	mov		bx, [di+DPT.wBasePort]
 16931                              <1> 	call	AdvAtaInit_DetectControllerForIdeBaseInBX
 16932                              <1> 	mov		[di+DPT_ADVANCED_ATA.wControllerID], ax	; Store zero if none detected
 16933                              <1> 	mov		[di+DPT_ADVANCED_ATA.wControllerBasePort], dx
 16934                              <1> 	jnc		SHORT .NoAdvancedControllerDetected
 16935                              <1> 
 16936                              <1> 	; Use highest common PIO mode from controller and drive.
 16937                              <1> 	; Many VLB controllers support PIO modes up to 2.
 16938                              <1> 	call	AdvAtaInit_GetControllerMaxPioModeToAL
 16939                              <1> 	jnc		SHORT .ChangeTo32bitDevice
 16940                              <1> 	and		BYTE [di+DPT.bFlagsHigh], ~FLGH_DPT_IORDY	; No IORDY supported if need to limit
 16941                              <1> 	MIN_U	[di+DPT_ADVANCED_ATA.bPioMode], al
 16942                              <1> 
 16943                              <1> 	; We have detected 32-bit controller so change Device Type since
 16944                              <1> 	; it might have been set to 16-bit on IDEVARS
 16945                              <1> .ChangeTo32bitDevice:
 16946                              <1> 	mov		BYTE [di+DPT_ATA.bDevice], DEVICE_32BIT_ATA
 16947                              <1> .NoAdvancedControllerDetected:
 16948                              <1> %endif	; MODULE_ADVANCED_ATA
 16949                              <1> 
 16950                              <1> 
 16951                              <1> ; End DPT
 16952 000011BC F8                  <1> 	clc
 16953 000011BD C3                  <1> 	ret
 16954                              <1> 
 16955                              <1> 
 16956                              <1> ;--------------------------------------------------------------------
 16957                              <1> ; IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP
 16958                              <1> ;	Parameters:
 16959                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 16960                              <1> ;		CS:BP:	Ptr to IDEVARS for the controller
 16961                              <1> ;	Returns:
 16962                              <1> ;		Nothing
 16963                              <1> ;	Corrupts registers:
 16964                              <1> ;		AL
 16965                              <1> ;--------------------------------------------------------------------
 16966                              <1> IdeDPT_StoreDeviceTypeToDPTinDSDIfromIdevarsInCSBP:
 16967 000011BE 2E8A4604            <1> 	mov		al, [cs:bp+IDEVARS.bDevice]
 16968 000011C2 884514              <1> 	mov		[di+DPT_ATA.bDevice], al
 16969 000011C5 C3                  <1> 	ret
 16970                                  	%include "IdeIO.asm"
 16971                              <1> ; Project name	:	XTIDE Universal BIOS
 16972                              <1> ; Description	:	IDE Register I/O functions when supporting 8-bit
 16973                              <1> ;					devices that need address translations.
 16974                              <1> 
 16975                              <1> ;
 16976                              <1> ; XTIDE Universal BIOS and Associated Tools
 16977                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 16978                              <1> ;
 16979                              <1> ; This program is free software; you can redistribute it and/or modify
 16980                              <1> ; it under the terms of the GNU General Public License as published by
 16981                              <1> ; the Free Software Foundation; either version 2 of the License, or
 16982                              <1> ; (at your option) any later version.
 16983                              <1> ;
 16984                              <1> ; This program is distributed in the hope that it will be useful,
 16985                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 16986                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 16987                              <1> ; GNU General Public License for more details.
 16988                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 16989                              <1> ;
 16990                              <1> 
 16991                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 16992                              <1> 
 16993                              <1> ; Section containing code
 16994                              <1> SECTION .text
 16995                              <1> 
 16996                              <1> ;--------------------------------------------------------------------
 16997                              <1> ; IdeIO_InputStatusRegisterToAL
 16998                              <1> ;	Parameters:
 16999                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17000                              <1> ;	Returns:
 17001                              <1> ;		AL:		IDE Status Register contents
 17002                              <1> ;	Corrupts registers:
 17003                              <1> ;		BX, DX
 17004                              <1> ;--------------------------------------------------------------------
 17005                              <1> ALIGN JUMP_ALIGN
 17006                              <1> IdeIO_InputStatusRegisterToAL:
 17007                              <1> %ifndef MODULE_8BIT_IDE
 17008                              <1> 	INPUT_TO_AL_FROM_IDE_REGISTER STATUS_REGISTER_in
 17009                              <1> 	ret
 17010                              <1> 
 17011                              <1> %else
 17012 000011C6 B207                <1> 	mov		dl, STATUS_REGISTER_in
 17013                              <1> 	; Fall to IdeIO_InputToALfromIdeRegisterInDL
 17014                              <1> 
 17015                              <1> ;--------------------------------------------------------------------
 17016                              <1> ; IdeIO_InputToALfromIdeRegisterInDL
 17017                              <1> ;	Parameters:
 17018                              <1> ;		DL:		IDE Register
 17019                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17020                              <1> ;	Returns:
 17021                              <1> ;		AL:		Inputted byte
 17022                              <1> ;	Corrupts registers:
 17023                              <1> ;		BX, DX
 17024                              <1> ;--------------------------------------------------------------------
 17025                              <1> IdeIO_InputToALfromIdeRegisterInDL:
 17026 000011C8 30F6                <1> 	xor		dh, dh	; IDE Register index now in DX
 17027 000011CA 89D3                <1> 	mov		bx, dx	; and BX
 17028 000011CC 8A4514              <1> 	mov		al, [di+DPT_ATA.bDevice]
 17029 000011CF 3C08                <1> 	cmp		al, DEVICE_8BIT_XTIDE_REV2
 17030 000011D1 7218                <1> 	jb		SHORT .InputToALfromRegisterInDX	; Standard IDE controllers and XTIDE rev 1
 17031                              <1> 
 17032                              <1> %ifdef MODULE_8BIT_IDE
 17033 000011D3 740E                <1> 	je		SHORT .ReverseA0andA3fromRegisterIndexInDX
 17034                              <1> 
 17035 000011D5 3C10                <1> 	cmp		al, DEVICE_8BIT_JRIDE_ISA
 17036 000011D7 7510                <1> 	jne		SHORT .ShlRegisterIndexInDX			; All XT-CF modes
 17037                              <1> 	; Fall to .InputToALfromMemoryMappedRegisterInDX
 17038                              <1> 
 17039                              <1> .InputToALfromMemoryMappedRegisterInDX:
 17040 000011D9 1E                  <1> 	push	ds
 17041 000011DA 8E5D04              <1> 	mov		ds, [di+DPT.wBasePort]	; Segment for JR-IDE/ISA
 17042 000011DD 8A87003E            <1> 	mov		al, [bx+JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET]
 17043 000011E1 1F                  <1> 	pop		ds
 17044 000011E2 C3                  <1> 	ret
 17045                              <1> %endif
 17046                              <1> 
 17047                              <1> .ReverseA0andA3fromRegisterIndexInDX:
 17048 000011E3 2E8A97[4C12]        <1> 	mov		dl, [cs:bx+g_rgbSwapA0andA3fromIdeRegisterIndex]
 17049                              <1> 	SKIP2B	bx	; Skip shl dx, 1
 17050                              <2>  %ifidni %1, f
 17051                              <2>  db 03Dh
 17052                              <2> 
 17053                              <2>  %elifidni %1, ax
 17054                              <2>  db 0B8h
 17055                              <2>  %elifidni %1, cx
 17056                              <2>  db 0B9h
 17057                              <2>  %elifidni %1, dx
 17058                              <2>  db 0BAh
 17059                              <2>  %elifidni %1, bx
 17060 000011E8 BB                  <2>  db 0BBh
 17061                              <2>  %elifidni %1, sp
 17062                              <2>  db 0BCh
 17063                              <2>  %elifidni %1, bp
 17064                              <2>  db 0BDh
 17065                              <2>  %elifidni %1, si
 17066                              <2>  db 0BEh
 17067                              <2>  %elifidni %1, di
 17068                              <2>  db 0BFh
 17069                              <2>  %else
 17070                              <2>  %error "Invalid parameter passed to SKIP2B"
 17071                              <2>  %endif
 17072                              <1> 
 17073                              <1> .ShlRegisterIndexInDX:
 17074                              <1> 	eSHL_IM	dx, 1
 17075                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 17076                              <2> %ifdef USE_386
 17077                              <2>  %if %2 = 1
 17078                              <2>  add %1, %1
 17079                              <2>  %else
 17080                              <2>  eSHIFT_IM %1, %2, shl
 17081                              <2>  %endif
 17082                              <2> %else
 17083                              <2>  eSHIFT_IM %1, %2, shl
 17084                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 17085                              <3> %ifndef USE_186
 17086                              <3>  %ifidni %1, cl
 17087                              <3>  times %2 %3 %1, 1
 17088                              <3>  %elifidni %1, ch
 17089                              <3>  times %2 %3 %1, 1
 17090                              <3>  %elifidni %1, cx
 17091                              <3>  times %2 %3 %1, 1
 17092                              <3>  %else
 17093                              <3>  %if %2 > 3
 17094                              <3>  push cx
 17095                              <3>  mov cl, %2
 17096                              <3>  %3 %1, cl
 17097                              <3>  pop cx
 17098                              <3>  %else
 17099 000011E9 D1E2                <3>  times %2 %3 %1, 1
 17100                              <3>  %endif
 17101                              <3>  %endif
 17102                              <3> 
 17103                              <3> %else
 17104                              <3>  %3 %1, %2
 17105                              <3> %endif
 17106                              <3> %endif
 17107                              <2> %endif
 17108                              <2> %endif
 17109                              <1> 	; Fall to .InputToALfromRegisterInDX
 17110                              <1> 
 17111                              <1> .InputToALfromRegisterInDX:
 17112 000011EB 035504              <1> 	add		dx, [di+DPT.wBasePort]
 17113 000011EE EC                  <1> 	in		al, dx
 17114 000011EF C3                  <1> 	ret
 17115                              <1> 
 17116                              <1> 
 17117                              <1> ;--------------------------------------------------------------------
 17118                              <1> ; IdeIO_OutputALtoIdeControlBlockRegisterInDL
 17119                              <1> ;	Parameters:
 17120                              <1> ;		AL:		Byte to output
 17121                              <1> ;		DL:		IDE Control Block Register
 17122                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17123                              <1> ;	Returns:
 17124                              <1> ;		Nothing
 17125                              <1> ;	Corrupts registers:
 17126                              <1> ;		BX, DX
 17127                              <1> ;--------------------------------------------------------------------
 17128                              <1> IdeIO_OutputALtoIdeControlBlockRegisterInDL:
 17129 000011F0 30F6                <1> 	xor		dh, dh	; IDE Register index now in DX
 17130                              <1> 
 17131 000011F2 8A5D14              <1> 	mov		bl, [di+DPT_ATA.bDevice]
 17132 000011F5 80FB08              <1> 	cmp		bl, DEVICE_8BIT_XTIDE_REV2
 17133 000011F8 721C                <1> 	jb		SHORT .OutputALtoControlBlockRegisterInDX	; Standard IDE controllers and XTIDE rev 1
 17134                              <1> 
 17135                              <1> %ifdef MODULE_8BIT_IDE
 17136 000011FA 740A                <1> 	je		SHORT .ReverseA0andA3fromRegisterIndexInDX
 17137                              <1> 
 17138 000011FC 80FB10              <1> 	cmp		bl, DEVICE_8BIT_JRIDE_ISA
 17139 000011FF 750E                <1> 	jne		SHORT .ShlRegisterIndexInDX		; All XT-CF modes
 17140                              <1> 	; Fall to .OutputALtoMemoryMappedRegisterInDX
 17141                              <1> 
 17142                              <1> .OutputALtoMemoryMappedRegisterInDX:
 17143 00001201 BB083E              <1> 	mov		bx, JRIDE_CONTROL_BLOCK_REGISTER_WINDOW_OFFSET
 17144 00001204 EB2D                <1> 	jmp 	SHORT IdeIO_OutputALtoIdeRegisterInDL.OutputALtoMemoryMappedRegisterInDXwithWindowOffsetInBX
 17145                              <1> %endif
 17146                              <1> 
 17147                              <1> .ReverseA0andA3fromRegisterIndexInDX:
 17148                              <1> 	; We cannot use lookup table since A3 will be always set because
 17149                              <1> 	; Control Block Registers start from Command Block + 8h. We can do
 17150                              <1> 	; a small trick since we only access Device Control Register at
 17151                              <1> 	; offset 6h: Always clear A3 and set A0.
 17152 00001206 2E035702            <1> 	add		dx, [cs:bx+IDEVARS.wControlBlockPort]
 17153 0000120A 80F209              <1> 	xor		dl, 1001b						; Clear A3, Set A0
 17154 0000120D EB3B                <1> 	jmp		SHORT OutputALtoPortInDX
 17155                              <1> 
 17156                              <1> .ShlRegisterIndexInDX:
 17157                              <1> 	eSHL_IM	dx, 1
 17158                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 17159                              <2> %ifdef USE_386
 17160                              <2>  %if %2 = 1
 17161                              <2>  add %1, %1
 17162                              <2>  %else
 17163                              <2>  eSHIFT_IM %1, %2, shl
 17164                              <2>  %endif
 17165                              <2> %else
 17166                              <2>  eSHIFT_IM %1, %2, shl
 17167                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 17168                              <3> %ifndef USE_186
 17169                              <3>  %ifidni %1, cl
 17170                              <3>  times %2 %3 %1, 1
 17171                              <3>  %elifidni %1, ch
 17172                              <3>  times %2 %3 %1, 1
 17173                              <3>  %elifidni %1, cx
 17174                              <3>  times %2 %3 %1, 1
 17175                              <3>  %else
 17176                              <3>  %if %2 > 3
 17177                              <3>  push cx
 17178                              <3>  mov cl, %2
 17179                              <3>  %3 %1, cl
 17180                              <3>  pop cx
 17181                              <3>  %else
 17182 0000120F D1E2                <3>  times %2 %3 %1, 1
 17183                              <3>  %endif
 17184                              <3>  %endif
 17185                              <3> 
 17186                              <3> %else
 17187                              <3>  %3 %1, %2
 17188                              <3> %endif
 17189                              <3> %endif
 17190                              <2> %endif
 17191                              <2> %endif
 17192 00001211 83C210              <1> 	add		dx, BYTE XTCF_CONTROL_BLOCK_OFFSET
 17193 00001214 EB31                <1> 	jmp		SHORT OutputALtoRegisterInDX
 17194                              <1> 
 17195                              <1> .OutputALtoControlBlockRegisterInDX:
 17196 00001216 E8EFF4              <1> 	call	AccessDPT_GetIdevarsToCSBX
 17197 00001219 2E035702            <1> 	add		dx, [cs:bx+IDEVARS.wControlBlockPort]
 17198 0000121D EB2B                <1> 	jmp		SHORT OutputALtoPortInDX
 17199                              <1> 
 17200                              <1> 
 17201                              <1> ;--------------------------------------------------------------------
 17202                              <1> ; IdeIO_OutputALtoIdeRegisterInDL
 17203                              <1> ;	Parameters:
 17204                              <1> ;		AL:		Byte to output
 17205                              <1> ;		DL:		IDE Command Block Register
 17206                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17207                              <1> ;	Returns:
 17208                              <1> ;		Nothing
 17209                              <1> ;	Corrupts registers:
 17210                              <1> ;		BX, DX
 17211                              <1> ;--------------------------------------------------------------------
 17212                              <1> ALIGN JUMP_ALIGN
 17213                              <1> IdeIO_OutputALtoIdeRegisterInDL:
 17214 0000121F 30F6                <1> 	xor		dh, dh	; IDE Register index now in DX
 17215                              <1> 
 17216 00001221 8A5D14              <1> 	mov		bl, [di+DPT_ATA.bDevice]
 17217 00001224 80FB08              <1> 	cmp		bl, DEVICE_8BIT_XTIDE_REV2
 17218 00001227 721E                <1> 	jb		SHORT OutputALtoRegisterInDX	; Standard IDE controllers and XTIDE rev 1
 17219                              <1> 
 17220                              <1> %ifdef MODULE_8BIT_IDE
 17221 00001229 7412                <1> 	je		SHORT .ReverseA0andA3fromRegisterIndexInDX
 17222                              <1> 
 17223 0000122B 80FB10              <1> 	cmp		bl, DEVICE_8BIT_JRIDE_ISA
 17224 0000122E 7515                <1> 	jne		SHORT .ShlRegisterIndexInDX		; All XT-CF modes
 17225                              <1> 	; Fall to .OutputALtoMemoryMappedRegisterInDX
 17226                              <1> 
 17227                              <1> .OutputALtoMemoryMappedRegisterInDX:
 17228 00001230 BB003E              <1> 	mov		bx, JRIDE_COMMAND_BLOCK_REGISTER_WINDOW_OFFSET
 17229                              <1> .OutputALtoMemoryMappedRegisterInDXwithWindowOffsetInBX:
 17230 00001233 01D3                <1> 	add		bx, dx
 17231 00001235 1E                  <1> 	push	ds
 17232 00001236 8E5D04              <1> 	mov		ds, [di+DPT.wBasePort]	; Segment for JR-IDE/ISA
 17233 00001239 8807                <1> 	mov		[bx], al
 17234 0000123B 1F                  <1> 	pop		ds
 17235 0000123C C3                  <1> 	ret
 17236                              <1> %endif
 17237                              <1> 
 17238                              <1> .ReverseA0andA3fromRegisterIndexInDX:
 17239 0000123D 89D3                <1> 	mov		bx, dx
 17240 0000123F 2E8A97[4C12]        <1> 	mov		dl, [cs:bx+g_rgbSwapA0andA3fromIdeRegisterIndex]
 17241                              <1> 	SKIP2B	bx	; Skip shl dx, 1
 17242                              <2>  %ifidni %1, f
 17243                              <2>  db 03Dh
 17244                              <2> 
 17245                              <2>  %elifidni %1, ax
 17246                              <2>  db 0B8h
 17247                              <2>  %elifidni %1, cx
 17248                              <2>  db 0B9h
 17249                              <2>  %elifidni %1, dx
 17250                              <2>  db 0BAh
 17251                              <2>  %elifidni %1, bx
 17252 00001244 BB                  <2>  db 0BBh
 17253                              <2>  %elifidni %1, sp
 17254                              <2>  db 0BCh
 17255                              <2>  %elifidni %1, bp
 17256                              <2>  db 0BDh
 17257                              <2>  %elifidni %1, si
 17258                              <2>  db 0BEh
 17259                              <2>  %elifidni %1, di
 17260                              <2>  db 0BFh
 17261                              <2>  %else
 17262                              <2>  %error "Invalid parameter passed to SKIP2B"
 17263                              <2>  %endif
 17264                              <1> 
 17265                              <1> .ShlRegisterIndexInDX:
 17266                              <1> 	eSHL_IM	dx, 1
 17267                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 17268                              <2> %ifdef USE_386
 17269                              <2>  %if %2 = 1
 17270                              <2>  add %1, %1
 17271                              <2>  %else
 17272                              <2>  eSHIFT_IM %1, %2, shl
 17273                              <2>  %endif
 17274                              <2> %else
 17275                              <2>  eSHIFT_IM %1, %2, shl
 17276                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 17277                              <3> %ifndef USE_186
 17278                              <3>  %ifidni %1, cl
 17279                              <3>  times %2 %3 %1, 1
 17280                              <3>  %elifidni %1, ch
 17281                              <3>  times %2 %3 %1, 1
 17282                              <3>  %elifidni %1, cx
 17283                              <3>  times %2 %3 %1, 1
 17284                              <3>  %else
 17285                              <3>  %if %2 > 3
 17286                              <3>  push cx
 17287                              <3>  mov cl, %2
 17288                              <3>  %3 %1, cl
 17289                              <3>  pop cx
 17290                              <3>  %else
 17291 00001245 D1E2                <3>  times %2 %3 %1, 1
 17292                              <3>  %endif
 17293                              <3>  %endif
 17294                              <3> 
 17295                              <3> %else
 17296                              <3>  %3 %1, %2
 17297                              <3> %endif
 17298                              <3> %endif
 17299                              <2> %endif
 17300                              <2> %endif
 17301                              <1> 	; Fall to OutputALtoRegisterInDX
 17302                              <1> 
 17303                              <1> ALIGN JUMP_ALIGN
 17304                              <1> OutputALtoRegisterInDX:
 17305 00001247 035504              <1> 	add		dx, [di+DPT.wBasePort]
 17306                              <1> OutputALtoPortInDX:
 17307 0000124A EE                  <1> 	out		dx, al
 17308 0000124B C3                  <1> 	ret
 17309                              <1> 
 17310                              <1> 
 17311                              <1> 
 17312                              <1> ; A0 <-> A3 lookup table
 17313                              <1> g_rgbSwapA0andA3fromIdeRegisterIndex:
 17314 0000124C 00                  <1> 	db	0000b	; <-> 0000b, 0
 17315 0000124D 08                  <1> 	db	1000b	; <-> 0001b, 1
 17316 0000124E 02                  <1> 	db	0010b	; <-> 0010b, 2
 17317 0000124F 0A                  <1> 	db	1010b	; <-> 0011b, 3
 17318 00001250 04                  <1> 	db	0100b	; <-> 0100b, 4
 17319 00001251 0C                  <1> 	db	1100b	; <-> 0101b, 5
 17320 00001252 06                  <1> 	db	0110b	; <-> 0110b, 6
 17321 00001253 0E                  <1> 	db	1110b	; <-> 0111b, 7
 17322                              <1> 
 17323                              <1> %endif ; MODULE_8BIT_IDE
 17324                                  %ifdef MODULE_IRQ
 17325                                  	%include "IdeIrq.asm"
 17326                                  %endif
 17327                                  
 17328                                  	; Serial Device support
 17329                                  %ifdef MODULE_SERIAL				; Serial Port Device support
 17330                                  	%include "SerialCommand.asm"
 17331                              <1> ; Project name	:	XTIDE Universal BIOS
 17332                              <1> ; Description	:	Serial Device Command functions.
 17333                              <1> 
 17334                              <1> ;
 17335                              <1> ; XTIDE Universal BIOS and Associated Tools
 17336                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17337                              <1> ;
 17338                              <1> ; This program is free software; you can redistribute it and/or modify
 17339                              <1> ; it under the terms of the GNU General Public License as published by
 17340                              <1> ; the Free Software Foundation; either version 2 of the License, or
 17341                              <1> ; (at your option) any later version.
 17342                              <1> ;
 17343                              <1> ; This program is distributed in the hope that it will be useful,
 17344                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17345                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17346                              <1> ; GNU General Public License for more details.
 17347                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17348                              <1> ;
 17349                              <1> 
 17350                              <1> ; Section containing code
 17351                              <1> SECTION .text
 17352                              <1> 
 17353                              <1> %define SERIALSERVER_AH_ALREADY_HAS_COMMAND_BYTE
 17354                              <1> %define SERIALSERVER_NO_ZERO_SECTOR_COUNTS
 17355                              <1> 
 17356                              <1> ;--------------------------------------------------------------------
 17357                              <1> ; SerialCommand_OutputWithParameters
 17358                              <1> ;	Parameters:
 17359                              <1> ;		BH:		Non-zero if 48-bit addressing used
 17360                              <1> ;               (ignored at present as 48-bit addressing is not supported)
 17361                              <1> ;		BL:		IDE Status Register bit to poll after command
 17362                              <1> ;               (ignored at present, since there is no IDE status register to poll)
 17363                              <1> ;		ES:SI:	Ptr to buffer (for data transfer commands)
 17364                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 17365                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 17366                              <1> ;	Returns:
 17367                              <1> ;		AH:		INT 13h Error Code
 17368                              <1> ;		CX:		Number of successfully transferred sectors (for transfer commands)
 17369                              <1> ;		CF:		Cleared if success, Set if error
 17370                              <1> ;	Corrupts registers:
 17371                              <1> ;		AL, BX, CX, DX, (ES:SI for data transfer commands)
 17372                              <1> ;--------------------------------------------------------------------
 17373                              <1> ALIGN JUMP_ALIGN
 17374                              <1> SerialCommand_OutputWithParameters:
 17375                              <1> 
 17376 00001254 B4A2                <1> 		mov		ah,SerialServer_Command_Read
 17377                              <1> 
 17378 00001256 8A4606              <1> 		mov		al,[bp+IDEPACK.bCommand]
 17379                              <1> 
 17380 00001259 3C20                <1> 		cmp		al,20h			; Read Sectors IDE command
 17381 0000125B 7409                <1> 		jz		.readOrWrite
 17382 0000125D FEC4                <1> 		inc		ah				; now SerialServer_Protocol_Write
 17383 0000125F 3C30                <1> 		cmp		al,30h			; Write Sectors IDE command
 17384 00001261 7403                <1> 		jz		.readOrWrite
 17385                              <1> 
 17386                              <1> ;  all other commands return success
 17387                              <1> ;  including function 0ech which should return drive information, this is handled with the identify functions
 17388                              <1> ;
 17389 00001263 30E4                <1> 		xor		ah,ah			;  also clears carry
 17390 00001265 C3                  <1> 		ret
 17391                              <1> 
 17392                              <1> .readOrWrite:
 17393 00001266 886600              <1> 		mov		[bp+IDEPACK.bFeatures],ah		; store protocol command
 17394 00001269 E854FD              <1> 		call	IdeTransfer_NormalizePointerInESSI
 17395                              <1> 
 17396 0000126C 8B5514              <1> 		mov		dx, [di+DPT_SERIAL.wSerialPortAndBaud]
 17397                              <1> 
 17398                              <1> ; fall through to SerialCommand_FallThroughToSerialServer_SendReceive
 17399                              <1> 
 17400                              <1> ALIGN JUMP_ALIGN
 17401                              <1> SerialCommand_FallThroughToSerialServer_SendReceive:
 17402                              <1> 
 17403                              <1> ; fall through to SerialServer_SendReceive
 17404                              <1> 
 17405                              <1> %include "SerialServer.asm"
 17406                              <2> ; Project name	:	Assembly Library
 17407                              <2> ; Description	:	Serial Server Support
 17408                              <2> 
 17409                              <2> ;
 17410                              <2> ; XTIDE Universal BIOS and Associated Tools
 17411                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 17412                              <2> ;
 17413                              <2> ; This program is free software; you can redistribute it and/or modify
 17414                              <2> ; it under the terms of the GNU General Public License as published by
 17415                              <2> ; the Free Software Foundation; either version 2 of the License, or
 17416                              <2> ; (at your option) any later version.
 17417                              <2> ;
 17418                              <2> ; This program is distributed in the hope that it will be useful,
 17419                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 17420                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 17421                              <2> ; GNU General Public License for more details.
 17422                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 17423                              <2> ;
 17424                              <2> 
 17425                              <2> 
 17426                              <2> %include "SerialServer.inc"
 17427                              <3> ; Project name	:	XTIDE Universal BIOS
 17428                              <3> ; Description	:	Serial Server Defines
 17429                              <3> 
 17430                              <3> %ifndef SERIALSERVER_INC
 17431                              <3> %define SERIALSERVER_INC
 17432                              <3> 
 17433                              <3> %include "Serial.inc"
 17434                              <4> ; Project name	:	AssemblyLibrary
 17435                              <4> ; Description	:	Defines for display library.
 17436                              <4> 
 17437                              <4> %ifndef SERIAL_INC
 17438                              <4> %define SERIAL_INC
 17439                              <4> 
 17440                              <4> ;--------------- UART Equates -----------------------------
 17441                              <4> ;
 17442                              <4> ; Serial Programming References:
 17443                              <4> ;    http://en.wikibooks.org/wiki/Serial_Programming
 17444                              <4> ;
 17445                              <4> 
 17446                              <4> Serial_UART_base						EQU		0
 17447                              <4> Serial_UART_transmitByte				EQU		0
 17448                              <4> Serial_UART_receiveByte					EQU		0
 17449                              <4> 
 17450                              <4> ;
 17451                              <4> ; Values for UART_divisorLow:
 17452                              <4> ; 60h = 1200, 30h = 2400, 18h = 4800, 0ch = 9600, 6 = 19200, 4 = 28800, 3 = 38400, 2 = 57600, 1 = 115200
 17453                              <4> ;
 17454                              <4> Serial_UART_divisorLow					EQU		0
 17455                              <4> 
 17456                              <4> ;
 17457                              <4> ; UART_divisorHigh is zero for all speeds including and above 1200 baud (which is all we do)
 17458                              <4> ;
 17459                              <4> Serial_UART_divisorHigh					EQU		1
 17460                              <4> 
 17461                              <4> Serial_UART_interruptIdent				EQU		2
 17462                              <4> Serial_UART_FIFOControl					EQU		2
 17463                              <4> 
 17464                              <4> Serial_UART_lineControl					EQU		3
 17465                              <4> 
 17466                              <4> Serial_UART_modemControl				EQU		4
 17467                              <4> 
 17468                              <4> Serial_UART_lineStatus					EQU		5
 17469                              <4> 
 17470                              <4> Serial_UART_modemStatus					EQU		6
 17471                              <4> 
 17472                              <4> Serial_UART_scratch						EQU		7
 17473                              <4> 
 17474                              <4> ;----------------------------------------------------------------------
 17475                              <4> ;
 17476                              <4> ; COM Number to I/O Port Address Mapping
 17477                              <4> ;
 17478                              <4> ; COM Number:                               1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12
 17479                              <4> ; Corresponds to I/O port:                3f8,  2f8,  3e8,  2e8,  2f0,  3e0,  2e0,  260,  368,  268,  360,  270
 17480                              <4> ; Corresponds to Packed I/O port (hex):    37,   17,   35,   15,   16,   34,   14,    4,   25,    5,   24,    6
 17481                              <4> ;
 17482                              <4> SERIAL_COM1_IOADDRESS	EQU		3f8h
 17483                              <4> SERIAL_COM2_IOADDRESS	EQU		2f8h
 17484                              <4> SERIAL_COM3_IOADDRESS	EQU		3e8h
 17485                              <4> SERIAL_COM4_IOADDRESS	EQU		2e8h
 17486                              <4> SERIAL_COM5_IOADDRESS	EQU		2f0h
 17487                              <4> SERIAL_COM6_IOADDRESS	EQU		3e0h
 17488                              <4> SERIAL_COM7_IOADDRESS	EQU		2e0h
 17489                              <4> SERIAL_COM8_IOADDRESS	EQU		260h
 17490                              <4> SERIAL_COM9_IOADDRESS	EQU		368h
 17491                              <4> SERIAL_COMA_IOADDRESS	EQU		268h
 17492                              <4> SERIAL_COMB_IOADDRESS	EQU		360h
 17493                              <4> SERIAL_COMC_IOADDRESS	EQU		270h
 17494                              <4> 
 17495                              <4> %endif
 17496                              <3> 
 17497                              <3> ;
 17498                              <3> ; Command codes
 17499                              <3> ;
 17500                              <3> SerialServer_Command_Header					EQU		0a0h
 17501                              <3> SerialServer_Command_Write					EQU		(SerialServer_Command_Header | 3)
 17502                              <3> SerialServer_Command_Read					EQU		(SerialServer_Command_Header | 2)
 17503                              <3> SerialServer_Command_Inquire				EQU		(SerialServer_Command_Header | 0)
 17504                              <3> SerialServer_Command_Custom_Read			EQU		(SerialServer_Command_Header | 4)
 17505                              <3> SerialServer_Command_Custom_Write			EQU		(SerialServer_Command_Header | 5)
 17506                              <3> 
 17507                              <3> SerialServer_SubCommand_Image_SendInitiate		EQU		1
 17508                              <3> SerialServer_SubCommand_Image_SendSectors		EQU		2
 17509                              <3> SerialServer_SubCommand_Image_SendComplete		EQU		3
 17510                              <3> 
 17511                              <3> ;
 17512                              <3> ; Locations within the ATA 512-byte Inquire structure, taken from the "Vendor specific area",
 17513                              <3> ; for serial port specific information that is returned by the server for an inquire.
 17514                              <3> ;
 17515                              <3> ; NOTE: These are byte offsets (because of the "*2"), which is more convenient here, while
 17516                              <3> ;       the ATA structure defines these in terms of word offsets.
 17517                              <3> ;
 17518                              <3> SerialServer_ATA_wServerVersion			EQU		(157*2)
 17519                              <3> SerialServer_ATA_wDriveFlags			EQU		(158*2)
 17520                              <3> SerialServer_ATA_wPortAndBaud			EQU		(159*2)
 17521                              <3> 
 17522                              <3> ;
 17523                              <3> ; Command structure passed to SerialServer_SendReceive.  This mirrors IDEPACK in the XTIDE Universal BIOS, 
 17524                              <3> ; since that structure is passed directly without copying values into this structure.
 17525                              <3> ;
 17526                              <3> struc SerialServer_Command
 17527                              <3> 	.wCommandAndCustom:	
 17528 00000000 <res 00000001>      <3> 	.bCommand				resb	1
 17529                              <3> 
 17530                              <3> 	.bCustomCommand:	
 17531 00000001 <res 00000001>      <3> 	.bDrvAndHead			resb	1	; LBA28 27...24
 17532                              <3> 
 17533                              <3> 	.wSectorCountAndLbaLow:
 17534 00000002 <res 00000001>      <3> 	.bSectorCount			resb	1
 17535                              <3> 
 17536                              <3> 	.bCustomData3:		
 17537                              <3> 	.bSectorNumber:
 17538 00000003 <res 00000001>      <3> 	.bLbaLow				resb	1	; LBA 7...0
 17539                              <3> 
 17540                              <3> 	.wCustomData1:		
 17541                              <3> 	.bCustomData1:		
 17542                              <3> 	.wCylinder:
 17543                              <3> 	.wLbaMiddleAndHigh:
 17544 00000004 <res 00000001>      <3> 	.bLbaMiddle				resb	1	; LBA 15...8
 17545                              <3> 
 17546                              <3> 	.bCustomData2:		
 17547 00000005 <res 00000001>      <3> 	.bLbaHigh				resb	1	; LBA 23...16
 17548                              <3> endstruc
 17549                              <3> 
 17550                              <3> %endif
 17551                              <3> 
 17552                              <2> 
 17553                              <2> ; Section containing code
 17554                              <2> SECTION .text
 17555                              <2> 
 17556                              <2> ;--------------------------------------------------------------------
 17557                              <2> ; SerialServer_SendReceive:
 17558                              <2> ;	Parameters:
 17559                              <2> ;       DX:		Packed I/O port and baud rate
 17560                              <2> ;		ES:SI:	Ptr to buffer (for data transfer commands)
 17561                              <2> ;		SS:BP:	Ptr to SerialServer_Command structure
 17562                              <2> ;	Returns:
 17563                              <2> ;		AH:		INT 13h Error Code
 17564                              <2> ;       CX:     Number of 512-byte blocks transferred
 17565                              <2> ;		CF:		Cleared if success, Set if error
 17566                              <2> ;	Corrupts registers:
 17567                              <2> ;		AL, BX, CX, DX
 17568                              <2> ;--------------------------------------------------------------------
 17569                              <2> SerialServer_SendReceive:
 17570                              <2> 
 17571 0000126F 56                  <2> 		push	si
 17572 00001270 57                  <2> 		push	di
 17573 00001271 55                  <2> 		push	bp
 17574                              <2> 
 17575                              <2> ;
 17576                              <2> ; Unpack I/O port and baud from DPT
 17577                              <2> ;		Port to DX for the remainder of the routine (+/- different register offsets)
 17578                              <2> ;		Baud in CH until UART initialization is complete
 17579                              <2> ;
 17580 00001272 88F5                <2> 		mov		ch,dh
 17581 00001274 30F6                <2> 		xor		dh,dh
 17582                              <2> 		eSHL_IM	dx, 2			; shift from one byte to two
 17583                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 17584                              <3> %ifdef USE_386
 17585                              <3>  %if %2 = 1
 17586                              <3>  add %1, %1
 17587                              <3>  %else
 17588                              <3>  eSHIFT_IM %1, %2, shl
 17589                              <3>  %endif
 17590                              <3> %else
 17591                              <3>  eSHIFT_IM %1, %2, shl
 17592                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 17593                              <4> %ifndef USE_186
 17594                              <4>  %ifidni %1, cl
 17595                              <4>  times %2 %3 %1, 1
 17596                              <4>  %elifidni %1, ch
 17597                              <4>  times %2 %3 %1, 1
 17598                              <4>  %elifidni %1, cx
 17599                              <4>  times %2 %3 %1, 1
 17600                              <4>  %else
 17601                              <4>  %if %2 > 3
 17602                              <4>  push cx
 17603                              <4>  mov cl, %2
 17604                              <4>  %3 %1, cl
 17605                              <4>  pop cx
 17606                              <4>  %else
 17607 00001276 D1E2<rept>          <4>  times %2 %3 %1, 1
 17608                              <4>  %endif
 17609                              <4>  %endif
 17610                              <4> 
 17611                              <4> %else
 17612                              <4>  %3 %1, %2
 17613                              <4> %endif
 17614                              <4> %endif
 17615                              <3> %endif
 17616                              <3> %endif
 17617                              <2> 
 17618 0000127A 8A4602              <2> 		mov		al,[bp+SerialServer_Command.bSectorCount]
 17619 0000127D 8A6600              <2> 		mov		ah,[bp+SerialServer_Command.bCommand]
 17620                              <2> 
 17621                              <2> ;
 17622                              <2> ; Command byte and sector count live at the top of the stack, pop/push are used to access
 17623                              <2> ;
 17624 00001280 50                  <2> 		push	ax				; save sector count for return value
 17625 00001281 50                  <2> 		push	ax				; working copy on the top of the stack
 17626                              <2> 
 17627                              <2> %ifndef EXCLUDE_FROM_XTIDE_UNIVERSAL_BIOS	; DF already cleared in Int13h.asm
 17628                              <2> 		cld
 17629                              <2> %endif
 17630                              <2> 
 17631                              <2> ;----------------------------------------------------------------------
 17632                              <2> ;
 17633                              <2> ; Initialize UART
 17634                              <2> ;
 17635                              <2> ; We do this each time since DOS (at boot) or another program may have
 17636                              <2> ; decided to reprogram the UART
 17637                              <2> ;
 17638 00001282 88D3                <2> 		mov		bl,dl			; setup BL with proper values for read/write loops (BH comes later)
 17639                              <2> 
 17640 00001284 B083                <2> 		mov		al,83h
 17641 00001286 80C203              <2> 		add		dl, Serial_UART_lineControl	; Clears CF
 17642 00001289 EE                  <2> 		out		dx,al
 17643                              <2> 
 17644 0000128A 88E8                <2> 		mov		al,ch
 17645 0000128C 88DA                <2> 		mov		dl,bl			; divisor low
 17646 0000128E EE                  <2> 		out		dx,al
 17647                              <2> 
 17648                              <2> %ifdef USE_UNDOC_INTEL
 17649                              <2> 		eSALC	; Clear AL using CF
 17650                              <2> %else
 17651 0000128F 31C0                <2> 		xor		ax,ax
 17652                              <2> %endif
 17653 00001291 42                  <2> 		inc		dx				; divisor high
 17654 00001292 52                  <2> 		push	dx
 17655 00001293 EE                  <2> 		out		dx,al
 17656                              <2> 
 17657 00001294 B047                <2> 		mov		al,047h
 17658 00001296 42                  <2> 		inc		dx				;  fifo
 17659 00001297 EE                  <2> 		out		dx,al
 17660                              <2> 
 17661 00001298 B003                <2> 		mov		al,03h
 17662 0000129A 42                  <2> 		inc		dx				;  linecontrol
 17663 0000129B EE                  <2> 		out		dx,al
 17664                              <2> 
 17665 0000129C B00B                <2> 		mov		al,0bh
 17666 0000129E 42                  <2> 		inc		dx				;  modemcontrol
 17667 0000129F EE                  <2> 		out		dx,al
 17668                              <2> 
 17669 000012A0 42                  <2> 		inc		dx				;  linestatus (no output now, just setting up BH for later use)
 17670 000012A1 88D7                <2> 		mov		bh,dl
 17671                              <2> 
 17672 000012A3 5A                  <2> 		pop		dx				; base, interrupts disabled
 17673                              <2> %ifdef USE_UNDOC_INTEL
 17674                              <2> 		eSALC	; Clear AL using CF
 17675                              <2> %else
 17676 000012A4 31C0                <2> 		xor		ax,ax
 17677                              <2> %endif
 17678 000012A6 EE                  <2> 		out		dx,al
 17679                              <2> 
 17680                              <2> ;----------------------------------------------------------------------
 17681                              <2> ;
 17682                              <2> ; Send Command
 17683                              <2> ;
 17684                              <2> ; Sends first six bytes of IDEREGS_AND_INTPACK as the command
 17685                              <2> ;
 17686 000012A7 06                  <2> 		push	es				; save off real buffer location
 17687 000012A8 56                  <2> 		push	si
 17688                              <2> 
 17689 000012A9 89EE                <2> 		mov		si,bp			; point to IDEREGS for command dispatch;
 17690 000012AB 16                  <2> 		push	ss
 17691 000012AC 07                  <2> 		pop		es
 17692                              <2> 
 17693 000012AD BFFFFF              <2> 		mov		di,0ffffh		; initialize checksum for write
 17694 000012B0 89FD                <2> 		mov		bp,di
 17695                              <2> 
 17696 000012B2 B90400              <2> 		mov		cx,4			; writing 3 words (plus 1)
 17697                              <2> 
 17698 000012B5 FA                  <2> 		cli						; interrupts off...
 17699                              <2> 
 17700 000012B6 E89F00              <2> 		call	SerialServer_WriteProtocol.entry
 17701                              <2> 
 17702 000012B9 5F                  <2> 		pop		di				; restore real buffer location (note change from SI to DI)
 17703                              <2> 								; Buffer is primarily referenced through ES:DI throughout, since
 17704                              <2> 								; we need to store (read sector) faster than we read (write sector)
 17705 000012BA 07                  <2> 		pop		es
 17706                              <2> 
 17707 000012BB 58                  <2> 		pop		ax				; load command byte (done before call to .nextSector on subsequent iterations)
 17708 000012BC 50                  <2> 		push	ax
 17709                              <2> 
 17710                              <2> %ifndef SERIALSERVER_NO_ZERO_SECTOR_COUNTS
 17711                              <2> 		test	al,al			; if no sectors to be transferred, wait for the ACK checksum on the command
 17712                              <2> 		jz		.zeroSectors
 17713                              <2> %endif
 17714                              <2> 
 17715                              <2> ;
 17716                              <2> ; Top of the read/write loop, one iteration per sector
 17717                              <2> ;
 17718                              <2> .nextSector:
 17719 000012BD BEFFFF              <2> 		mov		si,0ffffh		; initialize checksum for read or write
 17720 000012C0 89F5                <2> 		mov		bp,si
 17721                              <2> 
 17722 000012C2 B90101              <2> 		mov		cx,0101h		; writing 256 words (plus 1)
 17723                              <2> 
 17724 000012C5 D0EC                <2> 		shr		ah,1			; command byte, are we doing a write?
 17725 000012C7 7321                <2> 		jnc		.readEntry
 17726                              <2> 
 17727 000012C9 87F7                <2> 		xchg	si,di			; swap pointer and checksum, will be re-swap'ed in WriteProtocol
 17728 000012CB E88A00              <2> 		call	SerialServer_WriteProtocol.entry
 17729                              <2> 
 17730                              <2> .zeroSectors:
 17731 000012CE 41                  <2> 		inc		cx				; CX = 1 now (0 out of WriteProtocol)
 17732 000012CF EB19                <2> 		jmp		.readEntry
 17733                              <2> 
 17734                              <2> ;----------------------------------------------------------------------
 17735                              <2> ;
 17736                              <2> ; Timeout
 17737                              <2> ;
 17738                              <2> ; To save code space, we use the contents of DL to decide which byte in the word to return for reading.
 17739                              <2> ;
 17740                              <2> .readTimeout:
 17741 000012D1 50                  <2> 		push	ax				; not only does this push preserve AX (which we need), but it also
 17742                              <2> 								; means the stack has the same number of bytes on it as when we are
 17743                              <2> 								; sending a packet, important for error cleanup and exit
 17744 000012D2 B401                <2> 		mov		ah,1
 17745 000012D4 E8AB00              <2> 		call	SerialServer_WaitAndPoll_Read
 17746 000012D7 58                  <2> 		pop		ax
 17747 000012D8 F6C201              <2> 		test	dl,1
 17748 000012DB 7416                <2> 		jz		.readByte1Ready
 17749 000012DD EB1E                <2> 		jmp		.readByte2Ready
 17750                              <2> 
 17751                              <2> ;----------------------------------------------------------------------------
 17752                              <2> ;
 17753                              <2> ; Read Block (without interrupts, used when there is a FIFO, high speed)
 17754                              <2> ;
 17755                              <2> ; NOTE: This loop is very time sensitive.  Literally, another instruction
 17756                              <2> ; cannot be inserted into this loop without us falling behind at high
 17757                              <2> ; speed (460.8K baud) on a 4.77Mhz 8088, making it hard to receive
 17758                              <2> ; a full 512 byte block.
 17759                              <2> ;
 17760                              <2> .readLoop:
 17761 000012DF AB                  <2> 		stosw					; store word in caller's data buffer
 17762                              <2> 
 17763 000012E0 01C5                <2> 		add		bp, ax			; update Fletcher's checksum
 17764 000012E2 83D500              <2> 		adc		bp, 0
 17765 000012E5 01EE                <2> 		add		si, bp
 17766 000012E7 83D600              <2> 		adc		si, 0
 17767                              <2> 
 17768                              <2> .readEntry:
 17769 000012EA 88FA                <2> 		mov		dl,bh
 17770 000012EC EC                  <2> 		in		al,dx
 17771 000012ED D0E8                <2> 		shr		al,1			; data ready (byte 1)?
 17772 000012EF 88DA                <2> 		mov		dl,bl			; get ready to read data
 17773 000012F1 73DE                <2> 		jnc		.readTimeout	; nope not ready, update timeouts
 17774                              <2> 
 17775                              <2> ;
 17776                              <2> ; Entry point after initial timeout.  We enter here so that the checksum word
 17777                              <2> ; is not stored (and is left in AX after the loop is complete).
 17778                              <2> ;
 17779                              <2> .readByte1Ready:
 17780 000012F3 EC                  <2> 		in		al, dx			; read data byte 1
 17781                              <2> 
 17782 000012F4 88C4                <2> 		mov		ah, al			; store byte in ah for now
 17783                              <2> 
 17784                              <2> ;
 17785                              <2> ; note the placement of this reset of dl to bh, and that it is
 17786                              <2> ; before the return, which is assymetric with where this is done
 17787                              <2> ; above for byte 1.  The value of dl is used by the timeout routine
 17788                              <2> ; to know which byte to return to (.read_byte1_ready or
 17789                              <2> ; .read_byte2_ready)
 17790                              <2> ;
 17791 000012F6 88FA                <2> 		mov		dl,bh
 17792                              <2> 
 17793 000012F8 EC                  <2> 		in		al,dx
 17794 000012F9 D0E8                <2> 		shr		al,1			; data ready (byte 2)?
 17795 000012FB 73D4                <2> 		jnc		.readTimeout
 17796                              <2> .readByte2Ready:
 17797 000012FD 88DA                <2> 		mov		dl,bl
 17798 000012FF EC                  <2> 		in		al, dx			; read data byte 2
 17799                              <2> 
 17800 00001300 86C4                <2> 		xchg	al, ah			; ah was holding byte 1, reverse byte order
 17801                              <2> 
 17802 00001302 E2DB                <2> 		loop	.readLoop
 17803                              <2> 
 17804 00001304 FB                  <2> 		sti						; interrupts back on ASAP, between packets
 17805                              <2> 
 17806                              <2> ;
 17807                              <2> ; Compare checksums
 17808                              <2> ;
 17809 00001305 95                  <2> 		xchg	ax,bp
 17810 00001306 30C4                <2> 		xor		ah,al
 17811 00001308 89F1                <2> 		mov		cx,si
 17812 0000130A 30E9                <2> 		xor		cl,ch
 17813 0000130C 88C8                <2> 		mov		al,cl
 17814 0000130E 39E8                <2> 		cmp		ax,bp
 17815 00001310 750D                <2> 		jnz		SerialServer_OutputWithParameters_Error
 17816                              <2> 
 17817 00001312 58                  <2> 		pop		ax				; sector count and command byte
 17818 00001313 FEC8                <2> 		dec		al				; decrement sector count
 17819 00001315 50                  <2> 		push	ax				; save
 17820 00001316 7419                <2> 		jz		SerialServer_OutputWithParameters_ReturnCodeInAL
 17821                              <2> 
 17822 00001318 FA                  <2> 		cli						; interrupts back off for ACK byte to host
 17823                              <2> 								; (host could start sending data immediately)
 17824 00001319 EE                  <2> 		out		dx,al			; ACK with next sector number
 17825                              <2> 
 17826 0000131A EBA1                <2> 		jmp		short .nextSector
 17827                              <2> 
 17828                              <2> ;---------------------------------------------------------------------------
 17829                              <2> ;
 17830                              <2> ; Cleanup, error reporting, and exit
 17831                              <2> ;
 17832                              <2> 
 17833                              <2> ;
 17834                              <2> ; Used in situations where a call is underway, such as with SerialServer_WaitAndPoll
 17835                              <2> ;
 17836                              <2> ALIGN JUMP_ALIGN
 17837                              <2> SerialServer_OutputWithParameters_ErrorAndPop4Words:
 17838 0000131C 83C408              <2> 		add		sp,8
 17839                              <2> ;;; fall-through
 17840                              <2> 
 17841                              <2> ALIGN JUMP_ALIGN
 17842                              <2> SerialServer_OutputWithParameters_Error:
 17843                              <2> ;----------------------------------------------------------------------
 17844                              <2> ;
 17845                              <2> ; Clear read buffer
 17846                              <2> ;
 17847                              <2> ; In case there are extra characters or an error in the FIFO, clear it out.
 17848                              <2> ; In theory the initialization of the UART registers above should have
 17849                              <2> ; taken care of this, but I have seen cases where this is not true.
 17850                              <2> ;
 17851 0000131F 31C9                <2> 		xor		cx,cx					; timeout this clearing routine, in case the UART isn't there
 17852                              <2> .clearBuffer:
 17853 00001321 88FA                <2> 		mov		dl,bh
 17854 00001323 EC                  <2> 		in		al,dx
 17855 00001324 88DA                <2> 		mov		dl,bl
 17856 00001326 A88F                <2> 		test	al,08fh
 17857 00001328 7405                <2> 		jz		.clearBufferComplete
 17858 0000132A A801                <2> 		test	al,1
 17859 0000132C EC                  <2> 		in		al,dx
 17860 0000132D E0F2                <2> 		loopnz	.clearBuffer			; note ZF from test above
 17861                              <2> 
 17862                              <2> .clearBufferComplete:
 17863 0000132F B003                <2> 		mov		al, 3			;  error return code and CF (low order bit)
 17864                              <2> 
 17865                              <2> ALIGN JUMP_ALIGN
 17866                              <2> SerialServer_OutputWithParameters_ReturnCodeInAL:
 17867                              <2> %if 0
 17868                              <2> 		sti						;  all paths here will already have interrupts turned back on
 17869                              <2> %endif
 17870 00001331 88C4                <2> 		mov		ah, al			;  for success, AL will already be zero
 17871                              <2> 
 17872 00001333 5B                  <2> 		pop		bx				;  recover "ax" (command and count) from stack
 17873 00001334 59                  <2> 		pop		cx				;  recover saved sector count
 17874 00001335 30ED                <2> 		xor		ch, ch
 17875 00001337 28D9                <2> 		sub		cl, bl			; subtract off the number of sectors that remained
 17876                              <2> 
 17877 00001339 5D                  <2> 		pop		bp
 17878 0000133A 5F                  <2> 		pop		di
 17879 0000133B 5E                  <2> 		pop		si
 17880                              <2> 
 17881 0000133C D0EC                <2> 		shr		ah, 1			; shift down return code and CF
 17882                              <2> 
 17883 0000133E C3                  <2> 		ret
 17884                              <2> 
 17885                              <2> ;--------------------------------------------------------------------
 17886                              <2> ; SerialServer_WriteProtocol
 17887                              <2> ;
 17888                              <2> ; NOTE: As with its read counterpart, this loop is very time sensitive.
 17889                              <2> ; Although it will still function, adding additional instructions will
 17890                              <2> ; impact the write throughput, especially on slower machines.
 17891                              <2> ;
 17892                              <2> ;	Parameters:
 17893                              <2> ;		ES:SI:	Ptr to buffer
 17894                              <2> ;		CX:		Words to write, plus 1
 17895                              <2> ;		BP/DI:	Initialized for Checksum (-1 in each)
 17896                              <2> ;		DH:		I/O Port high byte
 17897                              <2> ;		BX:		LineStatus Register address (BH) and Receive/Transmit Register address (BL)
 17898                              <2> ;	Returns:
 17899                              <2> ;		BP/SI:	Checksum for written bytes, compared against ACK from server in .readLoop
 17900                              <2> ;		CX:     Zero
 17901                              <2> ;		DL:		Receive/Transmit Register address
 17902                              <2> ;		ES:DI:  Ptr to buffer
 17903                              <2> ;	Corrupts registers:
 17904                              <2> ;		AX
 17905                              <2> ;--------------------------------------------------------------------
 17906                              <2> ALIGN JUMP_ALIGN
 17907                              <2> SerialServer_WriteProtocol:
 17908                              <2> .writeLoop:
 17909 0000133F 26AD                <2> 		es lodsw				; fetch next word
 17910                              <2> 
 17911 00001341 EE                  <2> 		out		dx,al			; output first byte
 17912                              <2> 
 17913 00001342 01C5                <2> 		add		bp,ax			; update checksum
 17914 00001344 83D500              <2> 		adc		bp,0
 17915 00001347 01EF                <2> 		add		di,bp
 17916 00001349 83D700              <2> 		adc		di,0
 17917                              <2> 
 17918 0000134C 88FA                <2> 		mov		dl,bh			; transmit buffer empty?
 17919 0000134E EC                  <2> 		in		al,dx
 17920 0000134F A820                <2> 		test	al,20h
 17921 00001351 7420                <2> 		jz		.writeTimeout2	; nope, use our polling routine
 17922                              <2> 
 17923                              <2> .writeByte2Ready:
 17924 00001353 88DA                <2> 		mov		dl,bl
 17925 00001355 88E0                <2> 		mov		al,ah			; output second byte
 17926 00001357 EE                  <2> 		out		dx,al
 17927                              <2> 
 17928                              <2> .entry:
 17929 00001358 88FA                <2> 		mov		dl,bh			; transmit buffer empty?
 17930 0000135A EC                  <2> 		in		al,dx
 17931 0000135B A820                <2> 		test	al,20h
 17932 0000135D 88DA                <2> 		mov		dl,bl
 17933 0000135F 741B                <2> 		jz		.writeTimeout1	; nope, use our polling routine
 17934                              <2> 
 17935                              <2> .writeByte1Ready:
 17936 00001361 E2DC                <2> 		loop	.writeLoop
 17937                              <2> 
 17938 00001363 89F8                <2> 		mov		ax,di			; fold Fletcher's checksum and output
 17939 00001365 30E0                <2> 		xor		al,ah
 17940 00001367 EE                  <2> 		out		dx,al			; byte 1
 17941                              <2> 
 17942 00001368 E81500              <2> 		call	SerialServer_WaitAndPoll_Write
 17943                              <2> 
 17944 0000136B 89E8                <2> 		mov		ax,bp
 17945 0000136D 30E0                <2> 		xor		al,ah
 17946 0000136F EE                  <2> 		out		dx,al			; byte 2
 17947                              <2> 
 17948 00001370 87F7                <2> 		xchg	si,di			; preserve checksum word in si, move pointer back to di
 17949                              <2> 
 17950 00001372 C3                  <2> 		ret
 17951                              <2> 
 17952                              <2> .writeTimeout2:
 17953 00001373 88E2                <2> 		mov		dl,ah			; need to preserve AH, but don't need DL (will be reset upon return)
 17954 00001375 E80800              <2> 		call	SerialServer_WaitAndPoll_Write
 17955 00001378 88D4                <2> 		mov		ah,dl
 17956 0000137A EBD7                <2> 		jmp		.writeByte2Ready
 17957                              <2> 
 17958                              <2> .writeTimeout1:
 17959                              <2> 		ePUSH_T	ax, .writeByte1Ready	; return address for ret at end of SC_writeTimeout2
 17960                              <3> %ifndef USE_186
 17961                              <3>  %ifidni %2, 0
 17962                              <3>  xor %1, %1
 17963                              <3>  %else
 17964 0000137C B8[6113]            <3>  mov %1, %2
 17965                              <3>  %endif
 17966 0000137F 50                  <3>  push %1
 17967                              <3> 
 17968                              <3> %else
 17969                              <3>  push %2
 17970                              <3> %endif
 17971                              <2> ;;; fall-through
 17972                              <2> 
 17973                              <2> ;--------------------------------------------------------------------
 17974                              <2> ; SerialServer_WaitAndPoll
 17975                              <2> ;
 17976                              <2> ;	Parameters:
 17977                              <2> ;		AH:		UART_LineStatus bit to test (20h for write, or 1h for read)
 17978                              <2> ;               One entry point fills in AH with 20h for write
 17979                              <2> ;		DX:		Port address (OK if already incremented to UART_lineStatus)
 17980                              <2> ;       BX:
 17981                              <2> ;       Stack:	2 words on the stack below the command/count word
 17982                              <2> ;	Returns:
 17983                              <2> ;       Returns when desired UART_LineStatus bit is cleared
 17984                              <2> ;       Jumps directly to error exit if timeout elapses (and cleans up stack)
 17985                              <2> ;	Corrupts registers:
 17986                              <2> ;       AX
 17987                              <2> ;--------------------------------------------------------------------
 17988                              <2> 
 17989                              <2> SerialServer_WaitAndPoll_SoftDelayTicks   EQU   20
 17990                              <2> 
 17991                              <2> ALIGN JUMP_ALIGN
 17992                              <2> SerialServer_WaitAndPoll_Write:
 17993 00001380 B420                <2> 		mov		ah,20h
 17994                              <2> ;;; fall-through
 17995                              <2> 
 17996                              <2> ALIGN JUMP_ALIGN
 17997                              <2> SerialServer_WaitAndPoll_Read:
 17998 00001382 51                  <2> 		push	cx
 17999 00001383 52                  <2> 		push	dx
 18000                              <2> 
 18001                              <2> ;
 18002                              <2> ; We first poll in a tight loop, interrupts off, for the next character to come in/be sent
 18003                              <2> ;
 18004 00001384 31C9                <2> 		xor		cx,cx
 18005                              <2> .readTimeoutLoop:
 18006 00001386 88FA                <2> 		mov		dl,bh
 18007 00001388 EC                  <2> 		in		al,dx
 18008 00001389 84E0                <2> 		test	al,ah
 18009 0000138B 7513                <2> 		jnz		.readTimeoutComplete
 18010 0000138D E2F7                <2> 		loop	.readTimeoutLoop
 18011                              <2> 
 18012                              <2> ;
 18013                              <2> ; If that loop completes, then we assume there is a long delay involved, turn interrupts back on
 18014                              <2> ; and wait for a given number of timer ticks to pass.
 18015                              <2> ;
 18016 0000138F FB                  <2> 		sti
 18017 00001390 B114                <2> 		mov		cl,SerialServer_WaitAndPoll_SoftDelayTicks
 18018                              <2> %ifndef SERIALSERVER_TIMER_LOCATION
 18019 00001392 E803F9              <2> 		call	Timer_InitializeTimeoutWithTicksInCL
 18020                              <2> %else
 18021                              <2> 		push	ax
 18022                              <2> 		push	bx
 18023                              <2> 		mov		ax,SerialServer_WaitAndPoll_SoftDelayTicks
 18024                              <2> 		mov		bx,SERIALSERVER_TIMER_LOCATION
 18025                              <2> 		call	TimerTicks_InitializeTimeoutFromAX
 18026                              <2> 		pop		bx
 18027                              <2> 		pop		ax
 18028                              <2> %endif
 18029                              <2> 
 18030                              <2> .WaitAndPoll:
 18031                              <2> %ifndef SERIALSERVER_TIMER_LOCATION
 18032 00001395 E80CF9              <2> 		call	Timer_SetCFifTimeout
 18033                              <2> %else
 18034                              <2> 		push	ax
 18035                              <2> 		push	bx
 18036                              <2> 		mov		bx,SERIALSERVER_TIMER_LOCATION
 18037                              <2> 		call	TimerTicks_GetTimeoutTicksLeftToAXfromDSBX
 18038                              <2> 		pop		bx
 18039                              <2> 		pop		ax
 18040                              <2> %endif
 18041 00001398 7282                <2> 		jc		SerialServer_OutputWithParameters_ErrorAndPop4Words
 18042 0000139A EC                  <2> 		in		al,dx
 18043 0000139B 84E0                <2> 		test	al,ah
 18044 0000139D 74F6                <2> 		jz		.WaitAndPoll
 18045 0000139F FA                  <2> 		cli
 18046                              <2> 
 18047                              <2> .readTimeoutComplete:
 18048 000013A0 5A                  <2> 		pop		dx
 18049 000013A1 59                  <2> 		pop		cx
 18050 000013A2 C3                  <2> 		ret
 18051                              <2> 
 18052                              <2> 
 18053                              <1> 
 18054                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 18055                              <1> 	%if SerialCommand_FallThroughToSerialServer_SendReceive <> SerialServer_SendReceive
 18056                              <1> 		%error "SerialServer_SendReceive must be the first routine at the top of SerialServer.asm in the Assembly_Library"
 18057                              <1> 	%endif
 18058                              <1> %endif
 18059                              <1> 
 18060                              <1> ALIGN JUMP_ALIGN
 18061                              <1> SerialCommand_ReturnError:
 18062 000013A3 F9                  <1> 		stc
 18063 000013A4 C3                  <1> 		ret
 18064                              <1> 
 18065                              <1> ;--------------------------------------------------------------------
 18066                              <1> ; SerialCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH
 18067                              <1> ;	Parameters:
 18068                              <1> ;		BH:		Drive Select byte for Drive and Head Select Register
 18069                              <1> ;		DS:		Segment to RAMVARS
 18070                              <1> ;		ES:SI:	Ptr to buffer to receive 512-byte IDE Information
 18071                              <1> ;		CS:BP:	Ptr to IDEVARS
 18072                              <1> ;	Returns:
 18073                              <1> ;		CF:		Cleared if success, Set if error
 18074                              <1> ;	Corrupts registers:
 18075                              <1> ;		AL, BL, CX, DX, SI, DI, ES
 18076                              <1> ;--------------------------------------------------------------------
 18077                              <1> ALIGN JUMP_ALIGN
 18078                              <1> SerialCommand_IdentifyDeviceToBufferInESSIwithDriveSelectByteInBH:
 18079                              <1> ;
 18080                              <1> ; To improve boot time, we do our best to avoid looking for slave serial drives when we already know the results
 18081                              <1> ; from the looking for a master.  This is particularly true when doing a COM port scan, as we will end up running
 18082                              <1> ; through all the COM ports and baud rates a second time.
 18083                              <1> ;
 18084                              <1> ; But drive detection isn't the only case - we also need to get the right drive when called on int13h/25h.
 18085                              <1> ;
 18086                              <1> ; The decision tree:
 18087                              <1> ;
 18088                              <1> ;    Master:
 18089                              <1> ;		   wSerialPortAndBaud Non-Zero:           -> Continue with wSerialPortAndBaud (1)
 18090                              <1> ;		   wSerialPortAndBaud Zero:
 18091                              <1> ;		       previous serial drive not found:   -> Scan (2)
 18092                              <1> ;		       previous serial drive found:       -> Continue with previous serial drive info (3)
 18093                              <1> ;
 18094                              <1> ;    Slave:
 18095                              <1> ;		   wSerialPortAndBaud Non-Zero:
 18096                              <1> ;		   	   previous serial drive not found:   -> Error - Not Found (4)
 18097                              <1> ;			   previous serial drive found:       -> Continue with wSerialPackedAndBaud (5)
 18098                              <1> ;          wSerialPortAndBaud Zero:
 18099                              <1> ;		   	   previous serial drive not found:	  -> Error - Not Found (4)
 18100                              <1> ;			   previous serial drive found:       -> Continue with previous serial drive info (6)
 18101                              <1> ;
 18102                              <1> ; (1) This was a port/baud that was explicitly set with the configurator.  In the drive detection case, as this
 18103                              <1> ;     is the Master, we are checking out a new controller, and so don't care if we already have a serial drive.
 18104                              <1> ;     And as with the int13h/25h case, we just go off and get the needed information using the user's setting.
 18105                              <1> ; (2) We are using the special .ideVarsSerialAuto structure.  During drive detection, we would only be here
 18106                              <1> ;     if we hadn't already seen a serial drive (since we only scan if no explicit drives are set),
 18107                              <1> ;     so we go off to scan.
 18108                              <1> ; (3) We are using the special .ideVarsSerialAuto structure.  We won't get here during drive detection, but
 18109                              <1> ;     we might get here on an int13h/25h call.  If we have scanned COM drives, they are the ONLY serial drives
 18110                              <1> ;     in use, and so we use the values from the previously seen serial drive DPT.
 18111                              <1> ; (4) No master has been found yet, therefore no slave should be found.  Avoiding the slave reduces boot time,
 18112                              <1> ;     especially in the full COM port scan case.  Note that this is different from the hardware IDE, where we
 18113                              <1> ;     will scan for a slave even if a master is not present.  Note that if ANY master had been previously found,
 18114                              <1> ;     we will do the slave scan, which isn't harmful, it just wastes time.  But the most common case (by a wide
 18115                              <1> ;     margin) will be just one serial controller.
 18116                              <1> ; (5) A COM port scan for a master had been previously completed, and a drive was found.  In a multiple serial
 18117                              <1> ;     controller scenario being called with int13h/25h, we need to use the value in bSerialPackedPortAndBaud
 18118                              <1> ;     to make sure we get the proper drive.
 18119                              <1> ; (6) A COM port scan for a master had been previously completed, and a drive was found.  We would only get here
 18120                              <1> ;     if no serial drive was explicitly set by the user in the configurator or that drive had not been found.
 18121                              <1> ;     Instead of performing the full COM port scan for the slave, use the port/baud value stored during the
 18122                              <1> ;     master scan.
 18123                              <1> ;
 18124 000013A5 2E8B5600            <1> 		mov		dx,[cs:bp+IDEVARS.wSerialPortAndBaud]
 18125 000013A9 31C0                <1> 		xor		ax,ax
 18126                              <1> 
 18127 000013AB 56                  <1> 		push	si
 18128 000013AC E8F6F2              <1> 		call	FindDPT_ToDSDIforSerialDevice
 18129 000013AF 5E                  <1> 		pop		si
 18130                              <1> %ifdef MODULE_SERIAL_FLOPPY
 18131 000013B0 7307                <1> 		jnc		.founddpt
 18132                              <1> ;
 18133                              <1> ; If not found above with FindDPT_ToDSDIforSerialDevice, DI will point to the DPT after the last hard disk DPT
 18134                              <1> ; So, if there was a previously found floppy disk, DI will point to that DPT and we use that value for the slave.
 18135                              <1> ;
 18136 000013B2 803E0A0000          <1> 		cmp		byte [RAMVARS.xlateVars+XLATEVARS.bFlopCntAndFirst], 0
 18137 000013B7 7403                <1> 		jz		.notfounddpt
 18138                              <1> .founddpt:
 18139                              <1> %else
 18140                              <1> 		jc		.notfounddpt
 18141                              <1> %endif
 18142 000013B9 8B4514              <1> 		mov		ax, [di+DPT_SERIAL.wSerialPortAndBaud]
 18143                              <1> .notfounddpt:
 18144                              <1> 
 18145 000013BC F6C710              <1> 		test	bh, FLG_DRVNHEAD_DRV
 18146 000013BF 7404                <1> 		jz		.master
 18147                              <1> 
 18148 000013C1 85C0                <1> 		test	ax,ax			; Take care of the case that is different between master and slave.
 18149 000013C3 74DE                <1> 		jz		SerialCommand_ReturnError
 18150                              <1> 
 18151                              <1> ; fall-through
 18152                              <1> .master:
 18153 000013C5 85D2                <1> 		test	dx,dx
 18154 000013C7 7501                <1> 		jnz		.identifyDeviceInDX
 18155                              <1> 
 18156 000013C9 92                  <1> 		xchg	dx, ax			;  move ax to dx (move previously found serial drive to dx, could be zero)
 18157                              <1> 
 18158                              <1> .identifyDeviceInDX:
 18159                              <1> 
 18160                              <1> ; fall through to SerialCommand_FallThroughToSerialServerScan_ScanForServer
 18161                              <1> 
 18162                              <1> ALIGN JUMP_ALIGN
 18163                              <1> SerialCommand_FallThroughToSerialServerScan_ScanForServer:
 18164                              <1> 
 18165                              <1> ; fall through to SerialServerScan_ScanForServer
 18166                              <1> 
 18167                              <1> %include "SerialServerScan.asm"
 18168                              <2> ; Project name	:	Assembly Library
 18169                              <2> ; Description	:	Serial Server Support, Scan for Server
 18170                              <2> ;
 18171                              <2> ; This functionality is broken out from SerialServer as it may only be needed during
 18172                              <2> ; initialization to find a server, and then could be discarded, (for example the case
 18173                              <2> ; of a TSR).
 18174                              <2> 
 18175                              <2> ;
 18176                              <2> ; XTIDE Universal BIOS and Associated Tools
 18177                              <2> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 18178                              <2> ;
 18179                              <2> ; This program is free software; you can redistribute it and/or modify
 18180                              <2> ; it under the terms of the GNU General Public License as published by
 18181                              <2> ; the Free Software Foundation; either version 2 of the License, or
 18182                              <2> ; (at your option) any later version.
 18183                              <2> ;
 18184                              <2> ; This program is distributed in the hope that it will be useful,
 18185                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 18186                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 18187                              <2> ; GNU General Public License for more details.
 18188                              <2> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 18189                              <2> ;
 18190                              <2> 
 18191                              <2> 
 18192                              <2> %include "SerialServer.inc"
 18193                              <3> ; Project name	:	XTIDE Universal BIOS
 18194                              <3> ; Description	:	Serial Server Defines
 18195                              <3> 
 18196                              <3> %ifndef SERIALSERVER_INC
 18197                              <3> %define SERIALSERVER_INC
 18198                              <3> 
 18199                              <3> %include "Serial.inc"
 18200                              <3> 
 18201                              <3> ;
 18202                              <3> ; Command codes
 18203                              <3> ;
 18204                              <3> SerialServer_Command_Header					EQU		0a0h
 18205                              <3> SerialServer_Command_Write					EQU		(SerialServer_Command_Header | 3)
 18206                              <3> SerialServer_Command_Read					EQU		(SerialServer_Command_Header | 2)
 18207                              <3> SerialServer_Command_Inquire				EQU		(SerialServer_Command_Header | 0)
 18208                              <3> SerialServer_Command_Custom_Read			EQU		(SerialServer_Command_Header | 4)
 18209                              <3> SerialServer_Command_Custom_Write			EQU		(SerialServer_Command_Header | 5)
 18210                              <3> 
 18211                              <3> SerialServer_SubCommand_Image_SendInitiate		EQU		1
 18212                              <3> SerialServer_SubCommand_Image_SendSectors		EQU		2
 18213                              <3> SerialServer_SubCommand_Image_SendComplete		EQU		3
 18214                              <3> 
 18215                              <3> ;
 18216                              <3> ; Locations within the ATA 512-byte Inquire structure, taken from the "Vendor specific area",
 18217                              <3> ; for serial port specific information that is returned by the server for an inquire.
 18218                              <3> ;
 18219                              <3> ; NOTE: These are byte offsets (because of the "*2"), which is more convenient here, while
 18220                              <3> ;       the ATA structure defines these in terms of word offsets.
 18221                              <3> ;
 18222                              <3> SerialServer_ATA_wServerVersion			EQU		(157*2)
 18223                              <3> SerialServer_ATA_wDriveFlags			EQU		(158*2)
 18224                              <3> SerialServer_ATA_wPortAndBaud			EQU		(159*2)
 18225                              <3> 
 18226                              <3> ;
 18227                              <3> ; Command structure passed to SerialServer_SendReceive.  This mirrors IDEPACK in the XTIDE Universal BIOS, 
 18228                              <3> ; since that structure is passed directly without copying values into this structure.
 18229                              <3> ;
 18230                              <3> struc SerialServer_Command
 18231                              <3> 	.wCommandAndCustom:	
 18232                              <3> 	.bCommand				resb	1
 18233                              <3> 
 18234                              <3> 	.bCustomCommand:	
 18235                              <3> 	.bDrvAndHead			resb	1	; LBA28 27...24
 18236                              <3> 
 18237                              <3> 	.wSectorCountAndLbaLow:
 18238                              <3> 	.bSectorCount			resb	1
 18239                              <3> 
 18240                              <3> 	.bCustomData3:		
 18241                              <3> 	.bSectorNumber:
 18242                              <3> 	.bLbaLow				resb	1	; LBA 7...0
 18243                              <3> 
 18244                              <3> 	.wCustomData1:		
 18245                              <3> 	.bCustomData1:		
 18246                              <3> 	.wCylinder:
 18247                              <3> 	.wLbaMiddleAndHigh:
 18248                              <3> 	.bLbaMiddle				resb	1	; LBA 15...8
 18249                              <3> 
 18250                              <3> 	.bCustomData2:		
 18251                              <3> 	.bLbaHigh				resb	1	; LBA 23...16
 18252                              <3> endstruc
 18253                              <3> 
 18254                              <3> %endif
 18255                              <3> 
 18256                              <2> 
 18257                              <2> ; Section containing code
 18258                              <2> SECTION .text
 18259                              <2> 
 18260                              <2> ;--------------------------------------------------------------------
 18261                              <2> ; SerialServerScan_ScanForServer:
 18262                              <2> ;	Parameters:
 18263                              <2> ;       BH:		Drive Select byte for Drive and Head Select Register
 18264                              <2> ;               0xAx: Scan for drive, low nibble indicates drive
 18265                              <2> ;               0x0:  Scan for Server, independent of drives
 18266                              <2> ;		DX:		Port and Baud to Scan for
 18267                              <2> ;				0: Scan a known set of ports and bauds
 18268                              <2> ;		ES:SI:	Ptr to buffer for return
 18269                              <2> ;	Returns:
 18270                              <2> ;		CF:		Cleared if success, Set if error
 18271                              <2> ;	Corrupts registers:
 18272                              <2> ;		AL, BX, CX, DX, DI
 18273                              <2> ;--------------------------------------------------------------------
 18274                              <2> SerialServerScan_ScanForServer:
 18275 000013CA B90100              <2> 		mov		cx, 1			; one sector, not scanning (default)
 18276                              <2> 
 18277 000013CD 85D2                <2> 		test	dx, dx
 18278 000013CF 7545                <2> 		jnz		short SerialServerScan_CheckForServer_PortAndBaudInDX
 18279                              <2> 
 18280 000013D1 BF[0D14]            <2> 		mov		di,.scanPortAddresses-1
 18281 000013D4 B501                <2> 		mov		ch,1			;  tell server that we are scanning
 18282                              <2> 
 18283                              <2> .nextPort:
 18284 000013D6 47                  <2> 		inc		di				; load next port address
 18285 000013D7 30F6                <2> 		xor		dh, dh
 18286 000013D9 2E8A15              <2> 		mov		dl,[cs:di]
 18287                              <2> 		eSHL_IM	dx, 2			; shift from one byte to two
 18288                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 18289                              <3> %ifdef USE_386
 18290                              <3>  %if %2 = 1
 18291                              <3>  add %1, %1
 18292                              <3>  %else
 18293                              <3>  eSHIFT_IM %1, %2, shl
 18294                              <3>  %endif
 18295                              <3> %else
 18296                              <3>  eSHIFT_IM %1, %2, shl
 18297                              <4> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 18298                              <4> %ifndef USE_186
 18299                              <4>  %ifidni %1, cl
 18300                              <4>  times %2 %3 %1, 1
 18301                              <4>  %elifidni %1, ch
 18302                              <4>  times %2 %3 %1, 1
 18303                              <4>  %elifidni %1, cx
 18304                              <4>  times %2 %3 %1, 1
 18305                              <4>  %else
 18306                              <4>  %if %2 > 3
 18307                              <4>  push cx
 18308                              <4>  mov cl, %2
 18309                              <4>  %3 %1, cl
 18310                              <4>  pop cx
 18311                              <4>  %else
 18312 000013DC D1E2<rept>          <4>  times %2 %3 %1, 1
 18313                              <4>  %endif
 18314                              <4>  %endif
 18315                              <4> 
 18316                              <4> %else
 18317                              <4>  %3 %1, %2
 18318                              <4> %endif
 18319                              <4> %endif
 18320                              <3> %endif
 18321                              <3> %endif
 18322 000013E0 F9                  <2> 		stc						; setup error code for exit
 18323 000013E1 742A                <2> 		jz		.error
 18324                              <2> 
 18325                              <2> ;
 18326                              <2> ; Test for COM port presence, write to and read from registers
 18327                              <2> ;
 18328 000013E3 52                  <2> 		push	dx
 18329 000013E4 80C203              <2> 		add		dl,Serial_UART_lineControl
 18330 000013E7 B09A                <2> 		mov		al, 09ah
 18331 000013E9 EE                  <2> 		out		dx, al
 18332 000013EA EC                  <2> 		in		al, dx
 18333 000013EB 5A                  <2> 		pop		dx
 18334 000013EC 3C9A                <2> 		cmp		al, 09ah
 18335 000013EE 75E6                <2> 		jnz		.nextPort
 18336                              <2> 
 18337 000013F0 B00C                <2> 		mov		al, 0ch
 18338 000013F2 EE                  <2> 		out		dx, al
 18339 000013F3 EC                  <2> 		in		al, dx
 18340 000013F4 3C0C                <2> 		cmp		al, 0ch
 18341 000013F6 75DE                <2> 		jnz		.nextPort
 18342                              <2> 
 18343                              <2> ;
 18344                              <2> ; Begin baud rate scan on this port...
 18345                              <2> ;
 18346                              <2> ; On a scan, we support 6 baud rates, starting here and going higher by a factor of two each step, with a
 18347                              <2> ; small jump between 9600 and 38800.  These 6 were selected since we wanted to support 9600 baud and 115200,
 18348                              <2> ; *on the server side* if the client side had a 4x clock multiplier, a 2x clock multiplier, or no clock multiplier.
 18349                              <2> ;
 18350                              <2> ; Starting with 30h, that means 30h (2400 baud), 18h (4800 baud), 0ch (9600 baud), and
 18351                              <2> ;					            04h (28800 baud), 02h (57600 baud), 01h (115200 baud)
 18352                              <2> ;
 18353                              <2> ; Note: hardware baud multipliers (2x, 4x) will impact the final baud rate and are not known at this level
 18354                              <2> ;
 18355 000013F8 B660                <2> 		mov		dh,030h * 2	    ; multiply by 2 since we are about to divide by 2
 18356 000013FA 2E8A15              <2> 		mov		dl,[cs:di]		; restore single byte port address for scan
 18357                              <2> 
 18358                              <2> .nextBaud:
 18359 000013FD D0EE                <2> 		shr		dh,1
 18360 000013FF 74D5                <2> 		jz		.nextPort
 18361 00001401 80FE06              <2> 		cmp		dh,6			; skip from 6 to 4, to move from the top of the 9600 baud range
 18362 00001404 7502                <2> 		jnz		.testBaud		; to the bottom of the 115200 baud range
 18363 00001406 B604                <2> 		mov		dh,4
 18364                              <2> 
 18365                              <2> .testBaud:
 18366 00001408 E80B00              <2> 		call	SerialServerScan_CheckForServer_PortAndBaudInDX
 18367 0000140B 72F0                <2> 		jc		.nextBaud
 18368                              <2> 
 18369                              <2> .error:
 18370 0000140D C3                  <2> 		ret
 18371                              <2> 
 18372 0000140E B8                  <2> .scanPortAddresses: db	SERIAL_COM7_IOADDRESS >> 2
 18373 0000140F F8                  <2> 					db	SERIAL_COM6_IOADDRESS >> 2
 18374 00001410 BC                  <2> 					db	SERIAL_COM5_IOADDRESS >> 2
 18375 00001411 BA                  <2> 					db	SERIAL_COM4_IOADDRESS >> 2
 18376 00001412 FA                  <2> 					db	SERIAL_COM3_IOADDRESS >> 2
 18377 00001413 BE                  <2> 					db	SERIAL_COM2_IOADDRESS >> 2
 18378 00001414 FE                  <2> 					db	SERIAL_COM1_IOADDRESS >> 2
 18379 00001415 00                  <2> 					db	0
 18380                              <2> 
 18381                              <2> 
 18382                              <2> ;--------------------------------------------------------------------
 18383                              <2> ; SerialServer_CheckForServer_PortAndBaudInDX:
 18384                              <2> ;	Parameters:
 18385                              <2> ;       BH:		Drive Select byte for Drive and Head Select Register
 18386                              <2> ;               0xAx: Scan for drive, low nibble indicates drive
 18387                              <2> ;               0x0:  Scan for Server, independent of drives
 18388                              <2> ;		DX:		Baud and Port
 18389                              <2> ;		CH:		1: We are doing a scan for the serial server
 18390                              <2> ;               0: We are working off a specific port given by the user
 18391                              <2> ;		CL:		1, for one sector to read
 18392                              <2> ;		ES:SI:	Ptr to buffer for return
 18393                              <2> ;	Returns:
 18394                              <2> ;		AH:		INT 13h Error Code
 18395                              <2> ;		CF:		Cleared if success, Set if error
 18396                              <2> ;	Corrupts registers:
 18397                              <2> ;		AL, BX
 18398                              <2> ;--------------------------------------------------------------------
 18399                              <2> SerialServerScan_CheckForServer_PortAndBaudInDX:
 18400 00001416 55                  <2> 		push	bp				; setup fake SerialServer_Command
 18401                              <2> 
 18402 00001417 52                  <2> 		push	dx				; send port baud and rate, returned in inquire packet
 18403                              <2> 								; (and possibly returned in the drive identification string)
 18404                              <2> 
 18405 00001418 51                  <2> 		push	cx				; send number of sectors, and if it is on a scan or not
 18406                              <2> 
 18407 00001419 B3A0                <2> 		mov		bl,SerialServer_Command_Inquire			; protocol command onto stack with bh
 18408 0000141B 53                  <2> 		push	bx
 18409                              <2> 
 18410 0000141C 89E5                <2> 		mov		bp,sp
 18411                              <2> 
 18412 0000141E E84EFE              <2> 		call	SerialServer_SendReceive
 18413                              <2> 
 18414 00001421 5B                  <2> 		pop		bx
 18415 00001422 59                  <2> 		pop		cx
 18416 00001423 5A                  <2> 		pop		dx
 18417 00001424 5D                  <2> 		pop		bp
 18418                              <2> 
 18419 00001425 C3                  <2> 		ret
 18420                              <2> 
 18421                              <1> 
 18422                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 18423                              <1> 	%if SerialCommand_FallThroughToSerialServerScan_ScanForServer <> SerialServerScan_ScanForServer
 18424                              <1> 		%error "SerialServerScan_ScanForServer must be the first routine at the top of SerialServerScan.asm in the Assembly_Library"
 18425                              <1> 	%endif
 18426                              <1> %endif
 18427                              <1> 
 18428                              <1> 
 18429                                  	%include "SerialDPT.asm"
 18430                              <1> ; Project name	:	XTIDE Universal BIOS
 18431                              <1> ; Description	:	Sets Serial Device specific parameters to DPT.
 18432                              <1> 
 18433                              <1> ;
 18434                              <1> ; XTIDE Universal BIOS and Associated Tools
 18435                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 18436                              <1> ;
 18437                              <1> ; This program is free software; you can redistribute it and/or modify
 18438                              <1> ; it under the terms of the GNU General Public License as published by
 18439                              <1> ; the Free Software Foundation; either version 2 of the License, or
 18440                              <1> ; (at your option) any later version.
 18441                              <1> ;
 18442                              <1> ; This program is distributed in the hope that it will be useful,
 18443                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 18444                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 18445                              <1> ; GNU General Public License for more details.
 18446                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 18447                              <1> ;
 18448                              <1> 
 18449                              <1> ; Section containing code
 18450                              <1> SECTION .text
 18451                              <1> 
 18452                              <1> ;--------------------------------------------------------------------
 18453                              <1> ; SerialDPT_Finalize
 18454                              <1> ;	Parameters:
 18455                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 18456                              <1> ;		ES:SI:	Ptr to 512-byte ATA information read from the drive
 18457                              <1> ;	Returns:
 18458                              <1> ;		CF:		Set, indicates that this is a floppy disk
 18459                              <1> ;               Clear, indicates that this is a hard disk
 18460                              <1> ;	Corrupts registers:
 18461                              <1> ;		AX
 18462                              <1> ;--------------------------------------------------------------------
 18463                              <1> SerialDPT_Finalize:
 18464 00001426 268B843E01          <1> 		mov		ax, [es:si+SerialServer_ATA_wPortAndBaud]
 18465 0000142B 894514              <1> 		mov		[di+DPT_SERIAL.wSerialPortAndBaud], ax
 18466                              <1> 
 18467                              <1> ;
 18468                              <1> ; Note that this section is not under %ifdef MODULE_SERIAL_FLOPPY.  It is important to
 18469                              <1> ; distinguish floppy disks presented by the server and not treat them as hard disks, even
 18470                              <1> ; if the floppy support is disabled.
 18471                              <1> ;
 18472 0000142E 268A843C01          <1> 		mov		al, [es:si+SerialServer_ATA_wDriveFlags]
 18473                              <1> 		eSHL_IM	al, 1
 18474                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 18475                              <2> %ifdef USE_386
 18476                              <2>  %if %2 = 1
 18477                              <2>  add %1, %1
 18478                              <2>  %else
 18479                              <2>  eSHIFT_IM %1, %2, shl
 18480                              <2>  %endif
 18481                              <2> %else
 18482                              <2>  eSHIFT_IM %1, %2, shl
 18483                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 18484                              <3> %ifndef USE_186
 18485                              <3>  %ifidni %1, cl
 18486                              <3>  times %2 %3 %1, 1
 18487                              <3>  %elifidni %1, ch
 18488                              <3>  times %2 %3 %1, 1
 18489                              <3>  %elifidni %1, cx
 18490                              <3>  times %2 %3 %1, 1
 18491                              <3>  %else
 18492                              <3>  %if %2 > 3
 18493                              <3>  push cx
 18494                              <3>  mov cl, %2
 18495                              <3>  %3 %1, cl
 18496                              <3>  pop cx
 18497                              <3>  %else
 18498 00001433 D0E0                <3>  times %2 %3 %1, 1
 18499                              <3>  %endif
 18500                              <3>  %endif
 18501                              <3> 
 18502                              <3> %else
 18503                              <3>  %3 %1, %2
 18504                              <3> %endif
 18505                              <3> %endif
 18506                              <2> %endif
 18507                              <2> %endif
 18508 00001435 884501              <1> 		mov		byte [di+DPT.bFlagsHigh], al
 18509                              <1> 
 18510 00001438 C3                  <1> 		ret
 18511                              <1> 
 18512                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 18513                              <1> 	%if FLGH_DPT_SERIAL_DEVICE != 0x4 || FLGH_DPT_SERIAL_FLOPPY != 0x10 || FLGH_DPT_SERIAL_FLOPPY_TYPE_MASK != 0xe0 || FLGH_DPT_SERIAL_FLOPPY_TYPE_FIELD_POSITION != 5
 18514                              <1> 		%error "The serial server passes FLGH values into SerialDPT_Finalize directly.  If the flag positions are changed, corresponding changes will need to be made in the serial server, and likely a version check put in
 18515                              <1> 	%endif
 18516                              <1> %endif
 18517                                  %endif
 18518                                  
 18519                                  	; INT 13h Hard Disk BIOS functions
 18520                                  	%include "Int13h.asm"			; For Int 13h, Disk functions
 18521                              <1> ; Project name	:	XTIDE Universal BIOS
 18522                              <1> ; Description	:	Int 13h BIOS functions (Floppy and Hard disk).
 18523                              <1> 
 18524                              <1> ;
 18525                              <1> ; XTIDE Universal BIOS and Associated Tools
 18526                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 18527                              <1> ;
 18528                              <1> ; This program is free software; you can redistribute it and/or modify
 18529                              <1> ; it under the terms of the GNU General Public License as published by
 18530                              <1> ; the Free Software Foundation; either version 2 of the License, or
 18531                              <1> ; (at your option) any later version.
 18532                              <1> ;
 18533                              <1> ; This program is distributed in the hope that it will be useful,
 18534                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 18535                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 18536                              <1> ; GNU General Public License for more details.
 18537                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 18538                              <1> ;
 18539                              <1> 
 18540                              <1> ; Section containing code
 18541                              <1> SECTION .text
 18542                              <1> 
 18543                              <1> ;--------------------------------------------------------------------
 18544                              <1> ; Int 13h software interrupt handler.
 18545                              <1> ; This handler changes stack to top of stolen conventional memory
 18546                              <1> ; and then calls the actual INT 13h handler (Int13h_DiskFunctionsHandler).
 18547                              <1> ;
 18548                              <1> ; Int13h_DiskFunctionsHandlerWithStackChange
 18549                              <1> ;	Parameters:
 18550                              <1> ;		AH:		Bios function
 18551                              <1> ;		DL:		Drive number
 18552                              <1> ;		Other:	Depends on function
 18553                              <1> ;	Returns:
 18554                              <1> ;		Depends on function
 18555                              <1> ;--------------------------------------------------------------------
 18556                              <1> %ifdef RELOCATE_INT13H_STACK
 18557                              <1> ALIGN JUMP_ALIGN
 18558                              <1> Int13h_DiskFunctionsHandlerWithStackChange:
 18559                              <1> 	sti			; Enable interrupts
 18560                              <1> 	; TODO: Maybe we need to save Flags (DF) as well?
 18561                              <1> 	push	ds	; Save DS:DI on the original stack
 18562                              <1> 	push	di
 18563                              <1> 	call	RamVars_GetSegmentToDS
 18564                              <1> 
 18565                              <1> 	; Store entry registers to RAMVARS
 18566                              <1> %ifdef USE_386
 18567                              <1> 	pop		DWORD [RAMVARS.dwStackChangeDSDI]
 18568                              <1> %else
 18569                              <1> 	pop		WORD [RAMVARS.wStackChangeDI]	; Pop DS:DI to the top of what
 18570                              <1> 	pop		WORD [RAMVARS.wStackChangeDS]	; is to become the new stack
 18571                              <1> %endif
 18572                              <1> 	mov		[RAMVARS.fpInt13hEntryStack], sp
 18573                              <1> 	mov		[RAMVARS.fpInt13hEntryStack+2], ss
 18574                              <1> 
 18575                              <1> 	; Load new stack and restore DS and DI
 18576                              <1> 	mov		di, ds		; We can save 2 bytes by using PUSH/POP but it's slower
 18577                              <1> 	mov		ss, di		; No need to wrap with CLI/STI since this is for AT only (286+)
 18578                              <1> 	mov		sp, RAMVARS.rgbTopOfStack-4
 18579                              <1> 	pop		di			; DI before stack change
 18580                              <1> 	pop		ds			; DS before stack change
 18581                              <1> 
 18582                              <1> 	; Call INT 13h
 18583                              <1> 	pushf
 18584                              <1> 	push	cs
 18585                              <1> 	call	Int13h_DiskFunctionsHandler
 18586                              <1> 
 18587                              <1> 	; Restore stack (we must not corrupt FLAGS!)
 18588                              <1> %ifdef USE_386
 18589                              <1> 	lss		sp, [ss:RAMVARS.fpInt13hEntryStack]
 18590                              <1> %else
 18591                              <1> 	cli
 18592                              <1> 	mov		sp, [ss:RAMVARS.fpInt13hEntryStack]
 18593                              <1> 	mov		ss, [ss:RAMVARS.fpInt13hEntryStack+2]
 18594                              <1> 	sti
 18595                              <1> %endif
 18596                              <1> 	retf	2			; Skip FLAGS from stack
 18597                              <1> %endif ; RELOCATE_INT13H_STACK
 18598                              <1> 
 18599                              <1> 
 18600                              <1> ;--------------------------------------------------------------------
 18601                              <1> ; Int 13h software interrupt handler.
 18602                              <1> ; Jumps to specific function defined in AH.
 18603                              <1> ;
 18604                              <1> ; Note to developers: Do not make recursive INT 13h calls!
 18605                              <1> ;
 18606                              <1> ; Int13h_DiskFunctionsHandler
 18607                              <1> ;	Parameters:
 18608                              <1> ;		AH:		Bios function
 18609                              <1> ;		DL:		Drive number
 18610                              <1> ;		Other:	Depends on function
 18611                              <1> ;	Returns:
 18612                              <1> ;		Depends on function
 18613                              <1> ;--------------------------------------------------------------------
 18614                              <1> ALIGN JUMP_ALIGN
 18615                              <1> Int13h_DiskFunctionsHandler:
 18616                              <1> %ifndef RELOCATE_INT13H_STACK
 18617 00001439 FB                  <1> 	sti									; Enable interrupts
 18618                              <1> %endif
 18619 0000143A FC                  <1> 	cld									; String instructions to increment pointers
 18620                              <1> 	CREATE_FRAME_INTPACK_TO_SSBP	SIZE_OF_IDEPACK_WITHOUT_INTPACK
 18621                              <2>  ePUSHA
 18622                              <3> %ifndef USE_186
 18623 0000143B 50                  <3>  push ax
 18624 0000143C 51                  <3>  push cx
 18625 0000143D 52                  <3>  push dx
 18626 0000143E 53                  <3>  push bx
 18627 0000143F 54                  <3>  push sp
 18628 00001440 55                  <3>  push bp
 18629 00001441 56                  <3>  push si
 18630 00001442 57                  <3>  push di
 18631                              <3> 
 18632                              <3> %else
 18633                              <3>  pusha
 18634                              <3> %endif
 18635 00001443 1E                  <2>  push ds
 18636 00001444 06                  <2>  push es
 18637                              <2> %ifdef USE_386
 18638                              <2> 
 18639                              <2> 
 18640                              <2> %endif
 18641 00001445 83EC0C              <2>  sub sp, BYTE %1
 18642 00001448 89E5                <2>  mov bp, sp
 18643 0000144A E890F0              <1> 	call	RamVars_GetSegmentToDS
 18644                              <1> 
 18645                              <1> %ifdef MODULE_DRIVEXLATE
 18646 0000144D E880F6              <1> 	call	DriveXlate_ToOrBack
 18647 00001450 88160B00            <1> 	mov		[RAMVARS.xlateVars+XLATEVARS.bXlatedDrv], dl
 18648                              <1> %endif
 18649 00001454 E8E7F1              <1> 	call	FindDPT_ForDriveNumberInDL	; DS:DI points to our DPT, or NULL if not our drive
 18650 00001457 7224                <1> 	jc		SHORT .NotOurDrive			; DPT not found so this is not one of our drives
 18651                              <1> 
 18652                              <1> .OurFunction:
 18653                              <1> 	; Jump to correct BIOS function
 18654                              <1> 	eMOVZX	bx, ah
 18655                              <2> %ifndef USE_386
 18656                              <2>  %ifidni %1, ax
 18657                              <2>  mov al, %2
 18658                              <2>  xor ah, ah
 18659                              <2>  %elifidni %1, bx
 18660 00001459 88E3                <2>  mov bl, %2
 18661 0000145B 30FF                <2>  xor bh, bh
 18662                              <2>  %elifidni %1, cx
 18663                              <2>  mov cl, %2
 18664                              <2>  xor ch, ch
 18665                              <2>  %elifidni %1, dx
 18666                              <2>  mov dl, %2
 18667                              <2>  xor dh, dh
 18668                              <2>  %else
 18669                              <2>  push ax
 18670                              <2>  mov al, %2
 18671                              <2>  xor ah, ah
 18672                              <2>  xchg ax, %1
 18673                              <2>  pop ax
 18674                              <2>  %endif
 18675                              <2> 
 18676                              <2> %else
 18677                              <2>  movzx %1, %2
 18678                              <2> %endif
 18679                              <1> 	eSHL_IM	bx, 1
 18680                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 18681                              <2> %ifdef USE_386
 18682                              <2>  %if %2 = 1
 18683                              <2>  add %1, %1
 18684                              <2>  %else
 18685                              <2>  eSHIFT_IM %1, %2, shl
 18686                              <2>  %endif
 18687                              <2> %else
 18688                              <2>  eSHIFT_IM %1, %2, shl
 18689                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 18690                              <3> %ifndef USE_186
 18691                              <3>  %ifidni %1, cl
 18692                              <3>  times %2 %3 %1, 1
 18693                              <3>  %elifidni %1, ch
 18694                              <3>  times %2 %3 %1, 1
 18695                              <3>  %elifidni %1, cx
 18696                              <3>  times %2 %3 %1, 1
 18697                              <3>  %else
 18698                              <3>  %if %2 > 3
 18699                              <3>  push cx
 18700                              <3>  mov cl, %2
 18701                              <3>  %3 %1, cl
 18702                              <3>  pop cx
 18703                              <3>  %else
 18704 0000145D D1E3                <3>  times %2 %3 %1, 1
 18705                              <3>  %endif
 18706                              <3>  %endif
 18707                              <3> 
 18708                              <3> %else
 18709                              <3>  %3 %1, %2
 18710                              <3> %endif
 18711                              <3> %endif
 18712                              <2> %endif
 18713                              <2> %endif
 18714 0000145F 80FC25              <1> 	cmp		ah, 25h						; Possible EBIOS function?
 18715                              <1> %ifndef MODULE_EBIOS
 18716                              <1> 	ja		SHORT UnsupportedFunction
 18717                              <1> 	jmp		[cs:bx+g_rgw13hFuncJump]	; Jump to BIOS function
 18718                              <1> 
 18719                              <1> %else ; If using MODULE_EBIOS
 18720 00001462 7705                <1> 	ja		SHORT .JumpToEbiosFunction
 18721 00001464 2EFFA7[3A15]        <1> 	jmp		[cs:bx+g_rgw13hFuncJump]	; Jump to BIOS function
 18722                              <1> 
 18723                              <1> ALIGN JUMP_ALIGN
 18724                              <1> .JumpToEbiosFunction:
 18725 00001469 F60540              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_LBA_AND_EBIOS_SUPPORTED
 18726 0000146C 7418                <1> 	jz		SHORT UnsupportedFunction	; No eINT 13h for CHS drives
 18727 0000146E 80EB82              <1> 	sub		bl, 41h<<1					; BX = Offset to eINT 13h jump table
 18728 00001471 7213                <1> 	jb		SHORT UnsupportedFunction
 18729 00001473 80FC48              <1> 	cmp		ah, 48h
 18730 00001476 770E                <1> 	ja		SHORT UnsupportedFunction
 18731 00001478 2EFFA7[8615]        <1> 	jmp		[cs:bx+g_rgwEbiosFunctionJumpTable]
 18732                              <1> %endif	; MODULE_EBIOS
 18733                              <1> 
 18734                              <1> 
 18735                              <1> ALIGN JUMP_ALIGN
 18736                              <1> .NotOurDrive:
 18737 0000147D 84E4                <1> 	test	ah, ah
 18738 0000147F 74D8                <1> 	jz		SHORT .OurFunction			; We handle all function 0h requests (resets)
 18739                              <1> 
 18740                              <1> %ifndef MODULE_SERIAL_FLOPPY
 18741                              <1> ; Without floppy support, we handle only hard disk traffic for function 08h.
 18742                              <1> 	test	dl, dl
 18743                              <1> 	jns		SHORT Int13h_DirectCallToAnotherBios
 18744                              <1> %endif
 18745                              <1> ; With floppy support, we handle all traffic for function 08h, as we need to wrap both hard disk and floppy drive counts.
 18746 00001481 80FC08              <1> 	cmp		ah, 8
 18747 00001484 74D3                <1> 	je		SHORT .OurFunction
 18748                              <1> 	; Fall to Int13h_DirectCallToAnotherBios
 18749                              <1> 
 18750                              <1> 
 18751                              <1> ;--------------------------------------------------------------------
 18752                              <1> ; UnsupportedFunction
 18753                              <1> ; Int13h_DirectCallToAnotherBios
 18754                              <1> ;	Parameters:
 18755                              <1> ;		DL:		Translated drive number
 18756                              <1> ;		DS:		RAMVARS segment
 18757                              <1> ;		SS:BP:	Ptr to IDEPACK
 18758                              <1> ;		BX, DI:	Corrupted on Int13h_DiskFunctionsHandler
 18759                              <1> ;		Other:	Function specific INT 13h parameters
 18760                              <1> ;	Returns:
 18761                              <1> ;		Depends on function
 18762                              <1> ;	Corrupts registers:
 18763                              <1> ;		Flags
 18764                              <1> ;--------------------------------------------------------------------
 18765                              <1> ALIGN JUMP_ALIGN
 18766                              <1> UnsupportedFunction:
 18767                              <1> Int13h_DirectCallToAnotherBios:
 18768 00001486 E86B00              <1> 	call	ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 18769 00001489 8B5E18              <1> 	mov		bx, [bp+IDEPACK.intpack+INTPACK.bx]
 18770 0000148C 8B7E10              <1> 	mov		di, [bp+IDEPACK.intpack+INTPACK.di]
 18771 0000148F 8E5E0E              <1> 	mov		ds, [bp+IDEPACK.intpack+INTPACK.ds]
 18772 00001492 FF7624              <1> 	push	WORD [bp+IDEPACK.intpack+INTPACK.flags]
 18773 00001495 9D                  <1> 	popf
 18774 00001496 55                  <1> 	push	bp
 18775 00001497 8B6E14              <1> 	mov		bp, [bp+IDEPACK.intpack+INTPACK.bp]
 18776 0000149A CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h	; Can safely do as much recursion as it wants
 18777                              <1> 
 18778                              <1> 	; Store returned values to INTPACK
 18779 0000149C 5D                  <1> 	pop		bp	; Standard INT 13h functions never uses BP as return register
 18780                              <1> %ifdef USE_386
 18781                              <1> ;	mov		[bp+IDEPACK.intpack+INTPACK.gs], gs
 18782                              <1> ;	mov		[bp+IDEPACK.intpack+INTPACK.fs], fs
 18783                              <1> %endif
 18784 0000149D 8C460C              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.es], es
 18785 000014A0 8C5E0E              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ds], ds
 18786 000014A3 897E10              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.di], di
 18787 000014A6 897612              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.si], si
 18788 000014A9 895E18              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.bx], bx
 18789                              <1> %ifdef MODULE_DRIVEXLATE
 18790 000014AC 88761B              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dh], dh
 18791                              <1> %else
 18792                              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dx], dx
 18793                              <1> %endif
 18794 000014AF 894E1C              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.cx], cx
 18795 000014B2 89461E              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ax], ax
 18796 000014B5 9C                  <1> 	pushf
 18797 000014B6 8F4624              <1> 	pop		WORD [bp+IDEPACK.intpack+INTPACK.flags]
 18798 000014B9 E821F0              <1> 	call	RamVars_GetSegmentToDS
 18799                              <1> 
 18800                              <1> %ifdef MODULE_DRIVEXLATE
 18801 000014BC 3A160B00            <1> 	cmp		dl, [RAMVARS.xlateVars+XLATEVARS.bXlatedDrv]	; DL is still drive number?
 18802 000014C0 7403                <1> 	je		SHORT .ExchangeInt13hHandlers
 18803 000014C2 88561A              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dl], dl	; Something is returned in DL
 18804                              <1> ALIGN JUMP_ALIGN
 18805                              <1> .ExchangeInt13hHandlers:
 18806                              <1> %endif
 18807                              <1> 
 18808                              <1> %ifdef USE_186
 18809                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 18810                              <1> 	jmp		SHORT ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 18811                              <1> %else
 18812 000014C5 E82C00              <1> 	call	ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 18813 000014C8 EB0B                <1> 	jmp		SHORT Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 18814                              <1> %endif
 18815                              <1> 
 18816                              <1> 
 18817                              <1> %ifdef MODULE_SERIAL_FLOPPY
 18818                              <1> ;--------------------------------------------------------------------
 18819                              <1> ; Int13h_ReturnSuccessForFloppy
 18820                              <1> ;
 18821                              <1> ; Some operations, such as format of a floppy disk track, should just
 18822                              <1> ; return success, while for hard disks it should be treated as unsupported.
 18823                              <1> ;--------------------------------------------------------------------
 18824                              <1> ALIGN JUMP_ALIGN
 18825                              <1> Int13h_ReturnSuccessForFloppy:
 18826 000014CA 84D2                <1> 	test	dl, dl
 18827 000014CC 78B8                <1> 	js		SHORT UnsupportedFunction
 18828 000014CE 30E4                <1> 	xor		ah, ah
 18829 000014D0 EB03                <1> 	jmp		SHORT Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 18830                              <1> %endif
 18831                              <1> 
 18832                              <1> 
 18833                              <1> ;--------------------------------------------------------------------
 18834                              <1> ; Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 18835                              <1> ;	Parameters:
 18836                              <1> ;		AH:		BIOS Error code
 18837                              <1> ;		CL:		Number of sectors actually transferred
 18838                              <1> ;		SS:BP:	Ptr to IDEPACK
 18839                              <1> ;	Returns:
 18840                              <1> ;		All registers are loaded from INTPACK
 18841                              <1> ;--------------------------------------------------------------------
 18842                              <1> ALIGN JUMP_ALIGN
 18843                              <1> Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL:
 18844 000014D2 884E1E              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.al], cl
 18845                              <1> 	; Fall to Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 18846                              <1> 
 18847                              <1> 
 18848                              <1> ;--------------------------------------------------------------------
 18849                              <1> ; Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 18850                              <1> ; Int13h_ReturnFromHandlerWithoutStoringErrorCode
 18851                              <1> ;	Parameters:
 18852                              <1> ;		AH:		BIOS Error code
 18853                              <1> ;		DS:		RAMVARS segment
 18854                              <1> ;		SS:BP:	Ptr to IDEPACK
 18855                              <1> ;	Returns:
 18856                              <1> ;		All registers are loaded from INTPACK
 18857                              <1> ;--------------------------------------------------------------------
 18858                              <1> ALIGN JUMP_ALIGN
 18859                              <1> Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH:
 18860                              <1> %ifdef MODULE_SERIAL_FLOPPY
 18861 000014D5 8A461A              <1> 	mov		al, [bp+IDEPACK.intpack+INTPACK.dl]
 18862                              <1> Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH_ALHasDriveNumber:
 18863 000014D8 E83F00              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH_ALHasDriveNumber
 18864                              <1> 
 18865                              <1> %else
 18866                              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH
 18867                              <1> %endif
 18868                              <1> 
 18869                              <1> Int13h_ReturnFromHandlerWithoutStoringErrorCode:
 18870                              <1> 	; Always return with interrupts enabled since there are programs that rely
 18871                              <1> 	; on INT 13h to enable interrupts.
 18872 000014DB 804E2502            <1> 	or		BYTE [bp+IDEPACK.intpack+INTPACK.flags+1], (FLG_FLAGS_IF>>8)
 18873 000014DF 89EC                <1> 	mov		sp, bp	; This makes possible to exit anytime, no matter what is on stack
 18874                              <1> 	RESTORE_FRAME_INTPACK_FROM_SSBP		SIZE_OF_IDEPACK_WITHOUT_INTPACK
 18875 000014E1 83C40C              <2>  add sp, BYTE %1
 18876                              <2> %ifdef USE_386
 18877                              <2> 
 18878                              <2> 
 18879                              <2> %endif
 18880 000014E4 07                  <2>  pop es
 18881 000014E5 1F                  <2>  pop ds
 18882                              <2>  ePOPA
 18883                              <3> %ifndef USE_186
 18884 000014E6 5F                  <3>  pop di
 18885 000014E7 5E                  <3>  pop si
 18886 000014E8 5D                  <3>  pop bp
 18887 000014E9 58                  <3>  pop ax
 18888 000014EA 5B                  <3>  pop bx
 18889 000014EB 5A                  <3>  pop dx
 18890 000014EC 59                  <3>  pop cx
 18891 000014ED 58                  <3>  pop ax
 18892                              <3> 
 18893                              <3> %else
 18894                              <3>  popa
 18895                              <3> %endif
 18896 000014EE CF                  <2>  iret
 18897                              <1> 
 18898                              <1> 
 18899                              <1> ;--------------------------------------------------------------------
 18900                              <1> ; Int13h_CallPreviousInt13hHandler
 18901                              <1> ;	Parameters:
 18902                              <1> ;		AH:		INT 13h function to call
 18903                              <1> ;		DL:		Drive number
 18904                              <1> ;		DS:		RAMVARS segment
 18905                              <1> ;	Returns:
 18906                              <1> ;		Depends on function
 18907                              <1> ;       NOTE: ES:DI needs to be returned from the previous interrupt
 18908                              <1> ;		      handler, for floppy DPT in function 08h
 18909                              <1> ;	Corrupts registers:
 18910                              <1> ;		None
 18911                              <1> ;--------------------------------------------------------------------
 18912                              <1> ALIGN JUMP_ALIGN
 18913                              <1> Int13h_CallPreviousInt13hHandler:
 18914 000014EF E80200              <1> 	call	ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 18915 000014F2 CD13                <1> 	int		BIOS_DISK_INTERRUPT_13h
 18916                              <1> ;;;  fall-through to ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 18917                              <1> 
 18918                              <1> ;--------------------------------------------------------------------
 18919                              <1> ; ExchangeCurrentInt13hHandlerWithOldInt13hHandler
 18920                              <1> ;	Parameters:
 18921                              <1> ;		DS:		RAMVARS segment
 18922                              <1> ;	Returns:
 18923                              <1> ;		Nothing
 18924                              <1> ;	Corrupts registers:
 18925                              <1> ;       Nothing
 18926                              <1> ;       Note: Flags are preserved
 18927                              <1> ;--------------------------------------------------------------------
 18928                              <1> ALIGN JUMP_ALIGN
 18929                              <1> ExchangeCurrentInt13hHandlerWithOldInt13hHandler:
 18930 000014F4 06                  <1> 	push	es
 18931 000014F5 56                  <1> 	push	si
 18932                              <1> 	LOAD_BDA_SEGMENT_PRESERVE_FLAGS_TO	es, si
 18933                              <2> %ifndef USE_186
 18934 000014F6 BE0000              <2>  mov %2, 0
 18935 000014F9 8EC6                <2>  mov %1, %2
 18936                              <2> %elifidn %3, !
 18937                              <2>  mov %2, 0
 18938                              <2>  mov %1, %2
 18939                              <2> %else
 18940                              <2>  push BYTE 0
 18941                              <2>  pop %1
 18942                              <2> %endif
 18943 000014FB 8B360000            <1> 	mov		si, [RAMVARS.fpOldI13h]
 18944 000014FF FA                  <1> 	cli
 18945 00001500 2687364C00          <1> 	xchg	si, [es:BIOS_DISK_INTERRUPT_13h*4]
 18946 00001505 89360000            <1> 	mov		[RAMVARS.fpOldI13h], si
 18947 00001509 8B360200            <1> 	mov		si, [RAMVARS.fpOldI13h+2]
 18948 0000150D 2687364E00          <1> 	xchg	si, [es:BIOS_DISK_INTERRUPT_13h*4+2]
 18949 00001512 FB                  <1> 	sti
 18950 00001513 89360200            <1> 	mov		[RAMVARS.fpOldI13h+2], si
 18951 00001517 5E                  <1> 	pop		si
 18952 00001518 07                  <1> 	pop		es
 18953 00001519 C3                  <1> 	ret
 18954                              <1> 
 18955                              <1> 
 18956                              <1> ;--------------------------------------------------------------------
 18957                              <1> ; Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH
 18958                              <1> ; Int13h_SetErrorCodeToIntpackInSSBPfromAH
 18959                              <1> ;	Parameters:
 18960                              <1> ;		AH:		BIOS error code (00h = no error)
 18961                              <1> ;		SS:BP:	Ptr to IDEPACK
 18962                              <1> ;	Returns:
 18963                              <1> ;		SS:BP:	Ptr to IDEPACK with error condition set
 18964                              <1> ;	Corrupts registers:
 18965                              <1> ;		DS, DI
 18966                              <1> ;--------------------------------------------------------------------
 18967                              <1> ALIGN JUMP_ALIGN
 18968                              <1> %ifdef MODULE_SERIAL_FLOPPY
 18969                              <1> Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH_ALHasDriveNumber:
 18970                              <1> 	; Store error code to BDA
 18971 0000151A BB7404              <1> 	mov		bx, BDA.bHDLastSt
 18972 0000151D 84C0                <1> 	test	al, al
 18973 0000151F 7802                <1> 	js		SHORT .HardDisk
 18974 00001521 B341                <1> 	mov		bl, BDA.bFDRetST & 0xff
 18975                              <1> .HardDisk:
 18976                              <1> 	LOAD_BDA_SEGMENT_TO	ds, di
 18977                              <2> %ifndef USE_186
 18978 00001523 31FF                <2>  xor %2, %2
 18979 00001525 8EDF                <2>  mov %1, %2
 18980                              <2> %elifidn %3, !
 18981                              <2>  xor %2, %2
 18982                              <2>  mov %1, %2
 18983                              <2> %else
 18984                              <2>  push BYTE 0
 18985                              <2>  pop %1
 18986                              <2> %endif
 18987 00001527 8827                <1> 	mov		[bx], ah
 18988                              <1> 	; Fall to Int13h_SetErrorCodeToIntpackInSSBPfromAH
 18989                              <1> 
 18990                              <1> %else
 18991                              <1> Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH:
 18992                              <1> 	; Store error code to BDA
 18993                              <1> 	LOAD_BDA_SEGMENT_TO	ds, di
 18994                              <1> 	mov		[BDA.bHDLastSt], ah
 18995                              <1> 	; Fall to Int13h_SetErrorCodeToIntpackInSSBPfromAH
 18996                              <1> %endif
 18997                              <1> 
 18998                              <1> 	; Store error code to INTPACK
 18999                              <1> Int13h_SetErrorCodeToIntpackInSSBPfromAH:
 19000 00001529 88661F              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ah], ah
 19001 0000152C 84E4                <1> 	test	ah, ah
 19002 0000152E 7505                <1> 	jnz		SHORT .SetCFtoIntpack
 19003 00001530 806624FE            <1> 	and		BYTE [bp+IDEPACK.intpack+INTPACK.flags], ~FLG_FLAGS_CF
 19004 00001534 C3                  <1> 	ret
 19005                              <1> .SetCFtoIntpack:
 19006 00001535 804E2401            <1> 	or		BYTE [bp+IDEPACK.intpack+INTPACK.flags], FLG_FLAGS_CF
 19007 00001539 C3                  <1> 	ret
 19008                              <1> 
 19009                              <1> 
 19010                              <1> ; Jump table for correct BIOS function
 19011                              <1> ALIGN WORD_ALIGN
 19012                              <1> g_rgw13hFuncJump:
 19013 0000153A [9615]              <1> 	dw	AH0h_HandlerForDiskControllerReset			; 00h, Disk Controller Reset (All)
 19014 0000153C [F415]              <1> 	dw	AH1h_HandlerForReadDiskStatus				; 01h, Read Disk Status (All)
 19015 0000153E [0C16]              <1> 	dw	AH2h_HandlerForReadDiskSectors				; 02h, Read Disk Sectors (All)
 19016 00001540 [2016]              <1> 	dw	AH3h_HandlerForWriteDiskSectors				; 03h, Write Disk Sectors (All)
 19017 00001542 [3416]              <1> 	dw	AH4h_HandlerForVerifyDiskSectors			; 04h, Verify Disk Sectors (All)
 19018                              <1> %ifdef MODULE_SERIAL_FLOPPY
 19019 00001544 [CA14]              <1> 	dw	Int13h_ReturnSuccessForFloppy				; 05h, Format Disk Track (XT, AT, EISA)
 19020                              <1> %else
 19021                              <1> 	dw	UnsupportedFunction							; 05h, Format Disk Track (XT, AT, EISA)
 19022                              <1> %endif
 19023 00001546 [8614]              <1> 	dw	UnsupportedFunction							; 06h, Format Disk Track with Bad Sectors (XT)
 19024 00001548 [8614]              <1> 	dw	UnsupportedFunction							; 07h, Format Multiple Cylinders (XT)
 19025 0000154A [4216]              <1> 	dw	AH8h_HandlerForReadDiskDriveParameters		; 08h, Read Disk Drive Parameters (All)
 19026 0000154C [A916]              <1> 	dw	AH9h_HandlerForInitializeDriveParameters	; 09h, Initialize Drive Parameters (All)
 19027 0000154E [8614]              <1> 	dw	UnsupportedFunction							; 0Ah, Read Disk Sectors with ECC (XT, AT, EISA)
 19028 00001550 [8614]              <1> 	dw	UnsupportedFunction							; 0Bh, Write Disk Sectors with ECC (XT, AT, EISA)
 19029 00001552 [8617]              <1> 	dw	AHCh_HandlerForSeek							; 0Ch, Seek (All)
 19030 00001554 [A916]              <1> 	dw	AH9h_HandlerForInitializeDriveParameters	; 0Dh, Alternate Disk Reset (All)
 19031 00001556 [8614]              <1> 	dw	UnsupportedFunction							; 0Eh, Read Sector Buffer (XT, PS/1), ESDI Undocumented Diagnostic (PS/2)
 19032 00001558 [8614]              <1> 	dw	UnsupportedFunction							; 0Fh, Write Sector Buffer (XT, PS/1), ESDI Undocumented Diagnostic (PS/2)
 19033 0000155A [9417]              <1> 	dw	AH10h_HandlerForCheckDriveReady				; 10h, Check Drive Ready (All)
 19034 0000155C [9A17]              <1> 	dw	AH11h_HandlerForRecalibrate					; 11h, Recalibrate (All)
 19035 0000155E [8614]              <1> 	dw	UnsupportedFunction							; 12h, Controller RAM Diagnostic (XT)
 19036 00001560 [8614]              <1> 	dw	UnsupportedFunction							; 13h, Drive Diagnostic (XT)
 19037 00001562 [8614]              <1> 	dw	UnsupportedFunction							; 14h, Controller Internal Diagnostic (All)
 19038 00001564 [A717]              <1> 	dw	AH15h_HandlerForReadDiskDriveSize			; 15h, Read Disk Drive Size (AT+)
 19039 00001566 [8614]              <1> 	dw	UnsupportedFunction							; 16h,
 19040 00001568 [8614]              <1> 	dw	UnsupportedFunction							; 17h,
 19041 0000156A [8614]              <1> 	dw	UnsupportedFunction							; 18h,
 19042 0000156C [8614]              <1> 	dw	UnsupportedFunction							; 19h, Park Heads (PS/2)
 19043 0000156E [8614]              <1> 	dw	UnsupportedFunction							; 1Ah, Format ESDI Drive (PS/2)
 19044 00001570 [8614]              <1> 	dw	UnsupportedFunction							; 1Bh, Get ESDI Manufacturing Header (PS/2)
 19045 00001572 [8614]              <1> 	dw	UnsupportedFunction							; 1Ch, ESDI Special Functions (PS/2)
 19046 00001574 [8614]              <1> 	dw	UnsupportedFunction							; 1Dh,
 19047                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 19048 00001576 [D417]              <1> 	dw	AH1Eh_HandlerForXTCFfeatures				; 1Eh, Lo-tech XT-CF features (XTIDE Universal BIOS)
 19049                              <1> %else
 19050                              <1> 	dw	UnsupportedFunction							; 1Eh,
 19051                              <1> %endif
 19052 00001578 [8614]              <1> 	dw	UnsupportedFunction							; 1Fh,
 19053 0000157A [8614]              <1> 	dw	UnsupportedFunction							; 20h,
 19054 0000157C [8614]              <1> 	dw	UnsupportedFunction							; 21h, Read Disk Sectors, Multiple Blocks (PS/1)
 19055 0000157E [8614]              <1> 	dw	UnsupportedFunction							; 22h, Write Disk Sectors, Multiple Blocks (PS/1)
 19056 00001580 [2418]              <1> 	dw	AH23h_HandlerForSetControllerFeatures		; 23h, Set Controller Features Register (PS/1)
 19057 00001582 [3B18]              <1> 	dw	AH24h_HandlerForSetMultipleBlocks			; 24h, Set Multiple Blocks (PS/1)
 19058 00001584 [6218]              <1> 	dw	AH25h_HandlerForGetDriveInformation			; 25h, Get Drive Information (PS/1)
 19059                              <1> 
 19060                              <1> %ifdef MODULE_EBIOS
 19061                              <1> g_rgwEbiosFunctionJumpTable:
 19062 00001586 [D119]              <1> 	dw	AH41h_HandlerForCheckIfExtensionsPresent	; 41h, Check if Extensions Present (EBIOS)*
 19063 00001588 [2119]              <1> 	dw	AH42h_HandlerForExtendedReadSectors			; 42h, Extended Read Sectors (EBIOS)*
 19064 0000158A [3B19]              <1> 	dw	AH43h_HandlerForExtendedWriteSectors		; 43h, Extended Write Sectors (EBIOS)*
 19065 0000158C [5119]              <1> 	dw	AH44h_HandlerForExtendedVerifySectors		; 44h, Extended Verify Sectors (EBIOS)*
 19066 0000158E [8614]              <1> 	dw	UnsupportedFunction							; 45h, Lock and Unlock Drive (EBIOS)***
 19067 00001590 [8614]              <1> 	dw	UnsupportedFunction							; 46h, Eject Media Request (EBIOS)***
 19068 00001592 [6119]              <1> 	dw	AH47h_HandlerForExtendedSeek				; 47h, Extended Seek (EBIOS)*
 19069 00001594 [7519]              <1> 	dw	AH48h_HandlerForGetExtendedDriveParameters	; 48h, Get Extended Drive Parameters (EBIOS)*
 19070                              <1> ;	dw	UnsupportedFunction							; 49h, Get Extended Disk Change Status (EBIOS)***
 19071                              <1> ;	dw	UnsupportedFunction							; 4Ah, Initiate Disk Emulation (Bootable CD-ROM)
 19072                              <1> ;	dw	UnsupportedFunction							; 4Bh, Terminate Disk Emulation (Bootable CD-ROM)
 19073                              <1> ;	dw	UnsupportedFunction							; 4Ch, Initiate Disk Emulation and Boot (Bootable CD-ROM)
 19074                              <1> ;	dw	UnsupportedFunction							; 4Dh, Return Boot Catalog (Bootable CD-ROM)
 19075                              <1> ;	dw	UnsupportedFunction							; 4Eh, Set Hardware Configuration (EBIOS)**
 19076                              <1> ;
 19077                              <1> ;   * = Enhanced Drive Access Support (minimum required EBIOS functions)
 19078                              <1> ;  ** = Enhanced Disk Drive (EDD) Support
 19079                              <1> ; *** = Drive Locking and Ejecting Support
 19080                              <1> %endif
 19081                                  	%include "AH0h_HReset.asm"		; Required by Int13h_Jump.asm
 19082                              <1> ; Project name	:	XTIDE Universal BIOS
 19083                              <1> ; Description	:	Int 13h function AH=0h, Disk Controller Reset.
 19084                              <1> 
 19085                              <1> ;
 19086                              <1> ; XTIDE Universal BIOS and Associated Tools
 19087                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 19088                              <1> ;
 19089                              <1> ; This program is free software; you can redistribute it and/or modify
 19090                              <1> ; it under the terms of the GNU General Public License as published by
 19091                              <1> ; the Free Software Foundation; either version 2 of the License, or
 19092                              <1> ; (at your option) any later version.
 19093                              <1> ;
 19094                              <1> ; This program is distributed in the hope that it will be useful,
 19095                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 19096                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 19097                              <1> ; GNU General Public License for more details.
 19098                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 19099                              <1> ;
 19100                              <1> 
 19101                              <1> ; Section containing code
 19102                              <1> SECTION .text
 19103                              <1> 
 19104                              <1> ;--------------------------------------------------------------------
 19105                              <1> ; Int 13h function AH=0h, Disk Controller Reset.
 19106                              <1> ;
 19107                              <1> ; Note: We handle all AH=0h calls, even for drives handled by other
 19108                              <1> ; BIOSes!
 19109                              <1> ;
 19110                              <1> ; AH0h_HandlerForDiskControllerReset
 19111                              <1> ;	Parameters:
 19112                              <1> ;		DL:		Translated Drive number (ignored so all drives are reset)
 19113                              <1> ;				If bit 7 is set all hard disks and floppy disks reset.
 19114                              <1> ;		DS:DI:	Ptr to DPT (or Null if foreign drive)
 19115                              <1> ;		SS:BP:	Ptr to IDEPACK
 19116                              <1> ;	Returns with INTPACK:
 19117                              <1> ;		AH:		Int 13h return status (from drive requested in DL)
 19118                              <1> ;		CF:		0 if successful, 1 if error
 19119                              <1> ;--------------------------------------------------------------------
 19120                              <1> AH0h_HandlerForDiskControllerReset:
 19121                              <1> 	; Reset foreign Floppy and Hard Drives (those handled by other BIOSes)
 19122                              <1> 	eMOVZX	bx, dl										; Copy requested drive to BL and zero BH to assume no errors
 19123                              <2> %ifndef USE_386
 19124                              <2>  %ifidni %1, ax
 19125                              <2>  mov al, %2
 19126                              <2>  xor ah, ah
 19127                              <2>  %elifidni %1, bx
 19128 00001596 88D3                <2>  mov bl, %2
 19129 00001598 30FF                <2>  xor bh, bh
 19130                              <2>  %elifidni %1, cx
 19131                              <2>  mov cl, %2
 19132                              <2>  xor ch, ch
 19133                              <2>  %elifidni %1, dx
 19134                              <2>  mov dl, %2
 19135                              <2>  xor dh, dh
 19136                              <2>  %else
 19137                              <2>  push ax
 19138                              <2>  mov al, %2
 19139                              <2>  xor ah, ah
 19140                              <2>  xchg ax, %1
 19141                              <2>  pop ax
 19142                              <2>  %endif
 19143                              <2> 
 19144                              <2> %else
 19145                              <2>  movzx %1, %2
 19146                              <2> %endif
 19147                              <1> 
 19148 0000159A 30E4                <1> 	xor		ah, ah										; Disk Controller Reset
 19149 0000159C E850FF              <1> 	call	Int13h_CallPreviousInt13hHandler			; Reset floppy drives only or floppy drives and foreign hard disks
 19150 0000159F E81B00              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH
 19151                              <1> 
 19152                              <1> %ifdef MODULE_SERIAL_FLOPPY
 19153                              <1> ;
 19154                              <1> ; "Reset" emulated serial floppy drives, if any.  There is nothing to actually do for this reset,
 19155                              <1> ; but record the proper error return code if one of these floppy drives is the drive requested.
 19156                              <1> ;
 19157 000015A2 E873EF              <1> 	call	RamVars_UnpackFlopCntAndFirstToAL
 19158 000015A5 98                  <1> 	cbw													; Clears AH (there are flop drives) or ffh (there are not)
 19159                              <1> 														; Either AH has success code (flop drives are present)
 19160                              <1> 														; or it doesn't matter because we won't match drive ffh
 19161                              <1> 
 19162 000015A6 99                  <1> 	cwd													; clears DX (there are flop drives) or ffffh (there are not)
 19163                              <1> 
 19164 000015A7 10C2                <1> 	adc		dl, al										; second drive (CF set) if present
 19165                              <1> 														; If no drive is present, this will result in ffh which
 19166                              <1> 														; won't match a drive
 19167 000015A9 E81100              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH
 19168 000015AC 88C2                <1> 	mov		dl, al										; We may end up doing the first drive twice (if there is
 19169 000015AE E80C00              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH	; only one drive), but doing it again is not harmful.
 19170                              <1> %endif
 19171 000015B1 84DB                <1> 	test	bl, bl										; If we were called with a floppy disk, then we are done,
 19172 000015B3 7903                <1> 	jns		SHORT .SkipHardDiskReset					; don't do hard disks.
 19173                              <1> 
 19174                              <1> 	; Resetting our hard disks will modify dl and bl to be idevars offset based instead of drive number based,
 19175                              <1> 	; such that this call must be the last in the list of reset routines called.
 19176                              <1> 	;
 19177                              <1> 	; This needs to happen after ResetForeignDrives, as that call may have set the error code for 80h,
 19178                              <1> 	; and we need to override that value if we are xlate'd into 80h with one of our drives.
 19179                              <1> 	;
 19180 000015B5 E80C00              <1> 	call	ResetHardDisksHandledByOurBIOS
 19181                              <1> 
 19182                              <1> .SkipHardDiskReset:
 19183 000015B8 88FC                <1> 	mov		ah, bh
 19184 000015BA E918FF              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 19185                              <1> 
 19186                              <1> 
 19187                              <1> ;--------------------------------------------------------------------
 19188                              <1> ; BackupErrorCodeFromTheRequestedDriveToBH
 19189                              <1> ;	Parameters:
 19190                              <1> ;		AH:		Error code from the last resetted drive
 19191                              <1> ;		DL:		Drive last resetted
 19192                              <1> ;		BL:		Requested drive (DL when entering AH=00h)
 19193                              <1> ;	Returns:
 19194                              <1> ;		BH:		Backuped error code
 19195                              <1> ;	Corrupts registers:
 19196                              <1> ;		Nothing
 19197                              <1> ;--------------------------------------------------------------------
 19198                              <1> BackupErrorCodeFromTheRequestedDriveToBH:
 19199 000015BD 38DA                <1> 	cmp		dl, bl				; Requested drive?
 19200                              <1> 	eCMOVE	bh, ah
 19201                              <2>  eCMOVZ %1, %2
 19202 000015BF 7502                <3>  jnz SHORT %%Return
 19203 000015C1 88E7                <3>  mov %1, %2
 19204                              <3> %%Return:
 19205 000015C3 C3                  <1> 	ret
 19206                              <1> 
 19207                              <1> 
 19208                              <1> 
 19209                              <1> ; This defines what is called when resetting our drives at the end of drive detection.
 19210                              <1> AH0h_ResetAllOurHardDisksAtTheEndOfDriveInitialization equ ResetHardDisksHandledByOurBIOS.ErrorCodeNotUsed
 19211                              <1> 
 19212                              <1> ;--------------------------------------------------------------------
 19213                              <1> ; ResetHardDisksHandledByOurBIOS
 19214                              <1> ;	Parameters:
 19215                              <1> ;		BL:		Requested drive (DL when entering AH=00h)
 19216                              <1> ;		DS:DI:	Ptr to DPT for requested drive
 19217                              <1> ;				If DPT pointer is not available, or error result in BH won't be used anyway,
 19218                              <1> ;				enter through .ErrorCodeNotUsed.
 19219                              <1> ;		SS:BP:	Ptr to IDEPACK
 19220                              <1> ;	Returns:
 19221                              <1> ;		BH:		Error code from requested drive (if available)
 19222                              <1> ;	Corrupts registers:
 19223                              <1> ;		AX, BX, CX, DX, SI, DI
 19224                              <1> ;--------------------------------------------------------------------
 19225                              <1> ResetHardDisksHandledByOurBIOS:
 19226 000015C4 30DB                <1> 	xor		bl, bl										; Assume Null IdevarsOffset for now, assuming foreign drive
 19227 000015C6 85FF                <1> 	test	di, di
 19228 000015C8 7403                <1> 	jz		SHORT .ErrorCodeNotUsed
 19229 000015CA 8A5D02              <1> 	mov		bl, [di+DPT.bIdevarsOffset]					; replace drive number with Idevars pointer for cmp with dl
 19230                              <1> .ErrorCodeNotUsed:										; BH will be garbage on exit if this entry point is used,
 19231                              <1> 														; but reset of all drives will still happen
 19232 000015CD B251                <1> 	mov		dl, ROMVARS.ideVars0						; starting Idevars offset
 19233                              <1> 
 19234                              <1>     ; Get count of ALL Idevars structures, not just the ones that are configured.  This may seem odd,
 19235                              <1>     ; but it catches the .ideVarsSerialAuto structure, which would not be scanned if the count from
 19236                              <1> 	; RamVars_GetIdeControllerCountToCX was used.  Unused controllers won't make a difference, since no DPT
 19237                              <1> 	; will point to them.  Performance isn't an issue, as this is a reset operation.
 19238                              <1>     ;
 19239 000015CF B90500              <1> 	mov		cx, NUMBER_OF_IDEVARS
 19240                              <1> 
 19241                              <1> .loop:
 19242 000015D2 E8A5F0              <1> 	call	FindDPT_MasterOrSingleForIdevarsOffsetInDL
 19243 000015D5 7217                <1> 	jc		SHORT .ControllerNotAvailable
 19244                              <1> 
 19245                              <1> 	; Reset controller (both Master and Slave Drive). We ignore error codes
 19246                              <1> 	; here since initialization is the one that matters.
 19247 000015D7 51                  <1> 	push	cx
 19248 000015D8 52                  <1> 	push	dx
 19249 000015D9 53                  <1> 	push	bx
 19250                              <1> %ifdef MODULE_IRQ
 19251                              <1> 	call	Interrupts_UnmaskInterruptControllerForDriveInDSDI
 19252                              <1> %endif
 19253 000015DA E88FF6              <1> 	call	Device_ResetMasterAndSlaveController
 19254                              <1> %ifdef MODULE_ADVANCED_ATA
 19255                              <1> 	call	AdvAtaInit_InitializeControllerForDPTinDSDI
 19256                              <1> %endif
 19257 000015DD 5B                  <1> 	pop		bx
 19258 000015DE 5A                  <1> 	pop		dx
 19259                              <1> 
 19260                              <1> 	; Initialize Master Drive
 19261 000015DF E8CD00              <1> 	call	AH9h_InitializeDriveForUse					; Initialize Master drive
 19262 000015E2 E8D8FF              <1> 	call	BackupErrorCodeFromTheRequestedDriveToBH
 19263                              <1> 
 19264                              <1> 	; Initialize Slave Drive
 19265 000015E5 E897F0              <1> 	call	FindDPT_SlaveForIdevarsOffsetInDL
 19266 000015E8 7203                <1> 	jc		SHORT .SlaveDriveNotAvailable
 19267 000015EA E8C200              <1> 	call	AH9h_InitializeDriveForUse
 19268                              <1> 	; Here we have a small problem. Since DL now has offset to IDEVARS, it will be the same
 19269                              <1> 	; for both Master and Slave Drive. We simply ignore error from slave drive reset since most
 19270                              <1> 	; systems do not have slave drives at all and it is unlikely that AH=00h would be called for
 19271                              <1> 	; specific drive anyway. AH=Dh is for that.
 19272                              <1> 
 19273                              <1> .SlaveDriveNotAvailable:
 19274 000015ED 59                  <1> 	pop		cx
 19275                              <1> .ControllerNotAvailable:
 19276 000015EE 80C212              <1> 	add		dl, IDEVARS_size							; move Idevars pointer forward
 19277 000015F1 E2DF                <1> 	loop	.loop
 19278 000015F3 C3                  <1> 	ret
 19279                                  	%include "AH1h_HStatus.asm"		; Required by Int13h_Jump.asm
 19280                              <1> ; Project name	:	XTIDE Universal BIOS
 19281                              <1> ; Description	:	Int 13h function AH=1h, Read Disk Status.
 19282                              <1> 
 19283                              <1> ;
 19284                              <1> ; XTIDE Universal BIOS and Associated Tools
 19285                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 19286                              <1> ;
 19287                              <1> ; This program is free software; you can redistribute it and/or modify
 19288                              <1> ; it under the terms of the GNU General Public License as published by
 19289                              <1> ; the Free Software Foundation; either version 2 of the License, or
 19290                              <1> ; (at your option) any later version.
 19291                              <1> ;
 19292                              <1> ; This program is distributed in the hope that it will be useful,
 19293                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 19294                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 19295                              <1> ; GNU General Public License for more details.
 19296                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 19297                              <1> ;
 19298                              <1> 
 19299                              <1> ; Section containing code
 19300                              <1> SECTION .text
 19301                              <1> 
 19302                              <1> ;--------------------------------------------------------------------
 19303                              <1> ; Int 13h function AH=1h, Read Disk Status.
 19304                              <1> ;
 19305                              <1> ; AH1h_HandlerForReadDiskStatus
 19306                              <1> ;	Parameters:
 19307                              <1> ;		DL:		Translated Drive number
 19308                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 19309                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 19310                              <1> ;	Returns with INTPACK:
 19311                              <1> ;		AH:		Int 13h floppy return status
 19312                              <1> ;		CF:		0 if AH = RET_HD_SUCCESS, 1 otherwise (error)
 19313                              <1> ;--------------------------------------------------------------------
 19314                              <1> ALIGN JUMP_ALIGN
 19315                              <1> AH1h_HandlerForReadDiskStatus:
 19316                              <1> 	LOAD_BDA_SEGMENT_TO	ds, ax, !
 19317                              <2> %ifndef USE_186
 19318 000015F4 31C0                <2>  xor %2, %2
 19319 000015F6 8ED8                <2>  mov %1, %2
 19320                              <2> %elifidn %3, !
 19321                              <2>  xor %2, %2
 19322                              <2>  mov %1, %2
 19323                              <2> %else
 19324                              <2>  push BYTE 0
 19325                              <2>  pop %1
 19326                              <2> %endif
 19327                              <1> 
 19328                              <1> %ifdef MODULE_SERIAL_FLOPPY
 19329 000015F8 84D2                <1> 	test	dl, dl
 19330 000015FA 7806                <1> 	js		.HardDisk
 19331 000015FC 8A264104            <1> 	mov		ah, [BDA.bFDRetST]	; Unlike for hard disks below, floppy version does not clear the status
 19332 00001600 EB04                <1> 	jmp		.done
 19333                              <1> .HardDisk:
 19334                              <1> %endif
 19335                              <1> 
 19336 00001602 86267404            <1> 	xchg	ah, [BDA.bHDLastSt]	; Load and clear last error (AH is cleared with the LOAD_BDA_SEGMENT_TO above)
 19337                              <1> 
 19338                              <1> .done:
 19339                              <1> %ifndef USE_186
 19340 00001606 E820FF              <1> 	call	Int13h_SetErrorCodeToIntpackInSSBPfromAH
 19341 00001609 E9CFFE              <1> 	jmp		Int13h_ReturnFromHandlerWithoutStoringErrorCode
 19342                              <1> %else
 19343                              <1> 	push	Int13h_ReturnFromHandlerWithoutStoringErrorCode
 19344                              <1> 	jmp		Int13h_SetErrorCodeToIntpackInSSBPfromAH
 19345                              <1> %endif
 19346                                  	%include "AH2h_HRead.asm"		; Required by Int13h_Jump.asm
 19347                              <1> ; Project name	:	XTIDE Universal BIOS
 19348                              <1> ; Description	:	Int 13h function AH=2h, Read Disk Sectors.
 19349                              <1> 
 19350                              <1> ;
 19351                              <1> ; XTIDE Universal BIOS and Associated Tools
 19352                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 19353                              <1> ;
 19354                              <1> ; This program is free software; you can redistribute it and/or modify
 19355                              <1> ; it under the terms of the GNU General Public License as published by
 19356                              <1> ; the Free Software Foundation; either version 2 of the License, or
 19357                              <1> ; (at your option) any later version.
 19358                              <1> ;
 19359                              <1> ; This program is distributed in the hope that it will be useful,
 19360                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 19361                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 19362                              <1> ; GNU General Public License for more details.
 19363                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 19364                              <1> ;
 19365                              <1> 
 19366                              <1> ; Section containing code
 19367                              <1> SECTION .text
 19368                              <1> 
 19369                              <1> ;--------------------------------------------------------------------
 19370                              <1> ; Int 13h function AH=2h, Read Disk Sectors.
 19371                              <1> ;
 19372                              <1> ; AH2h_HandlerForReadDiskSectors
 19373                              <1> ;	Parameters:
 19374                              <1> ;		AL, CX, DH, ES:	Same as in INTPACK
 19375                              <1> ;		DL:		Translated Drive number
 19376                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 19377                              <1> ;		SS:BP:	Ptr to IDEPACK
 19378                              <1> ;	Parameters on INTPACK:
 19379                              <1> ;		AL:		Number of sectors to read (1...128)
 19380                              <1> ;		CH:		Cylinder number, bits 7...0
 19381                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 19382                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 19383                              <1> ;		DH:		Starting head number (0...255)
 19384                              <1> ;		ES:BX:	Pointer to buffer receiving data
 19385                              <1> ;	Returns with INTPACK:
 19386                              <1> ;		AH:		Int 13h/40h floppy return status
 19387                              <1> ;		AL:		Burst error length if AH returns 11h (we never return error code 11h)
 19388                              <1> ;				Number of sectors actually read (only valid if CF set for someBIOSes)
 19389                              <1> ;		CF:		0 if successful, 1 if error
 19390                              <1> ;--------------------------------------------------------------------
 19391                              <1> ALIGN JUMP_ALIGN
 19392                              <1> AH2h_HandlerForReadDiskSectors:
 19393 0000160C E8E802              <1> 	call	Prepare_BufferToESSIforOldInt13hTransfer
 19394 0000160F E8DE02              <1> 	call	Prepare_GetOldInt13hCommandIndexToBX
 19395 00001612 2E8AA7[1519]        <1> 	mov		ah, [cs:bx+g_rgbReadCommandLookup]
 19396 00001617 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 19397                              <1> %ifdef USE_186
 19398                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 19399                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 19400                              <1> %else
 19401 0000161A E804F6              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 19402 0000161D E9B2FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 19403                              <1> %endif
 19404                              <1> 
 19405                                  	%include "AH3h_HWrite.asm"		; Required by Int13h_Jump.asm
 19406                              <1> ; Project name	:	XTIDE Universal BIOS
 19407                              <1> ; Description	:	Int 13h function AH=3h, Write Disk Sectors.
 19408                              <1> 
 19409                              <1> ;
 19410                              <1> ; XTIDE Universal BIOS and Associated Tools
 19411                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 19412                              <1> ;
 19413                              <1> ; This program is free software; you can redistribute it and/or modify
 19414                              <1> ; it under the terms of the GNU General Public License as published by
 19415                              <1> ; the Free Software Foundation; either version 2 of the License, or
 19416                              <1> ; (at your option) any later version.
 19417                              <1> ;
 19418                              <1> ; This program is distributed in the hope that it will be useful,
 19419                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 19420                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 19421                              <1> ; GNU General Public License for more details.
 19422                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 19423                              <1> ;
 19424                              <1> 
 19425                              <1> ; Section containing code
 19426                              <1> SECTION .text
 19427                              <1> 
 19428                              <1> ;--------------------------------------------------------------------
 19429                              <1> ; Int 13h function AH=3h, Write Disk Sectors.
 19430                              <1> ;
 19431                              <1> ; AH3h_HandlerForWriteDiskSectors
 19432                              <1> ;	Parameters:
 19433                              <1> ;		AL, CX, DH, ES:	Same as in INTPACK
 19434                              <1> ;		DL:		Translated Drive number
 19435                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 19436                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 19437                              <1> ;	Parameters on INTPACK:
 19438                              <1> ;		AL:		Number of sectors to write (1...128)
 19439                              <1> ;		CH:		Cylinder number, bits 7...0
 19440                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 19441                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 19442                              <1> ;		DH:		Starting head number (0...255)
 19443                              <1> ;		ES:BX:	Pointer to source data
 19444                              <1> ;	Returns with INTPACK:
 19445                              <1> ;		AH:		Int 13h/40h floppy return status
 19446                              <1> ;		AL:		Number of sectors actually written (only valid if CF set for someBIOSes)
 19447                              <1> ;		CF:		0 if successful, 1 if error
 19448                              <1> ;--------------------------------------------------------------------
 19449                              <1> ALIGN JUMP_ALIGN
 19450                              <1> AH3h_HandlerForWriteDiskSectors:
 19451 00001620 E8D402              <1> 	call	Prepare_BufferToESSIforOldInt13hTransfer
 19452 00001623 E8CA02              <1> 	call	Prepare_GetOldInt13hCommandIndexToBX
 19453 00001626 2E8AA7[1919]        <1> 	mov		ah, [cs:bx+g_rgbWriteCommandLookup]
 19454 0000162B BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 19455                              <1> %ifdef USE_186
 19456                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 19457                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 19458                              <1> %else
 19459 0000162E E8F0F5              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 19460 00001631 E99EFE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 19461                              <1> %endif
 19462                                  	%include "AH4h_HVerify.asm"		; Required by Int13h_Jump.asm
 19463                              <1> ; Project name	:	XTIDE Universal BIOS
 19464                              <1> ; Description	:	Int 13h function AH=4h, Verify Disk Sectors.
 19465                              <1> 
 19466                              <1> ;
 19467                              <1> ; XTIDE Universal BIOS and Associated Tools
 19468                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 19469                              <1> ;
 19470                              <1> ; This program is free software; you can redistribute it and/or modify
 19471                              <1> ; it under the terms of the GNU General Public License as published by
 19472                              <1> ; the Free Software Foundation; either version 2 of the License, or
 19473                              <1> ; (at your option) any later version.
 19474                              <1> ;
 19475                              <1> ; This program is distributed in the hope that it will be useful,
 19476                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 19477                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 19478                              <1> ; GNU General Public License for more details.
 19479                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 19480                              <1> ;
 19481                              <1> 
 19482                              <1> ; Section containing code
 19483                              <1> SECTION .text
 19484                              <1> 
 19485                              <1> ;--------------------------------------------------------------------
 19486                              <1> ; Int 13h function AH=4h, Verify Disk Sectors.
 19487                              <1> ;
 19488                              <1> ; AH4h_HandlerForVerifyDiskSectors
 19489                              <1> ;	Parameters:
 19490                              <1> ;		AL, CX, DH:	Same as in INTPACK
 19491                              <1> ;		DL:		Translated Drive number
 19492                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 19493                              <1> ;		SS:BP:	Ptr to INTPACK
 19494                              <1> ;	Parameters on INTPACK in SS:BP:
 19495                              <1> ;		AL:		Number of sectors to verify (1...128)
 19496                              <1> ;		CH:		Cylinder number, bits 7...0
 19497                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 19498                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 19499                              <1> ;		DH:		Starting head number (0...255)
 19500                              <1> ;	Returns with INTPACK in SS:BP:
 19501                              <1> ;		AH:		Int 13h/40h floppy return status
 19502                              <1> ;		AL:		Number of sectors actually verified (only valid if CF set for someBIOSes)
 19503                              <1> ;		CF:		0 if successful, 1 if error
 19504                              <1> ;--------------------------------------------------------------------
 19505                              <1> ALIGN JUMP_ALIGN
 19506                              <1> AH4h_HandlerForVerifyDiskSectors:
 19507 00001634 B440                <1> 	mov		ah, COMMAND_VERIFY_SECTORS
 19508 00001636 E8C402              <1> 	call	Prepare_ByValidatingSectorsInALforOldInt13h	; Preserves AX
 19509 00001639 BB40FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRDY)
 19510                              <1> %ifdef USE_186
 19511                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 19512                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 19513                              <1> %else
 19514 0000163C E8E2F5              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 19515 0000163F E990FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAHandTransferredSectorsFromCL
 19516                              <1> %endif
 19517                                  	%include "AH8h_HParams.asm"		; Required by Int13h_Jump.asm
 19518                              <1> ; Project name	:	XTIDE Universal BIOS
 19519                              <1> ; Description	:	Int 13h function AH=8h, Read Disk Drive Parameters.
 19520                              <1> 
 19521                              <1> ;
 19522                              <1> ; XTIDE Universal BIOS and Associated Tools
 19523                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 19524                              <1> ;
 19525                              <1> ; This program is free software; you can redistribute it and/or modify
 19526                              <1> ; it under the terms of the GNU General Public License as published by
 19527                              <1> ; the Free Software Foundation; either version 2 of the License, or
 19528                              <1> ; (at your option) any later version.
 19529                              <1> ;
 19530                              <1> ; This program is distributed in the hope that it will be useful,
 19531                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 19532                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 19533                              <1> ; GNU General Public License for more details.
 19534                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 19535                              <1> ;
 19536                              <1> 
 19537                              <1> ; Section containing code
 19538                              <1> SECTION .text
 19539                              <1> 
 19540                              <1> ;--------------------------------------------------------------------
 19541                              <1> ; Int 13h function AH=8h, Read Disk Drive Parameters.
 19542                              <1> ;
 19543                              <1> ; AH8h_HandlerForReadDiskDriveParameters
 19544                              <1> ;	Parameters:
 19545                              <1> ;		DL:		Translated Drive number
 19546                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 19547                              <1> ;		SS:BP:	Ptr to IDEPACK
 19548                              <1> ;	Returns with INTPACK:
 19549                              <1> ;       BL:     Drive Type (for floppies only)
 19550                              <1> ;		CH:		Maximum cylinder number, bits 7...0
 19551                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9...8
 19552                              <1> ;				Bits 5...0:	Maximum sector number (1...63)
 19553                              <1> ;		DH:		Maximum head number (0...254)
 19554                              <1> ;		DL:		Number of drives!!!
 19555                              <1> ;       ES:DI:  Floppy DPT (for floppies only)
 19556                              <1> ;		AH:		Int 13h/40h floppy return status
 19557                              <1> ;		CF:		0 if successful, 1 if error
 19558                              <1> ;--------------------------------------------------------------------
 19559                              <1> AH8h_HandlerForReadDiskDriveParameters:
 19560 00001642 85FF                <1> 	test	di, di
 19561 00001644 742A                <1> 	jz		SHORT .NotOurDrive
 19562                              <1> 
 19563 00001646 E82F00              <1> 	call	AH8h_GetDriveParameters
 19564                              <1> 
 19565                              <1> %ifdef MODULE_SERIAL_FLOPPY
 19566 00001649 0E                  <1> 	push	cs							; setup registers if we are a floppy drive, in all cases
 19567 0000164A 07                  <1> 	pop		es							; if it is not a floppy drive, these values will not be put in INTPACK
 19568 0000164B BF[9B16]            <1> 	mov		di, AH8h_FloppyDPT
 19569                              <1> %endif
 19570                              <1> 	;; fall-through
 19571                              <1> 
 19572                              <1> .MidGame:
 19573 0000164E E8B6EE              <1> 	call	RamVars_GetCountOfKnownDrivesToAX		; assume hard disk for now, will discard if for floppies
 19574                              <1> 
 19575 00001651 F6461A80            <1> 	test	byte [bp+IDEPACK.intpack+INTPACK.dl], 080h
 19576 00001655 750C                <1> 	jnz		.Done
 19577                              <1> 
 19578 00001657 885E18              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.bl], bl
 19579                              <1> 
 19580 0000165A 8C460C              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.es], es
 19581 0000165D 897E10              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.di], di
 19582                              <1> 
 19583 00001660 E8ECEE              <1> 	call	FloppyDrive_GetCountToAX
 19584                              <1> 
 19585                              <1> .Done:
 19586 00001663 88F4                <1> 	mov		ah, dh
 19587                              <1> 
 19588 00001665 894E1C              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.cx], cx
 19589 00001668 87461A              <1> 	xchg	[bp+IDEPACK.intpack+INTPACK.dx], ax		; recover DL for BDA last status byte determination
 19590                              <1> 
 19591 0000166B 30E4                <1> 	xor		ah, ah
 19592                              <1> %ifdef MODULE_SERIAL_FLOPPY
 19593 0000166D E968FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH_ALHasDriveNumber
 19594                              <1> %else
 19595                              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 19596                              <1> %endif
 19597                              <1> 
 19598                              <1> .NotOurDrive:
 19599 00001670 E87CFE              <1> 	call	Int13h_CallPreviousInt13hHandler
 19600 00001673 73D9                <1> 	jnc		SHORT .MidGame
 19601 00001675 E95DFE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 19602                              <1> 
 19603                              <1> 
 19604                              <1> ;--------------------------------------------------------------------
 19605                              <1> ; Returns L-CHS parameters for drive and total hard disk count.
 19606                              <1> ;
 19607                              <1> ; AH8h_GetDriveParameters
 19608                              <1> ;	Parameters:
 19609                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 19610                              <1> ;	Returns:
 19611                              <1> ;		CH:		Maximum cylinder number, bits 7...0
 19612                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9...8
 19613                              <1> ;				Bits 5...0:	Maximum sector number (1...63)
 19614                              <1> ;		DH:		Maximum head number (0...254)
 19615                              <1> ;	Corrupts registers:
 19616                              <1> ;		AX, BX
 19617                              <1> ;--------------------------------------------------------------------
 19618                              <1> AH8h_GetDriveParameters:
 19619 00001678 E85CF0              <1> 	call	AccessDPT_GetLCHStoAXBLBH
 19620                              <1> %ifdef RESERVE_DIAGNOSTIC_CYLINDER
 19621 0000167B 48                  <1> 	dec		ax
 19622                              <1> %endif
 19623                              <1> 	MIN_U	ax, MAX_LCHS_CYLINDERS
 19624 0000167C 3D0004              <2>  cmp %1, %2
 19625 0000167F 7203                <2>  jb %%Return
 19626 00001681 B80004              <2>  mov %1, %2
 19627                              <2> ALIGN JUMP_ALIGN
 19628                              <2> %%Return:
 19629                              <1> 	; Fall to .PackReturnValues
 19630                              <1> 
 19631                              <1> ;--------------------------------------------------------------------
 19632                              <1> ; Packs L-CHS values to INT 13h, AH=08h return values.
 19633                              <1> ;
 19634                              <1> ; .PackReturnValues
 19635                              <1> ;	Parameters:
 19636                              <1> ;		AX:		Number of L-CHS cylinders available (1...1024)
 19637                              <1> ;		BL:		Number of L-CHS heads (1...255)
 19638                              <1> ;		BH:		Number of L-CHS sectors per track (1...63)
 19639                              <1> ;		DS:		RAMVARS segment
 19640                              <1> ;	Returns:
 19641                              <1> ;		CH:		Maximum cylinder number, bits 7...0
 19642                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9...8
 19643                              <1> ;				Bits 5...0:	Maximum sector number (1...63)
 19644                              <1> ;		DH:		Maximum head number (0...254)
 19645                              <1> ;	Corrupts registers:
 19646                              <1> ;		AX, BX
 19647                              <1> ;--------------------------------------------------------------------
 19648                              <1> .PackReturnValues:
 19649 00001684 48                  <1> 	dec		ax						; AX = Number of last cylinder
 19650 00001685 4B                  <1> 	dec		bx						; BL = Number of last head
 19651 00001686 91                  <1> 	xchg	cx, ax
 19652 00001687 86CD                <1> 	xchg	cl, ch					; CH = Last cylinder bits 0...7
 19653                              <1> 	eROR_IM	cl, 2					; CL bits 6...7 = Last cylinder bits 8...9
 19654                              <2>  eSHIFT_IM %1, %2, ror
 19655                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 19656                              <3> %ifndef USE_186
 19657                              <3>  %ifidni %1, cl
 19658 00001689 D0C9<rept>          <3>  times %2 %3 %1, 1
 19659                              <3>  %elifidni %1, ch
 19660                              <3>  times %2 %3 %1, 1
 19661                              <3>  %elifidni %1, cx
 19662                              <3>  times %2 %3 %1, 1
 19663                              <3>  %else
 19664                              <3>  %if %2 > 3
 19665                              <3>  push cx
 19666                              <3>  mov cl, %2
 19667                              <3>  %3 %1, cl
 19668                              <3>  pop cx
 19669                              <3>  %else
 19670                              <3>  times %2 %3 %1, 1
 19671                              <3>  %endif
 19672                              <3>  %endif
 19673                              <3> 
 19674                              <3> %else
 19675                              <3>  %3 %1, %2
 19676                              <3> %endif
 19677                              <3> %endif
 19678 0000168D 08F9                <1> 	or		cl, bh					; CL bits 0...5 = Sectors per track
 19679 0000168F 88DE                <1> 	mov		dh, bl					; DH = Maximum head number
 19680                              <1> 
 19681                              <1> %ifdef MODULE_SERIAL_FLOPPY
 19682 00001691 8A5D01              <1> 	mov		bl, [di+DPT.bFlagsHigh]
 19683                              <1> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS             ; not sure why this is needed for preprocessor-only
 19684                              <1> 	eSHR_IM	bl, FLGH_DPT_SERIAL_FLOPPY_TYPE_FIELD_POSITION
 19685                              <2>  eSHIFT_IM %1, %2, shr
 19686                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 19687                              <3> %ifndef USE_186
 19688                              <3>  %ifidni %1, cl
 19689                              <3>  times %2 %3 %1, 1
 19690                              <3>  %elifidni %1, ch
 19691                              <3>  times %2 %3 %1, 1
 19692                              <3>  %elifidni %1, cx
 19693                              <3>  times %2 %3 %1, 1
 19694                              <3>  %else
 19695                              <3>  %if %2 > 3
 19696 00001694 51                  <3>  push cx
 19697 00001695 B105                <3>  mov cl, %2
 19698 00001697 D2EB                <3>  %3 %1, cl
 19699 00001699 59                  <3>  pop cx
 19700                              <3>  %else
 19701                              <3>  times %2 %3 %1, 1
 19702                              <3>  %endif
 19703                              <3>  %endif
 19704                              <3> 
 19705                              <3> %else
 19706                              <3>  %3 %1, %2
 19707                              <3> %endif
 19708                              <3> %endif
 19709                              <1> %endif
 19710                              <1> %endif
 19711 0000169A C3                  <1> 	ret
 19712                              <1> 
 19713                              <1> %ifdef MODULE_SERIAL_FLOPPY
 19714                              <1> ;
 19715                              <1> ; Floppy Disk Parameter Table.  There is no way to specify more than one of these
 19716                              <1> ; for any given system, so no way to make this drive or media specific.
 19717                              <1> ; So we return fixed values out of the ROM for callers who might be expecting this information.
 19718                              <1> ;
 19719                              <1> ; On AT systems, we return the information for a 1.44 MB disk,
 19720                              <1> ; and on XT systems, we return the information for a 360 KB disk.
 19721                              <1> ;
 19722                              <1> AH8h_FloppyDPT:
 19723                              <1> %ifdef USE_AT
 19724                              <1> 	db		0ah << 4 | 0fh			; Offset 0: Drive timings, 1.44MB values
 19725                              <1> %else
 19726 0000169B DF                  <1> 	db		0dh << 4 | 0fh			; Offset 0: Drive timings, 360KB values
 19727                              <1> %endif
 19728                              <1> 
 19729 0000169C 02                  <1> 	db		1h << 1 | 0				; Offset 1: Typical values of 1 for head load time
 19730                              <1> 									;           DMA used (although it actually is not, but is more restrictive)
 19731 0000169D 25                  <1> 	db		25h						; Offset 2: Inactivity motor turn-off delay,
 19732                              <1> 									; 			Typical value of 25h for 2 second delay
 19733 0000169E 02                  <1> 	db		02h						; Offset 3: Sector size, always 512
 19734                              <1> 
 19735                              <1> %ifdef USE_AT
 19736                              <1> 	db		12h						; Offset 4: Sectors per track, 1.44MB value
 19737                              <1> 	db		1bh						; Offset 5: Sector gap, 1.44MB value
 19738                              <1> %else
 19739 0000169F 09                  <1> 	db		09h						; Offset 4: Sectors per track, 360KB value
 19740 000016A0 2A                  <1> 	db		2ah						; Offset 5: Sector gap, 360KB value
 19741                              <1> %endif
 19742                              <1> 
 19743 000016A1 FF                  <1> 	db		0ffh					; Offset 6: Data length
 19744                              <1> 
 19745                              <1> %ifdef USE_AT
 19746                              <1> 	db		6ch						; Offset 7: Format gap length, 1.44MB value
 19747                              <1> %else
 19748 000016A2 50                  <1> 	db		50h						; Offset 7: Format gap length, 360KB value
 19749                              <1> %endif
 19750                              <1> 
 19751 000016A3 F6                  <1> 	db		0f6h					; Offset 8: Fill byte for format
 19752 000016A4 0F                  <1> 	db		0fh						; Offset 9: Head setting time
 19753 000016A5 08                  <1> 	db		08h						; Offset A: Wait for motor startup time
 19754                              <1> 
 19755                              <1> %ifdef USE_AT
 19756                              <1> 	db		79						; Offset B: Maximum track number, 1.44MB value
 19757                              <1> 	db		0						; Offset C: Data transfer rate, 1.44MB value
 19758                              <1> 	db		4						; Offset D: Diskette CMOS drive type, 1.44MB value
 19759                              <1> %else
 19760 000016A6 27                  <1> 	db		39						; Offset B: Maximum track number, 360KB value
 19761 000016A7 80                  <1> 	db		80h						; Offset C: Data transfer rate, 360KB value
 19762 000016A8 01                  <1> 	db		1						; Offset D: Diskette CMOS drive type, 360KB value
 19763                              <1> %endif
 19764                              <1> %endif
 19765                                  	%include "AH9h_HInit.asm"		; Required by Int13h_Jump.asm
 19766                              <1> ; Project name	:	XTIDE Universal BIOS
 19767                              <1> ; Description	:	Int 13h function AH=9h, Initialize Drive Parameters.
 19768                              <1> 
 19769                              <1> ;
 19770                              <1> ; XTIDE Universal BIOS and Associated Tools
 19771                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 19772                              <1> ;
 19773                              <1> ; This program is free software; you can redistribute it and/or modify
 19774                              <1> ; it under the terms of the GNU General Public License as published by
 19775                              <1> ; the Free Software Foundation; either version 2 of the License, or
 19776                              <1> ; (at your option) any later version.
 19777                              <1> ;
 19778                              <1> ; This program is distributed in the hope that it will be useful,
 19779                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 19780                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 19781                              <1> ; GNU General Public License for more details.
 19782                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 19783                              <1> ;
 19784                              <1> 
 19785                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 19786                              <1> 
 19787                              <1> ; Section containing code
 19788                              <1> SECTION .text
 19789                              <1> 
 19790                              <1> ;--------------------------------------------------------------------
 19791                              <1> ; STORE_ERROR_FLAG_TO_DPT
 19792                              <1> ;	Parameters:
 19793                              <1> ;		%1:		Error flag to set
 19794                              <1> ;		AH:		BIOS Error Code
 19795                              <1> ;		DS:DI:	Ptr to DPT
 19796                              <1> ;		CF:		Set if error code in AH
 19797                              <1> ;	Returns:
 19798                              <1> ;		CF:		Clear if no error
 19799                              <1> ;				Set if error flag was set
 19800                              <1> ;	Corrupts registers:
 19801                              <1> ;		Nothing
 19802                              <1> ;--------------------------------------------------------------------
 19803                              <1> %macro STORE_ERROR_FLAG_TO_DPT 1
 19804                              <1> 	mov		al, %1
 19805                              <1> 	call	SetErrorFlagFromALwithErrorCodeInAH
 19806                              <1> %endmacro
 19807                              <1> 
 19808                              <1> 
 19809                              <1> ;--------------------------------------------------------------------
 19810                              <1> ; Int 13h function AH=9h, Initialize Drive Parameters.
 19811                              <1> ;
 19812                              <1> ; AH9h_HandlerForInitializeDriveParameters
 19813                              <1> ;	Parameters:
 19814                              <1> ;		DL:		Translated Drive number
 19815                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 19816                              <1> ;		SS:BP:	Ptr to IDEPACK
 19817                              <1> ;	Returns with INTPACK:
 19818                              <1> ;		AH:		Int 13h return status
 19819                              <1> ;		CF:		0 if successful, 1 if error
 19820                              <1> ;--------------------------------------------------------------------
 19821                              <1> AH9h_HandlerForInitializeDriveParameters:
 19822                              <1> %ifndef USE_186
 19823                              <1> 	; why is this different for 186+?
 19824 000016A9 E80300              <1> 	call	AH9h_InitializeDriveForUse
 19825 000016AC E926FE              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 19826                              <1> %else
 19827                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 19828                              <1> 	; Fall to AH9h_InitializeDriveForUse
 19829                              <1> %endif
 19830                              <1> 
 19831                              <1> 
 19832                              <1> ;--------------------------------------------------------------------
 19833                              <1> ; Initialize drive to be ready for use.
 19834                              <1> ;
 19835                              <1> ; AH9h_InitializeDriveForUse
 19836                              <1> ;	Parameters:
 19837                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 19838                              <1> ;		SS:BP:	Ptr to IDEPACK
 19839                              <1> ;	Returns:
 19840                              <1> ;		AH:		Int 13h return status
 19841                              <1> ;		CF:		0 if successful, 1 if error
 19842                              <1> ;	Corrupts registers:
 19843                              <1> ;		AL, CX
 19844                              <1> ;--------------------------------------------------------------------
 19845                              <1> AH9h_InitializeDriveForUse:
 19846 000016AF 31C0                <1> 	xor		ax, ax				; Clear AH to assume no errors
 19847                              <1> 
 19848                              <1> %ifdef MODULE_ADVANCED_ATA
 19849                              <1> 	; Clear Initialization Error flags from DPT
 19850                              <1> 	mov		[di+DPT.bInitError], al
 19851                              <1> %endif
 19852                              <1> 
 19853                              <1> %ifdef MODULE_SERIAL
 19854                              <1> 	; No need to do this for serial devices
 19855 000016B1 F6450104            <1> 	test		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_SERIAL_DEVICE	; Clears CF
 19856 000016B5 7401                <1> 	jz		SHORT .ContinueInitialization
 19857 000016B7 C3                  <1> 	ret		; With AH and CF cleared
 19858                              <1> .ContinueInitialization:
 19859                              <1> %endif
 19860                              <1> 
 19861 000016B8 06                  <1> 	push	es
 19862 000016B9 56                  <1> 	push	si
 19863 000016BA 52                  <1> 	push	dx
 19864 000016BB 53                  <1> 	push	bx
 19865                              <1> 
 19866                              <1> 
 19867                              <1> ;;;	SelectDrive
 19868                              <1> 	; Try to select drive and wait until ready
 19869 000016BC E803F0              <1> 	call	AccessDPT_GetDriveSelectByteForOldInt13hToAL
 19870 000016BF 884601              <1> 	mov		[bp+IDEPACK.bDrvAndHead], al
 19871 000016C2 E8C7F5              <1> 	call	Device_SelectDrive
 19872                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SELECT_DRIVE
 19873 000016C5 B001                <2>  mov al, %1
 19874 000016C7 E8A000              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 19875                              <1> %ifdef USE_386
 19876                              <1> 	jc		.ReturnWithErrorCodeInAH
 19877                              <1> %else
 19878 000016CA 7303                <1> 	jnc		SHORT .ContinueInitializationSinceDriveSelectedSuccesfully
 19879 000016CC E99100              <1> 	jmp		.ReturnWithErrorCodeInAH
 19880                              <1> .ContinueInitializationSinceDriveSelectedSuccesfully:
 19881                              <1> %endif
 19882                              <1> 
 19883                              <1> 
 19884                              <1> ;;; Set XT-CF mode
 19885                              <1> %ifdef MODULE_8BIT_IDE
 19886 000016CF E836F0              <1> 	call	AccessDPT_GetIdevarsToCSBX
 19887 000016D2 2E8A4702            <1> 	mov		al, [cs:bx+IDEVARS.bXTCFcontrolRegister]
 19888 000016D6 E89D00              <1> 	call	AH9h_SetModeFromALtoXTCF
 19889                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_XTCF_MODE
 19890 000016D9 B080                <2>  mov al, %1
 19891 000016DB E88C00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 19892                              <1> .DoNotSetXTCFmode:
 19893                              <1> %endif	; MODULE_8BIT_IDE
 19894                              <1> 
 19895                              <1> %ifdef MODULE_8BIT_IDE
 19896                              <1> ;;; Set 8-bit PIO mode
 19897 000016DE E89C00              <1> 	call	AH9h_Enable8bitModeForDevice8bitAta
 19898                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_8BIT_MODE
 19899 000016E1 B080                <2>  mov al, %1
 19900 000016E3 E88400              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 19901                              <1> .DoNotSet8bitMode:
 19902                              <1> %endif ; MODULE_8BIT_IDE
 19903                              <1> 
 19904                              <1> 
 19905                              <1> ;;;	InitializeDeviceParameters
 19906                              <1> 	; Initialize CHS parameters if LBA is not used and
 19907                              <1> 	; user has specified P-CHS parameters
 19908 000016E6 F60508              <1> 	test	BYTE [di+DPT.bFlagsLow], FLGL_DPT_ASSISTED_LBA
 19909 000016E9 751F                <1> 	jnz		SHORT .SkipInitializeDeviceParameters		; No need to initialize CHS parameters if LBA mode enabled
 19910 000016EB E80BF0              <1> 	call	AccessDPT_GetPointerToDRVPARAMStoCSBX
 19911 000016EE 2EF60720            <1> 	test	BYTE [cs:bx+DRVPARAMS.wFlags], FLG_DRVPARAMS_USERCHS    ; User specified P-CHS?
 19912 000016F2 7416                <1> 	jz		SHORT .SkipInitializeDeviceParameters
 19913                              <1> 
 19914                              <1> 	; Initialize Logical Sectors per Track and Max Head number
 19915 000016F4 2E8B4704            <1> 	mov		ax, [cs:bx+DRVPARAMS.wHeadsAndSectors]
 19916 000016F8 48                  <1> 	dec		ax						; Max Head number
 19917 000016F9 86C4                <1> 	xchg		al, ah						; Heads now in AH
 19918 000016FB 89C2                <1> 	mov		dx, ax						; Sectors per Track now in DL
 19919 000016FD B091                <1> 	mov		al, COMMAND_INITIALIZE_DEVICE_PARAMETERS
 19920 000016FF BB80B5              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_BSY, FLG_STATUS_BSY)
 19921 00001702 E83DF5              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
 19922                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_INITIALIZE_CHS_PARAMETERS
 19923 00001705 B002                <2>  mov al, %1
 19924 00001707 E86000              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 19925                              <1> .SkipInitializeDeviceParameters:
 19926                              <1> 
 19927                              <1> 
 19928                              <1> ;;;	SetWriteCache
 19929                              <1> 	; Enable or Disable Write Cache
 19930 0000170A E8ECEF              <1> 	call	AccessDPT_GetPointerToDRVPARAMStoCSBX
 19931 0000170D 2E8A1F              <1> 	mov		bl, [cs:bx+DRVPARAMS.wFlags]
 19932 00001710 53                  <1> 	push		bx	; Save .wFlags for later use in InitializeBlockMode
 19933 00001711 83E303              <1> 	and		bx, BYTE MASK_DRVPARAMS_WRITECACHE
 19934 00001714 740D                <1> 	jz		SHORT .SkipSetWriteCache		; DEFAULT_WRITE_CACHE
 19935 00001716 2E8BB7[6517]        <1> 	mov		si, [cs:bx+.rgbWriteCacheCommands]
 19936 0000171B E81001              <1> 	call	AH23h_SetControllerFeatures
 19937                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_WRITE_CACHE
 19938 0000171E B004                <2>  mov al, %1
 19939 00001720 E84700              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 19940                              <1> .SkipSetWriteCache:
 19941                              <1> 
 19942                              <1> 
 19943                              <1> ;;;	RecalibrateDrive
 19944                              <1> 	; Recalibrate drive by seeking to cylinder 0
 19945 00001723 E87A00              <1> 	call	AH11h_RecalibrateDrive
 19946                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_RECALIBRATE_DRIVE
 19947 00001726 B008                <2>  mov al, %1
 19948 00001728 E83F00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 19949                              <1> 
 19950                              <1> 
 19951                              <1> ;;;	InitializeBlockMode
 19952                              <1> 	; Initialize block mode transfers
 19953 0000172B 58                  <1> 	pop		ax	; Restore .wFlags saved in SetWriteCache
 19954 0000172C F6450102            <1> 	test		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_BLOCK_MODE_SUPPORTED
 19955 00001730 7416                <1> 	jz		SHORT .BlockModeNotSupportedOrDisabled
 19956 00001732 A810                <1> 	test		al, FLG_DRVPARAMS_BLOCKMODE
 19957 00001734 7412                <1> 	jz		SHORT .BlockModeNotSupportedOrDisabled
 19958                              <1> 
 19959                              <1> 	; Try block sizes until we find largest possible supported by drive
 19960 00001736 B380                <1> 	mov		bl, 128
 19961                              <1> .TryNextBlockSize:
 19962 00001738 88D8                <1> 	mov		al, bl
 19963 0000173A E80401              <1> 	call	AH24h_SetBlockSize	; Stores block size to DPT
 19964 0000173D 7309                <1> 	jnc		SHORT .SupportedBlockSizeFound
 19965 0000173F D0EB                <1> 	shr		bl, 1
 19966 00001741 73F5                <1> 	jnc		SHORT .TryNextBlockSize
 19967                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_BLOCK_MODE
 19968 00001743 B010                <2>  mov al, %1
 19969 00001745 E82200              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 19970                              <1> .BlockModeNotSupportedOrDisabled:
 19971                              <1> .SupportedBlockSizeFound:
 19972                              <1> 
 19973                              <1> 
 19974                              <1> %ifdef MODULE_ADVANCED_ATA
 19975                              <1> ;;;	InitializePioMode
 19976                              <1> 	; Initialize fastest supported PIO mode
 19977                              <1> 	mov		dl, PIO_DEFAULT_MODE_DISABLE_IORDY
 19978                              <1> 	test		BYTE [di+DPT.bFlagsHigh], FLGH_DPT_IORDY
 19979                              <1> 	jz		SHORT .IordyNotSupported
 19980                              <1> 
 19981                              <1> 	; Advanced PIO mode 3 and above
 19982                              <1> 	mov		dl, [di+DPT_ADVANCED_ATA.bPioMode]
 19983                              <1> 	or		dl, PIO_FLOW_CONTROL_MODE_xxx
 19984                              <1> 
 19985                              <1> .IordyNotSupported:
 19986                              <1> 	mov		si, FEATURE_SET_TRANSFER_MODE
 19987                              <1> 	call	AH23h_SetControllerFeatures
 19988                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_SET_PIO_MODE
 19989                              <1> %endif ; MODULE_ADVANCED_ATA
 19990                              <1> 
 19991                              <1> 
 19992                              <1> %ifdef MODULE_FEATURE_SETS
 19993                              <1> ;;;	InitStandbyTimer
 19994                              <1> 	; Initialize the standby timer (if supported)
 19995 00001748 F6450120            <1> 	test	BYTE [di+DPT.bFlagsHigh], FLGH_DPT_POWER_MANAGEMENT_SUPPORTED
 19996 0000174C 7412                <1> 	jz		SHORT .NoPowerManagementSupport
 19997                              <1> 
 19998 0000174E B0E3                <1> 	mov		al, COMMAND_IDLE
 19999 00001750 2E8A165000          <1> 	mov		dl, [cs:ROMVARS.bIdleTimeout]
 20000 00001755 BB80B5              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_BSY, FLG_STATUS_BSY)
 20001 00001758 E8E7F4              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
 20002                              <1> 	STORE_ERROR_FLAG_TO_DPT		FLG_INITERROR_FAILED_TO_INITIALIZE_STANDBY_TIMER
 20003 0000175B B040                <2>  mov al, %1
 20004 0000175D E80A00              <2>  call SetErrorFlagFromALwithErrorCodeInAH
 20005                              <1> .NoPowerManagementSupport:
 20006                              <1> %endif ; MODULE_FEATURE_SETS
 20007                              <1> 
 20008                              <1> 
 20009                              <1> 	; There might have been several errors so just return one error code for them all
 20010                              <1> .ReturnWithErrorCodeInAH:
 20011                              <1> %ifdef MODULE_ADVANCED_ATA
 20012                              <1> 	mov		ah, [di+DPT.bInitError]
 20013                              <1> 	test		ah, ah	; Clears CF
 20014                              <1> 	jz		SHORT .ReturnWithSuccess
 20015                              <1> 	mov		ah, RET_HD_RESETFAIL
 20016                              <1> 	stc
 20017                              <1> .ReturnWithSuccess:
 20018                              <1> %endif
 20019                              <1> 
 20020 00001760 5B                  <1> 	pop		bx
 20021 00001761 5A                  <1> 	pop		dx
 20022 00001762 5E                  <1> 	pop		si
 20023 00001763 07                  <1> 	pop		es
 20024 00001764 C3                  <1> 	ret
 20025                              <1> 
 20026                              <1> 
 20027                              <1> .rgbWriteCacheCommands:
 20028 00001765 00                  <1> 	db		0								; DEFAULT_WRITE_CACHE
 20029 00001766 82                  <1> 	db		FEATURE_DISABLE_WRITE_CACHE		; DISABLE_WRITE_CACHE
 20030 00001767 02                  <1> 	db		FEATURE_ENABLE_WRITE_CACHE		; ENABLE_WRITE_CACHE
 20031                              <1> 
 20032                              <1> 
 20033                              <1> 
 20034                              <1> ;--------------------------------------------------------------------
 20035                              <1> ; SetErrorFlagFromALwithErrorCodeInAH
 20036                              <1> ;	Parameters:
 20037                              <1> ;		AH:		BIOS Error Code
 20038                              <1> ;		AL:		Error flag to set
 20039                              <1> ;		DS:DI:		Ptr to DPT
 20040                              <1> ;		CF:		Set if error code in AH
 20041                              <1> ;				Clear if AH = 0
 20042                              <1> ;	Returns:
 20043                              <1> ;		CF:		Clear if no error
 20044                              <1> ;				Set if error flag was set
 20045                              <1> ;	Corrupts registers:
 20046                              <1> ;		Nothing
 20047                              <1> ;--------------------------------------------------------------------
 20048                              <1> IgnoreInvalidCommandError:
 20049 00001768 30E4                <1> 	xor		ah, ah	; Clears CF
 20050                              <1> SetErrorFlagFromALwithErrorCodeInAH:
 20051 0000176A 7309                <1> 	jnc		SHORT .NoErrorFlagToSet
 20052 0000176C 80FC01              <1> 	cmp		ah, RET_HD_INVALID
 20053 0000176F 76F7                <1> 	jbe		SHORT IgnoreInvalidCommandError
 20054                              <1> 
 20055 00001771 084503              <1> 	or		[di+DPT.bInitError], al
 20056 00001774 F9                  <1> 	stc
 20057                              <1> .NoErrorFlagToSet:
 20058 00001775 C3                  <1> 	ret
 20059                              <1> 
 20060                              <1> 
 20061                              <1> %ifdef MODULE_8BIT_IDE_ADVANCED
 20062                              <1> ;--------------------------------------------------------------------
 20063                              <1> ; AH9h_SetModeFromALtoXTCF
 20064                              <1> ;	Parameters:
 20065                              <1> ;		AL:		XT-CF Mode to set
 20066                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 20067                              <1> ;		SS:BP:		Ptr to IDEPACK
 20068                              <1> ;	Returns:
 20069                              <1> ;		AH:		Int 13h return status
 20070                              <1> ;		CF:		Clear if successful or device is not XT-CF
 20071                              <1> ;				Set if failed to set mode for XT-CF
 20072                              <1> ;	Corrupts registers:
 20073                              <1> ;		AL, BX, CX, DX, SI
 20074                              <1> ;--------------------------------------------------------------------
 20075                              <1> AH9h_SetModeFromALtoXTCF:
 20076 00001776 E865EF              <1> 	call		AccessDPT_IsThisDeviceXTCF
 20077 00001779 75ED                <1> 	jne		SHORT IgnoreInvalidCommandError
 20078 0000177B EB7A                <1> 	jmp		AH1Eh_ChangeXTCFmodeBasedOnModeInAL
 20079                              <1> %endif ; MODULE_8BIT_IDE_ADVANCED
 20080                              <1> 
 20081                              <1> %ifdef MODULE_8BIT_IDE
 20082                              <1> ;--------------------------------------------------------------------
 20083                              <1> ; AH9h_Enable8bitModeForDevice8bitAta
 20084                              <1> ;	Parameters:
 20085                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20086                              <1> ;		SS:BP:	Ptr to IDEPACK
 20087                              <1> ;	Returns:
 20088                              <1> ;		AH:		Int 13h return status
 20089                              <1> ;		CF:		Clear if successful or device is not DEVICE_8BIT_ATA
 20090                              <1> ;				Set if failed to set 8-bit mode for DEVICE_8BIT_ATA
 20091                              <1> ;	Corrupts registers:
 20092                              <1> ;		AL, BX, CX, DX, SI
 20093                              <1> ;--------------------------------------------------------------------
 20094                              <1> AH9h_Enable8bitModeForDevice8bitAta:
 20095 0000177D 807D1404            <1> 	cmp		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_ATA
 20096 00001781 75E5                <1> 	jne		SHORT IgnoreInvalidCommandError
 20097 00001783 E9B000              <1> 	jmp		AH23h_Enable8bitPioMode
 20098                              <1> %endif
 20099                                  	%include "AHCh_HSeek.asm"		; Required by Int13h_Jump.asm
 20100                              <1> ; Project name	:	XTIDE Universal BIOS
 20101                              <1> ; Description	:	Int 13h function AH=Ch, Seek.
 20102                              <1> 
 20103                              <1> ;
 20104                              <1> ; XTIDE Universal BIOS and Associated Tools
 20105                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 20106                              <1> ;
 20107                              <1> ; This program is free software; you can redistribute it and/or modify
 20108                              <1> ; it under the terms of the GNU General Public License as published by
 20109                              <1> ; the Free Software Foundation; either version 2 of the License, or
 20110                              <1> ; (at your option) any later version.
 20111                              <1> ;
 20112                              <1> ; This program is distributed in the hope that it will be useful,
 20113                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 20114                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 20115                              <1> ; GNU General Public License for more details.
 20116                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 20117                              <1> ;
 20118                              <1> 
 20119                              <1> ; Section containing code
 20120                              <1> SECTION .text
 20121                              <1> 
 20122                              <1> ;--------------------------------------------------------------------
 20123                              <1> ; Int 13h function AH=Ch, Seek.
 20124                              <1> ;
 20125                              <1> ; AHCh_HandlerForSeek
 20126                              <1> ;	Parameters:
 20127                              <1> ;		CX, DH:	Same as in INTPACK
 20128                              <1> ;		DL:		Translated Drive number
 20129                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20130                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 20131                              <1> ;	Parameters on INTPACK:
 20132                              <1> ;		CH:		Cylinder number, bits 7...0
 20133                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 20134                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 20135                              <1> ;		DH:		Starting head number (0...255)
 20136                              <1> ;	Returns with INTPACK:
 20137                              <1> ;		AH:		BIOS Error code
 20138                              <1> ;		CF:		0 if successful, 1 if error
 20139                              <1> ;--------------------------------------------------------------------
 20140                              <1> ALIGN JUMP_ALIGN
 20141                              <1> AHCh_HandlerForSeek:
 20142                              <1> %ifndef USE_186
 20143 00001786 E80300              <1> 	call	AHCh_SeekToCylinder
 20144 00001789 E949FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20145                              <1> %else
 20146                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20147                              <1> 	; Fall to AHCh_SeekToCylinder
 20148                              <1> %endif
 20149                              <1> 
 20150                              <1> ;--------------------------------------------------------------------
 20151                              <1> ; AHCh_SeekToCylinder
 20152                              <1> ;	Parameters:
 20153                              <1> ;		CH:		Cylinder number, bits 7...0
 20154                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 20155                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 20156                              <1> ;		DH:		Starting head number (0...255)
 20157                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20158                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 20159                              <1> ;	Returns:
 20160                              <1> ;		AH:		BIOS Error code
 20161                              <1> ;		CF:		0 if successful, 1 if error
 20162                              <1> ;	Corrupts registers:
 20163                              <1> ;		AL, BX, CX, DX
 20164                              <1> ;--------------------------------------------------------------------
 20165                              <1> AHCh_SeekToCylinder:
 20166 0000178C B470                <1> 	mov		ah, COMMAND_SEEK
 20167 0000178E BB40FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRDY)
 20168 00001791 E98DF4              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 20169                                  	%include "AH10h_HReady.asm"		; Required by Int13h_Jump.asm
 20170                              <1> ; Project name	:	XTIDE Universal BIOS
 20171                              <1> ; Description	:	Int 13h function AH=10h, Check Drive Ready.
 20172                              <1> 
 20173                              <1> ;
 20174                              <1> ; XTIDE Universal BIOS and Associated Tools
 20175                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 20176                              <1> ;
 20177                              <1> ; This program is free software; you can redistribute it and/or modify
 20178                              <1> ; it under the terms of the GNU General Public License as published by
 20179                              <1> ; the Free Software Foundation; either version 2 of the License, or
 20180                              <1> ; (at your option) any later version.
 20181                              <1> ;
 20182                              <1> ; This program is distributed in the hope that it will be useful,
 20183                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 20184                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 20185                              <1> ; GNU General Public License for more details.
 20186                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 20187                              <1> ;
 20188                              <1> 
 20189                              <1> ; Section containing code
 20190                              <1> SECTION .text
 20191                              <1> 
 20192                              <1> ;--------------------------------------------------------------------
 20193                              <1> ; Int 13h function AH=10h, Check Drive Ready.
 20194                              <1> ;
 20195                              <1> ; AH10h_HandlerForCheckDriveReady
 20196                              <1> ;	Parameters:
 20197                              <1> ;		DL:		Translated Drive number
 20198                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20199                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 20200                              <1> ;	Returns with INTPACK:
 20201                              <1> ;		AH:		Int 13h return status
 20202                              <1> ;		CF:		0 if successful, 1 if error
 20203                              <1> ;--------------------------------------------------------------------
 20204                              <1> ALIGN JUMP_ALIGN
 20205                              <1> AH10h_HandlerForCheckDriveReady:
 20206                              <1> %ifdef USE_186
 20207                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20208                              <1> 	jmp		Device_SelectDrive
 20209                              <1> %else
 20210 00001794 E8F5F4              <1> 	call	Device_SelectDrive
 20211 00001797 E93BFD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20212                              <1> %endif
 20213                                  	%include "AH11h_HRecal.asm"		; Required by Int13h_Jump.asm
 20214                              <1> ; Project name	:	XTIDE Universal BIOS
 20215                              <1> ; Description	:	Int 13h function AH=11h, Recalibrate.
 20216                              <1> 
 20217                              <1> ;
 20218                              <1> ; XTIDE Universal BIOS and Associated Tools
 20219                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 20220                              <1> ;
 20221                              <1> ; This program is free software; you can redistribute it and/or modify
 20222                              <1> ; it under the terms of the GNU General Public License as published by
 20223                              <1> ; the Free Software Foundation; either version 2 of the License, or
 20224                              <1> ; (at your option) any later version.
 20225                              <1> ;
 20226                              <1> ; This program is distributed in the hope that it will be useful,
 20227                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 20228                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 20229                              <1> ; GNU General Public License for more details.
 20230                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 20231                              <1> ;
 20232                              <1> 
 20233                              <1> ; Section containing code
 20234                              <1> SECTION .text
 20235                              <1> 
 20236                              <1> ;--------------------------------------------------------------------
 20237                              <1> ; Int 13h function AH=11h, Recalibrate.
 20238                              <1> ;
 20239                              <1> ; AH11h_HandlerForRecalibrate
 20240                              <1> ;	Parameters:
 20241                              <1> ;		DL:		Translated Drive number
 20242                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20243                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 20244                              <1> ;	Returns with INTPACK:
 20245                              <1> ;		AH:		BIOS Error code
 20246                              <1> ;		CF:		0 if successful, 1 if error
 20247                              <1> ;--------------------------------------------------------------------
 20248                              <1> AH11h_HandlerForRecalibrate:
 20249                              <1> %ifndef USE_186
 20250 0000179A E80300              <1> 	call	AH11h_RecalibrateDrive
 20251 0000179D E935FD              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20252                              <1> %else
 20253                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20254                              <1> 	; Fall to AH11h_RecalibrateDrive
 20255                              <1> %endif
 20256                              <1> 
 20257                              <1> 
 20258                              <1> ;--------------------------------------------------------------------
 20259                              <1> ; AH11h_HRecalibrate
 20260                              <1> ;	Parameters:
 20261                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20262                              <1> ;		SS:BP:	Ptr to IDEREGS_AND_INTPACK
 20263                              <1> ;	Returns:
 20264                              <1> ;		AH:		BIOS Error code
 20265                              <1> ;		CF:		0 if successful, 1 if error
 20266                              <1> ;	Corrupts registers:
 20267                              <1> ;		AL, BX, CX, DX
 20268                              <1> ;--------------------------------------------------------------------
 20269                              <1> AH11h_RecalibrateDrive:
 20270                              <1> 	; Recalibrate command is optional, vendor specific and not even
 20271                              <1> 	; supported on later ATA-standards. Let's do seek instead.
 20272 000017A0 B90100              <1> 	mov		cx, 1						; Seek to Cylinder 0, Sector 1
 20273 000017A3 30F6                <1> 	xor		dh, dh						; Head 0
 20274 000017A5 EBE5                <1> 	jmp		AHCh_SeekToCylinder
 20275                                  	%include "AH15h_HSize.asm"		; Required by Int13h_Jump.asm
 20276                              <1> ; Project name	:	XTIDE Universal BIOS
 20277                              <1> ; Description	:	Int 13h function AH=15h, Read Disk Drive Size.
 20278                              <1> 
 20279                              <1> ;
 20280                              <1> ; XTIDE Universal BIOS and Associated Tools
 20281                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 20282                              <1> ;
 20283                              <1> ; This program is free software; you can redistribute it and/or modify
 20284                              <1> ; it under the terms of the GNU General Public License as published by
 20285                              <1> ; the Free Software Foundation; either version 2 of the License, or
 20286                              <1> ; (at your option) any later version.
 20287                              <1> ;
 20288                              <1> ; This program is distributed in the hope that it will be useful,
 20289                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 20290                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 20291                              <1> ; GNU General Public License for more details.
 20292                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 20293                              <1> ;
 20294                              <1> 
 20295                              <1> ; Section containing code
 20296                              <1> SECTION .text
 20297                              <1> 
 20298                              <1> ;--------------------------------------------------------------------
 20299                              <1> ; Int 13h function AH=15h, Read Disk Drive Size.
 20300                              <1> ;
 20301                              <1> ; AH15h_HandlerForReadDiskDriveSize
 20302                              <1> ;	Parameters:
 20303                              <1> ;		DL:		Translated Drive number
 20304                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20305                              <1> ;		SS:BP:	Ptr to IDEPACK
 20306                              <1> ;	Returns with INTPACK:
 20307                              <1> ;		If successful:
 20308                              <1> ;			AH:		Hard Disk: 3 (Hard disk accessible)
 20309                              <1> ;                   Floppy:    1 (Floppy disk, without change detection)
 20310                              <1> ;			CX:DX:	Total number of sectors
 20311                              <1> ;			CF:		0
 20312                              <1> ;		If failed:
 20313                              <1> ;			AH:		0 (Drive not present)
 20314                              <1> ;			CX:DX:	0
 20315                              <1> ;			CF:		1
 20316                              <1> ;--------------------------------------------------------------------
 20317                              <1> AH15h_HandlerForReadDiskDriveSize:
 20318                              <1> %ifdef MODULE_SERIAL_FLOPPY
 20319 000017A7 B101                <1> 	mov		cl, 1										; 1 = floppy disk, no change detection
 20320                              <1> 
 20321 000017A9 84D2                <1> 	test	dl,dl										; DO NOT store the sector count if this is a
 20322 000017AB 790D                <1> 	jns		.FloppyDrive								; floppy disk, some OS's depend on this not
 20323                              <1> 														; happening for floppies in order to boot.
 20324                              <1> %endif
 20325                              <1> 
 20326 000017AD E81300              <1> 	call	AH15h_GetSectorCountToBXDXAX
 20327 000017B0 89561C              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.cx], dx			; HIWORD to CX
 20328 000017B3 87461A              <1> 	xchg	[bp+IDEPACK.intpack+INTPACK.dx], ax			; LOWORD to DX, AL gets drive number
 20329                              <1> 
 20330 000017B6 30E4                <1> 	xor		ah, ah
 20331                              <1> %ifdef MODULE_SERIAL_FLOPPY
 20332 000017B8 B103                <1> 	mov		cl, 3										; 3 = Hard Disk Accessible
 20333                              <1> .FloppyDrive:
 20334                              <1> 
 20335 000017BA E85DFD              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH_ALHasDriveNumber	; Store success to BDA and CF
 20336 000017BD 884E1F              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.ah], cl
 20337                              <1> %else
 20338                              <1> 	call	Int13h_SetErrorCodeToBdaAndToIntpackInSSBPfromAH	; Store success to BDA and CF
 20339                              <1> 	mov		BYTE [bp+IDEPACK.intpack+INTPACK.ah], 3
 20340                              <1> %endif
 20341                              <1> 
 20342 000017C0 E918FD              <1> 	jmp		Int13h_ReturnFromHandlerWithoutStoringErrorCode
 20343                              <1> 
 20344                              <1> 
 20345                              <1> ;--------------------------------------------------------------------
 20346                              <1> ; AH15h_GetSectorCountFromForeignDriveToDXAX:
 20347                              <1> ; AH15h_GetSectorCountToBXDXAX:
 20348                              <1> ;	Parameters:
 20349                              <1> ;		DL:		Drive number (AH15h_GetSectorCountFromForeignDriveToDXAX only)
 20350                              <1> ;		DS:		RAMVARS segment
 20351                              <1> ;		DS:DI:	Ptr to DPT (AH15h_GetSectorCountToDXAX only)
 20352                              <1> ;	Returns:
 20353                              <1> ;		DX:AX:	Total sector count
 20354                              <1> ;		BX:		Zero
 20355                              <1> ;	Corrupts registers:
 20356                              <1> ;		CX
 20357                              <1> ;--------------------------------------------------------------------
 20358                              <1> %ifdef MODULE_BOOT_MENU
 20359                              <1> AH15h_GetSectorCountFromForeignDriveToDXAX:
 20360                              <1> 	mov		ah, GET_DRIVE_PARAMETERS
 20361                              <1> 	call	Int13h_CallPreviousInt13hHandler
 20362                              <1> 	jmp		SHORT ConvertAH08hReturnValuesToSectorCount
 20363                              <1> %endif
 20364                              <1> 
 20365                              <1> AH15h_GetSectorCountToBXDXAX:
 20366 000017C3 E8B2FE              <1> 	call	AH8h_GetDriveParameters
 20367                              <1> 	; Fall to ConvertAH08hReturnValuesToSectorCount
 20368                              <1> 
 20369                              <1> ConvertAH08hReturnValuesToSectorCount:
 20370 000017C6 E8A800              <1> 	call	Address_ExtractLCHSparametersFromOldInt13hAddress
 20371 000017C9 88F8                <1> 	mov		al, bh		; AL = Max head number
 20372 000017CB 41                  <1> 	inc		cx			; Max cylinder number to cylinder count
 20373 000017CC 40                  <1> 	inc		ax			; Max head number to head count (AH=8h returns max 254 so no overflow to AH)
 20374 000017CD F6E3                <1> 	mul		bl			; AX = Head count * Sectors per track
 20375 000017CF F7E1                <1> 	mul		cx			; DX:AX = Total sector count for AH=0xh transfer functions
 20376 000017D1 31DB                <1> 	xor		bx, bx
 20377 000017D3 C3                  <1> 	ret
 20378                                  %ifdef MODULE_8BIT_IDE_ADVANCED
 20379                                  	%include "AH1Eh_XTCF.asm"
 20380                              <1> ; Project name	:	XTIDE Universal BIOS
 20381                              <1> ; Description	:	Int 13h function AH=1Eh, Lo-tech XT-CF features
 20382                              <1> ;
 20383                              <1> ; More information at http://www.lo-tech.co.uk/XT-CF
 20384                              <1> 
 20385                              <1> ;
 20386                              <1> ; XTIDE Universal BIOS and Associated Tools
 20387                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 20388                              <1> ;
 20389                              <1> ; This program is free software; you can redistribute it and/or modify
 20390                              <1> ; it under the terms of the GNU General Public License as published by
 20391                              <1> ; the Free Software Foundation; either version 2 of the License, or
 20392                              <1> ; (at your option) any later version.
 20393                              <1> ;
 20394                              <1> ; This program is distributed in the hope that it will be useful,
 20395                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 20396                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 20397                              <1> ; GNU General Public License for more details.
 20398                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 20399                              <1> ;
 20400                              <1> 
 20401                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 20402                              <1> 
 20403                              <1> ; Section containing code
 20404                              <1> SECTION .text
 20405                              <1> 
 20406                              <1> ;--------------------------------------------------------------------
 20407                              <1> ; Int 13h function AH=1Eh, Lo-tech XT-CF features.
 20408                              <1> ; This function is supported only by XTIDE Universal BIOS.
 20409                              <1> ;
 20410                              <1> ; AH1Eh_HandlerForXTCFfeatures
 20411                              <1> ;	Parameters:
 20412                              <1> ;		AL, CX:		Same as in INTPACK
 20413                              <1> ;		DL:		Translated Drive number
 20414                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 20415                              <1> ;		SS:BP:		Ptr to IDEPACK
 20416                              <1> ;	Parameters on INTPACK:
 20417                              <1> ;		AL:		XT-CF subcommand (see XTCF.inc for more info)
 20418                              <1> ;	Returns with INTPACK:
 20419                              <1> ;		AH:		Int 13h return status
 20420                              <1> ;		CF:		0 if successful, 1 if error
 20421                              <1> ;--------------------------------------------------------------------
 20422                              <1> AH1Eh_HandlerForXTCFfeatures:
 20423                              <1> %ifndef USE_186
 20424 000017D4 E80300              <1> 	call	ProcessXTCFsubcommandFromAL
 20425 000017D7 E9FBFC              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20426                              <1> %else
 20427                              <1> 	push		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20428                              <1> 	; Fall to ProcessXTCFsubcommandFromAL
 20429                              <1> %endif
 20430                              <1> 
 20431                              <1> 
 20432                              <1> ;--------------------------------------------------------------------
 20433                              <1> ; ProcessXTCFsubcommandFromAL
 20434                              <1> ;	Parameters:
 20435                              <1> ;		AL:		XT-CF subcommand (see XTCF.inc for more info)
 20436                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 20437                              <1> ;		SS:BP:		Ptr to IDEPACK
 20438                              <1> ;	Returns:
 20439                              <1> ;		AH:		Int 13h return status
 20440                              <1> ;		CF:		0 if successful, 1 if error
 20441                              <1> ;	Corrupts registers:
 20442                              <1> ;		AL, BX, CX, DX, SI
 20443                              <1> ;--------------------------------------------------------------------
 20444                              <1> ProcessXTCFsubcommandFromAL:
 20445                              <1> 	; IS_THIS_DRIVE_XTCF. We check this for all commands.
 20446 000017DA E801EF              <1> 	call	AccessDPT_IsThisDeviceXTCF
 20447 000017DD 7541                <1> 	jne	XTCFnotFound
 20448 000017DF 83E07F              <1> 	and		ax, BYTE 7Fh				; Subcommand now in AX (clears AH and CF)
 20449 000017E2 7408                <1> 	jz	.ReturnWithSuccess				; Sub-function IS_THIS_DRIVE_XTCF (=0)
 20450                              <1> 
 20451 000017E4 48                  <1> 	dec		ax					; Test subcommand...
 20452 000017E5 7406                <1> 	jz	.GetXTCFtransferMode				; ...for value 1 (GET_XTCF_TRANSFER_MODE)
 20453 000017E7 48                  <1> 	dec		ax					; Test subcommand...
 20454 000017E8 740A                <1> 	jz	.SetXTCFtransferMode				; ...for value 2 (SET_XTCF_TRANSFER_MODE)
 20455 000017EA EB34                <1> 	jmp	XTCFnotFound					; otherwise, invalid sub-function requested
 20456                              <1> 
 20457                              <1> .ReturnWithSuccess:
 20458 000017EC C3                  <1> 	ret							; return with AH and CF cleared
 20459                              <1> 
 20460                              <1> .GetXTCFtransferMode:
 20461 000017ED 8A4514              <1> 	mov		al, BYTE [di+DPT_ATA.bDevice]		; get current mode from DPT
 20462 000017F0 88461B              <1> 	mov		[bp+IDEPACK.intpack+INTPACK.dh], al	; and return mode via INTPACK...
 20463 000017F3 C3                  <1> 	ret							; ...with AH and CF cleared
 20464                              <1> 
 20465                              <1> .SetXTCFtransferMode:
 20466 000017F4 8A461B              <1> 	mov		al, [bp+IDEPACK.intpack+INTPACK.dh]	; get specified mode (eg XTCF_DMA_MODE) 
 20467                              <1> 	; and fall to AH1Eh_ChangeXTCFmodeBasedOnControlRegisterInAL
 20468                              <1> 
 20469                              <1> 
 20470                              <1> ;--------------------------------------------------------------------
 20471                              <1> ; AH1Eh_ChangeXTCFmodeBasedOnModeInAL
 20472                              <1> ;	Parameters:
 20473                              <1> ;		AL:		XT-CF Mode (see XTCF.inc)
 20474                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 20475                              <1> ;		SS:BP:		Ptr to IDEPACK
 20476                              <1> ;	Returns:	
 20477                              <1> ;		AH:		Int 13h return status
 20478                              <1> ;		CF:		0 if successful, 1 if error
 20479                              <1> ;	Corrupts registers:
 20480                              <1> ;		AL, BX, CX, DX, SI
 20481                              <1> ;--------------------------------------------------------------------
 20482                              <1> AH1Eh_ChangeXTCFmodeBasedOnModeInAL:
 20483                              <1> 	; Note: Control register (as of XT-CFv3) is now a write-only register,
 20484                              <1> 	;       whos purpose is *only* to raise DRQ.  The register cannot be read.
 20485                              <1> 	;       Selected transfer mode is stored in BIOS variable (DPT_ATA.bDevice).
 20486                              <1> 
 20487                              <1> 	; We always need to enable 8-bit mode since 16-bit mode is restored
 20488                              <1> 	; when controller is reset (AH=00h or 0Dh)
 20489                              <1> 	; 
 20490                              <1> 	; Note that when selecting 'DEVICE_8BIT_PIO_MODE_WITH_BIU_OFFLOAD' mode,
 20491                              <1> 	; the ATA device (i.e. CompactFlash card) will operate in 8-bit mode, but
 20492                              <1> 	; data will be transferred from it's data register using 16-bit CPU instructions
 20493                              <1> 	; like REP INSW.  This works because XT-CF adapters are 8-bit cards, and
 20494                              <1> 	; the BIU in the machine splits each WORD requested by the CPU into two 8-bit
 20495                              <1> 	; ISA cycles at base+0h and base+1h.  The XT-CF cards do not decode A0, hence
 20496                              <1> 	; both accesses appear the same to the card and the BIU then re-constructs
 20497                              <1> 	; the data for presentation to the CPU.
 20498                              <1> 	;
 20499                              <1> 	; Also note though that some machines, noteably AT&T PC6300, have hardware
 20500                              <1> 	; errors in the BIU logic, resulting in reversed byte ordering.  Therefore,
 20501                              <1> 	; mode DEVICE_8BIT_PIO is the default transfer mode for best system
 20502                              <1> 	; compatibility.
 20503                              <1> 
 20504                              <1> 	ePUSH_T	bx, AH23h_Enable8bitPioMode
 20505                              <2> %ifndef USE_186
 20506                              <2>  %ifidni %2, 0
 20507                              <2>  xor %1, %1
 20508                              <2>  %else
 20509 000017F7 BB[3618]            <2>  mov %1, %2
 20510                              <2>  %endif
 20511 000017FA 53                  <2>  push %1
 20512                              <2> 
 20513                              <2> %else
 20514                              <2>  push %2
 20515                              <2> %endif
 20516                              <1> 
 20517                              <1> 	; Convert mode to device type (see XTCF.inc for full details)
 20518 000017FB 0400                <1> 	add		al, 0			; XTCF_8BIT_PIO_MODE = 0
 20519 000017FD 7408                <1> 	jz	.Set8bitPioMode
 20520 000017FF FEC8                <1> 	dec		al			; XTCF_8BIT_PIO_MODE_WITH_BIU_OFFLOAD = 1
 20521 00001801 7409                <1> 	jz	.Set8bitPioModeWithBIUOffload
 20522 00001803 FEC8                <1> 	dec		al			; XTCF_DMA_MODE = 2
 20523 00001805 740A                <1> 	jz	.SetDMATransferMode
 20524                              <1> 	; any other value, set PIO 8-bit mode anyway so fall to .Set8bitPioMode
 20525                              <1> 
 20526                              <1> .Set8bitPioMode:
 20527 00001807 C645140A            <1> 	mov		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_XTCF_PIO8
 20528 0000180B C3                  <1> 	ret		; through AH23h_Enable8bitPioMode
 20529                              <1> 
 20530                              <1> .Set8bitPioModeWithBIUOffload:
 20531 0000180C C645140C            <1> 	mov		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_XTCF_PIO8_WITH_BIU_OFFLOAD
 20532 00001810 C3                  <1> 	ret		; through AH23h_Enable8bitPioMode
 20533                              <1> 
 20534                              <1> .SetDMATransferMode:
 20535 00001811 C645140E            <1> 	mov		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_XTCF_DMA
 20536                              <1> 	; DMA transfers have limited block size, which is checked in AH24h_SetBlockSize
 20537 00001815 8A4515              <1> 	mov		al, [di+DPT_ATA.bBlockSize]
 20538 00001818 EB27                <1> 	jmp	AH24h_SetBlockSize
 20539                              <1> 	; exit via ret in AH24_SetBlockSize then through AH23h_Enable8bitPioMode
 20540                              <1> 
 20541                              <1> 
 20542                              <1> ;--------------------------------------------------------------------
 20543                              <1> ; AH1Eh_DetectXTCFwithBasePortInDX
 20544                              <1> ;	Parameters:
 20545                              <1> ;		DX:		Base I/O port address to check
 20546                              <1> ;	Returns:
 20547                              <1> ;		AH:		RET_HD_SUCCESS if XT-CF is found from port
 20548                              <1> ;				RET_HD_INVALID if XT-CF is not found
 20549                              <1> ;		CF:		Cleared if XT-CF found
 20550                              <1> ;				Set if XT-CF not found
 20551                              <1> ;	Corrupts registers:
 20552                              <1> ;		AL
 20553                              <1> ;--------------------------------------------------------------------
 20554                              <1> AH1Eh_DetectXTCFwithBasePortInDX:
 20555                              <1> ; Note this detection routine is not possible now, since the control
 20556                              <1> ; register cannot be read.
 20557                              <1> ; 
 20558                              <1> ; Hard-coded to return found at 300h, to enable testing of the rest of the
 20559                              <1> ; BIOS.
 20560                              <1> ;
 20561                              <1> ;	push		dx
 20562                              <1> ;	add		dl, XTCF_CONTROL_REGISTER_INVERTED_in	; set DX to XT-CF config register (inverted)
 20563                              <1> ;	in		al, dx		; get value
 20564                              <1> ;	mov		ah, al		; save in ah
 20565                              <1> ;	inc		dx			; set DX to XT-CF config register (non-inverted)
 20566                              <1> ;	in		al, dx		; get value
 20567                              <1> ;	not		al			; invert value
 20568                              <1> ;	pop		dx
 20569                              <1> ;	sub		ah, al		; do they match? (clear AH if they do)
 20570                              <1> ;	jz		SHORT XTCFfound
 20571                              <1> ;
 20572 0000181A 81FA0003            <1> 	cmp		dx, 300h
 20573 0000181E 7403                <1> 	je	XTCFfound
 20574                              <1> 
 20575                              <1> XTCFnotFound:
 20576                              <1> AH1Eh_LoadInvalidCommandToAHandSetCF:
 20577 00001820 F9                  <1> 	stc					; set carry flag since XT-CF not found
 20578 00001821 B401                <1> 	mov		ah, RET_HD_INVALID
 20579                              <1> XTCFfound:
 20580 00001823 C3                  <1> 	ret					; and return
 20581                              <1> 
 20582                                  %endif
 20583                                  	%include "AH23h_HFeatures.asm"	; Required by Int13h_Jump.asm
 20584                              <1> ; Project name	:	XTIDE Universal BIOS
 20585                              <1> ; Description	:	Int 13h function AH=23h,
 20586                              <1> ;					Set Controller Features Register.
 20587                              <1> 
 20588                              <1> ;
 20589                              <1> ; XTIDE Universal BIOS and Associated Tools
 20590                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 20591                              <1> ;
 20592                              <1> ; This program is free software; you can redistribute it and/or modify
 20593                              <1> ; it under the terms of the GNU General Public License as published by
 20594                              <1> ; the Free Software Foundation; either version 2 of the License, or
 20595                              <1> ; (at your option) any later version.
 20596                              <1> ;
 20597                              <1> ; This program is distributed in the hope that it will be useful,
 20598                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 20599                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 20600                              <1> ; GNU General Public License for more details.
 20601                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 20602                              <1> ;
 20603                              <1> 
 20604                              <1> ; Section containing code
 20605                              <1> SECTION .text
 20606                              <1> 
 20607                              <1> ;--------------------------------------------------------------------
 20608                              <1> ; Int 13h function AH=23h, Set Controller Features Register.
 20609                              <1> ;
 20610                              <1> ; AH23h_HandlerForSetControllerFeatures
 20611                              <1> ;	Parameters:
 20612                              <1> ;		AL, CX:	Same as in INTPACK
 20613                              <1> ;		DL:		Translated Drive number
 20614                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20615                              <1> ;		SS:BP:	Ptr to IDEPACK
 20616                              <1> ;	Parameters on INTPACK:
 20617                              <1> ;		AL:		Feature Number (parameter to Features Register = subcommand)
 20618                              <1> ;	(Parameter registers are undocumented, these are specific for this BIOS):
 20619                              <1> ;		BL:		Parameter to Sector Count Register (subcommand specific)
 20620                              <1> ;		BH:		Parameter to LBA Low / Sector Number Register (subcommand specific)
 20621                              <1> ;		CL:		Parameter to LBA Middle / Cylinder Low Register (subcommand specific)
 20622                              <1> ;		CH:		Parameter to LBA High / Cylinder High Register (subcommand specific)
 20623                              <1> ;	Returns with INTPACK:
 20624                              <1> ;		AH:		Int 13h return status
 20625                              <1> ;		CF:		0 if successful, 1 if error
 20626                              <1> ;--------------------------------------------------------------------
 20627                              <1> AH23h_HandlerForSetControllerFeatures:
 20628 00001824 96                  <1> 	xchg	si, ax		; SI = Feature Number
 20629 00001825 8B5618              <1> 	mov		dx, [bp+IDEPACK.intpack+INTPACK.bx]
 20630                              <1> %ifndef USE_186
 20631 00001828 E80300              <1> 	call	AH23h_SetControllerFeatures
 20632 0000182B E9A7FC              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20633                              <1> %else
 20634                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20635                              <1> 	; Fall to AH23h_SetControllerFeatures
 20636                              <1> %endif
 20637                              <1> 
 20638                              <1> 
 20639                              <1> ;--------------------------------------------------------------------
 20640                              <1> ; AH23h_SetControllerFeatures
 20641                              <1> ;	Parameters:
 20642                              <1> ;		DL:		Parameter to Sector Count Register (subcommand specific)
 20643                              <1> ;		DH:		Parameter to LBA Low / Sector Number Register (subcommand specific)
 20644                              <1> ;		CL:		Parameter to LBA Middle / Cylinder Low Register (subcommand specific)
 20645                              <1> ;		CH:		Parameter to LBA High / Cylinder High Register (subcommand specific)
 20646                              <1> ;		SI:		Feature Number (parameter to Features Register = subcommand)
 20647                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20648                              <1> ;		SS:BP:	Ptr to IDEPACK
 20649                              <1> ;	Returns:
 20650                              <1> ;		AH:		Int 13h return status
 20651                              <1> ;		CF:		0 if successful, 1 if error
 20652                              <1> ;	Corrupts registers:
 20653                              <1> ;		AL, BX, CX, DX
 20654                              <1> ;--------------------------------------------------------------------
 20655                              <1> AH23h_SetControllerFeatures:
 20656 0000182E B0EF                <1> 	mov		al, COMMAND_SET_FEATURES
 20657 00001830 BB80B5              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_BSY, FLG_STATUS_BSY)
 20658 00001833 E90CF4              <1> 	jmp		Idepack_StoreNonExtParametersAndIssueCommandFromAL
 20659                              <1> 
 20660                              <1> 
 20661                              <1> ;--------------------------------------------------------------------
 20662                              <1> ; AH23h_Enable8bitPioMode
 20663                              <1> ;	Parameters:
 20664                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20665                              <1> ;		SS:BP:	Ptr to IDEPACK
 20666                              <1> ;	Returns:
 20667                              <1> ;		AH:		Int 13h return status
 20668                              <1> ;		CF:		0 if successful, 1 if error
 20669                              <1> ;	Corrupts registers:
 20670                              <1> ;		AL, BX, CX, DX, SI
 20671                              <1> ;--------------------------------------------------------------------
 20672                              <1> %ifdef MODULE_8BIT_IDE
 20673                              <1> AH23h_Enable8bitPioMode:
 20674 00001836 BE0100              <1> 	mov		si, FEATURE_ENABLE_8BIT_PIO_TRANSFER_MODE
 20675 00001839 EBF3                <1> 	jmp		SHORT AH23h_SetControllerFeatures
 20676                              <1> %endif
 20677                                  	%include "AH24h_HSetBlocks.asm"	; Required by Int13h_Jump.asm
 20678                              <1> ; Project name	:	XTIDE Universal BIOS
 20679                              <1> ; Description	:	Int 13h function AH=24h, Set Multiple Blocks.
 20680                              <1> 
 20681                              <1> ;
 20682                              <1> ; XTIDE Universal BIOS and Associated Tools
 20683                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 20684                              <1> ;
 20685                              <1> ; This program is free software; you can redistribute it and/or modify
 20686                              <1> ; it under the terms of the GNU General Public License as published by
 20687                              <1> ; the Free Software Foundation; either version 2 of the License, or
 20688                              <1> ; (at your option) any later version.
 20689                              <1> ;
 20690                              <1> ; This program is distributed in the hope that it will be useful,
 20691                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 20692                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 20693                              <1> ; GNU General Public License for more details.
 20694                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 20695                              <1> ;
 20696                              <1> 
 20697                              <1> ; Modified by JJP for XT-CFv3 support, Mar-13
 20698                              <1> 
 20699                              <1> ; Section containing code
 20700                              <1> SECTION .text
 20701                              <1> 
 20702                              <1> ;--------------------------------------------------------------------
 20703                              <1> ; Int 13h function AH=24h, Set Multiple Blocks.
 20704                              <1> ;
 20705                              <1> ; AH24h_HandlerForSetMultipleBlocks
 20706                              <1> ;	Parameters:
 20707                              <1> ;		AL:		Same as in INTPACK
 20708                              <1> ;		DL:		Translated Drive number
 20709                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20710                              <1> ;		SS:BP:	Ptr to IDEPACK
 20711                              <1> ;	Parameters on INTPACK:
 20712                              <1> ;		AL:		Number of Sectors per Block (1, 2, 4, 8, 16, 32, 64 or 128)
 20713                              <1> ;	Returns with INTPACK:
 20714                              <1> ;		AH:		Int 13h return status
 20715                              <1> ;		CF:		0 if successful, 1 if error
 20716                              <1> ;--------------------------------------------------------------------
 20717                              <1> AH24h_HandlerForSetMultipleBlocks:
 20718                              <1> %ifndef USE_186
 20719 0000183B E80300              <1> 	call	AH24h_SetBlockSize
 20720 0000183E E994FC              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20721                              <1> %else
 20722                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20723                              <1> 	; Fall to AH24h_SetBlockSize
 20724                              <1> %endif
 20725                              <1> 
 20726                              <1> 
 20727                              <1> ;--------------------------------------------------------------------
 20728                              <1> ; AH24h_SetBlockSize
 20729                              <1> ;	Parameters:
 20730                              <1> ;		AL:		Number of Sectors per Block (1, 2, 4, 8, 16, 32, 64 or 128)
 20731                              <1> ;		DS:DI:		Ptr to DPT (in RAMVARS segment)
 20732                              <1> ;		SS:BP:		Ptr to IDEPACK
 20733                              <1> ;	Returns:
 20734                              <1> ;		AH:		Int 13h return status
 20735                              <1> ;		CF:		0 if successful, 1 if error
 20736                              <1> ;	Corrupts registers:
 20737                              <1> ;		AL, CX, DX
 20738                              <1> ;--------------------------------------------------------------------
 20739                              <1> AH24h_SetBlockSize:
 20740                              <1> %ifdef MODULE_8BIT_IDE
 20741                              <1> 	; XT-CFv3 does not support largest block size in DMA mode,
 20742                              <1> 	; so check for that device:
 20743 00001841 807D140E            <1> 	cmp		BYTE [di+DPT_ATA.bDevice], DEVICE_8BIT_XTCF_DMA
 20744 00001845 7506                <1> 	jne	.SetBlockSize
 20745                              <1> 	; XT-CFv3 in DMA mode selected - check requested block size
 20746 00001847 3C40                <1> 	cmp		al, XTCF_DMA_MODE_MAX_BLOCK_SIZE
 20747 00001849 7602                <1> 	jbe	.SetBlockSize
 20748                              <1> 	; Otherwise, limit block size to maximum permitted
 20749 0000184B B040                <1> 	mov		al, XTCF_DMA_MODE_MAX_BLOCK_SIZE
 20750                              <1> .SetBlockSize:
 20751                              <1> %endif ; MODULE_8BIT_IDE
 20752 0000184D 53                  <1> 	push		bx
 20753 0000184E 50                  <1> 	push		ax
 20754 0000184F 92                  <1> 	xchg		dx, ax				; DL = Block size (Sector Count Register)
 20755 00001850 B0C6                <1> 	mov		al, COMMAND_SET_MULTIPLE_MODE
 20756 00001852 BB40B5              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRDY, FLG_STATUS_DRDY)
 20757 00001855 E8EAF3              <1> 	call	Idepack_StoreNonExtParametersAndIssueCommandFromAL
 20758 00001858 5B                  <1> 	pop		bx				; BL = Block size (preserve AH)
 20759 00001859 7302                <1> 	jnc	SHORT .StoreBlockSize
 20760 0000185B B301                <1> 	mov		bl, 1				; Block size 1 will always work
 20761                              <1> .StoreBlockSize:					; Store new block size to DPT and return
 20762 0000185D 885D15              <1> 	mov		[di+DPT_ATA.bBlockSize], bl
 20763 00001860 5B                  <1> 	pop		bx
 20764 00001861 C3                  <1> 	ret
 20765                              <1> 
 20766                                  	%include "AH25h_HDrvID.asm"		; Required by Int13h_Jump.asm
 20767                              <1> ; Project name	:	XTIDE Universal BIOS
 20768                              <1> ; Description	:	Int 13h function AH=25h, Get Drive Information.
 20769                              <1> 
 20770                              <1> ;
 20771                              <1> ; XTIDE Universal BIOS and Associated Tools
 20772                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 20773                              <1> ;
 20774                              <1> ; This program is free software; you can redistribute it and/or modify
 20775                              <1> ; it under the terms of the GNU General Public License as published by
 20776                              <1> ; the Free Software Foundation; either version 2 of the License, or
 20777                              <1> ; (at your option) any later version.
 20778                              <1> ;
 20779                              <1> ; This program is distributed in the hope that it will be useful,
 20780                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 20781                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 20782                              <1> ; GNU General Public License for more details.
 20783                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 20784                              <1> ;
 20785                              <1> 
 20786                              <1> ; Section containing code
 20787                              <1> SECTION .text
 20788                              <1> 
 20789                              <1> ;--------------------------------------------------------------------
 20790                              <1> ; Int 13h function AH=25h, Get Drive Information.
 20791                              <1> ;
 20792                              <1> ; AH25h_HandlerForGetDriveInformation
 20793                              <1> ;	Parameters:
 20794                              <1> ;		ES:		Same as in INTPACK
 20795                              <1> ;		DL:		Translated Drive number
 20796                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 20797                              <1> ;		SS:BP:	Ptr to IDEPACK
 20798                              <1> ;	Parameters on INTPACK:
 20799                              <1> ;		ES:BX:	Ptr to buffer to receive 512-byte drive information
 20800                              <1> ;	Returns with INTPACK:
 20801                              <1> ;		AH:		Int 13h return status
 20802                              <1> ;		CF:		0 if successful, 1 if error
 20803                              <1> ;--------------------------------------------------------------------
 20804                              <1> AH25h_HandlerForGetDriveInformation:
 20805 00001862 B801EC              <1> 	mov		ax, (COMMAND_IDENTIFY_DEVICE << 8 | 1)		; Read 1 sector
 20806 00001865 E88F00              <1> 	call	Prepare_BufferToESSIforOldInt13hTransfer	; Preserves AX
 20807 00001868 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 20808                              <1> %ifdef USE_186
 20809                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20810                              <1> 	jmp		Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 20811                              <1> %else
 20812 0000186B E8B3F3              <1> 	call	Idepack_TranslateOldInt13hAddressAndIssueCommandFromAH
 20813 0000186E E964FC              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 20814                              <1> %endif
 20815                                  	%include "Address.asm"			; For sector address translations
 20816                              <1> ; Project name	:	XTIDE Universal BIOS
 20817                              <1> ; Description	:	Functions for address translations.
 20818                              <1> 
 20819                              <1> ;
 20820                              <1> ; XTIDE Universal BIOS and Associated Tools
 20821                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 20822                              <1> ;
 20823                              <1> ; This program is free software; you can redistribute it and/or modify
 20824                              <1> ; it under the terms of the GNU General Public License as published by
 20825                              <1> ; the Free Software Foundation; either version 2 of the License, or
 20826                              <1> ; (at your option) any later version.
 20827                              <1> ;
 20828                              <1> ; This program is distributed in the hope that it will be useful,
 20829                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 20830                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 20831                              <1> ; GNU General Public License for more details.
 20832                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 20833                              <1> ;
 20834                              <1> 
 20835                              <1> ; Section containing code
 20836                              <1> SECTION .text
 20837                              <1> 
 20838                              <1> ;---------------------------------------------------------------------
 20839                              <1> ; Address_ExtractLCHSparametersFromOldInt13hAddress
 20840                              <1> ;	Parameters:
 20841                              <1> ;		CH:		Cylinder number, bits 7...0
 20842                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 20843                              <1> ;				Bits 5...0:	Sector number
 20844                              <1> ;		DH:		Head number
 20845                              <1> ;	Returns:
 20846                              <1> ;		BL:		Sector number (1...63)
 20847                              <1> ;		BH:		Head number (0...255)
 20848                              <1> ;		CX:		Cylinder number (0...1023)
 20849                              <1> ;	Corrupts registers:
 20850                              <1> ;		Nothing
 20851                              <1> ;--------------------------------------------------------------------
 20852                              <1> ALIGN JUMP_ALIGN
 20853                              <1> Address_ExtractLCHSparametersFromOldInt13hAddress:
 20854 00001871 88CB                <1> 	mov		bl, cl				; Copy sector number...
 20855 00001873 80E33F              <1> 	and		bl, 3Fh				; ...and limit to 1...63
 20856 00001876 28D9                <1> 	sub		cl, bl				; Remove from cylinder number high
 20857                              <1> 	eROL_IM	cl, 2				; High bits to beginning
 20858                              <2>  eSHIFT_IM %1, %2, rol
 20859                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 20860                              <3> %ifndef USE_186
 20861                              <3>  %ifidni %1, cl
 20862 00001878 D0C1<rept>          <3>  times %2 %3 %1, 1
 20863                              <3>  %elifidni %1, ch
 20864                              <3>  times %2 %3 %1, 1
 20865                              <3>  %elifidni %1, cx
 20866                              <3>  times %2 %3 %1, 1
 20867                              <3>  %else
 20868                              <3>  %if %2 > 3
 20869                              <3>  push cx
 20870                              <3>  mov cl, %2
 20871                              <3>  %3 %1, cl
 20872                              <3>  pop cx
 20873                              <3>  %else
 20874                              <3>  times %2 %3 %1, 1
 20875                              <3>  %endif
 20876                              <3>  %endif
 20877                              <3> 
 20878                              <3> %else
 20879                              <3>  %3 %1, %2
 20880                              <3> %endif
 20881                              <3> %endif
 20882 0000187C 88F7                <1> 	mov		bh, dh				; Copy Head number
 20883 0000187E 86CD                <1> 	xchg	cl, ch				; Cylinder number now in CX
 20884 00001880 C3                  <1> 	ret
 20885                              <1> 
 20886                              <1> 
 20887                              <1> ;---------------------------------------------------------------------
 20888                              <1> ; Converts LARGE addressing mode LCHS parameters to IDE P-CHS parameters.
 20889                              <1> ; PCylinder	= (LCylinder << n) + (LHead / PHeadCount)
 20890                              <1> ; PHead		= LHead % PHeadCount
 20891                              <1> ; PSector	= LSector
 20892                              <1> ;
 20893                              <1> ; ConvertLargeModeLCHStoPCHS:
 20894                              <1> ;	Parameters:
 20895                              <1> ;		BL:		Sector number (1...63)
 20896                              <1> ;		BH:		Head number (0...239)
 20897                              <1> ;		CX:		Cylinder number (0...1023)
 20898                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 20899                              <1> ;	Returns:
 20900                              <1> ;		BL:		Sector number (1...63)
 20901                              <1> ;		BH:		Head number (0...15)
 20902                              <1> ;		CX:		Cylinder number (0...16382)
 20903                              <1> ;	Corrupts registers:
 20904                              <1> ;		AX, DX
 20905                              <1> ;--------------------------------------------------------------------
 20906                              <1> ALIGN JUMP_ALIGN
 20907                              <1> ConvertLargeModeLCHStoPCHS:
 20908                              <1> 	; LHead / PHeadCount and LHead % PHeadCount
 20909                              <1> 	eMOVZX	ax, bh					; Copy L-CHS Head number to AX
 20910                              <2> %ifndef USE_386
 20911                              <2>  %ifidni %1, ax
 20912 00001881 88F8                <2>  mov al, %2
 20913 00001883 30E4                <2>  xor ah, ah
 20914                              <2>  %elifidni %1, bx
 20915                              <2>  mov bl, %2
 20916                              <2>  xor bh, bh
 20917                              <2>  %elifidni %1, cx
 20918                              <2>  mov cl, %2
 20919                              <2>  xor ch, ch
 20920                              <2>  %elifidni %1, dx
 20921                              <2>  mov dl, %2
 20922                              <2>  xor dh, dh
 20923                              <2>  %else
 20924                              <2>  push ax
 20925                              <2>  mov al, %2
 20926                              <2>  xor ah, ah
 20927                              <2>  xchg ax, %1
 20928                              <2>  pop ax
 20929                              <2>  %endif
 20930                              <2> 
 20931                              <2> %else
 20932                              <2>  movzx %1, %2
 20933                              <2> %endif
 20934 00001885 F6750A              <1> 	div		BYTE [di+DPT.bPchsHeads]; AL = LHead / PHeadCount, AH = LHead % PHeadCount
 20935 00001888 88E7                <1> 	mov		bh, ah					; Copy P-CHS Head number to BH
 20936 0000188A 30E4                <1> 	xor		ah, ah					; AX = LHead / PHeadCount
 20937                              <1> 
 20938                              <1> 	; (LCylinder << n) + (LHead / PHeadCount)
 20939 0000188C 89CA                <1> 	mov		dx, cx					; Copy L-CHS Cylinder number to DX
 20940 0000188E 8A0D                <1> 	mov		cl, [di+DPT.bFlagsLow]	; Load shift count
 20941 00001890 80E103              <1> 	and		cl, MASKL_DPT_CHS_SHIFT_COUNT
 20942 00001893 D3E2                <1> 	shl		dx, cl					; DX = LCylinder << n
 20943 00001895 01D0                <1> 	add		ax, dx					; AX = P-CHS Cylinder number
 20944 00001897 91                  <1> 	xchg	cx, ax					; Move P-CHS Cylinder number to CX
 20945                              <1> DoNotConvertLCHS:
 20946 00001898 C3                  <1> 	ret
 20947                              <1> 
 20948                              <1> 
 20949                              <1> ;--------------------------------------------------------------------
 20950                              <1> ; Address_OldInt13hAddressToIdeAddress
 20951                              <1> ;	Parameters:
 20952                              <1> ;		CH:		Cylinder number, bits 7...0
 20953                              <1> ;		CL:		Bits 7...6: Cylinder number bits 9 and 8
 20954                              <1> ;				Bits 5...0:	Starting sector number (1...63)
 20955                              <1> ;		DH:		Starting head number (0...255)
 20956                              <1> ;		DS:DI:	Ptr to DPT
 20957                              <1> ;	Returns:
 20958                              <1> ;		BL:		LBA Low Register / Sector Number Register (LBA 7...0)
 20959                              <1> ;		CL:		LBA Mid Register / Low Cylinder Register (LBA 15...8)
 20960                              <1> ;		CH:		LBA High Register / High Cylinder Register (LBA 23...16)
 20961                              <1> ;		BH:		Drive and Head Register (LBA 27...24)
 20962                              <1> ;	Corrupts registers:
 20963                              <1> ;		AX, DX
 20964                              <1> ;--------------------------------------------------------------------
 20965                              <1> ALIGN JUMP_ALIGN
 20966                              <1> Address_OldInt13hAddressToIdeAddress:
 20967 00001899 E8D5FF              <1> 		call	Address_ExtractLCHSparametersFromOldInt13hAddress
 20968                              <1> 		ACCESSDPT__GET_UNSHIFTED_TRANSLATE_MODE_TO_AXZF
 20969 0000189C 8A05                <2>  mov al, [di+DPT.bFlagsLow]
 20970 0000189E 83E00C              <2>  and ax, BYTE MASKL_DPT_TRANSLATEMODE
 20971                              <1> 
 20972                              <1> ;;; 0: ADDRESSING_MODE_NORMAL
 20973 000018A1 74F5                <1> 		jz		SHORT DoNotConvertLCHS
 20974                              <1> 
 20975                              <1> ;;; 1: ADDRESSING_MODE_LARGE
 20976 000018A3 A808                <1> 		test	al, FLGL_DPT_ASSISTED_LBA
 20977 000018A5 74DA                <1> 		jz		SHORT ConvertLargeModeLCHStoPCHS
 20978                              <1> 
 20979                              <1> ;;; 2: ADDRESSING_MODE_ASSISTED_LBA
 20980                              <1> 		; Fall through to ConvertAssistedLBAModeLCHStoLBARegisterValues
 20981                              <1> 
 20982                              <1> 
 20983                              <1> ;---------------------------------------------------------------------
 20984                              <1> ; Converts LCHS parameters to 28-bit LBA address.
 20985                              <1> ; Only 24-bits are used since LHCS to LBA28 conversion has 8.4GB limit.
 20986                              <1> ; LBA = ((cylToSeek*headsPerCyl+headToSeek)*sectPerTrack)+sectToSeek-1
 20987                              <1> ;
 20988                              <1> ; Returned address is in same registers that
 20989                              <1> ; DoNotConvertLCHS and ConvertLargeModeLCHStoPCHS returns.
 20990                              <1> ;
 20991                              <1> ; ConvertAssistedLBAModeLCHStoLBARegisterValues:
 20992                              <1> ;	Parameters:
 20993                              <1> ;		BL:		Sector number (1...63)
 20994                              <1> ;		BH:		Head number (0...254)
 20995                              <1> ;		CX:		Cylinder number (0...1023)
 20996                              <1> ;		DS:DI:	Ptr to Disk Parameter Table
 20997                              <1> ;	Returns:
 20998                              <1> ;		BL:		LBA Low Register / Sector Number Register (LBA 7...0)
 20999                              <1> ;		CL:		LBA Mid Register / Low Cylinder Register (LBA 15...8)
 21000                              <1> ;		CH:		LBA High Register / High Cylinder Register (LBA 23...16)
 21001                              <1> ;		BH:		Drive and Head Register (LBA 27...24)
 21002                              <1> ;	Corrupts registers:
 21003                              <1> ;		AX, DX
 21004                              <1> ;--------------------------------------------------------------------
 21005                              <1> ConvertAssistedLBAModeLCHStoLBARegisterValues:
 21006                              <1> 	; cylToSeek*headsPerCyl (18-bit result)
 21007                              <1> 	; Max = 1023 * 255 = 260,865 = 3FB01h
 21008 000018A7 B83F00              <1> 	mov		ax, LBA_ASSIST_SPT		; Load Sectors per Track
 21009 000018AA 91                  <1> 	xchg	cx, ax					; Cylinder number to AX, Sectors per Track to CX
 21010                              <1> %ifdef USE_386
 21011                              <1> 	movzx	dx, [di+DPT.bLchsHeads]
 21012                              <1> %else
 21013 000018AB 99                  <1> 	cwd
 21014 000018AC 8A5508              <1> 	mov		dl, [di+DPT.bLchsHeads]
 21015                              <1> %endif
 21016 000018AF F7E2                <1> 	mul		dx						; DX:AX = cylToSeek*headsPerCyl
 21017                              <1> 
 21018                              <1> 	; +=headToSeek (18-bit result)
 21019                              <1> 	; Max = 260,865 + 254 = 261,119 = 3FBFFh
 21020 000018B1 00F8                <1> 	add		al, bh					; Add Head number to DX:AX
 21021 000018B3 10F4                <1> 	adc		ah, dh					; DH = Zero after previous multiplication
 21022 000018B5 10F2                <1> 	adc		dl, dh
 21023                              <1> 
 21024                              <1> 	; *=sectPerTrack (18-bit by 6-bit multiplication with 24-bit result)
 21025                              <1> 	; Max = 261,119 * 63 = 16,450,497 = FB03C1h
 21026 000018B7 92                  <1> 	xchg	ax, dx					; Hiword to AX, loword to DX
 21027 000018B8 F6E1                <1> 	mul		cl						; AX = hiword * Sectors per Track
 21028 000018BA 88C7                <1> 	mov		bh, al					; Backup hiword * Sectors per Track
 21029 000018BC 92                  <1> 	xchg	ax, dx					; Loword back to AX
 21030 000018BD F7E1                <1> 	mul		cx						; DX:AX = loword * Sectors per Track
 21031 000018BF 00FA                <1> 	add		dl, bh					; DX:AX = (cylToSeek*headsPerCyl+headToSeek)*sectPerTrack
 21032                              <1> 
 21033                              <1> 	; +=sectToSeek-1 (24-bit result)
 21034                              <1> 	; Max = 16,450,497 + 63 - 1 = 16,450,559 = FB03FFh
 21035 000018C1 30FF                <1> 	xor		bh, bh					; Sector number now in BX
 21036 000018C3 4B                  <1> 	dec		bx						; sectToSeek-=1
 21037 000018C4 01D8                <1> 	add		ax, bx					; Add to loword
 21038 000018C6 10FA                <1> 	adc		dl, bh					; Add possible carry to byte2, BH=zero
 21039                              <1> 
 21040                              <1> 	; Copy DX:AX to proper return registers
 21041 000018C8 93                  <1> 	xchg	bx, ax					; BL = Sector Number Register (LBA 7...0)
 21042 000018C9 88F9                <1> 	mov		cl, bh					; Low Cylinder Register (LBA 15...8)
 21043 000018CB 88D5                <1> 	mov		ch, dl					; High Cylinder Register (LBA 23...16)
 21044 000018CD 88F7                <1> 	mov		bh, dh					; Drive and Head Register (LBA 27...24)
 21045 000018CF C3                  <1> 	ret
 21046                                  	%include "Prepare.asm"			; For buffer pointer normalization
 21047                              <1> ; Project name	:	XTIDE Universal BIOS
 21048                              <1> ; Description	:	Functions for preparing data buffer for transfer.
 21049                              <1> 
 21050                              <1> ;
 21051                              <1> ; XTIDE Universal BIOS and Associated Tools
 21052                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 21053                              <1> ;
 21054                              <1> ; This program is free software; you can redistribute it and/or modify
 21055                              <1> ; it under the terms of the GNU General Public License as published by
 21056                              <1> ; the Free Software Foundation; either version 2 of the License, or
 21057                              <1> ; (at your option) any later version.
 21058                              <1> ;
 21059                              <1> ; This program is distributed in the hope that it will be useful,
 21060                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 21061                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 21062                              <1> ; GNU General Public License for more details.
 21063                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 21064                              <1> ;
 21065                              <1> 
 21066                              <1> ; Section containing code
 21067                              <1> SECTION .text
 21068                              <1> 
 21069                              <1> ;--------------------------------------------------------------------
 21070                              <1> ; Prepare_ByLoadingDapToESSIandVerifyingForTransfer
 21071                              <1> ;	Parameters:
 21072                              <1> ;		SI:		Offset to DAP
 21073                              <1> ;		DS:DI:	Ptr to DPT
 21074                              <1> ;		SS:BP:	Ptr to IDEPACK
 21075                              <1> ;	Parameters on INTPACK:
 21076                              <1> ;		DS:SI:	Ptr to Disk Address Packet
 21077                              <1> ;	Returns:
 21078                              <1> ;		BX:		Index to command lookup table
 21079                              <1> ;		ES:SI:	Ptr to Disk Address Packet (DAP)
 21080                              <1> ;		Exits from INT 13h if invalid DAP
 21081                              <1> ;	Corrupts registers:
 21082                              <1> ;		AX, DX
 21083                              <1> ;--------------------------------------------------------------------
 21084                              <1> %ifdef MODULE_EBIOS
 21085                              <1> ALIGN JUMP_ALIGN
 21086                              <1> Prepare_ByLoadingDapToESSIandVerifyingForTransfer:
 21087                              <1> 	; Load pointer to DAP to ES:SI and make sure it is valid
 21088 000018D0 8E460E              <1> 	mov		es, [bp+IDEPACK.intpack+INTPACK.ds]	; ES:SI to point Disk Address Packet
 21089 000018D3 26803C10            <1> 	cmp		BYTE [es:si+DAP.bSize], MINIMUM_DAP_SIZE
 21090 000018D7 7234                <1> 	jb		SHORT InvalidDAP
 21091                              <1> 
 21092                              <1> 	; Make sure that sector count is valid
 21093 000018D9 268B4402            <1> 	mov		ax, [es:si+DAP.wSectorCount]
 21094 000018DD 85C0                <1> 	test	ax, ax
 21095 000018DF 7431                <1> 	jz		SHORT ZeroSectorsRequestedSoNoErrors
 21096 000018E1 83F87F              <1> 	cmp		ax, BYTE 127
 21097 000018E4 7727                <1> 	ja		SHORT InvalidNumberOfSectorsRequested
 21098                              <1> 
 21099                              <1> 	; Get EBIOS command index to BX
 21100                              <1> 	; LBA28 or LBA48 command
 21101 000018E6 E80700              <1> 	call	Prepare_GetOldInt13hCommandIndexToBX
 21102 000018E9 8A05                <1> 	mov		al, [di+DPT.bFlagsLow]
 21103                              <1> 	eSHL_IM	al, 1					; Set CF if LBA48 supported
 21104                              <2> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 21105                              <2> %ifdef USE_386
 21106                              <2>  %if %2 = 1
 21107                              <2>  add %1, %1
 21108                              <2>  %else
 21109                              <2>  eSHIFT_IM %1, %2, shl
 21110                              <2>  %endif
 21111                              <2> %else
 21112                              <2>  eSHIFT_IM %1, %2, shl
 21113                              <3> %ifndef CHECK_FOR_UNUSED_ENTRYPOINTS
 21114                              <3> %ifndef USE_186
 21115                              <3>  %ifidni %1, cl
 21116                              <3>  times %2 %3 %1, 1
 21117                              <3>  %elifidni %1, ch
 21118                              <3>  times %2 %3 %1, 1
 21119                              <3>  %elifidni %1, cx
 21120                              <3>  times %2 %3 %1, 1
 21121                              <3>  %else
 21122                              <3>  %if %2 > 3
 21123                              <3>  push cx
 21124                              <3>  mov cl, %2
 21125                              <3>  %3 %1, cl
 21126                              <3>  pop cx
 21127                              <3>  %else
 21128 000018EB D0E0                <3>  times %2 %3 %1, 1
 21129                              <3>  %endif
 21130                              <3>  %endif
 21131                              <3> 
 21132                              <3> %else
 21133                              <3>  %3 %1, %2
 21134                              <3> %endif
 21135                              <3> %endif
 21136                              <2> %endif
 21137                              <2> %endif
 21138 000018ED 10FB                <1> 	adc		bl, bh					; LBA48 EXT commands
 21139 000018EF C3                  <1> 	ret
 21140                              <1> %endif ; MODULE_EBIOS
 21141                              <1> 
 21142                              <1> 
 21143                              <1> ;--------------------------------------------------------------------
 21144                              <1> ; Prepare_GetOldInt13hCommandIndexToBX
 21145                              <1> ;	Parameters:
 21146                              <1> ;		DS:DI:	Ptr to DPT
 21147                              <1> ;	Returns:
 21148                              <1> ;		BX:		Index to command lookup table
 21149                              <1> ;	Corrupts registers:
 21150                              <1> ;		Nothing
 21151                              <1> ;--------------------------------------------------------------------
 21152                              <1> ALIGN JUMP_ALIGN
 21153                              <1> Prepare_GetOldInt13hCommandIndexToBX:
 21154                              <1> 	; Block mode or single sector
 21155 000018F0 8A5D01              <1> 	mov		bl, [di+DPT.bFlagsHigh]
 21156 000018F3 83E302              <1> 	and		bx, BYTE FLGH_DPT_BLOCK_MODE_SUPPORTED	; Bit 1
 21157 000018F6 C3                  <1> 	ret
 21158                              <1> 
 21159                              <1> 
 21160                              <1> ;---------------------------------------------------------------------
 21161                              <1> ; Prepare_BufferToESSIforOldInt13hTransfer
 21162                              <1> ;	Parameters:
 21163                              <1> ;		AL:		Number of sectors to transfer
 21164                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 21165                              <1> ;		SS:BP:	Ptr to IDEPACK
 21166                              <1> ;	Parameters on INTPACK:
 21167                              <1> ;		ES:BX:	Ptr to data buffer
 21168                              <1> ;	Returns:
 21169                              <1> ;		ES:SI:	Ptr to normalized data buffer
 21170                              <1> ;		Exits INT 13h if error
 21171                              <1> ;	Corrupts registers:
 21172                              <1> ;		BX
 21173                              <1> ;--------------------------------------------------------------------
 21174                              <1> ALIGN JUMP_ALIGN
 21175                              <1> Prepare_BufferToESSIforOldInt13hTransfer:
 21176 000018F7 8B7618              <1> 	mov		si, [bp+IDEPACK.intpack+INTPACK.bx]	; Load offset
 21177 000018FA 8E460C              <1> 	mov		es, [bp+IDEPACK.intpack+INTPACK.es]	; Load segment
 21178                              <1> 	; Fall to Prepare_ByValidatingSectorsInALforOldInt13h
 21179                              <1> 
 21180                              <1> ;---------------------------------------------------------------------
 21181                              <1> ; Prepare_ByValidatingSectorsInALforOldInt13h
 21182                              <1> ;	Parameters:
 21183                              <1> ;		AL:		Number of sectors to transfer
 21184                              <1> ;	Returns:
 21185                              <1> ;		Exits INT 13h if invalid number of sectors in AL
 21186                              <1> ;	Corrupts registers:
 21187                              <1> ;		Nothing
 21188                              <1> ;--------------------------------------------------------------------
 21189                              <1> Prepare_ByValidatingSectorsInALforOldInt13h:
 21190 000018FD 84C0                <1> 	test	al, al
 21191 000018FF 7803                <1> 	js		SHORT .CheckZeroOffsetFor128Sectors		; 128 or more
 21192 00001901 740A                <1> 	jz		SHORT InvalidNumberOfSectorsRequested	; Zero not allowed for old INT 13h
 21193 00001903 C3                  <1> 	ret		; Continue with transfer
 21194                              <1> 
 21195                              <1> ALIGN JUMP_ALIGN
 21196                              <1> .CheckZeroOffsetFor128Sectors:
 21197 00001904 3C80                <1> 	cmp		al, 128
 21198 00001906 7705                <1> 	ja		SHORT InvalidNumberOfSectorsRequested
 21199 00001908 85F6                <1> 	test	si, si								; Offset must be zero to xfer 128 sectors
 21200 0000190A 7504                <1> 	jnz		SHORT CannotAlignPointerProperly
 21201 0000190C C3                  <1> 	ret		; Continue with transfer
 21202                              <1> 
 21203                              <1> InvalidDAP:
 21204                              <1> InvalidNumberOfSectorsRequested:
 21205                              <1> Prepare_ReturnFromInt13hWithInvalidFunctionError:
 21206 0000190D B401                <1> 	mov		ah, RET_HD_INVALID
 21207                              <1> 	SKIP2B	f
 21208                              <2>  %ifidni %1, f
 21209 0000190F 3D                  <2>  db 03Dh
 21210                              <2> 
 21211                              <2>  %elifidni %1, ax
 21212                              <2>  db 0B8h
 21213                              <2>  %elifidni %1, cx
 21214                              <2>  db 0B9h
 21215                              <2>  %elifidni %1, dx
 21216                              <2>  db 0BAh
 21217                              <2>  %elifidni %1, bx
 21218                              <2>  db 0BBh
 21219                              <2>  %elifidni %1, sp
 21220                              <2>  db 0BCh
 21221                              <2>  %elifidni %1, bp
 21222                              <2>  db 0BDh
 21223                              <2>  %elifidni %1, si
 21224                              <2>  db 0BEh
 21225                              <2>  %elifidni %1, di
 21226                              <2>  db 0BFh
 21227                              <2>  %else
 21228                              <2>  %error "Invalid parameter passed to SKIP2B"
 21229                              <2>  %endif
 21230                              <1> CannotAlignPointerProperly:
 21231 00001910 B409                <1> 	mov		ah, RET_HD_BOUNDARY
 21232                              <1> ZeroSectorsRequestedSoNoErrors:
 21233 00001912 E9C0FB              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 21234                              <1> 
 21235                              <1> 
 21236                              <1> 
 21237                              <1> ; Command lookup tables
 21238                              <1> g_rgbReadCommandLookup:
 21239 00001915 20                  <1> 	db		COMMAND_READ_SECTORS		; 00b, CHS or LBA28 single sector
 21240 00001916 24                  <1> 	db		COMMAND_READ_SECTORS_EXT	; 01b, LBA48 single sector
 21241 00001917 C4                  <1> 	db		COMMAND_READ_MULTIPLE		; 10b, CHS or LBA28 block mode
 21242                              <1> %ifdef MODULE_EBIOS
 21243 00001918 29                  <1> 	db		COMMAND_READ_MULTIPLE_EXT	; 11b, LBA48 block mode
 21244                              <1> %endif
 21245                              <1> 
 21246                              <1> g_rgbWriteCommandLookup:
 21247 00001919 30                  <1> 	db		COMMAND_WRITE_SECTORS
 21248 0000191A 34                  <1> 	db		COMMAND_WRITE_SECTORS_EXT
 21249 0000191B C5                  <1> 	db		COMMAND_WRITE_MULTIPLE
 21250                              <1> %ifdef MODULE_EBIOS
 21251 0000191C 39                  <1> 	db		COMMAND_WRITE_MULTIPLE_EXT
 21252                              <1> %endif
 21253                              <1> 
 21254                              <1> g_rgbVerifyCommandLookup:
 21255 0000191D 40                  <1> 	db		COMMAND_VERIFY_SECTORS
 21256 0000191E 42                  <1> 	db		COMMAND_VERIFY_SECTORS_EXT
 21257 0000191F 40                  <1> 	db		COMMAND_VERIFY_SECTORS
 21258                              <1> %ifdef MODULE_EBIOS
 21259 00001920 42                  <1> 	db		COMMAND_VERIFY_SECTORS_EXT
 21260                              <1> %endif
 21261                                  %ifdef MODULE_EBIOS
 21262                                  	%include "AH42h_ExtendedReadSectors.asm"
 21263                              <1> ; Project name	:	XTIDE Universal BIOS
 21264                              <1> ; Description	:	Int 13h function AH=42h, Extended Read Sectors.
 21265                              <1> 
 21266                              <1> ;
 21267                              <1> ; XTIDE Universal BIOS and Associated Tools
 21268                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 21269                              <1> ;
 21270                              <1> ; This program is free software; you can redistribute it and/or modify
 21271                              <1> ; it under the terms of the GNU General Public License as published by
 21272                              <1> ; the Free Software Foundation; either version 2 of the License, or
 21273                              <1> ; (at your option) any later version.
 21274                              <1> ;
 21275                              <1> ; This program is distributed in the hope that it will be useful,
 21276                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 21277                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 21278                              <1> ; GNU General Public License for more details.
 21279                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 21280                              <1> ;
 21281                              <1> 
 21282                              <1> ; Section containing code
 21283                              <1> SECTION .text
 21284                              <1> 
 21285                              <1> ;--------------------------------------------------------------------
 21286                              <1> ; Int 13h function AH=42h, Extended Read Sectors.
 21287                              <1> ;
 21288                              <1> ; AH42h_HandlerForExtendedReadSectors
 21289                              <1> ;	Parameters:
 21290                              <1> ;		SI:		Same as in INTPACK
 21291                              <1> ;		DL:		Translated Drive number
 21292                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 21293                              <1> ;		SS:BP:	Ptr to IDEPACK
 21294                              <1> ;	Parameters on INTPACK:
 21295                              <1> ;		DS:SI:	Ptr to Disk Address Packet
 21296                              <1> ;	Returns with INTPACK:
 21297                              <1> ;		AH:		Int 13h return status
 21298                              <1> ;		CF:		0 if successful, 1 if error
 21299                              <1> ;	Return with Disk Address Packet in INTPACK:
 21300                              <1> ;		.wSectorCount	Number of sectors read successfully
 21301                              <1> ;--------------------------------------------------------------------
 21302                              <1> ALIGN JUMP_ALIGN
 21303                              <1> AH42h_HandlerForExtendedReadSectors:
 21304 00001921 E8ACFF              <1> 	call	Prepare_ByLoadingDapToESSIandVerifyingForTransfer
 21305 00001924 2E8AA7[1519]        <1> 	mov		ah, [cs:bx+g_rgbReadCommandLookup]
 21306 00001929 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 21307 0000192C E8BBF2              <1> 	call	Idepack_ConvertDapToIdepackAndIssueCommandFromAH
 21308                              <1> 	; Fall to AH42h_ReturnFromInt13hAfterStoringErrorCodeFromAHandTransferredSectorsFromCX
 21309                              <1> 
 21310                              <1> 
 21311                              <1> ;--------------------------------------------------------------------
 21312                              <1> ; AH42h_ReturnFromInt13hAfterStoringErrorCodeFromAHandTransferredSectorsFromCX
 21313                              <1> ;	Parameters:
 21314                              <1> ;		AH:		INT 13h Error Code
 21315                              <1> ;		CX:		Number of successfully transferred sectors
 21316                              <1> ;		SS:BP:	Ptr to IDEPACK
 21317                              <1> ;	Returns:
 21318                              <1> ;		Nothing, jumps to Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 21319                              <1> ;	Corrupts registers:
 21320                              <1> ;		SI, DS
 21321                              <1> ;--------------------------------------------------------------------
 21322                              <1> AH42h_ReturnFromInt13hAfterStoringErrorCodeFromAHandTransferredSectorsFromCX:
 21323 0000192F 8E5E0E              <1> 	mov		ds, [bp+IDEPACK.intpack+INTPACK.ds]
 21324 00001932 8B7612              <1> 	mov		si, [bp+IDEPACK.intpack+INTPACK.si]
 21325 00001935 894C02              <1> 	mov		[si+DAP.wSectorCount], cx
 21326 00001938 E99AFB              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 21327                                  	%include "AH43h_ExtendedWriteSectors.asm"
 21328                              <1> ; Project name	:	XTIDE Universal BIOS
 21329                              <1> ; Description	:	Int 13h function AH=43h, Extended Write Sectors.
 21330                              <1> 
 21331                              <1> ;
 21332                              <1> ; XTIDE Universal BIOS and Associated Tools
 21333                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 21334                              <1> ;
 21335                              <1> ; This program is free software; you can redistribute it and/or modify
 21336                              <1> ; it under the terms of the GNU General Public License as published by
 21337                              <1> ; the Free Software Foundation; either version 2 of the License, or
 21338                              <1> ; (at your option) any later version.
 21339                              <1> ;
 21340                              <1> ; This program is distributed in the hope that it will be useful,
 21341                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 21342                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 21343                              <1> ; GNU General Public License for more details.
 21344                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 21345                              <1> ;
 21346                              <1> 
 21347                              <1> ; Section containing code
 21348                              <1> SECTION .text
 21349                              <1> 
 21350                              <1> ;--------------------------------------------------------------------
 21351                              <1> ; Int 13h function AH=43h, Extended Write Sectors.
 21352                              <1> ;
 21353                              <1> ; AH43h_HandlerForExtendedWriteSectors
 21354                              <1> ;	Parameters:
 21355                              <1> ;		SI:		Same as in INTPACK
 21356                              <1> ;		DL:		Translated Drive number
 21357                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 21358                              <1> ;		SS:BP:	Ptr to IDEPACK
 21359                              <1> ;	Parameters on INTPACK:
 21360                              <1> ;		AL:		0 or 1 to write with verify off
 21361                              <1> ;				2 to write with verify (if supported)
 21362                              <1> ;		DS:SI:	Ptr to Disk Address Packet
 21363                              <1> ;	Returns with INTPACK:
 21364                              <1> ;		AH:		Int 13h return status
 21365                              <1> ;		CF:		0 if successful, 1 if error
 21366                              <1> ;	Return with Disk Address Packet in INTPACK:
 21367                              <1> ;		.wSectorCount	Number of sectors written successfully
 21368                              <1> ;--------------------------------------------------------------------
 21369                              <1> ALIGN JUMP_ALIGN
 21370                              <1> AH43h_HandlerForExtendedWriteSectors:
 21371 0000193B 807E1E02            <1> 	cmp		BYTE [bp+IDEPACK.intpack+INTPACK.al], 2	; Verify requested?
 21372 0000193F 73CC                <1> 	jae		SHORT Prepare_ReturnFromInt13hWithInvalidFunctionError
 21373                              <1> 
 21374 00001941 E88CFF              <1> 	call	Prepare_ByLoadingDapToESSIandVerifyingForTransfer
 21375 00001944 2E8AA7[1919]        <1> 	mov		ah, [cs:bx+g_rgbWriteCommandLookup]
 21376 00001949 BB08FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRQ)
 21377                              <1> %ifdef USE_186
 21378                              <1> 	push	AH42h_ReturnFromInt13hAfterStoringErrorCodeFromAHandTransferredSectorsFromCX
 21379                              <1> 	jmp		Idepack_ConvertDapToIdepackAndIssueCommandFromAH
 21380                              <1> %else
 21381 0000194C E89BF2              <1> 	call	Idepack_ConvertDapToIdepackAndIssueCommandFromAH
 21382 0000194F EBDE                <1> 	jmp		SHORT AH42h_ReturnFromInt13hAfterStoringErrorCodeFromAHandTransferredSectorsFromCX
 21383                              <1> %endif
 21384                                  	%include "AH44h_ExtendedVerifySectors.asm"
 21385                              <1> ; Project name	:	XTIDE Universal BIOS
 21386                              <1> ; Description	:	Int 13h function AH=44h, Extended Verify Sectors.
 21387                              <1> 
 21388                              <1> ;
 21389                              <1> ; XTIDE Universal BIOS and Associated Tools
 21390                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 21391                              <1> ;
 21392                              <1> ; This program is free software; you can redistribute it and/or modify
 21393                              <1> ; it under the terms of the GNU General Public License as published by
 21394                              <1> ; the Free Software Foundation; either version 2 of the License, or
 21395                              <1> ; (at your option) any later version.
 21396                              <1> ;
 21397                              <1> ; This program is distributed in the hope that it will be useful,
 21398                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 21399                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 21400                              <1> ; GNU General Public License for more details.
 21401                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 21402                              <1> ;
 21403                              <1> 
 21404                              <1> ; Section containing code
 21405                              <1> SECTION .text
 21406                              <1> 
 21407                              <1> ;--------------------------------------------------------------------
 21408                              <1> ; Int 13h function AH=44h, Extended Verify Sectors.
 21409                              <1> ;
 21410                              <1> ; AH44h_HandlerForExtendedVerifySectors
 21411                              <1> ;	Parameters:
 21412                              <1> ;		SI:		Same as in INTPACK
 21413                              <1> ;		DL:		Translated Drive number
 21414                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 21415                              <1> ;		SS:BP:	Ptr to IDEPACK
 21416                              <1> ;	Parameters on INTPACK:
 21417                              <1> ;		DS:SI:	Ptr to Disk Address Packet
 21418                              <1> ;	Returns with INTPACK:
 21419                              <1> ;		AH:		Int 13h return status
 21420                              <1> ;		CF:		0 if successful, 1 if error
 21421                              <1> ;	Return with Disk Address Packet in INTPACK:
 21422                              <1> ;		.wSectorCount	Number of sectors verified successfully
 21423                              <1> ;--------------------------------------------------------------------
 21424                              <1> ALIGN JUMP_ALIGN
 21425                              <1> AH44h_HandlerForExtendedVerifySectors:
 21426 00001951 E87CFF              <1> 	call	Prepare_ByLoadingDapToESSIandVerifyingForTransfer
 21427 00001954 2E8AA7[1D19]        <1> 	mov		ah, [cs:bx+g_rgbVerifyCommandLookup]
 21428 00001959 BB40FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRDY)
 21429                              <1> %ifdef USE_186
 21430                              <1> 	push	AH42h_ReturnFromInt13hAfterStoringErrorCodeFromAHandTransferredSectorsFromCX
 21431                              <1> 	jmp		Idepack_ConvertDapToIdepackAndIssueCommandFromAH
 21432                              <1> %else
 21433 0000195C E88BF2              <1> 	call	Idepack_ConvertDapToIdepackAndIssueCommandFromAH
 21434 0000195F EBCE                <1> 	jmp		SHORT AH42h_ReturnFromInt13hAfterStoringErrorCodeFromAHandTransferredSectorsFromCX
 21435                              <1> %endif
 21436                                  	%include "AH47h_ExtendedSeek.asm"
 21437                              <1> ; Project name	:	XTIDE Universal BIOS
 21438                              <1> ; Description	:	Int 13h function AH=47h, Extended Seek.
 21439                              <1> 
 21440                              <1> ;
 21441                              <1> ; XTIDE Universal BIOS and Associated Tools
 21442                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 21443                              <1> ;
 21444                              <1> ; This program is free software; you can redistribute it and/or modify
 21445                              <1> ; it under the terms of the GNU General Public License as published by
 21446                              <1> ; the Free Software Foundation; either version 2 of the License, or
 21447                              <1> ; (at your option) any later version.
 21448                              <1> ;
 21449                              <1> ; This program is distributed in the hope that it will be useful,
 21450                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 21451                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 21452                              <1> ; GNU General Public License for more details.
 21453                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 21454                              <1> ;
 21455                              <1> 
 21456                              <1> ; Section containing code
 21457                              <1> SECTION .text
 21458                              <1> 
 21459                              <1> ;--------------------------------------------------------------------
 21460                              <1> ; Int 13h function AH=47h, Extended Seek.
 21461                              <1> ;
 21462                              <1> ; AH47h_HandlerForExtendedSeek
 21463                              <1> ;	Parameters:
 21464                              <1> ;		SI:		Same as in INTPACK
 21465                              <1> ;		DL:		Translated Drive number
 21466                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 21467                              <1> ;		SS:BP:	Ptr to IDEPACK
 21468                              <1> ;	Parameters on INTPACK:
 21469                              <1> ;		DS:SI:	Ptr to Disk Address Packet
 21470                              <1> ;	Returns with INTPACK:
 21471                              <1> ;		AH:		Int 13h return status
 21472                              <1> ;		CF:		0 if successful, 1 if error
 21473                              <1> ;--------------------------------------------------------------------
 21474                              <1> ALIGN JUMP_ALIGN
 21475                              <1> AH47h_HandlerForExtendedSeek:
 21476                              <1> 	; Note that there is no Seek command for LBA48 addressing!
 21477 00001961 8E460E              <1> 	mov		es, [bp+IDEPACK.intpack+INTPACK.ds]	; ES:SI to point Disk Address Packet
 21478 00001964 26803C10            <1> 	cmp		BYTE [es:si+DAP.bSize], MINIMUM_DAP_SIZE
 21479 00001968 72A3                <1> 	jb		SHORT Prepare_ReturnFromInt13hWithInvalidFunctionError
 21480                              <1> 
 21481 0000196A B470                <1> 	mov		ah, COMMAND_SEEK
 21482 0000196C BB40FF              <1> 	mov		bx, TIMEOUT_AND_STATUS_TO_WAIT(TIMEOUT_DRQ, FLG_STATUS_DRDY)
 21483                              <1> %ifdef USE_186
 21484                              <1> 	push	Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 21485                              <1> 	jmp		Idepack_ConvertDapToIdepackAndIssueCommandFromAH
 21486                              <1> %else
 21487 0000196F E878F2              <1> 	call	Idepack_ConvertDapToIdepackAndIssueCommandFromAH
 21488 00001972 E960FB              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 21489                              <1> %endif
 21490                                  	%include "AH48h_GetExtendedDriveParameters.asm"
 21491                              <1> ; Project name	:	XTIDE Universal BIOS
 21492                              <1> ; Description	:	Int 13h function AH=48h, Get Extended Drive Parameters.
 21493                              <1> 
 21494                              <1> ;
 21495                              <1> ; XTIDE Universal BIOS and Associated Tools
 21496                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 21497                              <1> ;
 21498                              <1> ; This program is free software; you can redistribute it and/or modify
 21499                              <1> ; it under the terms of the GNU General Public License as published by
 21500                              <1> ; the Free Software Foundation; either version 2 of the License, or
 21501                              <1> ; (at your option) any later version.
 21502                              <1> ;
 21503                              <1> ; This program is distributed in the hope that it will be useful,
 21504                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 21505                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 21506                              <1> ; GNU General Public License for more details.
 21507                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 21508                              <1> ;
 21509                              <1> 
 21510                              <1> ; Section containing code
 21511                              <1> SECTION .text
 21512                              <1> 
 21513                              <1> ;--------------------------------------------------------------------
 21514                              <1> ; Int 13h function AH=48h, Get Extended Drive Parameters.
 21515                              <1> ;
 21516                              <1> ; AH48h_GetExtendedDriveParameters
 21517                              <1> ;	Parameters:
 21518                              <1> ;		SI:		Same as in INTPACK
 21519                              <1> ;		DL:		Translated Drive number
 21520                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 21521                              <1> ;		SS:BP:	Ptr to IDEPACK
 21522                              <1> ;	Parameters on INTPACK:
 21523                              <1> ;		DS:SI:	Ptr to Extended Drive Information Table to fill
 21524                              <1> ;	Returns with INTPACK:
 21525                              <1> ;		AH:		Int 13h return status
 21526                              <1> ;		DS:SI:	Ptr to Extended Drive Information Table
 21527                              <1> ;		CF:		0 if successful, 1 if error
 21528                              <1> ;--------------------------------------------------------------------
 21529                              <1> AH48h_HandlerForGetExtendedDriveParameters:
 21530 00001975 E877ED              <1> 	call	AccessDPT_GetLbaSectorCountToBXDXAX
 21531                              <1> 
 21532                              <1> 	; Point DS:SI to Extended Drive Information Table to fill
 21533 00001978 1E                  <1> 	push	ds
 21534 00001979 07                  <1> 	pop		es			; DPT now in ES:DI
 21535 0000197A 8E5E0E              <1> 	mov		ds, [bp+IDEPACK.intpack+INTPACK.ds]
 21536 0000197D B91A00              <1> 	mov		cx, MINIMUM_EDRIVEINFO_SIZE
 21537 00001980 390C                <1> 	cmp		[si+EDRIVE_INFO.wSize], cx
 21538 00001982 7289                <1> 	jb		Prepare_ReturnFromInt13hWithInvalidFunctionError
 21539 00001984 740C                <1> 	je		SHORT .SkipEddConfigurationParameters
 21540                              <1> 
 21541                              <1> 	; We do not support EDD Configuration Parameters so set to FFFF:FFFFh
 21542 00001986 83E91B              <1> 	sub		cx, BYTE MINIMUM_EDRIVEINFO_SIZE+1	; CX => FFFFh
 21543 00001989 894C1A              <1> 	mov		[si+EDRIVE_INFO.fpEDDparams], cx
 21544 0000198C 894C1C              <1> 	mov		[si+EDRIVE_INFO.fpEDDparams+2], cx
 21545 0000198F B92200              <1> 	mov		cx, EDRIVE_INFO_size
 21546                              <1> 
 21547                              <1> 	; Fill Extended Drive Information Table in DS:SI
 21548                              <1> .SkipEddConfigurationParameters:
 21549 00001992 890C                <1> 	mov		[si+EDRIVE_INFO.wSize], cx
 21550 00001994 C744020300          <1> 	mov		WORD [si+EDRIVE_INFO.wFlags], FLG_DMA_BOUNDARY_ERRORS_HANDLED_BY_BIOS | FLG_CHS_INFORMATION_IS_VALID
 21551                              <1> 
 21552                              <1> 	; Store total sector count
 21553 00001999 894410              <1> 	mov		[si+EDRIVE_INFO.qwTotalSectors], ax
 21554 0000199C 31C0                <1> 	xor		ax, ax									; Return with success
 21555 0000199E 895412              <1> 	mov		[si+EDRIVE_INFO.qwTotalSectors+2], dx
 21556 000019A1 895C14              <1> 	mov		[si+EDRIVE_INFO.qwTotalSectors+4], bx
 21557 000019A4 894416              <1> 	mov		[si+EDRIVE_INFO.qwTotalSectors+6], ax	; Always zero
 21558 000019A7 C744180002          <1> 	mov		WORD [si+EDRIVE_INFO.wSectorSize], 512
 21559                              <1> 
 21560                              <1> 	; Store P-CHS
 21561                              <1> 	eMOVZX	dx, BYTE [es:di+DPT.bPchsHeads]
 21562                              <2> %ifndef USE_386
 21563                              <2>  %ifidni %1, ax
 21564                              <2>  mov al, %2
 21565                              <2>  xor ah, ah
 21566                              <2>  %elifidni %1, bx
 21567                              <2>  mov bl, %2
 21568                              <2>  xor bh, bh
 21569                              <2>  %elifidni %1, cx
 21570                              <2>  mov cl, %2
 21571                              <2>  xor ch, ch
 21572                              <2>  %elifidni %1, dx
 21573 000019AC 268A550A            <2>  mov dl, %2
 21574 000019B0 30F6                <2>  xor dh, dh
 21575                              <2>  %else
 21576                              <2>  push ax
 21577                              <2>  mov al, %2
 21578                              <2>  xor ah, ah
 21579                              <2>  xchg ax, %1
 21580                              <2>  pop ax
 21581                              <2>  %endif
 21582                              <2> 
 21583                              <2> %else
 21584                              <2>  movzx %1, %2
 21585                              <2> %endif
 21586 000019B2 31C0                <1> 	xor		ax, ax									; Also a return code
 21587 000019B4 895408              <1> 	mov		[si+EDRIVE_INFO.dwHeads], dx
 21588 000019B7 89440A              <1> 	mov		[si+EDRIVE_INFO.dwHeads+2], ax
 21589                              <1> 
 21590 000019BA 268A550B            <1> 	mov		dl, [es:di+DPT.bPchsSectorsPerTrack]
 21591 000019BE 89540C              <1> 	mov		[si+EDRIVE_INFO.dwSectorsPerTrack], dx
 21592 000019C1 89440E              <1> 	mov		[si+EDRIVE_INFO.dwSectorsPerTrack+2], ax
 21593                              <1> 
 21594 000019C4 268B550C            <1> 	mov		dx, [es:di+DPT.wPchsCylinders]
 21595 000019C8 895404              <1> 	mov		[si+EDRIVE_INFO.dwCylinders], dx
 21596 000019CB 894406              <1> 	mov		[si+EDRIVE_INFO.dwCylinders+2], ax
 21597                              <1> 
 21598                              <1> .ReturnWithError:
 21599 000019CE E904FB              <1> 	jmp		Int13h_ReturnFromHandlerAfterStoringErrorCodeFromAH
 21600                                  	%include "AH41h_CheckIfExtensionsPresent.asm"
 21601                              <1> ; Project name	:	XTIDE Universal BIOS
 21602                              <1> ; Description	:	Int 13h function AH=41h, Check if Extensions Present.
 21603                              <1> 
 21604                              <1> ;
 21605                              <1> ; XTIDE Universal BIOS and Associated Tools
 21606                              <1> ; Copyright (C) 2009-2010 by Tomi Tilli, 2011-2013 by XTIDE Universal BIOS Team.
 21607                              <1> ;
 21608                              <1> ; This program is free software; you can redistribute it and/or modify
 21609                              <1> ; it under the terms of the GNU General Public License as published by
 21610                              <1> ; the Free Software Foundation; either version 2 of the License, or
 21611                              <1> ; (at your option) any later version.
 21612                              <1> ;
 21613                              <1> ; This program is distributed in the hope that it will be useful,
 21614                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
 21615                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 21616                              <1> ; GNU General Public License for more details.
 21617                              <1> ; Visit http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 21618                              <1> ;
 21619                              <1> 
 21620                              <1> ; Section containing code
 21621                              <1> SECTION .text
 21622                              <1> 
 21623                              <1> ;--------------------------------------------------------------------
 21624                              <1> ; Int 13h function AH=41h, Check if Extensions Present.
 21625                              <1> ;
 21626                              <1> ; AH41h_HandlerForCheckIfExtensionsPresent
 21627                              <1> ;	Parameters:
 21628                              <1> ;		DL:		Translated Drive number
 21629                              <1> ;		DS:DI:	Ptr to DPT (in RAMVARS segment)
 21630                              <1> ;		SS:BP:	Ptr to IDEPACK
 21631                              <1> ;	Parameters on INTPACK:
 21632                              <1> ;		BX:		55AAh
 21633                              <1> ;	Returns with INTPACK:
 21634                              <1> ;		AH:		Major version of EBIOS extensions
 21635                              <1> ;		BX:		AA55h
 21636                              <1> ;		CX:		Support bits
 21637                              <1> ;		CF:		0 if successful, 1 if error
 21638                              <1> ;--------------------------------------------------------------------
 21639                              <1> AH41h_HandlerForCheckIfExtensionsPresent:
 21640 000019D1 817E18AA55          <1> 	cmp		WORD [bp+IDEPACK.intpack+INTPACK.bx], 55AAh
 21641 000019D6 7515                <1> 	jne		SHORT .EbiosNotSupported
 21642                              <1> 
 21643 000019D8 C6461F21            <1> 	mov		BYTE [bp+IDEPACK.intpack+INTPACK.ah], EBIOS_VERSION
 21644 000019DC C7461855AA          <1> 	mov		WORD [bp+IDEPACK.intpack+INTPACK.bx], 0AA55h
 21645 000019E1 C7461C0100          <1> 	mov		WORD [bp+IDEPACK.intpack+INTPACK.cx], ENHANCED_DRIVE_ACCESS_SUPPORT
 21646 000019E6 806624FE            <1> 	and		BYTE [bp+IDEPACK.intpack+INTPACK.flags], ~FLG_FLAGS_CF	; Return with CF cleared
 21647 000019EA E9EEFA              <1> 	jmp		Int13h_ReturnFromHandlerWithoutStoringErrorCode
 21648                              <1> .EbiosNotSupported:
 21649 000019ED E996FA              <1> 	jmp		Int13h_DirectCallToAnotherBios
 21650                                  %endif
